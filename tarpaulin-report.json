{"files":[{"path":["/","workspace","crates","ofml-cli","src","main.rs"],"content":"//! OFML Interpreter CLI\n//!\n//! A command-line interface for OFML (Office Furniture Modeling Language) processing.\n\nuse std::fs;\nuse std::path::Path;\nuse std::process;\n\nuse clap::{CommandFactory, Parser, Subcommand};\nuse clap_complete::{generate, Shell};\nuse tracing_subscriber::{fmt, prelude::*, EnvFilter};\n\nuse ofml_lib::alb_loader::{load_manufacturer_with_deps, AlbLoader};\nuse ofml_lib::geometry;\nuse ofml_lib::operations::{\n    self, export_to_glb, load_geometry_file, validate_geometry, ProductConfig,\n};\nuse ofml_lib::parser::Parser as OfmlParser;\nuse ofml_lib::tokenize;\nuse ofml_lib::Interpreter;\n\n/// OFML Interpreter - Process Office Furniture Modeling Language files\n#[derive(Parser)]\n#[command(name = \"ofml\")]\n#[command(author, version, about, long_about = None)]\nstruct Cli {\n    /// Increase output verbosity (-v, -vv, -vvv)\n    #[arg(short, long, action = clap::ArgAction::Count, global = true)]\n    verbose: u8,\n\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    // =====================\n    // OAP Configurator Commands\n    // =====================\n    /// List available manufacturers from OFML data directory\n    Manufacturers {\n        /// Path to OFML data directory\n        data_path: String,\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n    },\n\n    /// List articles for a specific manufacturer\n    Articles {\n        /// Path to OFML data directory\n        data_path: String,\n        /// Manufacturer ID (e.g., \"vitra\")\n        manufacturer: String,\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n        /// Filter by series\n        #[arg(short, long)]\n        series: Option<String>,\n    },\n\n    /// Configure a product and display/export pricing\n    Configure {\n        /// Path to OFML data directory\n        data_path: String,\n        /// Manufacturer ID\n        manufacturer: String,\n        /// Article/class name\n        article: String,\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n        /// Export configuration to file\n        #[arg(short, long)]\n        export: Option<String>,\n        /// Price lookup date (YYYY-MM-DD)\n        #[arg(short = 'd', long)]\n        price_date: Option<String>,\n        /// List available properties and exit\n        #[arg(short, long)]\n        list_properties: bool,\n        /// Property values (format: name=value)\n        #[arg(last = true)]\n        properties: Vec<String>,\n    },\n\n    /// Browse XCF catalog structure for a manufacturer\n    Catalog {\n        /// Path to OFML data directory\n        data_path: String,\n        /// Manufacturer ID (e.g., \"bisley\", \"kn\")\n        manufacturer: String,\n        /// Language code (default: de)\n        #[arg(short, long, default_value = \"de\")]\n        language: String,\n        /// Output as JSON\n        #[arg(short, long)]\n        json: bool,\n        /// Show full tree structure\n        #[arg(short, long)]\n        tree: bool,\n        /// Search for category/article by name\n        #[arg(short, long)]\n        search: Option<String>,\n        /// List all available catalogs\n        #[arg(long)]\n        list: bool,\n        /// Load a specific catalog by name (e.g., \"desks_m_cat\")\n        #[arg(short = 'c', long)]\n        catalog_name: Option<String>,\n    },\n\n    // =====================\n    // Existing Commands\n    // =====================\n    /// Parse and display AST (CLS files)\n    Parse {\n        /// Path to CLS file\n        file_path: String,\n    },\n\n    /// Check syntax only (CLS files)\n    Check {\n        /// Path to CLS file\n        file_path: String,\n    },\n\n    /// Display tokens (CLS files)\n    Tokenize {\n        /// Path to CLS file\n        file_path: String,\n    },\n\n    /// Execute the file (CLS files)\n    Run {\n        /// Path to CLS file\n        file_path: String,\n    },\n\n    /// Execute CLS and export scene to GLB\n    Export {\n        /// Path to CLS file\n        file_path: String,\n    },\n\n    /// Convert 3DS/GEO/OBJ file to GLB\n    Convert {\n        /// Path to geometry file\n        file_path: String,\n    },\n\n    /// Merge multiple geometry files into one GLB\n    Merge {\n        /// Output GLB file path\n        output_path: String,\n        /// Input geometry files\n        input_files: Vec<String>,\n    },\n\n    /// Read and dump EBASE database\n    Ebase {\n        /// Path to EBASE file\n        file_path: String,\n        /// Table name to dump records\n        table_name: Option<String>,\n    },\n\n    /// Assemble product from OFML data\n    Product {\n        /// Path to product directory\n        product_path: String,\n        /// Article name (optional)\n        article: Option<String>,\n        /// Output GLB path (optional)\n        output: Option<String>,\n    },\n\n    /// Validate geometry file and show metrics\n    Validate {\n        /// Path to geometry file\n        file_path: String,\n    },\n\n    /// Explore OFML data directory\n    Ofml {\n        /// Path to OFML data directory\n        data_path: String,\n        /// Manufacturer name (optional)\n        manufacturer: Option<String>,\n        /// Product name (optional)\n        product: Option<String>,\n    },\n\n    /// List and extract CLS files from ALB\n    Cls {\n        /// Path to ALB file\n        alb_path: String,\n        /// Filename pattern to extract\n        filename: Option<String>,\n    },\n\n    /// List or extract files from ALB\n    Alb {\n        /// Path to ALB file\n        alb_path: String,\n        /// Pattern to extract\n        pattern: Option<String>,\n        /// Output directory\n        output_dir: Option<String>,\n    },\n\n    /// Build product from CLS using scene graph\n    Build {\n        /// Path to ALB file\n        alb_path: String,\n        /// Class name to instantiate\n        class_name: Option<String>,\n    },\n\n    /// Convert product with OBJ files to GLB\n    Gsx {\n        /// Path to product directory\n        product_path: String,\n        /// Output GLB path\n        output: Option<String>,\n    },\n\n    /// Export 2D floor plan from odb2d to SVG\n    Svg {\n        /// Path to EBASE file with odb2d\n        ebase_path: String,\n        /// Output SVG path\n        output: Option<String>,\n    },\n\n    /// Evaluate EBASE expression\n    Expr {\n        /// Expression to evaluate\n        expression: String,\n    },\n\n    /// Load manufacturer with multi-ALB support\n    Manufacturer {\n        /// Path to OFML data directory\n        data_dir: String,\n        /// Manufacturer name\n        manufacturer: Option<String>,\n        /// Class name to instantiate\n        class_name: Option<String>,\n    },\n\n    /// Extract 3DS files from ALB and convert to GLB\n    Extract {\n        /// Path to ALB file\n        alb_path: String,\n        /// Pattern to match\n        pattern: Option<String>,\n    },\n\n    /// Generate shell completion scripts\n    Completions {\n        /// Shell type (bash, zsh, fish, elvish, powershell)\n        #[arg(value_enum)]\n        shell: Shell,\n    },\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    // Configure tracing based on verbosity\n    let filter = match cli.verbose {\n        0 => \"error\",\n        1 => \"warn\",\n        2 => \"info\",\n        _ => \"debug\",\n    };\n\n    tracing_subscriber::registry()\n        .with(fmt::layer().with_writer(std::io::stderr))\n        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new(filter)))\n        .init();\n\n    let result = match cli.command {\n        // OAP Commands\n        Commands::Manufacturers { data_path, json } => cmd_oap_manufacturers(&data_path, json),\n        Commands::Articles {\n            data_path,\n            manufacturer,\n            json,\n            series,\n        } => cmd_oap_articles(&data_path, &manufacturer, json, series.as_deref()),\n        Commands::Configure {\n            data_path,\n            manufacturer,\n            article,\n            json,\n            export,\n            price_date,\n            list_properties,\n            properties,\n        } => cmd_oap_configure(\n            &data_path,\n            &manufacturer,\n            &article,\n            json,\n            export.as_deref(),\n            price_date.as_deref(),\n            list_properties,\n            &properties,\n        ),\n        Commands::Catalog {\n            data_path,\n            manufacturer,\n            language,\n            json,\n            tree,\n            search,\n            list,\n            catalog_name,\n        } => cmd_oap_catalog(\n            &data_path,\n            &manufacturer,\n            &language,\n            json,\n            tree,\n            search.as_deref(),\n            list,\n            catalog_name.as_deref(),\n        ),\n\n        // Existing commands\n        Commands::Parse { file_path } => {\n            let source = read_source_file(&file_path);\n            cmd_parse(&source, &file_path)\n        }\n        Commands::Check { file_path } => {\n            let source = read_source_file(&file_path);\n            cmd_check(&source, &file_path)\n        }\n        Commands::Tokenize { file_path } => {\n            let source = read_source_file(&file_path);\n            cmd_tokenize(&source, &file_path)\n        }\n        Commands::Run { file_path } => {\n            let source = read_source_file(&file_path);\n            cmd_run(&source, &file_path)\n        }\n        Commands::Export { file_path } => {\n            let source = read_source_file(&file_path);\n            cmd_export(&source, &file_path)\n        }\n        Commands::Convert { file_path } => cmd_convert(&file_path),\n        Commands::Merge {\n            output_path,\n            input_files,\n        } => {\n            let files: Vec<&str> = input_files.iter().map(|s| s.as_str()).collect();\n            cmd_merge(&output_path, &files)\n        }\n        Commands::Ebase {\n            file_path,\n            table_name,\n        } => cmd_ebase(&file_path, table_name.as_deref()),\n        Commands::Product {\n            product_path,\n            article,\n            output,\n        } => cmd_product(&product_path, article.as_deref(), output.as_deref()),\n        Commands::Validate { file_path } => cmd_validate(&file_path),\n        Commands::Ofml {\n            data_path,\n            manufacturer,\n            product,\n        } => cmd_ofml(&data_path, manufacturer.as_deref(), product.as_deref()),\n        Commands::Cls { alb_path, filename } => cmd_cls(&alb_path, filename.as_deref()),\n        Commands::Alb {\n            alb_path,\n            pattern,\n            output_dir,\n        } => cmd_alb(&alb_path, pattern.as_deref(), output_dir.as_deref()),\n        Commands::Build {\n            alb_path,\n            class_name,\n        } => cmd_build(&alb_path, class_name.as_deref()),\n        Commands::Gsx {\n            product_path,\n            output,\n        } => cmd_gsx(&product_path, output.as_deref()),\n        Commands::Svg { ebase_path, output } => cmd_svg(&ebase_path, output.as_deref()),\n        Commands::Expr { expression } => cmd_expr(&expression),\n        Commands::Manufacturer {\n            data_dir,\n            manufacturer,\n            class_name,\n        } => cmd_manufacturer(&data_dir, manufacturer.as_deref(), class_name.as_deref()),\n        Commands::Extract { alb_path, pattern } => {\n            cmd_extract(&alb_path, pattern.as_deref().unwrap_or(\"\"))\n        }\n        Commands::Completions { shell } => {\n            generate(shell, &mut Cli::command(), \"ofml\", &mut std::io::stdout());\n            Ok(())\n        }\n    };\n\n    if let Err(e) = result {\n        eprintln!(\"Error: {}\", e);\n        process::exit(1);\n    }\n}\n\nfn read_source_file(path: &str) -> String {\n    match fs::read_to_string(path) {\n        Ok(s) => s,\n        Err(e) => {\n            eprintln!(\"Error reading file '{}': {}\", path, e);\n            process::exit(1);\n        }\n    }\n}\n\ntype CmdResult = Result<(), String>;\n\n// ============================================================================\n// OAP Configurator Commands\n// ============================================================================\n\nfn cmd_oap_manufacturers(data_path: &str, json_output: bool) -> CmdResult {\n    use ofml_lib::oap::{manufacturers, strings, Manufacturer};\n\n    let path = Path::new(data_path);\n    if !path.exists() {\n        return Err(format!(\n            \"{}: {}\",\n            strings::MSG_MANUFACTURER_NOT_FOUND,\n            data_path\n        ));\n    }\n\n    // Initialize manufacturer names from Manufacturers.ebase\n    manufacturers::init_from_data_path(path);\n\n    // Load installed manufacturers from SQLite (fast)\n    let installed = manufacturers::get_installed_manufacturers(path);\n\n    let mfr_list: Vec<Manufacturer> = installed\n        .into_iter()\n        .map(|m| Manufacturer {\n            id: m.id,\n            name: m.name,\n            path: m.path,\n        })\n        .collect();\n\n    if json_output {\n        let output = serde_json::json!({\n            \"manufacturers\": mfr_list,\n            \"total\": mfr_list.len()\n        });\n        println!(\"{}\", serde_json::to_string_pretty(&output).unwrap());\n    } else {\n        println!(\"{} {}:\", strings::MSG_MANUFACTURERS_HEADER, data_path);\n        println!();\n        for m in &mfr_list {\n            println!(\"  {:<12} {}\", m.id, m.name);\n        }\n        println!();\n        println!(\"{}: {} Hersteller\", strings::MSG_TOTAL, mfr_list.len());\n    }\n\n    Ok(())\n}\n\nfn cmd_oap_articles(\n    data_path: &str,\n    manufacturer: &str,\n    json_output: bool,\n    series_filter: Option<&str>,\n) -> CmdResult {\n    use ofml_lib::oap::{manufacturers, ocd, strings, Article};\n\n    let path = Path::new(data_path);\n    let mfr_path = path.join(manufacturer);\n\n    if !mfr_path.exists() {\n        return Err(format!(\n            \"{}: '{}'\",\n            strings::MSG_MANUFACTURER_NOT_FOUND,\n            manufacturer\n        ));\n    }\n\n    // Initialize manufacturer names from Manufacturers.ebase\n    manufacturers::init_from_data_path(path);\n\n    // Get manufacturer display name\n    let mfr_display_name = manufacturers::get_display_name(manufacturer);\n\n    // Load OCD articles from pdata.ebase files\n    let articles_with_desc = ocd::load_articles_with_descriptions(&mfr_path, \"DE\");\n\n    let mut articles: Vec<Article> = articles_with_desc\n        .into_iter()\n        // Filter out internal/cryptic articles\n        .filter(|(ocd_art, _)| {\n            // Skip internal articles (starting with @)\n            if ocd_art.article_nr.starts_with('@') {\n                return false;\n            }\n            // Skip articles with control characters in series\n            if ocd_art.series.chars().any(|c| c.is_control()) {\n                return false;\n            }\n            true\n        })\n        .map(|(ocd_art, description)| Article {\n            id: ocd_art.article_nr.clone(),\n            manufacturer_id: manufacturer.to_string(),\n            series_id: if ocd_art.series.is_empty() {\n                None\n            } else {\n                Some(ocd_art.series.clone())\n            },\n            short_description: description,\n            long_description: None,\n            base_article_number: ocd_art.article_nr.clone(),\n            has_configuration: true,\n        })\n        .collect();\n\n    // Apply series filter\n    if let Some(series) = series_filter {\n        articles.retain(|a| {\n            a.series_id\n                .as_ref()\n                .map(|s| s.to_lowercase().contains(&series.to_lowercase()))\n                .unwrap_or(false)\n        });\n    }\n\n    // Sort by series first, then by article number\n    articles.sort_by(|a, b| match (&a.series_id, &b.series_id) {\n        (Some(sa), Some(sb)) => sa.cmp(sb).then(a.id.cmp(&b.id)),\n        (Some(_), None) => std::cmp::Ordering::Less,\n        (None, Some(_)) => std::cmp::Ordering::Greater,\n        (None, None) => a.id.cmp(&b.id),\n    });\n\n    if json_output {\n        let output = serde_json::json!({\n            \"manufacturer\": manufacturer,\n            \"manufacturer_name\": mfr_display_name,\n            \"articles\": articles,\n            \"total\": articles.len()\n        });\n        println!(\"{}\", serde_json::to_string_pretty(&output).unwrap());\n    } else {\n        println!(\n            \"{} {} ({}):\",\n            strings::MSG_ARTICLES_HEADER,\n            mfr_display_name,\n            manufacturer\n        );\n        println!();\n\n        // Group by series\n        let mut current_series: Option<String> = None;\n        for article in &articles {\n            let article_series = article.series_id.clone().unwrap_or_default();\n            if current_series.as_ref() != Some(&article_series) {\n                if !article_series.is_empty() {\n                    println!();\n                    println!(\"  [{}]\", article_series);\n                }\n                current_series = Some(article_series);\n            }\n\n            let config_indicator = if article.has_configuration {\n                \"‚óè\"\n            } else {\n                \"‚óã\"\n            };\n            println!(\n                \"    {} {:<30} {}\",\n                config_indicator, article.id, article.short_description\n            );\n        }\n\n        println!();\n        println!(\"{}: {} Artikel\", strings::MSG_TOTAL, articles.len());\n    }\n\n    Ok(())\n}\n\n#[allow(clippy::too_many_arguments)]\nfn cmd_oap_configure(\n    data_path: &str,\n    manufacturer: &str,\n    article: &str,\n    json_output: bool,\n    export_path: Option<&str>,\n    price_date_str: Option<&str>,\n    list_properties: bool,\n    property_args: &[String],\n) -> CmdResult {\n    use chrono::NaiveDate;\n    use ofml_lib::oap::config::Configuration;\n    use ofml_lib::oap::price::{PriceLookup, PriceQuery};\n    use ofml_lib::oap::property::{parse_property_value, validate_property_value};\n    use ofml_lib::oap::{format_german_price_with_currency, strings};\n\n    let path = Path::new(data_path);\n\n    // Parse price date\n    let price_date = match price_date_str {\n        Some(s) => NaiveDate::parse_from_str(s, \"%Y-%m-%d\")\n            .map_err(|_| format!(\"Invalid date format: {}. Use YYYY-MM-DD\", s))?,\n        None => chrono::Local::now().date_naive(),\n    };\n\n    // Load manufacturer\n    let loader =\n        load_manufacturer_with_deps(path, manufacturer, None).map_err(|e| e.to_string())?;\n\n    let mut interp = Interpreter::new();\n    loader\n        .load_into_interpreter(&mut interp)\n        .map_err(|e| e.to_string())?;\n\n    // Find the class\n    let class = interp\n        .classes\n        .get(article)\n        .cloned()\n        .ok_or_else(|| format!(\"{}: '{}'\", strings::MSG_ARTICLE_NOT_FOUND, article))?;\n\n    // Instantiate the class\n    let instance = interp\n        .instantiate_class_public(class)\n        .map_err(|e| e.to_string())?;\n\n    // Extract properties from instance\n    let properties = ofml_lib::oap::property::extract_properties_from_cls(&instance);\n\n    // If list-properties flag, just show properties and exit\n    if list_properties {\n        println!(\"Properties for {}::{}:\", manufacturer, article);\n        println!();\n\n        let mut defs: Vec<_> = properties.definitions.iter().collect();\n        defs.sort_by_key(|(_, d)| d.sort_order);\n\n        for (name, def) in defs {\n            let type_str = match &def.prop_type {\n                ofml_lib::property::PropertyType::Int { min, max } => {\n                    let min_str = min.map(|v| v.to_string()).unwrap_or_default();\n                    let max_str = max.map(|v| v.to_string()).unwrap_or_default();\n                    format!(\"int     {}-{}\", min_str, max_str)\n                }\n                ofml_lib::property::PropertyType::Float { min, max } => {\n                    let min_str = min.map(|v| format!(\"{:.1}\", v)).unwrap_or_default();\n                    let max_str = max.map(|v| format!(\"{:.1}\", v)).unwrap_or_default();\n                    format!(\"float   {}-{}\", min_str, max_str)\n                }\n                ofml_lib::property::PropertyType::Choice { options } => {\n                    format!(\"choice  {}\", options.join(\",\"))\n                }\n                ofml_lib::property::PropertyType::Bool => \"bool\".to_string(),\n                ofml_lib::property::PropertyType::String => \"string\".to_string(),\n            };\n            let state_str = match def.state {\n                ofml_lib::property::PropertyState::Enabled => \"[enabled]\",\n                ofml_lib::property::PropertyState::Hidden => \"[hidden]\",\n                ofml_lib::property::PropertyState::ReadOnly => \"[readonly]\",\n            };\n            println!(\"  {:<16} {} {}\", name, type_str, state_str);\n        }\n        return Ok(());\n    }\n\n    // Create configuration\n    let mut config = Configuration::with_properties(\n        article.to_string(),\n        manufacturer.to_string(),\n        properties.clone(),\n    );\n\n    // Apply property values from command line\n    for prop_arg in property_args {\n        if let Some((name, value_str)) = prop_arg.split_once('=') {\n            if let Some(def) = config.properties.definitions.get(name) {\n                match parse_property_value(def, value_str) {\n                    Ok(value) => {\n                        if let Err(e) = validate_property_value(def, &value) {\n                            return Err(format!(\n                                \"{}: {} - {}\",\n                                strings::MSG_INVALID_PROPERTY_VALUE,\n                                name,\n                                e\n                            ));\n                        }\n                        config.properties.values.insert(name.to_string(), value);\n                    }\n                    Err(e) => {\n                        return Err(format!(\n                            \"{}: {} - {}\",\n                            strings::MSG_INVALID_PROPERTY_VALUE,\n                            name,\n                            e\n                        ));\n                    }\n                }\n            } else {\n                return Err(format!(\"Property not found: {}\", name));\n            }\n        } else {\n            return Err(format!(\n                \"Invalid property format: {}. Use name=value\",\n                prop_arg\n            ));\n        }\n    }\n\n    // Generate variant code\n    config.update_variant_code();\n\n    // Lookup price\n    let price_lookup = PriceLookup::new(data_path);\n    let price_query = PriceQuery::new(\n        manufacturer.to_string(),\n        config.article_number.clone().unwrap_or_default(),\n        config.variant_code.clone(),\n        price_date,\n    );\n\n    config.price = price_lookup.lookup(&price_query).ok();\n\n    // Output\n    if json_output {\n        let export_data = config.to_export_data();\n        println!(\"{}\", serde_json::to_string_pretty(&export_data).unwrap());\n    } else {\n        println!(\n            \"{}: {}::{}\",\n            strings::MSG_CONFIGURING,\n            manufacturer,\n            article\n        );\n        if let Some(ref art_num) = config.article_number {\n            println!(\"Article: {}\", art_num);\n        }\n        println!();\n\n        println!(\"{}:\", strings::MSG_PROPERTIES);\n        let mut defs: Vec<_> = config.properties.definitions.iter().collect();\n        defs.sort_by_key(|(_, d)| d.sort_order);\n\n        for (name, def) in defs {\n            let value = config\n                .properties\n                .values\n                .get(name)\n                .map(|v| format!(\"{:?}\", v))\n                .unwrap_or_else(|| \"-\".to_string());\n\n            let type_info = match &def.prop_type {\n                ofml_lib::property::PropertyType::Int { min, max } => {\n                    let min_str = min.map(|v| v.to_string()).unwrap_or_default();\n                    let max_str = max.map(|v| v.to_string()).unwrap_or_default();\n                    format!(\"[{}-{}]\", min_str, max_str)\n                }\n                ofml_lib::property::PropertyType::Float { min, max } => {\n                    let min_str = min.map(|v| format!(\"{:.1}\", v)).unwrap_or_default();\n                    let max_str = max.map(|v| format!(\"{:.1}\", v)).unwrap_or_default();\n                    format!(\"[{}-{}]\", min_str, max_str)\n                }\n                ofml_lib::property::PropertyType::Choice { options } => {\n                    format!(\"[{}]\", options.join(\",\"))\n                }\n                ofml_lib::property::PropertyType::Bool => \"[ja/nein]\".to_string(),\n                ofml_lib::property::PropertyType::String => \"\".to_string(),\n            };\n\n            println!(\"  {:<16} = {:<16} {}\", name, value, type_info);\n        }\n\n        println!();\n        println!(\"{}: {}\", strings::MSG_VARIANT_CODE, config.variant_code);\n\n        if let Some(ref price) = config.price {\n            println!(\n                \"{}: {}\",\n                strings::MSG_BASE_PRICE,\n                format_german_price_with_currency(price.base_price, &price.currency)\n            );\n            for surcharge in &price.surcharges {\n                let amount_str = if surcharge.is_percentage {\n                    format!(\"{}%\", surcharge.amount)\n                } else {\n                    format_german_price_with_currency(surcharge.amount, &price.currency)\n                };\n                println!(\"  + {}: {}\", surcharge.name, amount_str);\n            }\n            println!(\n                \"{}: {}\",\n                strings::MSG_TOTAL_PRICE,\n                format_german_price_with_currency(price.total_price, &price.currency)\n            );\n            println!(\n                \"{}: {}\",\n                strings::MSG_PRICE_DATE,\n                price.price_date.format(\"%d.%m.%Y\")\n            );\n        } else {\n            println!(\"{}\", strings::MSG_PRICE_NOT_AVAILABLE);\n        }\n    }\n\n    // Export if requested\n    if let Some(export_file) = export_path {\n        let export_data = config.to_export_data();\n        let json = serde_json::to_string_pretty(&export_data).map_err(|e| e.to_string())?;\n        fs::write(export_file, json).map_err(|e| e.to_string())?;\n        eprintln!(\"{}: {}\", strings::MSG_EXPORT_SUCCESS, export_file);\n    }\n\n    Ok(())\n}\n\n#[allow(clippy::too_many_arguments)]\nfn cmd_oap_catalog(\n    data_path: &str,\n    manufacturer: &str,\n    language: &str,\n    json_output: bool,\n    show_tree: bool,\n    search: Option<&str>,\n    list_catalogs: bool,\n    catalog_name: Option<&str>,\n) -> CmdResult {\n    use ofml_lib::oap::catalog::{\n        find_manufacturer_catalogs, CatalogLoader, CatalogNode, NodeType,\n    };\n    use ofml_lib::oap::manufacturers;\n\n    let path = Path::new(data_path);\n    let mfr_path = path.join(manufacturer);\n\n    if !mfr_path.exists() {\n        return Err(format!(\"Manufacturer not found: {}\", manufacturer));\n    }\n\n    // Initialize manufacturer names\n    manufacturers::init_from_data_path(path);\n    let mfr_name = manufacturers::get_display_name(manufacturer);\n\n    // Find all catalogs\n    let catalogs = find_manufacturer_catalogs(&mfr_path);\n\n    if catalogs.is_empty() {\n        // List available series as fallback\n        println!(\"No XCF catalog found for {} ({})\", mfr_name, manufacturer);\n        println!();\n        println!(\"Available series directories:\");\n        if let Ok(entries) = std::fs::read_dir(&mfr_path) {\n            let mut series: Vec<_> = entries\n                .filter_map(|e| e.ok())\n                .filter(|e| e.path().is_dir())\n                .filter_map(|e| e.file_name().to_str().map(|s| s.to_string()))\n                .filter(|s| !s.starts_with('.') && s != \"catalog\")\n                .collect();\n            series.sort();\n            for s in &series {\n                println!(\"  {}\", s);\n            }\n        }\n        return Ok(());\n    }\n\n    // List catalogs mode\n    if list_catalogs {\n        if json_output {\n            let json_cats: Vec<_> = catalogs\n                .iter()\n                .map(|c| {\n                    serde_json::json!({\n                        \"name\": c.name,\n                        \"is_master\": c.is_master,\n                        \"path\": c.path.display().to_string()\n                    })\n                })\n                .collect();\n            println!(\"{}\", serde_json::to_string_pretty(&json_cats).unwrap());\n        } else {\n            println!(\"Available catalogs for {} ({}):\", mfr_name, manufacturer);\n            println!();\n            for cat in &catalogs {\n                let master_tag = if cat.is_master { \" [MASTER]\" } else { \"\" };\n                println!(\"  {}{}\", cat.name, master_tag);\n                println!(\"    Path: {}\", cat.path.display());\n            }\n            println!();\n            println!(\"Use --catalog-name to load a specific catalog\");\n        }\n        return Ok(());\n    }\n\n    // Load specific or default catalog\n    let catalog = if let Some(name) = catalog_name {\n        // Find specific catalog by name\n        let cat_info = catalogs.iter().find(|c| c.name == name).ok_or_else(|| {\n            format!(\n                \"Catalog '{}' not found. Use --list to see available catalogs.\",\n                name\n            )\n        })?;\n        CatalogLoader::load(&cat_info.path, language)\n            .map_err(|e| format!(\"Failed to load catalog: {}\", e))?\n    } else {\n        // Load first master catalog, or first available\n        let cat_info = catalogs\n            .iter()\n            .find(|c| c.is_master)\n            .or_else(|| catalogs.first())\n            .ok_or_else(|| \"No catalog available\".to_string())?;\n        CatalogLoader::load(&cat_info.path, language)\n            .map_err(|e| format!(\"Failed to load catalog: {}\", e))?\n    };\n\n    let stats = catalog.stats();\n\n    // Handle search\n    if let Some(query) = search {\n        let query_lower = query.to_lowercase();\n\n        fn search_tree(\n            node: &CatalogNode,\n            query: &str,\n            path: &[String],\n        ) -> Vec<(Vec<String>, CatalogNode)> {\n            let mut results = Vec::new();\n            let current_path: Vec<String> = path\n                .iter()\n                .cloned()\n                .chain(std::iter::once(node.name.clone()))\n                .collect();\n\n            if node.name.to_lowercase().contains(query) || node.id.to_lowercase().contains(query) {\n                results.push((current_path.clone(), node.clone()));\n            }\n\n            for child in &node.children {\n                results.extend(search_tree(child, query, &current_path));\n            }\n            results\n        }\n\n        let results = search_tree(&catalog.root, &query_lower, &[]);\n\n        if json_output {\n            let json_results: Vec<_> = results\n                .iter()\n                .map(|(path, node)| {\n                    serde_json::json!({\n                        \"path\": path.join(\" > \"),\n                        \"id\": node.id,\n                        \"name\": node.name,\n                        \"type\": match node.node_type {\n                            NodeType::Folder => \"folder\",\n                            NodeType::Article => \"article\",\n                            NodeType::Root => \"root\",\n                        }\n                    })\n                })\n                .collect();\n            println!(\"{}\", serde_json::to_string_pretty(&json_results).unwrap());\n        } else {\n            println!(\n                \"Search results for '{}' in {} ({}):\",\n                query, mfr_name, manufacturer\n            );\n            println!();\n            for (path, node) in &results {\n                let type_icon = match node.node_type {\n                    NodeType::Folder => \"üìÅ\",\n                    NodeType::Article => \"üìÑ\",\n                    NodeType::Root => \"üè†\",\n                };\n                println!(\"{} {} ({})\", type_icon, path.join(\" > \"), node.id);\n            }\n            println!();\n            println!(\"Found {} results\", results.len());\n        }\n        return Ok(());\n    }\n\n    // Output\n    if json_output {\n        fn node_to_json(node: &CatalogNode) -> serde_json::Value {\n            serde_json::json!({\n                \"id\": node.id,\n                \"name\": node.name,\n                \"type\": match node.node_type {\n                    NodeType::Folder => \"folder\",\n                    NodeType::Article => \"article\",\n                    NodeType::Root => \"root\",\n                },\n                \"children\": node.children.iter().map(node_to_json).collect::<Vec<_>>()\n            })\n        }\n\n        let output = serde_json::json!({\n            \"manufacturer\": manufacturer,\n            \"manufacturer_name\": mfr_name,\n            \"language\": language,\n            \"stats\": {\n                \"total_nodes\": stats.total_nodes,\n                \"folders\": stats.folder_count,\n                \"articles\": stats.article_count,\n                \"languages\": stats.languages,\n            },\n            \"catalog\": node_to_json(&catalog.root)\n        });\n        println!(\"{}\", serde_json::to_string_pretty(&output).unwrap());\n    } else {\n        println!(\"XCF Catalog: {} ({})\", mfr_name, manufacturer);\n        println!(\"Language: {}\", language);\n        println!(\"Source: {}\", catalog.source_path.display());\n        println!();\n        println!(\"Statistics:\");\n        println!(\"  Categories: {}\", stats.folder_count);\n        println!(\"  Articles: {}\", stats.article_count);\n        println!(\"  Languages: {}\", stats.languages.join(\", \"));\n        println!();\n\n        if show_tree {\n            fn print_tree(node: &CatalogNode, indent: usize, max_depth: usize) {\n                if indent > max_depth {\n                    return;\n                }\n                let prefix = \"  \".repeat(indent);\n                let icon = match node.node_type {\n                    NodeType::Folder => \"üìÅ\",\n                    NodeType::Article => \"üìÑ\",\n                    NodeType::Root => \"üè†\",\n                };\n\n                if node.node_type != NodeType::Root {\n                    println!(\"{}{} {}\", prefix, icon, node.name);\n                }\n\n                for child in &node.children {\n                    print_tree(child, indent + 1, max_depth);\n                }\n            }\n\n            println!(\"Catalog Structure:\");\n            print_tree(&catalog.root, 0, 10);\n        } else {\n            // Show top-level categories only\n            println!(\"Top-level Categories:\");\n            for child in &catalog.root.children {\n                let child_count = child.children.len();\n                let article_count = child.article_count();\n                println!(\n                    \"  üìÅ {} ({} sub-categories, {} articles)\",\n                    child.name, child_count, article_count\n                );\n            }\n            println!();\n            println!(\"Use --tree to see full structure, --search to find items\");\n        }\n    }\n\n    Ok(())\n}\n\nfn cmd_tokenize(source: &str, file_path: &str) -> CmdResult {\n    let tokens = tokenize(source).map_err(|e| e.to_string())?;\n\n    println!(\"Tokens from {}:\", file_path);\n    println!(\"{:-<60}\", \"\");\n    for (i, t) in tokens.iter().enumerate() {\n        let preview = &source[t.span.clone()];\n        let preview = if preview.len() > 30 {\n            format!(\"{}...\", &preview[..27])\n        } else {\n            preview.to_string()\n        };\n        println!(\"{:4}: {:?} @ {:?} = {:?}\", i, t.token, t.span, preview);\n    }\n    println!(\"{:-<60}\", \"\");\n    println!(\"Total: {} tokens\", tokens.len());\n    Ok(())\n}\n\nfn cmd_parse(source: &str, file_path: &str) -> CmdResult {\n    let unit = OfmlParser::new(source)\n        .and_then(|mut p| p.parse())\n        .map_err(|e| e.to_string())?;\n\n    println!(\"AST from {}:\", file_path);\n    println!(\"{:-<60}\", \"\");\n\n    if let Some(ref pkg) = unit.package {\n        println!(\"Package: {}\", pkg);\n    }\n\n    if !unit.imports.is_empty() {\n        println!(\"\\nImports:\");\n        for import in &unit.imports {\n            let wildcard = if import.wildcard { \"::*\" } else { \"\" };\n            println!(\"  {}{}\", import.path, wildcard);\n        }\n    }\n\n    println!(\"\\nStatements: {}\", unit.statements.len());\n    for (i, stmt) in unit.statements.iter().enumerate() {\n        print_stmt(stmt, i, 1);\n    }\n\n    println!(\"{:-<60}\", \"\");\n    println!(\"Parsing successful!\");\n    Ok(())\n}\n\nfn cmd_check(source: &str, file_path: &str) -> CmdResult {\n    let unit = OfmlParser::new(source)\n        .and_then(|mut p| p.parse())\n        .map_err(|e| format!(\"{}: FAILED\\n  Error: {}\", file_path, e))?;\n\n    let (class_count, func_count, var_count) = count_elements(&unit);\n\n    println!(\"{}: OK\", file_path);\n    println!(\n        \"  Package: {}\",\n        unit.package\n            .map(|p| p.to_string())\n            .unwrap_or_else(|| \"(none)\".to_string())\n    );\n    println!(\"  Imports: {}\", unit.imports.len());\n    println!(\"  Classes: {}\", class_count);\n    println!(\"  Functions: {}\", func_count);\n    println!(\"  Variables: {}\", var_count);\n    Ok(())\n}\n\nfn cmd_run(source: &str, file_path: &str) -> CmdResult {\n    let unit = OfmlParser::new(source)\n        .and_then(|mut p| p.parse())\n        .map_err(|e| e.to_string())?;\n\n    let mut interp = Interpreter::new();\n\n    println!(\"Executing {}...\", file_path);\n    println!(\"{:-<60}\", \"\");\n\n    interp.execute(&unit).map_err(|e| e.to_string())?;\n\n    println!(\"{:-<60}\", \"\");\n    println!(\"Execution complete!\");\n\n    if !interp.output.is_empty() {\n        println!(\"\\nOutput:\");\n        for line in &interp.output {\n            println!(\"  {}\", line);\n        }\n    }\n\n    if !interp.classes.is_empty() {\n        println!(\"\\nRegistered classes:\");\n        for name in interp.classes.keys() {\n            println!(\"  {}\", name);\n        }\n    }\n    Ok(())\n}\n\nfn cmd_export(source: &str, file_path: &str) -> CmdResult {\n    let unit = OfmlParser::new(source)\n        .and_then(|mut p| p.parse())\n        .map_err(|e| e.to_string())?;\n\n    let mut interp = Interpreter::new();\n\n    println!(\"Executing {}...\", file_path);\n    interp.execute(&unit).map_err(|e| e.to_string())?;\n    println!(\"Execution complete!\");\n\n    if !interp.output.is_empty() {\n        println!(\"\\nOutput:\");\n        for line in &interp.output {\n            println!(\"  {}\", line);\n        }\n    }\n\n    interp.scene.debug_print();\n\n    if interp.scene.mesh_count() > 0 {\n        let scene3ds = interp.scene.to_scene();\n        let glb = export_to_glb(&scene3ds).map_err(|e| e.to_string())?;\n\n        let output_path = Path::new(file_path).with_extension(\"glb\");\n        fs::write(&output_path, &glb).map_err(|e| e.to_string())?;\n        println!(\n            \"\\nWritten: {} ({} bytes, {} meshes)\",\n            output_path.display(),\n            glb.len(),\n            scene3ds.meshes.len()\n        );\n    } else {\n        println!(\"\\nNo geometry in scene graph\");\n    }\n    Ok(())\n}\n\nfn cmd_convert(file_path: &str) -> CmdResult {\n    let path = Path::new(file_path);\n    let scene = load_geometry_file(path).map_err(|e| e.to_string())?;\n\n    let ext = path\n        .extension()\n        .and_then(|s| s.to_str())\n        .unwrap_or(\"\")\n        .to_uppercase();\n\n    println!(\"Parsed {} file: {}\", ext, file_path);\n    println!(\"  Meshes: {}\", scene.meshes.len());\n    println!(\"  Materials: {}\", scene.materials.len());\n\n    for mesh in &scene.meshes {\n        println!(\n            \"  - {} ({} vertices, {} faces)\",\n            mesh.name,\n            mesh.vertices.len(),\n            mesh.faces.len()\n        );\n    }\n\n    let glb = export_to_glb(&scene).map_err(|e| e.to_string())?;\n    let output_path = path.with_extension(\"glb\");\n    fs::write(&output_path, &glb).map_err(|e| e.to_string())?;\n    println!(\"\\nWritten: {} ({} bytes)\", output_path.display(), glb.len());\n    Ok(())\n}\n\nfn cmd_merge(output_path: &str, input_files: &[&str]) -> CmdResult {\n    if input_files.is_empty() {\n        return Err(\"Usage: merge <output.glb> <file1.geo> [file2.geo] ...\".to_string());\n    }\n\n    let paths: Vec<&Path> = input_files.iter().map(|s| Path::new(*s)).collect();\n    let scene = operations::load_and_merge_geometry(&paths).map_err(|e| e.to_string())?;\n\n    println!(\n        \"Combined scene: {} meshes, {} materials\",\n        scene.meshes.len(),\n        scene.materials.len()\n    );\n\n    let glb = export_to_glb(&scene).map_err(|e| e.to_string())?;\n    fs::write(output_path, &glb).map_err(|e| e.to_string())?;\n    println!(\"Written: {} ({} bytes)\", output_path, glb.len());\n    Ok(())\n}\n\nfn cmd_validate(file_path: &str) -> CmdResult {\n    let path = Path::new(file_path);\n    let scene = load_geometry_file(path).map_err(|e| e.to_string())?;\n\n    let result = validate_geometry(&scene);\n    let bbox = &result.bounding_box;\n    let dims = bbox.dimensions();\n    let center = bbox.center();\n\n    let ext = path\n        .extension()\n        .and_then(|s| s.to_str())\n        .unwrap_or(\"\")\n        .to_uppercase();\n\n    println!(\"Geometry Validation: {}\", file_path);\n    println!(\"{}\", \"=\".repeat(60));\n    println!();\n    println!(\"Format: .{}\", ext);\n    println!(\"Meshes: {}\", result.mesh_count);\n    println!(\"Total Vertices: {}\", result.vertex_count);\n    println!(\"Total Faces: {}\", result.face_count);\n    println!(\"Materials: {}\", result.material_count);\n    println!();\n    println!(\"Bounding Box:\");\n    println!(\n        \"  Min: [{:.4}, {:.4}, {:.4}] m\",\n        bbox.min[0], bbox.min[1], bbox.min[2]\n    );\n    println!(\n        \"  Max: [{:.4}, {:.4}, {:.4}] m\",\n        bbox.max[0], bbox.max[1], bbox.max[2]\n    );\n    println!();\n    println!(\"Dimensions (W x H x D):\");\n    println!(\n        \"  {:.1} x {:.1} x {:.1} mm\",\n        dims[0] * 1000.0,\n        dims[1] * 1000.0,\n        dims[2] * 1000.0\n    );\n    println!(\n        \"Center: [{:.4}, {:.4}, {:.4}] m\",\n        center[0], center[1], center[2]\n    );\n    println!();\n\n    if !result.warnings.is_empty() {\n        println!(\"Warnings:\");\n        for w in &result.warnings {\n            println!(\"  ‚ö† {}\", w);\n        }\n        println!();\n    }\n\n    if !result.errors.is_empty() {\n        println!(\"Errors:\");\n        for e in &result.errors {\n            println!(\"  ‚úó {}\", e);\n        }\n        return Err(\"INVALID\".to_string());\n    }\n\n    println!(\"‚úì VALID\");\n    Ok(())\n}\n\nfn cmd_product(product_path: &str, article: Option<&str>, output: Option<&str>) -> CmdResult {\n    let path = Path::new(product_path);\n\n    if article.is_none() && output.is_none() {\n        return list_product_articles(path);\n    }\n\n    let config = ProductConfig {\n        article: article.map(|s| s.to_string()),\n        ..Default::default()\n    };\n\n    println!(\"Loading product from: {}\", product_path);\n\n    let result = operations::assemble_product(path, &config).map_err(|e| e.to_string())?;\n\n    if let Some(art) = article {\n        println!(\n            \"Article: {} ({} geometry refs)\",\n            art, result.geometry_loaded\n        );\n    } else {\n        println!(\"All articles: {} geometry refs\", result.geometry_loaded);\n    }\n\n    if !result.geometry_missing.is_empty() && result.geometry_missing.len() <= 5 {\n        for name in &result.geometry_missing {\n            eprintln!(\"  Warning: geometry not found: {}\", name);\n        }\n    }\n\n    println!(\"\\nCombined scene: {} meshes\", result.scene.meshes.len());\n\n    let glb = export_to_glb(&result.scene).map_err(|e| e.to_string())?;\n\n    let output_path = output.map(|s| s.to_string()).unwrap_or_else(|| {\n        let name = path\n            .file_name()\n            .and_then(|s| s.to_str())\n            .unwrap_or(\"product\");\n        format!(\"{}.glb\", name)\n    });\n\n    fs::write(&output_path, &glb).map_err(|e| e.to_string())?;\n    println!(\"Written: {} ({} bytes)\", output_path, glb.len());\n    Ok(())\n}\n\nfn list_product_articles(path: &Path) -> CmdResult {\n    use ofml_lib::ebase::{EBaseReader, Odb3dRecord};\n\n    let odb_path = find_odb_path(path)?;\n\n    let mut reader = EBaseReader::open(&odb_path).map_err(|e| e.to_string())?;\n    let records = reader\n        .read_records(\"odb3d\", None)\n        .map_err(|e| e.to_string())?;\n\n    let mut articles: std::collections::HashSet<String> = std::collections::HashSet::new();\n    for record in &records {\n        if let Some(odb_rec) = Odb3dRecord::from_record(record) {\n            if !odb_rec.odb_name.is_empty() {\n                articles.insert(odb_rec.odb_name.clone());\n            }\n        }\n    }\n\n    println!(\"Found {} odb3d records\", records.len());\n    if !articles.is_empty() {\n        println!(\"\\nAvailable articles ({}):\", articles.len());\n        let mut sorted: Vec<_> = articles.iter().collect();\n        sorted.sort();\n        for art in sorted.iter().take(30) {\n            println!(\"  {}\", art);\n        }\n        if sorted.len() > 30 {\n            println!(\"  ... and {} more\", sorted.len() - 30);\n        }\n        println!(\"\\nUsage: product {} <article> [output.glb]\", path.display());\n    }\n    Ok(())\n}\n\nfn find_odb_path(path: &Path) -> Result<std::path::PathBuf, String> {\n    let direct = path.join(\"odb.ebase\");\n    if direct.exists() {\n        return Ok(direct);\n    }\n\n    for version in &[\"1\", \"2\", \"3\", \"current\"] {\n        let odb = path.join(version).join(\"odb.ebase\");\n        if odb.exists() {\n            return Ok(odb);\n        }\n    }\n\n    Err(format!(\"odb.ebase not found in {}\", path.display()))\n}\n\nfn cmd_ebase(ebase_path: &str, table_name: Option<&str>) -> CmdResult {\n    use ofml_lib::ebase::EBaseReader;\n\n    let mut reader = EBaseReader::open(ebase_path).map_err(|e| e.to_string())?;\n\n    println!(\"EBase Database: {}\", ebase_path);\n    println!(\"Version: {}.{}\", reader.major_version, reader.minor_version);\n    println!(\"Tables: {}\", reader.tables.len());\n    println!();\n\n    for (name, table) in &reader.tables {\n        println!(\"  Table: {}\", name);\n        println!(\"    Records: {}\", table.record_count);\n        println!(\"    Record Size: {} bytes\", table.record_size);\n        println!(\"    Columns ({}):\", table.columns.len());\n        for col in &table.columns {\n            let type_name = match col.type_id {\n                1 => \"int8\",\n                2 => \"uint8\",\n                3 => \"int16\",\n                4 => \"uint16\",\n                5 => \"int32\",\n                6 => \"uint32\",\n                7 => \"float32\",\n                8 => \"float64\",\n                9 => \"string\",\n                10 => \"string_ref\",\n                11 => \"blob_ref\",\n                _ => \"unknown\",\n            };\n            println!(\n                \"      - {}: {} (offset={})\",\n                col.name, type_name, col.offset\n            );\n        }\n        println!();\n    }\n\n    if let Some(tbl) = table_name {\n        println!(\"=== Records from {} (limit 20) ===\\n\", tbl);\n        let records = reader\n            .read_records(tbl, Some(20))\n            .map_err(|e| e.to_string())?;\n\n        for (i, record) in records.iter().enumerate() {\n            println!(\"Record {}:\", i);\n            for (key, value) in record {\n                let val_str = format_ebase_value(value);\n                println!(\"  {}: {}\", key, val_str);\n            }\n            println!();\n        }\n    }\n    Ok(())\n}\n\nfn format_ebase_value(value: &ofml_lib::ebase::Value) -> String {\n    use ofml_lib::ebase::Value;\n    match value {\n        Value::Int(v) => format!(\"{}\", v),\n        Value::UInt(v) => format!(\"{}\", v),\n        Value::Float(v) => format!(\"{}\", v),\n        Value::String(v) => format!(\"'{}'\", v),\n        Value::Blob(v) => format!(\"<blob:{}>\", v),\n        Value::Null => \"NULL\".to_string(),\n    }\n}\n\nfn cmd_ofml(data_path: &str, manufacturer: Option<&str>, product: Option<&str>) -> CmdResult {\n    use ofml_lib::ofml::OFMLDataReader;\n\n    let reader = OFMLDataReader::new(data_path);\n\n    match (manufacturer, product) {\n        (None, _) => {\n            let summary = reader.get_summary();\n            println!(\"OFML Data Directory: {}\", data_path);\n            println!(\"{}\", \"=\".repeat(60));\n            println!();\n            println!(\"Manufacturers: {}\", summary.manufacturers.len());\n            println!(\"Total Products: {}\", summary.total_products);\n            println!(\"Total ALB Files: {}\", summary.total_alb_files);\n            println!(\"Total GEO Files: {}\", summary.total_geo_files);\n            println!();\n\n            for mfr in &summary.manufacturers {\n                let count = summary.product_counts.get(mfr).unwrap_or(&0);\n                println!(\"  {}: {} products\", mfr, count);\n            }\n        }\n        (Some(mfr), None) => {\n            let products = reader.discover_products(mfr);\n            println!(\"Manufacturer: {}\", mfr);\n            println!(\"Products: {}\", products.len());\n            println!();\n\n            for prod in &products {\n                if let Ok(p) = reader.load_product(mfr, prod) {\n                    let has_odb = if p.has_odb() { \" [ODB]\" } else { \"\" };\n                    println!(\n                        \"  {}: {} ALB, {} GEO, {} MAT{}\",\n                        prod,\n                        p.album_files.len(),\n                        p.geo_files.len(),\n                        p.mat_files.len(),\n                        has_odb\n                    );\n                }\n            }\n        }\n        (Some(mfr), Some(prod)) => {\n            let p = reader.load_product(mfr, prod).map_err(|e| e.to_string())?;\n            println!(\"Product: {}/{}\", mfr, prod);\n            println!(\"Path: {}\", p.base_path.display());\n            println!();\n            println!(\"ALB Files: {}\", p.album_files.len());\n            println!(\"GEO Files: {}\", p.geo_files.len());\n            println!(\"MAT Files: {}\", p.mat_files.len());\n            println!(\"Countries: {:?}\", p.get_countries());\n        }\n    }\n    Ok(())\n}\n\nfn cmd_cls(alb_path: &str, filename: Option<&str>) -> CmdResult {\n    use ofml_lib::ofml::AlbArchive;\n\n    let mut archive = AlbArchive::open(alb_path).map_err(|e| e.to_string())?;\n    let cls_files = archive.get_cls_files();\n\n    match filename {\n        None => {\n            println!(\"ALB Archive: {}\", alb_path);\n            println!(\"CLS Files: {}\", cls_files.len());\n            println!();\n\n            for name in &cls_files {\n                let short = Path::new(name)\n                    .file_name()\n                    .map(|s| s.to_string_lossy().to_string())\n                    .unwrap_or_else(|| name.clone());\n                println!(\"  {}\", short);\n            }\n        }\n        Some(target) => {\n            let matching: Vec<_> = cls_files\n                .iter()\n                .filter(|n| n.to_lowercase().contains(&target.to_lowercase()))\n                .collect();\n\n            if matching.is_empty() {\n                return Err(format!(\"No CLS file matching '{}' found\", target));\n            }\n\n            for name in matching {\n                let content = archive.extract_cls(name).map_err(|e| e.to_string())?;\n                println!(\"// === {} ===\", name);\n                println!(\"{}\", content);\n            }\n        }\n    }\n    Ok(())\n}\n\nfn cmd_alb(alb_path: &str, pattern: Option<&str>, output_dir: Option<&str>) -> CmdResult {\n    use ofml_lib::ofml::AlbArchive;\n\n    let mut archive = AlbArchive::open(alb_path).map_err(|e| e.to_string())?;\n    let all_files = archive.list_files();\n\n    match pattern {\n        None => {\n            println!(\"ALB Archive: {}\", alb_path);\n            println!(\"Total files: {}\", all_files.len());\n            println!();\n\n            let mut by_ext: std::collections::HashMap<String, Vec<&str>> =\n                std::collections::HashMap::new();\n            for name in &all_files {\n                let ext = Path::new(name)\n                    .extension()\n                    .and_then(|s| s.to_str())\n                    .unwrap_or(\"(none)\")\n                    .to_lowercase();\n                by_ext.entry(ext).or_default().push(name);\n            }\n\n            let mut exts: Vec<_> = by_ext.keys().collect();\n            exts.sort();\n\n            for ext in exts {\n                println!(\".{}: {} files\", ext, by_ext[ext].len());\n            }\n\n            println!();\n            println!(\"Use: alb <file.alb> <pattern> [outdir] to extract files\");\n        }\n        Some(pat) => {\n            let output_path = Path::new(output_dir.unwrap_or(\".\"));\n            if !output_path.exists() {\n                fs::create_dir_all(output_path).map_err(|e| e.to_string())?;\n            }\n\n            let matching: Vec<_> = if pat == \"*\" {\n                all_files.iter().collect()\n            } else {\n                all_files\n                    .iter()\n                    .filter(|n| n.to_lowercase().contains(&pat.to_lowercase()))\n                    .collect()\n            };\n\n            println!(\n                \"Extracting {} files to {}\",\n                matching.len(),\n                output_path.display()\n            );\n\n            let mut extracted = 0;\n            for name in matching {\n                if let Ok(data) = archive.extract(name) {\n                    let filename = Path::new(name)\n                        .file_name()\n                        .map(|s| s.to_string_lossy().to_string())\n                        .unwrap_or_else(|| name.replace('/', \"_\"));\n\n                    let out_file = output_path.join(&filename);\n                    if fs::write(&out_file, &data).is_ok() {\n                        println!(\"  {} ({} bytes)\", filename, data.len());\n                        extracted += 1;\n                    }\n                }\n            }\n            println!(\"\\nExtracted {} files\", extracted);\n        }\n    }\n    Ok(())\n}\n\nfn cmd_build(alb_path: &str, class_name: Option<&str>) -> CmdResult {\n    use std::io::Read;\n\n    let password = b\"Gur#Ynzo$Yvrf%Qbja&Ba*Oebnqjnl.\";\n    let alb = Path::new(alb_path);\n\n    println!(\"Building product from: {}\", alb_path);\n    if let Some(name) = class_name {\n        println!(\"Target class: {}\", name);\n    }\n    println!(\"{:-<60}\", \"\");\n\n    let file = fs::File::open(alb_path).map_err(|e| e.to_string())?;\n    let mut archive = zip::ZipArchive::new(file).map_err(|e| e.to_string())?;\n\n    let mut interp = Interpreter::new();\n    interp.set_alb_path(alb.to_path_buf());\n\n    let mut cls_sources: Vec<(String, String)> = Vec::new();\n    for i in 0..archive.len() {\n        let mut file = match archive.by_index_decrypt(i, password) {\n            Ok(f) => f,\n            Err(_) => continue,\n        };\n\n        let name = file.name().to_string();\n        if !name.to_lowercase().ends_with(\".cls\") {\n            continue;\n        }\n\n        let mut source = String::new();\n        if file.read_to_string(&mut source).is_ok() {\n            cls_sources.push((name, source));\n        }\n    }\n\n    println!(\"Found {} CLS files\", cls_sources.len());\n\n    for (name, source) in &cls_sources {\n        match OfmlParser::new(source).and_then(|mut p| p.parse()) {\n            Ok(unit) => {\n                if let Err(e) = interp.execute(&unit) {\n                    eprintln!(\"  {} - runtime error: {}\", name, e);\n                }\n            }\n            Err(e) => {\n                eprintln!(\"  {} - parse error: {}\", name, e);\n            }\n        }\n    }\n\n    println!(\"Registered {} classes\", interp.classes.len());\n\n    match class_name {\n        Some(target_class) => {\n            if let Some(class) = interp.classes.get(target_class).cloned() {\n                println!(\"Instantiating: {}\", target_class);\n                match interp.instantiate_class_public(class) {\n                    Ok(_) => println!(\"  Instance created successfully\"),\n                    Err(e) => eprintln!(\"  Error instantiating: {}\", e),\n                }\n            } else {\n                println!(\"Available classes:\");\n                for name in interp.classes.keys() {\n                    println!(\"  - {}\", name);\n                }\n                return Err(format!(\"Class '{}' not found\", target_class));\n            }\n        }\n        None => {\n            println!(\"Available classes:\");\n            for name in interp.classes.keys() {\n                println!(\"  - {}\", name);\n            }\n            println!(\"\\nSpecify a class name to instantiate\");\n            return Ok(());\n        }\n    }\n\n    interp.scene.debug_print();\n\n    if interp.scene.mesh_count() > 0 {\n        let scene3ds = interp.scene.to_scene();\n        let glb = export_to_glb(&scene3ds).map_err(|e| e.to_string())?;\n\n        let output_name = format!(\n            \"{}_scene.glb\",\n            class_name.unwrap_or(\"product\").to_lowercase()\n        );\n        let output_path = alb.parent().unwrap_or(Path::new(\".\")).join(&output_name);\n\n        fs::write(&output_path, &glb).map_err(|e| e.to_string())?;\n        println!(\n            \"\\nWritten: {} ({} bytes, {} meshes)\",\n            output_path.display(),\n            glb.len(),\n            scene3ds.meshes.len()\n        );\n    } else {\n        println!(\"\\nNo geometry in scene graph\");\n    }\n    Ok(())\n}\n\nfn cmd_gsx(product_path: &str, output: Option<&str>) -> CmdResult {\n    use ofml_lib::ofml::AlbArchive;\n    use std::path::PathBuf;\n\n    let product_dir = Path::new(product_path);\n\n    let alb_path = if product_dir.is_file() && product_path.ends_with(\".alb\") {\n        product_dir.to_path_buf()\n    } else {\n        find_alb_in_versions(product_dir)?\n    };\n\n    println!(\"SEDUS (gsx) Product Conversion\");\n    println!(\"ALB: {}\", alb_path.display());\n\n    let mut archive = AlbArchive::open(&alb_path).map_err(|e| e.to_string())?;\n    let obj_files = archive.get_obj_files();\n    println!(\"Found {} OBJ files in ALB\", obj_files.len());\n\n    if obj_files.is_empty() {\n        return Err(\"No OBJ files found in ALB\".to_string());\n    }\n\n    let mut combined_scene = geometry::Scene3DS::default();\n    let mut loaded_count = 0;\n\n    for obj_name in &obj_files {\n        if let Ok(mut scene) = archive.extract_obj(obj_name) {\n            let stem = Path::new(obj_name)\n                .file_stem()\n                .and_then(|s| s.to_str())\n                .unwrap_or(\"mesh\");\n            for (i, mesh) in scene.meshes.iter_mut().enumerate() {\n                mesh.name = format!(\"{}_{}\", stem, i);\n            }\n            combined_scene.meshes.extend(scene.meshes);\n            combined_scene.materials.extend(scene.materials);\n            loaded_count += 1;\n        }\n    }\n\n    println!(\"Loaded {} of {} OBJ files\", loaded_count, obj_files.len());\n\n    if combined_scene.meshes.is_empty() {\n        return Err(\"No valid geometry loaded\".to_string());\n    }\n\n    let output_path = match output {\n        Some(p) => PathBuf::from(p),\n        None => {\n            let stem = alb_path\n                .file_stem()\n                .and_then(|s| s.to_str())\n                .unwrap_or(\"gsx_product\");\n            PathBuf::from(format!(\"/tmp/{}.glb\", stem))\n        }\n    };\n\n    let glb_data = export_to_glb(&combined_scene).map_err(|e| e.to_string())?;\n    fs::write(&output_path, &glb_data).map_err(|e| e.to_string())?;\n\n    println!();\n    println!(\n        \"Output: {} ({} bytes)\",\n        output_path.display(),\n        glb_data.len()\n    );\n    println!(\"Meshes: {}\", combined_scene.meshes.len());\n    Ok(())\n}\n\nfn find_alb_in_versions(product_dir: &Path) -> Result<std::path::PathBuf, String> {\n    for version in &[\"1\", \"2\", \"3\"] {\n        let version_dir = product_dir.join(version);\n        if version_dir.exists() {\n            if let Ok(entries) = fs::read_dir(&version_dir) {\n                for entry in entries.filter_map(|e| e.ok()) {\n                    let path = entry.path();\n                    if path.extension().map(|s| s == \"alb\").unwrap_or(false) {\n                        return Ok(path);\n                    }\n                }\n            }\n        }\n    }\n    Err(\"No ALB file found in product directory\".to_string())\n}\n\nfn cmd_svg(ebase_path: &str, output: Option<&str>) -> CmdResult {\n    println!(\"Reading 2D records from: {}\", ebase_path);\n\n    let compound =\n        operations::export_2d_floorplan(Path::new(ebase_path)).map_err(|e| e.to_string())?;\n\n    let svg = compound.to_svg();\n\n    let output_path = output.map(|s| s.to_string()).unwrap_or_else(|| {\n        Path::new(ebase_path)\n            .with_extension(\"svg\")\n            .to_string_lossy()\n            .to_string()\n    });\n\n    fs::write(&output_path, &svg).map_err(|e| e.to_string())?;\n    println!(\"Written: {} ({} bytes)\", output_path, svg.len());\n    Ok(())\n}\n\nfn cmd_expr(expression: &str) -> CmdResult {\n    use std::collections::HashMap;\n\n    println!(\"Evaluating: {}\", expression);\n    println!(\"{:-<60}\", \"\");\n\n    let props: HashMap<String, f64> = HashMap::new();\n    let result = operations::evaluate_expression(expression, &props)?;\n\n    println!(\"Result: {:?}\", result);\n    Ok(())\n}\n\nfn cmd_manufacturer(\n    data_dir: &str,\n    manufacturer: Option<&str>,\n    class_name: Option<&str>,\n) -> CmdResult {\n    let data_path = Path::new(data_dir);\n\n    match manufacturer {\n        None => {\n            println!(\"OFML Data Directory: {}\", data_dir);\n            println!(\"{}\", \"=\".repeat(60));\n            println!();\n\n            let mut manufacturers = Vec::new();\n            if let Ok(entries) = fs::read_dir(data_path) {\n                for entry in entries.filter_map(|e| e.ok()) {\n                    let path = entry.path();\n                    if path.is_dir() {\n                        if let Some(name) = path.file_name().and_then(|n| n.to_str()) {\n                            if !name.starts_with('.')\n                                && !name.starts_with(\"pCon\")\n                                && !name.contains(\"plugin\")\n                                && !name.contains(\"setup\")\n                                && (path.join(\"basics\").exists() || path.join(\"global\").exists())\n                            {\n                                manufacturers.push(name.to_string());\n                            }\n                        }\n                    }\n                }\n            }\n\n            manufacturers.sort();\n            println!(\"Available manufacturers ({}):\", manufacturers.len());\n            for mfr in &manufacturers {\n                let mut alb_count = 0;\n                let mut cls_count = 0;\n                let mfr_path = data_path.join(mfr);\n                if let Ok(entries) = fs::read_dir(&mfr_path) {\n                    for entry in entries.filter_map(|e| e.ok()) {\n                        if entry.path().is_dir() {\n                            alb_count += 1;\n                        }\n                    }\n                }\n\n                let mut loader = AlbLoader::new(data_path);\n                if loader.load_manufacturer(mfr).is_ok() {\n                    cls_count = loader.stats().classes;\n                }\n\n                if cls_count > 0 {\n                    println!(\"  {}: {} packages, {} classes\", mfr, alb_count, cls_count);\n                } else {\n                    println!(\"  {}: {} packages\", mfr, alb_count);\n                }\n            }\n\n            println!();\n            println!(\"Usage: manufacturer <data_dir> <manufacturer> [class]\");\n        }\n        Some(mfr) => {\n            println!(\"Loading manufacturer: {}\", mfr);\n            println!(\"{}\", \"=\".repeat(60));\n\n            let loader =\n                load_manufacturer_with_deps(data_path, mfr, None).map_err(|e| e.to_string())?;\n\n            let stats = loader.stats();\n            println!();\n            println!(\"Loaded:\");\n            println!(\"  ALBs: {}\", stats.albs);\n            println!(\"  Packages: {}\", stats.packages);\n            println!(\"  CLS Files: {}\", stats.files);\n            println!(\"  Classes: {}\", stats.classes);\n            println!();\n\n            println!(\"Packages:\");\n            let mut packages: Vec<_> = loader.sources.keys().collect();\n            packages.sort();\n            for pkg in packages.iter().take(20) {\n                let cls_count = loader.sources.get(*pkg).map(|v| v.len()).unwrap_or(0);\n                println!(\"  {} ({} files)\", pkg, cls_count);\n            }\n            if packages.len() > 20 {\n                println!(\"  ... and {} more\", packages.len() - 20);\n            }\n            println!();\n\n            let mut interp = Interpreter::new();\n            match loader.load_into_interpreter(&mut interp) {\n                Ok(loaded) => {\n                    println!(\"Successfully parsed {} CLS files\", loaded);\n                    println!(\"Registered {} classes in interpreter\", interp.classes.len());\n                }\n                Err(e) => {\n                    eprintln!(\"Warning: Some files failed to load: {}\", e);\n                }\n            }\n\n            match class_name {\n                None => {\n                    println!();\n                    println!(\"Available classes ({})\", interp.classes.len());\n                    let mut names: Vec<_> = interp.classes.keys().collect();\n                    names.sort();\n                    for name in names.iter().take(50) {\n                        println!(\"  {}\", name);\n                    }\n                    if names.len() > 50 {\n                        println!(\"  ... and {} more\", names.len() - 50);\n                    }\n                    println!();\n                    println!(\"Usage: manufacturer {} {} <class_name>\", data_dir, mfr);\n                }\n                Some(target_class) => {\n                    println!();\n                    println!(\"Instantiating: {}\", target_class);\n\n                    if let Some(class) = interp.classes.get(target_class).cloned() {\n                        match interp.instantiate_class_public(class) {\n                            Ok(instance) => {\n                                println!(\"Instance created successfully!\");\n\n                                if let ofml_lib::Value::Object(obj_ref) = &instance {\n                                    let obj = obj_ref.borrow();\n                                    println!(\"  Class: {}\", obj.class.name);\n                                    println!(\"  Properties: {}\", obj.properties.len());\n                                    for (key, _) in obj.properties.iter().take(10) {\n                                        println!(\"    - {}\", key);\n                                    }\n                                }\n\n                                if interp.scene.mesh_count() > 0 {\n                                    let scene3ds = interp.scene.to_scene();\n                                    let glb =\n                                        export_to_glb(&scene3ds).map_err(|e| e.to_string())?;\n\n                                    let output_path =\n                                        format!(\"/tmp/{}_{}.glb\", mfr, target_class.to_lowercase());\n                                    fs::write(&output_path, &glb).map_err(|e| e.to_string())?;\n                                    println!();\n                                    println!(\n                                        \"Geometry exported: {} ({} bytes, {} meshes)\",\n                                        output_path,\n                                        glb.len(),\n                                        scene3ds.meshes.len()\n                                    );\n                                }\n                            }\n                            Err(e) => {\n                                eprintln!(\"Error instantiating class: {}\", e);\n                            }\n                        }\n                    } else {\n                        let target_lower = target_class.to_lowercase();\n                        let similar: Vec<_> = interp\n                            .classes\n                            .keys()\n                            .filter(|n| n.to_lowercase().contains(&target_lower))\n                            .take(10)\n                            .collect();\n\n                        if !similar.is_empty() {\n                            println!(\"Class '{}' not found. Similar classes:\", target_class);\n                            for name in similar {\n                                println!(\"  {}\", name);\n                            }\n                        } else {\n                            return Err(format!(\"Class '{}' not found\", target_class));\n                        }\n                    }\n                }\n            }\n        }\n    }\n    Ok(())\n}\n\nfn cmd_extract(alb_path: &str, pattern: &str) -> CmdResult {\n    use std::io::Read;\n\n    let password = b\"Gur#Ynzo$Yvrf%Qbja&Ba*Oebnqjnl.\";\n    let file = fs::File::open(alb_path).map_err(|e| e.to_string())?;\n    let mut archive = zip::ZipArchive::new(file).map_err(|e| e.to_string())?;\n\n    println!(\"ALB archive: {}\", alb_path);\n    println!(\n        \"Pattern: {}\",\n        if pattern.is_empty() { \"*\" } else { pattern }\n    );\n\n    let mut converted = 0;\n    let output_dir = Path::new(alb_path).parent().unwrap_or(Path::new(\".\"));\n\n    for i in 0..archive.len() {\n        let mut file = match archive.by_index_decrypt(i, password) {\n            Ok(f) => f,\n            Err(_) => continue,\n        };\n\n        let name = file.name().to_string();\n        if !name.to_lowercase().ends_with(\".3ds\") {\n            continue;\n        }\n        if !pattern.is_empty() && !name.to_lowercase().contains(&pattern.to_lowercase()) {\n            continue;\n        }\n\n        let mut data = Vec::new();\n        if file.read_to_end(&mut data).is_err() {\n            continue;\n        }\n\n        let scene = match geometry::parse_3ds(&data) {\n            Ok(s) => s,\n            Err(e) => {\n                eprintln!(\"  {} - parse error: {}\", name, e);\n                continue;\n            }\n        };\n\n        let glb = match export_to_glb(&scene) {\n            Ok(g) => g,\n            Err(e) => {\n                eprintln!(\"  {} - convert error: {}\", name, e);\n                continue;\n            }\n        };\n\n        let base_name = Path::new(&name)\n            .file_stem()\n            .and_then(|s| s.to_str())\n            .unwrap_or(\"output\");\n        let output_path = output_dir.join(format!(\"{}.glb\", base_name));\n\n        if fs::write(&output_path, &glb).is_ok() {\n            let verts: usize = scene.meshes.iter().map(|m| m.vertices.len()).sum();\n            let faces: usize = scene.meshes.iter().map(|m| m.faces.len()).sum();\n            println!(\n                \"  {} -> {} ({} verts, {} faces)\",\n                name,\n                output_path.display(),\n                verts,\n                faces\n            );\n            converted += 1;\n        }\n    }\n\n    println!(\"\\nConverted {} files\", converted);\n    Ok(())\n}\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\nfn print_stmt(stmt: &ofml_lib::ast::Stmt, idx: usize, indent: usize) {\n    let prefix = \"  \".repeat(indent);\n    use ofml_lib::ast::Stmt;\n\n    match stmt {\n        Stmt::Class(c) => {\n            let parent = c\n                .parent\n                .as_ref()\n                .map(|p| format!(\": {}\", p))\n                .unwrap_or_default();\n            println!(\"{}[{}] class {}{}\", prefix, idx, c.name, parent);\n            println!(\"{}     members: {}\", prefix, c.members.len());\n        }\n        Stmt::Func(f) => {\n            println!(\n                \"{}[{}] func {}({})\",\n                prefix,\n                idx,\n                f.name,\n                f.params.join(\", \")\n            );\n        }\n        Stmt::Var(v) => {\n            let init = if v.initializer.is_some() {\n                \" = ...\"\n            } else {\n                \"\"\n            };\n            println!(\"{}[{}] var {}{}\", prefix, idx, v.name, init);\n        }\n        Stmt::If(_) => println!(\"{}[{}] if statement\", prefix, idx),\n        Stmt::While(_) => println!(\"{}[{}] while loop\", prefix, idx),\n        Stmt::For(_) => println!(\"{}[{}] for loop\", prefix, idx),\n        Stmt::Foreach(_) => println!(\"{}[{}] foreach loop\", prefix, idx),\n        Stmt::Return(_) => println!(\"{}[{}] return\", prefix, idx),\n        Stmt::Expr(_) => println!(\"{}[{}] expression\", prefix, idx),\n        Stmt::Block(b) => {\n            println!(\"{}[{}] block ({} stmts)\", prefix, idx, b.stmts.len());\n        }\n        _ => println!(\"{}[{}] {:?}\", prefix, idx, std::mem::discriminant(stmt)),\n    }\n}\n\nfn count_elements(unit: &ofml_lib::ast::TranslationUnit) -> (usize, usize, usize) {\n    use ofml_lib::ast::{ClassMember, Stmt};\n\n    let mut classes = 0;\n    let mut funcs = 0;\n    let mut vars = 0;\n\n    fn count_stmt(stmt: &Stmt, classes: &mut usize, funcs: &mut usize, vars: &mut usize) {\n        match stmt {\n            Stmt::Class(c) => {\n                *classes += 1;\n                for member in &c.members {\n                    match member {\n                        ClassMember::Func(_) => *funcs += 1,\n                        ClassMember::Var(_) => *vars += 1,\n                        ClassMember::Rule(_) => *funcs += 1,\n                        ClassMember::Expr(_) => {}\n                    }\n                }\n            }\n            Stmt::Func(_) => *funcs += 1,\n            Stmt::Var(_) => *vars += 1,\n            Stmt::Block(b) => {\n                for s in &b.stmts {\n                    count_stmt(s, classes, funcs, vars);\n                }\n            }\n            _ => {}\n        }\n    }\n\n    for stmt in &unit.statements {\n        count_stmt(stmt, &mut classes, &mut funcs, &mut vars);\n    }\n\n    (classes, funcs, vars)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","benches","ebase_expr_bench.rs"],"content":"//! Benchmarks for EBASE expression evaluation.\r\n\r\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\r\nuse ofml_lib::ebase_expr::EbaseEvaluator;\r\nuse std::collections::HashMap;\r\n\r\nfn bench_simple_import(c: &mut Criterion) {\r\n    let mut evaluator = EbaseEvaluator::new();\r\n    let props = HashMap::new();\r\n\r\n    c.bench_function(\"simple_import\", |b| {\r\n        b.iter(|| {\r\n            evaluator\r\n                .evaluate(black_box(r#\"\"table_top\" 1 1 1 imp\"#), &props)\r\n                .unwrap()\r\n        })\r\n    });\r\n}\r\n\r\nfn bench_variable_substitution(c: &mut Criterion) {\r\n    let mut evaluator = EbaseEvaluator::new();\r\n    let mut props = HashMap::new();\r\n    props.insert(\"M__BREITE\".to_string(), 1600.0);\r\n    props.insert(\"M__TIEFE\".to_string(), 800.0);\r\n    props.insert(\"M__HOEHE\".to_string(), 720.0);\r\n\r\n    c.bench_function(\"variable_substitution\", |b| {\r\n        b.iter(|| {\r\n            evaluator\r\n                .evaluate(\r\n                    black_box(r#\"\"panel\" ${M__BREITE:-100} 1000 / ${M__TIEFE:-100} 1000 / 1 imp\"#),\r\n                    &props,\r\n                )\r\n                .unwrap()\r\n        })\r\n    });\r\n}\r\n\r\nfn bench_arithmetic_expression(c: &mut Criterion) {\r\n    let mut evaluator = EbaseEvaluator::new();\r\n    let props = HashMap::new();\r\n\r\n    c.bench_function(\"arithmetic_expression\", |b| {\r\n        b.iter(|| {\r\n            evaluator\r\n                .evaluate(\r\n                    black_box(r#\"\"test\" 100 200 + 300 * 1000 / 1 1 imp\"#),\r\n                    &props,\r\n                )\r\n                .unwrap()\r\n        })\r\n    });\r\n}\r\n\r\nfn bench_conditional_expression(c: &mut Criterion) {\r\n    let mut evaluator = EbaseEvaluator::new();\r\n    let props = HashMap::new();\r\n\r\n    c.bench_function(\"conditional_expression\", |b| {\r\n        b.iter(|| {\r\n            evaluator\r\n                .evaluate(\r\n                    black_box(r#\"1 1 == { \"true_case\" } { \"false_case\" } ifelse 1 1 1 imp\"#),\r\n                    &props,\r\n                )\r\n                .unwrap()\r\n        })\r\n    });\r\n}\r\n\r\ncriterion_group!(\r\n    benches,\r\n    bench_simple_import,\r\n    bench_variable_substitution,\r\n    bench_arithmetic_expression,\r\n    bench_conditional_expression\r\n);\r\ncriterion_main!(benches);\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","benches","family_loading_bench.rs"],"content":"//! Benchmarks for product family loading with parallel processing.\r\n//!\r\n//! These benchmarks measure the performance of loading manufacturer data,\r\n//! including EBase parsing, OAM loading, and article grouping.\r\n//!\r\n//! Run with: `cargo bench --bench family_loading_bench`\r\n\r\nuse criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion};\r\nuse std::path::Path;\r\n\r\n/// Benchmark loading a single manufacturer's families\r\n/// This measures the full parallel loading pipeline:\r\n/// - Property loading (parallel EBase parsing)\r\n/// - OAM loading (parallel)\r\n/// - Article loading and grouping (parallel)\r\nfn bench_family_loading(c: &mut Criterion) {\r\n    let mut group = c.benchmark_group(\"family_loading\");\r\n\r\n    // Configure for longer measurement time due to I/O\r\n    group.sample_size(20);\r\n    group.measurement_time(std::time::Duration::from_secs(10));\r\n\r\n    // Test with available manufacturers\r\n    let manufacturers = [\r\n        (\"/reference/ofmldata/sex\", \"Sedus\"),\r\n        (\"/reference/ofmldata/bisley\", \"Bisley\"),\r\n        (\"/reference/ofmldata/vitra\", \"Vitra\"),\r\n        (\"/reference/ofmldata/frmr\", \"Framery\"),\r\n    ];\r\n\r\n    for (path, name) in manufacturers {\r\n        let mfr_path = Path::new(path);\r\n        if !mfr_path.exists() {\r\n            continue;\r\n        }\r\n\r\n        group.bench_with_input(\r\n            BenchmarkId::new(\"load_families\", name),\r\n            &mfr_path,\r\n            |b, path| {\r\n                b.iter(|| {\r\n                    ofml_lib::oap::families::FamilyLoader::load(\r\n                        black_box(path),\r\n                        \"DE\",\r\n                    )\r\n                })\r\n            },\r\n        );\r\n    }\r\n\r\n    group.finish();\r\n}\r\n\r\n/// Benchmark loading OCD properties only (parallel EBase parsing)\r\nfn bench_property_loading(c: &mut Criterion) {\r\n    let mut group = c.benchmark_group(\"property_loading\");\r\n    group.sample_size(20);\r\n    group.measurement_time(std::time::Duration::from_secs(10));\r\n\r\n    let manufacturers = [\r\n        (\"/reference/ofmldata/sex\", \"Sedus\"),\r\n        (\"/reference/ofmldata/bisley\", \"Bisley\"),\r\n    ];\r\n\r\n    for (path, name) in manufacturers {\r\n        let mfr_path = Path::new(path);\r\n        if !mfr_path.exists() {\r\n            continue;\r\n        }\r\n\r\n        group.bench_with_input(\r\n            BenchmarkId::new(\"load_properties\", name),\r\n            &mfr_path,\r\n            |b, path| {\r\n                b.iter(|| {\r\n                    ofml_lib::oap::ocd_properties::load_manufacturer_properties(\r\n                        black_box(path),\r\n                    )\r\n                })\r\n            },\r\n        );\r\n    }\r\n\r\n    group.finish();\r\n}\r\n\r\n/// Benchmark single EBase file reading (baseline for parallel comparison)\r\nfn bench_ocd_reader(c: &mut Criterion) {\r\n    let pdata_path = Path::new(\"/reference/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\r\n    if !pdata_path.exists() {\r\n        return;\r\n    }\r\n\r\n    c.bench_function(\"ocd_reader_single_file\", |b| {\r\n        b.iter(|| {\r\n            ofml_lib::oap::ocd::OcdReader::from_ebase(black_box(pdata_path))\r\n        })\r\n    });\r\n}\r\n\r\n/// Benchmark article loading with descriptions (parallel)\r\nfn bench_article_loading(c: &mut Criterion) {\r\n    let mut group = c.benchmark_group(\"article_loading\");\r\n    group.sample_size(20);\r\n\r\n    let manufacturers = [\r\n        (\"/reference/ofmldata/sex\", \"Sedus\"),\r\n        (\"/reference/ofmldata/bisley\", \"Bisley\"),\r\n    ];\r\n\r\n    for (path, name) in manufacturers {\r\n        let mfr_path = Path::new(path);\r\n        if !mfr_path.exists() {\r\n            continue;\r\n        }\r\n\r\n        group.bench_with_input(\r\n            BenchmarkId::new(\"load_articles\", name),\r\n            &mfr_path,\r\n            |b, path| {\r\n                b.iter(|| {\r\n                    ofml_lib::oap::ocd::load_articles_with_full_descriptions(\r\n                        black_box(path),\r\n                        \"DE\",\r\n                    )\r\n                })\r\n            },\r\n        );\r\n    }\r\n\r\n    group.finish();\r\n}\r\n\r\ncriterion_group!(\r\n    benches,\r\n    bench_family_loading,\r\n    bench_property_loading,\r\n    bench_ocd_reader,\r\n    bench_article_loading,\r\n);\r\ncriterion_main!(benches);\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","benches","geometry_bench.rs"],"content":"//! Benchmarks for geometry loading and processing.\n\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse ofml_lib::geometry::{parse_obj, scene_to_glb};\n\n// Sample OBJ data\nfn create_sample_obj_data() -> Vec<u8> {\n    let obj_content = r#\"\n# Simple cube OBJ\nv -0.5 -0.5 0.5\nv 0.5 -0.5 0.5\nv 0.5 0.5 0.5\nv -0.5 0.5 0.5\nv -0.5 -0.5 -0.5\nv 0.5 -0.5 -0.5\nv 0.5 0.5 -0.5\nv -0.5 0.5 -0.5\nf 1 2 3 4\nf 5 6 7 8\nf 1 5 6 2\nf 2 6 7 3\nf 3 7 8 4\nf 4 8 5 1\n\"#;\n    obj_content.as_bytes().to_vec()\n}\n\nfn bench_parse_obj(c: &mut Criterion) {\n    let data = create_sample_obj_data();\n\n    c.bench_function(\"parse_obj_cube\", |b| b.iter(|| parse_obj(black_box(&data))));\n}\n\nfn bench_parse_obj_large(c: &mut Criterion) {\n    // Create a larger OBJ with many vertices\n    let mut obj_content = String::from(\"# Large mesh\\n\");\n    for i in 0..1000 {\n        let x = (i % 10) as f32;\n        let y = ((i / 10) % 10) as f32;\n        let z = (i / 100) as f32;\n        obj_content.push_str(&format!(\"v {} {} {}\\n\", x, y, z));\n    }\n    // Add some faces\n    for i in 0..333 {\n        let base = i * 3 + 1;\n        obj_content.push_str(&format!(\"f {} {} {}\\n\", base, base + 1, base + 2));\n    }\n    let data = obj_content.as_bytes().to_vec();\n\n    c.bench_function(\"parse_obj_large\", |b| {\n        b.iter(|| parse_obj(black_box(&data)))\n    });\n}\n\nfn bench_scene_to_glb(c: &mut Criterion) {\n    use ofml_lib::geometry::{CoordSystem, Face, Material3DS, Mesh, Scene3DS, Vertex};\n\n    // Create a simple scene\n    let mut scene = Scene3DS::default();\n    let mesh = Mesh {\n        name: \"cube\".to_string(),\n        vertices: vec![\n            Vertex {\n                x: -0.5,\n                y: -0.5,\n                z: 0.5,\n            },\n            Vertex {\n                x: 0.5,\n                y: -0.5,\n                z: 0.5,\n            },\n            Vertex {\n                x: 0.5,\n                y: 0.5,\n                z: 0.5,\n            },\n            Vertex {\n                x: -0.5,\n                y: 0.5,\n                z: 0.5,\n            },\n            Vertex {\n                x: -0.5,\n                y: -0.5,\n                z: -0.5,\n            },\n            Vertex {\n                x: 0.5,\n                y: -0.5,\n                z: -0.5,\n            },\n            Vertex {\n                x: 0.5,\n                y: 0.5,\n                z: -0.5,\n            },\n            Vertex {\n                x: -0.5,\n                y: 0.5,\n                z: -0.5,\n            },\n        ],\n        normals: vec![],\n        faces: vec![\n            Face {\n                a: 0,\n                b: 1,\n                c: 2,\n                flags: 0,\n            },\n            Face {\n                a: 0,\n                b: 2,\n                c: 3,\n                flags: 0,\n            },\n            Face {\n                a: 4,\n                b: 5,\n                c: 6,\n                flags: 0,\n            },\n            Face {\n                a: 4,\n                b: 6,\n                c: 7,\n                flags: 0,\n            },\n        ],\n        tex_coords: vec![],\n        material_name: Some(\"default\".to_string()),\n        transform: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0],\n        coord_system: CoordSystem::YupGltf,\n    };\n    scene.meshes.push(mesh);\n    scene.materials.insert(\n        \"default\".to_string(),\n        Material3DS {\n            name: \"default\".to_string(),\n            diffuse: [0.8, 0.8, 0.8],\n            ambient: [0.2, 0.2, 0.2],\n            specular: [0.3, 0.3, 0.3],\n            texture: None,\n            metallic: 0.0,\n            roughness: 0.5,\n        },\n    );\n\n    c.bench_function(\"scene_to_glb\", |b| {\n        b.iter(|| scene_to_glb(black_box(&scene)))\n    });\n}\n\nfn bench_glb_export_large(c: &mut Criterion) {\n    use ofml_lib::geometry::{CoordSystem, Face, Material3DS, Mesh, Scene3DS, Vertex};\n\n    // Create a larger scene\n    let mut scene = Scene3DS::default();\n    let mut vertices = Vec::new();\n    let mut faces = Vec::new();\n\n    // Generate a grid of vertices\n    for i in 0..100 {\n        for j in 0..100 {\n            vertices.push(Vertex {\n                x: i as f32 / 100.0,\n                y: j as f32 / 100.0,\n                z: ((i + j) as f32 / 200.0).sin() * 0.1,\n            });\n        }\n    }\n\n    // Generate faces\n    for i in 0..99 {\n        for j in 0..99 {\n            let base = i * 100 + j;\n            faces.push(Face {\n                a: base as u16,\n                b: (base + 1) as u16,\n                c: (base + 100) as u16,\n                flags: 0,\n            });\n            faces.push(Face {\n                a: (base + 1) as u16,\n                b: (base + 101) as u16,\n                c: (base + 100) as u16,\n                flags: 0,\n            });\n        }\n    }\n\n    scene.meshes.push(Mesh {\n        name: \"terrain\".to_string(),\n        vertices,\n        normals: vec![],\n        faces,\n        tex_coords: vec![],\n        material_name: Some(\"terrain_mat\".to_string()),\n        transform: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0],\n        coord_system: CoordSystem::YupGltf,\n    });\n\n    scene.materials.insert(\n        \"terrain_mat\".to_string(),\n        Material3DS {\n            name: \"terrain_mat\".to_string(),\n            diffuse: [0.5, 0.7, 0.4],\n            ambient: [0.2, 0.2, 0.2],\n            specular: [0.1, 0.1, 0.1],\n            texture: None,\n            metallic: 0.0,\n            roughness: 0.8,\n        },\n    );\n\n    c.bench_function(\"glb_export_large\", |b| {\n        b.iter(|| scene_to_glb(black_box(&scene)))\n    });\n}\n\ncriterion_group!(\n    benches,\n    bench_parse_obj,\n    bench_parse_obj_large,\n    bench_scene_to_glb,\n    bench_glb_export_large\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","src","alb_loader.rs"],"content":"//! Multi-ALB Loader for OFML Package Dependencies\n//!\n//! This module handles loading multiple ALB (Archive Library) files in the correct\n//! dependency order and resolving cross-package class references.\n//!\n//! ## Architecture\n//!\n//! OFML manufacturers typically organize their data in multiple ALBs:\n//! - `global` - Global manufacturer settings and resources\n//! - `basics` - Base classes shared across products\n//! - Product-specific ALBs (e.g., `workit`, `joyn`)\n//!\n//! The loader ensures that dependencies are loaded before dependents.\n\nuse std::collections::{HashMap, HashSet};\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::{Path, PathBuf};\n\nuse crate::interpreter::Interpreter;\nuse crate::parser::Parser;\n\n/// ALB Archive password (standard OFML encryption key)\nconst ALB_PASSWORD: &[u8] = b\"Gur#Ynzo$Yvrf%Qbja&Ba*Oebnqjnl.\";\n\n/// Result type for ALB operations\npub type AlbResult<T> = Result<T, AlbError>;\n\n/// ALB loading errors\n#[derive(Debug)]\npub enum AlbError {\n    Io(std::io::Error),\n    Zip(zip::result::ZipError),\n    Parse(String),\n    MissingDependency(String),\n    CircularDependency(String),\n}\n\nimpl std::fmt::Display for AlbError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            AlbError::Io(e) => write!(f, \"IO error: {}\", e),\n            AlbError::Zip(e) => write!(f, \"ZIP error: {}\", e),\n            AlbError::Parse(msg) => write!(f, \"Parse error: {}\", msg),\n            AlbError::MissingDependency(dep) => write!(f, \"Missing dependency: {}\", dep),\n            AlbError::CircularDependency(msg) => write!(f, \"Circular dependency: {}\", msg),\n        }\n    }\n}\n\nimpl std::error::Error for AlbError {}\n\nimpl From<std::io::Error> for AlbError {\n    fn from(e: std::io::Error) -> Self {\n        AlbError::Io(e)\n    }\n}\n\nimpl From<zip::result::ZipError> for AlbError {\n    fn from(e: zip::result::ZipError) -> Self {\n        AlbError::Zip(e)\n    }\n}\n\n/// CLS source file with package information\n#[derive(Debug, Clone)]\npub struct ClsSource {\n    /// Original filename\n    pub filename: String,\n    /// Package declaration (e.g., \"::vitra::workit\")\n    pub package: String,\n    /// Import statements\n    pub imports: Vec<String>,\n    /// Source code\n    pub source: String,\n    /// Classes defined in this file\n    pub classes: Vec<String>,\n    /// Parent classes referenced (for dependency ordering)\n    pub parent_classes: Vec<String>,\n}\n\nimpl ClsSource {\n    /// Parse CLS source to extract package, imports, and class definitions\n    pub fn parse(filename: &str, source: &str) -> Self {\n        let mut package = String::new();\n        let mut imports = Vec::new();\n        let mut classes = Vec::new();\n        let mut parent_classes = Vec::new();\n\n        for line in source.lines() {\n            let line = line.trim();\n\n            // Package declaration\n            if line.starts_with(\"package \") {\n                package = line\n                    .strip_prefix(\"package \")\n                    .unwrap_or(\"\")\n                    .trim_end_matches(';')\n                    .trim()\n                    .to_string();\n            }\n\n            // Import statements\n            if line.starts_with(\"import \") {\n                let import = line\n                    .strip_prefix(\"import \")\n                    .unwrap_or(\"\")\n                    .trim_end_matches(';')\n                    .trim()\n                    .to_string();\n                imports.push(import);\n            }\n\n            // Class definitions with inheritance\n            if line.contains(\"class \") && (line.contains(\": \") || line.contains(\":\")) {\n                // Extract class name and parent\n                if let Some(class_part) = line.split(\"class \").nth(1) {\n                    let parts: Vec<&str> = class_part.split(':').collect();\n                    if !parts.is_empty() {\n                        let class_name = parts[0].trim().to_string();\n                        if !class_name.is_empty() && class_name != \"{\" {\n                            classes.push(class_name);\n                        }\n                    }\n                    if parts.len() > 1 {\n                        let parent = parts[1].trim().trim_start_matches(':').trim();\n                        // Remove anything after the class name (like {)\n                        let parent = parent.split_whitespace().next().unwrap_or(parent);\n                        let parent = parent.trim_end_matches('{').trim();\n                        if !parent.is_empty() {\n                            parent_classes.push(parent.to_string());\n                        }\n                    }\n                }\n            }\n        }\n\n        Self {\n            filename: filename.to_string(),\n            package,\n            imports,\n            source: source.to_string(),\n            classes,\n            parent_classes,\n        }\n    }\n\n    /// Get the fully qualified class names\n    pub fn qualified_classes(&self) -> Vec<String> {\n        self.classes\n            .iter()\n            .map(|c| {\n                if self.package.is_empty() {\n                    c.clone()\n                } else {\n                    format!(\"{}::{}\", self.package, c)\n                }\n            })\n            .collect()\n    }\n}\n\n/// Multi-ALB loader for loading manufacturer packages with dependencies\n#[derive(Debug)]\npub struct AlbLoader {\n    /// Base directory for OFML data\n    pub data_dir: PathBuf,\n    /// Loaded CLS sources by package\n    pub sources: HashMap<String, Vec<ClsSource>>,\n    /// Class name to package mapping\n    pub class_to_package: HashMap<String, String>,\n    /// Package to ALB path mapping\n    pub package_to_alb: HashMap<String, PathBuf>,\n    /// Loaded ALBs (to avoid reloading)\n    loaded_albs: HashSet<PathBuf>,\n}\n\nimpl AlbLoader {\n    /// Create a new ALB loader\n    pub fn new(data_dir: impl AsRef<Path>) -> Self {\n        Self {\n            data_dir: data_dir.as_ref().to_path_buf(),\n            sources: HashMap::new(),\n            class_to_package: HashMap::new(),\n            package_to_alb: HashMap::new(),\n            loaded_albs: HashSet::new(),\n        }\n    }\n\n    /// Load all ALBs for a manufacturer with dependencies\n    pub fn load_manufacturer(&mut self, manufacturer: &str) -> AlbResult<()> {\n        let mfr_dir = self.data_dir.join(manufacturer);\n        if !mfr_dir.exists() {\n            return Err(AlbError::Io(std::io::Error::new(\n                std::io::ErrorKind::NotFound,\n                format!(\"Manufacturer directory not found: {}\", manufacturer),\n            )));\n        }\n\n        // Find all ALBs for this manufacturer\n        let mut albs = Vec::new();\n        self.find_albs(&mfr_dir, &mut albs)?;\n\n        // Load ALBs in dependency order (global, basics first)\n        let priority_order = [\"global\", \"basics\", \"extension\"];\n\n        // Sort ALBs by priority\n        albs.sort_by(|a, b| {\n            let a_name = a.file_stem().unwrap_or_default().to_string_lossy();\n            let b_name = b.file_stem().unwrap_or_default().to_string_lossy();\n\n            let a_priority = priority_order\n                .iter()\n                .position(|&p| a_name.contains(p))\n                .unwrap_or(99);\n            let b_priority = priority_order\n                .iter()\n                .position(|&p| b_name.contains(p))\n                .unwrap_or(99);\n\n            a_priority.cmp(&b_priority)\n        });\n\n        // Load each ALB\n        for alb_path in albs {\n            self.load_alb(&alb_path)?;\n        }\n\n        Ok(())\n    }\n\n    /// Find all ALB files in a directory recursively\n    fn find_albs(&self, dir: &Path, albs: &mut Vec<PathBuf>) -> AlbResult<()> {\n        if !dir.is_dir() {\n            return Ok(());\n        }\n\n        for entry in std::fs::read_dir(dir)? {\n            let entry = entry?;\n            let path = entry.path();\n\n            if path.is_dir() {\n                self.find_albs(&path, albs)?;\n            } else if path.extension().is_some_and(|e| e == \"alb\") {\n                albs.push(path);\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Load a single ALB file\n    pub fn load_alb(&mut self, path: &Path) -> AlbResult<Vec<ClsSource>> {\n        let canonical = path.canonicalize().unwrap_or_else(|_| path.to_path_buf());\n\n        if self.loaded_albs.contains(&canonical) {\n            // Already loaded, return existing sources\n            return Ok(Vec::new());\n        }\n\n        let file = File::open(path)?;\n        let mut archive = zip::ZipArchive::new(file)?;\n        let mut cls_sources = Vec::new();\n\n        for i in 0..archive.len() {\n            let mut file = match archive.by_index_decrypt(i, ALB_PASSWORD) {\n                Ok(f) => f,\n                Err(_) => continue,\n            };\n\n            let name = file.name().to_string();\n            if !name.to_lowercase().ends_with(\".cls\") {\n                continue;\n            }\n\n            let mut source = String::new();\n            if file.read_to_string(&mut source).is_ok() {\n                let cls = ClsSource::parse(&name, &source);\n\n                // Register classes\n                for class_name in &cls.classes {\n                    self.class_to_package\n                        .insert(class_name.clone(), cls.package.clone());\n                }\n\n                // Register package to ALB mapping\n                if !cls.package.is_empty() {\n                    self.package_to_alb\n                        .insert(cls.package.clone(), path.to_path_buf());\n                }\n\n                cls_sources.push(cls);\n            }\n        }\n\n        // Store sources by package\n        for cls in &cls_sources {\n            self.sources\n                .entry(cls.package.clone())\n                .or_default()\n                .push(cls.clone());\n        }\n\n        self.loaded_albs.insert(canonical);\n        Ok(cls_sources)\n    }\n\n    /// Resolve a class name to its fully qualified name\n    pub fn resolve_class(\n        &self,\n        name: &str,\n        current_package: &str,\n        imports: &[String],\n    ) -> Option<String> {\n        // Already fully qualified\n        if name.starts_with(\"::\") {\n            return Some(name.to_string());\n        }\n\n        // Check current package\n        if self.class_to_package.get(name) == Some(&current_package.to_string()) {\n            return Some(format!(\"{}::{}\", current_package, name));\n        }\n\n        // Check imports\n        for import in imports {\n            let import_pkg = import.trim_end_matches(\"::*\");\n            if let Some(pkg) = self.class_to_package.get(name) {\n                if pkg.starts_with(import_pkg) || import_pkg.ends_with(&format!(\"::{}\", name)) {\n                    return Some(format!(\"{}::{}\", pkg, name));\n                }\n            }\n        }\n\n        // Check if it's a known class in any package\n        if let Some(pkg) = self.class_to_package.get(name) {\n            return Some(format!(\"{}::{}\", pkg, name));\n        }\n\n        // Could be a framework class\n        None\n    }\n\n    /// Get all CLS sources sorted by dependency order\n    pub fn get_sorted_sources(&self) -> Vec<&ClsSource> {\n        // First, collect and sort by filename to ensure deterministic initial order\n        let mut all_sources: Vec<&ClsSource> = self.sources.values().flatten().collect();\n        all_sources.sort_by(|a, b| a.filename.cmp(&b.filename));\n\n        // Build a map from class name to source index\n        let mut class_to_idx: HashMap<&str, usize> = HashMap::new();\n        for (i, src) in all_sources.iter().enumerate() {\n            for class in &src.classes {\n                class_to_idx.insert(class.as_str(), i);\n            }\n        }\n\n        // Calculate priority scores for each source\n        let priority_packages = [\"::ofml::oi\", \"::ofml::xoi\", \"::ofml::go\"];\n        let mut scores: Vec<(usize, i32, &str)> = all_sources\n            .iter()\n            .enumerate()\n            .map(|(i, src)| {\n                let mut score = 0i32;\n\n                // Package priority (lower is better)\n                let pkg_priority = priority_packages\n                    .iter()\n                    .position(|&p| src.package.starts_with(p))\n                    .map(|p| p as i32)\n                    .unwrap_or(99);\n                score += pkg_priority * 10000;\n\n                // Basics comes before others\n                if !src.package.contains(\"basics\") {\n                    score += 5000;\n                }\n\n                // Parent dependencies: if parent is in our sources, we should come after it\n                for parent in &src.parent_classes {\n                    if let Some(&parent_idx) = class_to_idx.get(parent.as_str()) {\n                        if parent_idx != i {\n                            // We depend on something, increase our score slightly\n                            score += 100;\n                        }\n                    }\n                }\n\n                (i, score, src.filename.as_str())\n            })\n            .collect();\n\n        // Sort by score, then by filename for deterministic ordering\n        scores.sort_by(|a, b| match a.1.cmp(&b.1) {\n            std::cmp::Ordering::Equal => a.2.cmp(b.2),\n            other => other,\n        });\n\n        // Return sources in sorted order\n        scores.iter().map(|&(i, _, _)| all_sources[i]).collect()\n    }\n\n    /// Load all sources into an interpreter\n    pub fn load_into_interpreter(&self, interp: &mut Interpreter) -> AlbResult<usize> {\n        let sources = self.get_sorted_sources();\n        let mut loaded = 0;\n        let mut errors = Vec::new();\n\n        for cls in sources {\n            match Parser::new(&cls.source) {\n                Ok(mut parser) => match parser.parse() {\n                    Ok(ast) => {\n                        if let Err(e) = interp.execute(&ast) {\n                            errors.push(format!(\"{}: {}\", cls.filename, e));\n                        } else {\n                            loaded += 1;\n                        }\n                    }\n                    Err(e) => {\n                        errors.push(format!(\"{}: parse error: {}\", cls.filename, e));\n                    }\n                },\n                Err(e) => {\n                    errors.push(format!(\"{}: lex error: {}\", cls.filename, e));\n                }\n            }\n        }\n\n        if !errors.is_empty() && loaded == 0 {\n            return Err(AlbError::Parse(errors.join(\"\\n\")));\n        }\n\n        Ok(loaded)\n    }\n\n    /// Get statistics about loaded packages\n    pub fn stats(&self) -> LoaderStats {\n        LoaderStats {\n            packages: self.sources.len(),\n            classes: self.class_to_package.len(),\n            files: self.sources.values().map(|v| v.len()).sum(),\n            albs: self.loaded_albs.len(),\n        }\n    }\n}\n\n/// Statistics about loaded packages\n#[derive(Debug, Clone)]\npub struct LoaderStats {\n    pub packages: usize,\n    pub classes: usize,\n    pub files: usize,\n    pub albs: usize,\n}\n\n/// Load manufacturer data with all dependencies\npub fn load_manufacturer_with_deps(\n    data_dir: &Path,\n    manufacturer: &str,\n    product_alb: Option<&Path>,\n) -> AlbResult<AlbLoader> {\n    let mut loader = AlbLoader::new(data_dir);\n\n    // Load ofml framework ALBs first if available\n    let ofml_path = data_dir.join(\"ofml\");\n    if ofml_path.exists() {\n        let _ = loader.load_manufacturer(\"ofml\");\n    }\n\n    // Load manufacturer\n    loader.load_manufacturer(manufacturer)?;\n\n    // Load specific product ALB if provided\n    if let Some(alb) = product_alb {\n        loader.load_alb(alb)?;\n    }\n\n    Ok(loader)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_cls_source_parse() {\n        let source = r#\"\npackage ::vitra::workit;\nimport ::ofml::oi::*;\nimport ::ofml::xoi::*;\n\npublic class WorkitDesk : xOiBTGPlElement3\n{\n    public func initialize(pFa, pNa)\n    {\n        xOiBTGPlElement3::initialize(pFa, pNa);\n    }\n}\n        \"#;\n\n        let cls = ClsSource::parse(\"workit.cls\", source);\n        assert_eq!(cls.package, \"::vitra::workit\");\n        assert_eq!(cls.imports.len(), 2);\n        assert!(cls.imports.contains(&\"::ofml::oi::*\".to_string()));\n        assert!(cls.imports.contains(&\"::ofml::xoi::*\".to_string()));\n        assert_eq!(cls.classes.len(), 1);\n        assert!(cls.classes.contains(&\"WorkitDesk\".to_string()));\n        assert!(cls.parent_classes.contains(&\"xOiBTGPlElement3\".to_string()));\n    }\n\n    #[test]\n    fn test_cls_source_parse_empty() {\n        let cls = ClsSource::parse(\"empty.cls\", \"\");\n        assert_eq!(cls.filename, \"empty.cls\");\n        assert!(cls.package.is_empty());\n        assert!(cls.imports.is_empty());\n        assert!(cls.classes.is_empty());\n        assert!(cls.parent_classes.is_empty());\n    }\n\n    #[test]\n    fn test_cls_source_parse_no_inheritance() {\n        let source = r#\"\npackage ::test;\nclass SimpleClass {\n    func test() {}\n}\n        \"#;\n        let cls = ClsSource::parse(\"simple.cls\", source);\n        assert_eq!(cls.package, \"::test\");\n        assert!(cls.classes.is_empty()); // No colon after class name means no inheritance detected\n    }\n\n    #[test]\n    fn test_cls_source_parse_multiple_classes() {\n        let source = r#\"\npackage ::multi;\nimport ::base::*;\npublic class ClassA : BaseA {}\nprivate class ClassB : BaseB {}\n        \"#;\n        let cls = ClsSource::parse(\"multi.cls\", source);\n        assert_eq!(cls.classes.len(), 2);\n        assert!(cls.classes.contains(&\"ClassA\".to_string()));\n        assert!(cls.classes.contains(&\"ClassB\".to_string()));\n        assert_eq!(cls.parent_classes.len(), 2);\n        assert!(cls.parent_classes.contains(&\"BaseA\".to_string()));\n        assert!(cls.parent_classes.contains(&\"BaseB\".to_string()));\n    }\n\n    #[test]\n    fn test_cls_source_qualified_classes() {\n        let cls = ClsSource {\n            filename: \"test.cls\".to_string(),\n            package: \"::test::package\".to_string(),\n            imports: vec![],\n            source: String::new(),\n            classes: vec![\"MyClass\".to_string(), \"OtherClass\".to_string()],\n            parent_classes: vec![],\n        };\n\n        let qualified = cls.qualified_classes();\n        assert!(qualified.contains(&\"::test::package::MyClass\".to_string()));\n        assert!(qualified.contains(&\"::test::package::OtherClass\".to_string()));\n    }\n\n    #[test]\n    fn test_cls_source_qualified_classes_empty_package() {\n        let cls = ClsSource {\n            filename: \"test.cls\".to_string(),\n            package: String::new(),\n            imports: vec![],\n            source: String::new(),\n            classes: vec![\"MyClass\".to_string()],\n            parent_classes: vec![],\n        };\n\n        let qualified = cls.qualified_classes();\n        assert_eq!(qualified, vec![\"MyClass\".to_string()]);\n    }\n\n    #[test]\n    fn test_alb_loader_new() {\n        let loader = AlbLoader::new(\"/tmp\");\n        assert_eq!(loader.data_dir, PathBuf::from(\"/tmp\"));\n        assert!(loader.sources.is_empty());\n        assert!(loader.class_to_package.is_empty());\n    }\n\n    #[test]\n    fn test_alb_loader_new_pathbuf() {\n        let loader = AlbLoader::new(PathBuf::from(\"/test/path\"));\n        assert_eq!(loader.data_dir, PathBuf::from(\"/test/path\"));\n    }\n\n    #[test]\n    fn test_resolve_class_fully_qualified() {\n        let loader = AlbLoader::new(\"/tmp\");\n        let result = loader.resolve_class(\"::ofml::xoi::xOiBTGPlElement3\", \"\", &[]);\n        assert_eq!(result, Some(\"::ofml::xoi::xOiBTGPlElement3\".to_string()));\n    }\n\n    #[test]\n    fn test_resolve_class_from_current_package() {\n        let mut loader = AlbLoader::new(\"/tmp\");\n        loader\n            .class_to_package\n            .insert(\"MyClass\".to_string(), \"::test::pkg\".to_string());\n\n        let result = loader.resolve_class(\"MyClass\", \"::test::pkg\", &[]);\n        assert_eq!(result, Some(\"::test::pkg::MyClass\".to_string()));\n    }\n\n    #[test]\n    fn test_resolve_class_from_imports() {\n        let mut loader = AlbLoader::new(\"/tmp\");\n        loader\n            .class_to_package\n            .insert(\"ImportedClass\".to_string(), \"::other::pkg\".to_string());\n\n        let imports = vec![\"::other::pkg::*\".to_string()];\n        let result = loader.resolve_class(\"ImportedClass\", \"::current::pkg\", &imports);\n        assert_eq!(result, Some(\"::other::pkg::ImportedClass\".to_string()));\n    }\n\n    #[test]\n    fn test_resolve_class_unknown() {\n        let loader = AlbLoader::new(\"/tmp\");\n        let result = loader.resolve_class(\"UnknownClass\", \"::test\", &[]);\n        assert_eq!(result, None);\n    }\n\n    #[test]\n    fn test_loader_stats_empty() {\n        let loader = AlbLoader::new(\"/tmp\");\n        let stats = loader.stats();\n        assert_eq!(stats.packages, 0);\n        assert_eq!(stats.classes, 0);\n        assert_eq!(stats.files, 0);\n        assert_eq!(stats.albs, 0);\n    }\n\n    #[test]\n    fn test_loader_stats_with_data() {\n        let mut loader = AlbLoader::new(\"/tmp\");\n\n        // Add some test data\n        loader.class_to_package.insert(\"A\".to_string(), \"pkg1\".to_string());\n        loader.class_to_package.insert(\"B\".to_string(), \"pkg1\".to_string());\n\n        let cls = ClsSource {\n            filename: \"test.cls\".to_string(),\n            package: \"pkg1\".to_string(),\n            imports: vec![],\n            source: String::new(),\n            classes: vec![\"A\".to_string(), \"B\".to_string()],\n            parent_classes: vec![],\n        };\n        loader.sources.insert(\"pkg1\".to_string(), vec![cls]);\n\n        let stats = loader.stats();\n        assert_eq!(stats.packages, 1);\n        assert_eq!(stats.classes, 2);\n        assert_eq!(stats.files, 1);\n    }\n\n    #[test]\n    fn test_alb_error_display() {\n        let io_err = AlbError::Io(std::io::Error::new(\n            std::io::ErrorKind::NotFound,\n            \"test error\",\n        ));\n        assert!(io_err.to_string().contains(\"IO error\"));\n        assert!(io_err.to_string().contains(\"test error\"));\n\n        let parse_err = AlbError::Parse(\"parse failed\".to_string());\n        assert!(parse_err.to_string().contains(\"Parse error\"));\n        assert!(parse_err.to_string().contains(\"parse failed\"));\n\n        let missing_err = AlbError::MissingDependency(\"dep1\".to_string());\n        assert!(missing_err.to_string().contains(\"Missing dependency\"));\n        assert!(missing_err.to_string().contains(\"dep1\"));\n\n        let circular_err = AlbError::CircularDependency(\"A -> B -> A\".to_string());\n        assert!(circular_err.to_string().contains(\"Circular dependency\"));\n        assert!(circular_err.to_string().contains(\"A -> B -> A\"));\n    }\n\n    #[test]\n    fn test_alb_error_from_io() {\n        let io_err = std::io::Error::new(std::io::ErrorKind::NotFound, \"file not found\");\n        let alb_err: AlbError = io_err.into();\n        matches!(alb_err, AlbError::Io(_));\n    }\n\n    #[test]\n    fn test_alb_error_from_zip() {\n        let zip_err = zip::result::ZipError::FileNotFound;\n        let alb_err: AlbError = zip_err.into();\n        matches!(alb_err, AlbError::Zip(_));\n    }\n\n    #[test]\n    fn test_alb_error_is_error() {\n        let err = AlbError::Parse(\"test\".to_string());\n        // Verify it implements std::error::Error\n        let _: &dyn std::error::Error = &err;\n    }\n\n    #[test]\n    fn test_cls_source_debug() {\n        let cls = ClsSource::parse(\"test.cls\", \"package ::test;\");\n        let debug = format!(\"{:?}\", cls);\n        assert!(debug.contains(\"ClsSource\"));\n        assert!(debug.contains(\"test.cls\"));\n    }\n\n    #[test]\n    fn test_cls_source_clone() {\n        let cls = ClsSource {\n            filename: \"original.cls\".to_string(),\n            package: \"::pkg\".to_string(),\n            imports: vec![\"::import\".to_string()],\n            source: \"source code\".to_string(),\n            classes: vec![\"Class1\".to_string()],\n            parent_classes: vec![\"Parent1\".to_string()],\n        };\n        let cloned = cls.clone();\n        assert_eq!(cloned.filename, cls.filename);\n        assert_eq!(cloned.package, cls.package);\n        assert_eq!(cloned.imports, cls.imports);\n        assert_eq!(cloned.classes, cls.classes);\n    }\n\n    #[test]\n    fn test_loader_stats_debug_clone() {\n        let stats = LoaderStats {\n            packages: 5,\n            classes: 20,\n            files: 10,\n            albs: 3,\n        };\n        let debug = format!(\"{:?}\", stats);\n        assert!(debug.contains(\"LoaderStats\"));\n        assert!(debug.contains(\"5\"));\n\n        let cloned = stats.clone();\n        assert_eq!(cloned.packages, stats.packages);\n        assert_eq!(cloned.classes, stats.classes);\n    }\n\n    #[test]\n    fn test_alb_loader_debug() {\n        let loader = AlbLoader::new(\"/tmp/test\");\n        let debug = format!(\"{:?}\", loader);\n        assert!(debug.contains(\"AlbLoader\"));\n        assert!(debug.contains(\"/tmp/test\"));\n    }\n\n    #[test]\n    fn test_load_manufacturer_not_found() {\n        let mut loader = AlbLoader::new(\"/nonexistent\");\n        let result = loader.load_manufacturer(\"unknown\");\n        assert!(result.is_err());\n        matches!(result.unwrap_err(), AlbError::Io(_));\n    }\n\n    #[test]\n    fn test_get_sorted_sources_empty() {\n        let loader = AlbLoader::new(\"/tmp\");\n        let sorted = loader.get_sorted_sources();\n        assert!(sorted.is_empty());\n    }\n\n    #[test]\n    fn test_get_sorted_sources_priority() {\n        let mut loader = AlbLoader::new(\"/tmp\");\n\n        // Add sources with different packages\n        let basics = ClsSource {\n            filename: \"basics.cls\".to_string(),\n            package: \"::test::basics\".to_string(),\n            imports: vec![],\n            source: String::new(),\n            classes: vec![\"BasicsClass\".to_string()],\n            parent_classes: vec![],\n        };\n\n        let product = ClsSource {\n            filename: \"product.cls\".to_string(),\n            package: \"::test::product\".to_string(),\n            imports: vec![],\n            source: String::new(),\n            classes: vec![\"ProductClass\".to_string()],\n            parent_classes: vec![\"BasicsClass\".to_string()],\n        };\n\n        let ofml = ClsSource {\n            filename: \"oi.cls\".to_string(),\n            package: \"::ofml::oi\".to_string(),\n            imports: vec![],\n            source: String::new(),\n            classes: vec![\"OiClass\".to_string()],\n            parent_classes: vec![],\n        };\n\n        loader.sources.insert(\"::test::product\".to_string(), vec![product]);\n        loader.sources.insert(\"::test::basics\".to_string(), vec![basics]);\n        loader.sources.insert(\"::ofml::oi\".to_string(), vec![ofml]);\n\n        let sorted = loader.get_sorted_sources();\n        assert_eq!(sorted.len(), 3);\n\n        // OFML should come first, then basics, then product\n        assert!(sorted[0].package.starts_with(\"::ofml::oi\"));\n    }\n\n    #[test]\n    fn test_resolve_class_with_explicit_import() {\n        let mut loader = AlbLoader::new(\"/tmp\");\n        loader\n            .class_to_package\n            .insert(\"SpecificClass\".to_string(), \"::pkg::sub\".to_string());\n\n        let imports = vec![\"::pkg::sub::SpecificClass\".to_string()];\n        let result = loader.resolve_class(\"SpecificClass\", \"::other\", &imports);\n        assert_eq!(result, Some(\"::pkg::sub::SpecificClass\".to_string()));\n    }\n\n    #[test]\n    fn test_cls_source_parse_with_brace_on_same_line() {\n        let source = r#\"\npackage ::test;\nclass MyClass : Parent {\n    func test() {}\n}\n        \"#;\n        let cls = ClsSource::parse(\"test.cls\", source);\n        assert!(cls.classes.contains(&\"MyClass\".to_string()));\n        assert!(cls.parent_classes.contains(&\"Parent\".to_string()));\n    }\n\n    // Integration test with real OFML data\n    #[test]\n    fn test_load_manufacturer_with_real_data() {\n        let data_path = Path::new(\"/reference/ofmldata\");\n        if !data_path.exists() {\n            return;\n        }\n\n        let mut loader = AlbLoader::new(data_path);\n\n        // Try to find ALBs in a known manufacturer\n        let sex_path = data_path.join(\"sex\");\n        if sex_path.exists() {\n            let mut albs = Vec::new();\n            let _ = loader.find_albs(&sex_path, &mut albs);\n            // Sedus should have ALB files\n            if !albs.is_empty() {\n                // Load the first ALB\n                let result = loader.load_alb(&albs[0]);\n                assert!(result.is_ok() || result.is_err()); // Either is valid for this test\n            }\n        }\n    }\n\n    #[test]\n    fn test_find_albs_nonexistent() {\n        let loader = AlbLoader::new(\"/tmp\");\n        let mut albs = Vec::new();\n        let result = loader.find_albs(Path::new(\"/nonexistent/dir\"), &mut albs);\n        assert!(result.is_ok());\n        assert!(albs.is_empty());\n    }\n\n    #[test]\n    fn test_find_albs_file_not_dir() {\n        let loader = AlbLoader::new(\"/tmp\");\n        let mut albs = Vec::new();\n        // Use a file path instead of directory\n        let result = loader.find_albs(Path::new(\"/etc/hosts\"), &mut albs);\n        assert!(result.is_ok());\n        assert!(albs.is_empty());\n    }\n\n    #[test]\n    fn test_load_alb_nonexistent() {\n        let mut loader = AlbLoader::new(\"/tmp\");\n        let result = loader.load_alb(Path::new(\"/nonexistent/file.alb\"));\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_load_manufacturer_with_deps_nonexistent() {\n        let result = load_manufacturer_with_deps(Path::new(\"/nonexistent\"), \"unknown\", None);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_cls_source_parse_package_without_semicolon() {\n        let source = \"package ::test\";\n        let cls = ClsSource::parse(\"test.cls\", source);\n        assert_eq!(cls.package, \"::test\");\n    }\n\n    #[test]\n    fn test_cls_source_parse_class_without_brace() {\n        let source = r#\"\npackage ::test;\nclass SomeClass : SomeParent\n\"#;\n        let cls = ClsSource::parse(\"test.cls\", source);\n        // The parser should still extract the class and parent\n        assert!(cls.classes.contains(&\"SomeClass\".to_string()));\n        assert!(cls.parent_classes.contains(&\"SomeParent\".to_string()));\n    }\n\n    #[test]\n    fn test_resolve_class_known_in_any_package() {\n        let mut loader = AlbLoader::new(\"/tmp\");\n        loader\n            .class_to_package\n            .insert(\"GlobalClass\".to_string(), \"::global::pkg\".to_string());\n\n        // Not in current package, not in imports, but known globally\n        let result = loader.resolve_class(\"GlobalClass\", \"::other::pkg\", &[]);\n        assert_eq!(result, Some(\"::global::pkg::GlobalClass\".to_string()));\n    }\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":8}},{"line":41,"address":[],"length":0,"stats":{"Line":8}},{"line":42,"address":[],"length":0,"stats":{"Line":8}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":8}},{"line":45,"address":[],"length":0,"stats":{"Line":8}},{"line":46,"address":[],"length":0,"stats":{"Line":8}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":8}},{"line":85,"address":[],"length":0,"stats":{"Line":16}},{"line":86,"address":[],"length":0,"stats":{"Line":16}},{"line":87,"address":[],"length":0,"stats":{"Line":16}},{"line":88,"address":[],"length":0,"stats":{"Line":16}},{"line":90,"address":[],"length":0,"stats":{"Line":52}},{"line":91,"address":[],"length":0,"stats":{"Line":108}},{"line":94,"address":[],"length":0,"stats":{"Line":79}},{"line":95,"address":[],"length":0,"stats":{"Line":21}},{"line":96,"address":[],"length":0,"stats":{"Line":14}},{"line":97,"address":[],"length":0,"stats":{"Line":7}},{"line":98,"address":[],"length":0,"stats":{"Line":7}},{"line":99,"address":[],"length":0,"stats":{"Line":7}},{"line":100,"address":[],"length":0,"stats":{"Line":7}},{"line":104,"address":[],"length":0,"stats":{"Line":75}},{"line":105,"address":[],"length":0,"stats":{"Line":12}},{"line":111,"address":[],"length":0,"stats":{"Line":6}},{"line":115,"address":[],"length":0,"stats":{"Line":86}},{"line":117,"address":[],"length":0,"stats":{"Line":10}},{"line":118,"address":[],"length":0,"stats":{"Line":25}},{"line":119,"address":[],"length":0,"stats":{"Line":5}},{"line":120,"address":[],"length":0,"stats":{"Line":15}},{"line":121,"address":[],"length":0,"stats":{"Line":15}},{"line":122,"address":[],"length":0,"stats":{"Line":10}},{"line":125,"address":[],"length":0,"stats":{"Line":5}},{"line":126,"address":[],"length":0,"stats":{"Line":15}},{"line":128,"address":[],"length":0,"stats":{"Line":25}},{"line":129,"address":[],"length":0,"stats":{"Line":15}},{"line":130,"address":[],"length":0,"stats":{"Line":10}},{"line":131,"address":[],"length":0,"stats":{"Line":15}},{"line":139,"address":[],"length":0,"stats":{"Line":24}},{"line":142,"address":[],"length":0,"stats":{"Line":24}},{"line":149,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":2}},{"line":152,"address":[],"length":0,"stats":{"Line":5}},{"line":153,"address":[],"length":0,"stats":{"Line":6}},{"line":154,"address":[],"length":0,"stats":{"Line":2}},{"line":156,"address":[],"length":0,"stats":{"Line":4}},{"line":180,"address":[],"length":0,"stats":{"Line":22}},{"line":182,"address":[],"length":0,"stats":{"Line":66}},{"line":183,"address":[],"length":0,"stats":{"Line":44}},{"line":184,"address":[],"length":0,"stats":{"Line":44}},{"line":185,"address":[],"length":0,"stats":{"Line":22}},{"line":186,"address":[],"length":0,"stats":{"Line":22}},{"line":191,"address":[],"length":0,"stats":{"Line":2}},{"line":192,"address":[],"length":0,"stats":{"Line":6}},{"line":193,"address":[],"length":0,"stats":{"Line":2}},{"line":194,"address":[],"length":0,"stats":{"Line":4}},{"line":195,"address":[],"length":0,"stats":{"Line":4}},{"line":196,"address":[],"length":0,"stats":{"Line":2}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":445}},{"line":234,"address":[],"length":0,"stats":{"Line":445}},{"line":235,"address":[],"length":0,"stats":{"Line":2}},{"line":238,"address":[],"length":0,"stats":{"Line":2694}},{"line":239,"address":[],"length":0,"stats":{"Line":3616}},{"line":240,"address":[],"length":0,"stats":{"Line":5424}},{"line":242,"address":[],"length":0,"stats":{"Line":1808}},{"line":243,"address":[],"length":0,"stats":{"Line":1768}},{"line":244,"address":[],"length":0,"stats":{"Line":5505}},{"line":245,"address":[],"length":0,"stats":{"Line":82}},{"line":249,"address":[],"length":0,"stats":{"Line":443}},{"line":253,"address":[],"length":0,"stats":{"Line":2}},{"line":254,"address":[],"length":0,"stats":{"Line":10}},{"line":256,"address":[],"length":0,"stats":{"Line":6}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":6}},{"line":262,"address":[],"length":0,"stats":{"Line":3}},{"line":263,"address":[],"length":0,"stats":{"Line":2}},{"line":265,"address":[],"length":0,"stats":{"Line":5}},{"line":266,"address":[],"length":0,"stats":{"Line":12}},{"line":267,"address":[],"length":0,"stats":{"Line":6}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":9}},{"line":272,"address":[],"length":0,"stats":{"Line":3}},{"line":273,"address":[],"length":0,"stats":{"Line":3}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":1}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":3}},{"line":305,"address":[],"length":0,"stats":{"Line":1}},{"line":309,"address":[],"length":0,"stats":{"Line":6}},{"line":316,"address":[],"length":0,"stats":{"Line":12}},{"line":317,"address":[],"length":0,"stats":{"Line":1}},{"line":321,"address":[],"length":0,"stats":{"Line":15}},{"line":322,"address":[],"length":0,"stats":{"Line":1}},{"line":326,"address":[],"length":0,"stats":{"Line":6}},{"line":327,"address":[],"length":0,"stats":{"Line":4}},{"line":328,"address":[],"length":0,"stats":{"Line":6}},{"line":329,"address":[],"length":0,"stats":{"Line":7}},{"line":330,"address":[],"length":0,"stats":{"Line":2}},{"line":336,"address":[],"length":0,"stats":{"Line":5}},{"line":337,"address":[],"length":0,"stats":{"Line":1}},{"line":341,"address":[],"length":0,"stats":{"Line":1}},{"line":345,"address":[],"length":0,"stats":{"Line":2}},{"line":347,"address":[],"length":0,"stats":{"Line":12}},{"line":348,"address":[],"length":0,"stats":{"Line":10}},{"line":351,"address":[],"length":0,"stats":{"Line":6}},{"line":352,"address":[],"length":0,"stats":{"Line":10}},{"line":353,"address":[],"length":0,"stats":{"Line":12}},{"line":354,"address":[],"length":0,"stats":{"Line":9}},{"line":359,"address":[],"length":0,"stats":{"Line":4}},{"line":360,"address":[],"length":0,"stats":{"Line":6}},{"line":363,"address":[],"length":0,"stats":{"Line":5}},{"line":364,"address":[],"length":0,"stats":{"Line":6}},{"line":367,"address":[],"length":0,"stats":{"Line":6}},{"line":368,"address":[],"length":0,"stats":{"Line":3}},{"line":369,"address":[],"length":0,"stats":{"Line":24}},{"line":370,"address":[],"length":0,"stats":{"Line":4}},{"line":371,"address":[],"length":0,"stats":{"Line":3}},{"line":372,"address":[],"length":0,"stats":{"Line":3}},{"line":375,"address":[],"length":0,"stats":{"Line":5}},{"line":376,"address":[],"length":0,"stats":{"Line":2}},{"line":380,"address":[],"length":0,"stats":{"Line":5}},{"line":381,"address":[],"length":0,"stats":{"Line":4}},{"line":382,"address":[],"length":0,"stats":{"Line":2}},{"line":384,"address":[],"length":0,"stats":{"Line":1}},{"line":389,"address":[],"length":0,"stats":{"Line":9}},{"line":394,"address":[],"length":0,"stats":{"Line":8}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":4}},{"line":400,"address":[],"length":0,"stats":{"Line":9}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":2}},{"line":439,"address":[],"length":0,"stats":{"Line":4}},{"line":440,"address":[],"length":0,"stats":{"Line":4}},{"line":441,"address":[],"length":0,"stats":{"Line":10}},{"line":442,"address":[],"length":0,"stats":{"Line":4}},{"line":457,"address":[],"length":0,"stats":{"Line":1}},{"line":462,"address":[],"length":0,"stats":{"Line":3}},{"line":465,"address":[],"length":0,"stats":{"Line":3}},{"line":466,"address":[],"length":0,"stats":{"Line":1}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":4}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}}],"covered":136,"coverable":193},{"path":["/","workspace","crates","ofml-lib","src","article.rs"],"content":"//! Article Configuration System - Product configuration from OFML data.\n//!\n//! This module implements article configuration for OFML products including:\n//! - Loading article properties from EBASE tables\n//! - Property resolution with defaults\n//! - Variant selection based on article properties\n//! - ODB lookup for geometry loading\n\nuse std::collections::HashMap;\n\nuse crate::errors::ArticleError;\n\n/// A property value that can be stored in an article configuration.\n#[derive(Debug, Clone, PartialEq)]\npub enum PropertyValue {\n    /// Integer value (e.g., dimensions in mm)\n    Int(i64),\n    /// Floating-point value\n    Float(f64),\n    /// String value (e.g., material codes)\n    String(String),\n    /// Boolean value\n    Bool(bool),\n}\n\nimpl PropertyValue {\n    /// Convert to i64 if possible.\n    pub fn as_int(&self) -> Option<i64> {\n        match self {\n            PropertyValue::Int(v) => Some(*v),\n            PropertyValue::Float(v) => Some(*v as i64),\n            _ => None,\n        }\n    }\n\n    /// Convert to f64 if possible.\n    pub fn as_float(&self) -> Option<f64> {\n        match self {\n            PropertyValue::Int(v) => Some(*v as f64),\n            PropertyValue::Float(v) => Some(*v),\n            _ => None,\n        }\n    }\n\n    /// Get as string.\n    pub fn as_str(&self) -> Option<&str> {\n        match self {\n            PropertyValue::String(s) => Some(s),\n            _ => None,\n        }\n    }\n\n    /// Get as bool if possible.\n    pub fn as_bool(&self) -> Option<bool> {\n        match self {\n            PropertyValue::Bool(v) => Some(*v),\n            PropertyValue::Int(v) => Some(*v != 0),\n            _ => None,\n        }\n    }\n\n    /// Create from string value, attempting to parse as number.\n    pub fn from_string(s: &str) -> Self {\n        // Try parsing as integer\n        if let Ok(i) = s.parse::<i64>() {\n            return PropertyValue::Int(i);\n        }\n        // Try parsing as float\n        if let Ok(f) = s.parse::<f64>() {\n            return PropertyValue::Float(f);\n        }\n        // Try parsing as bool\n        match s.to_lowercase().as_str() {\n            \"true\" | \"yes\" | \"1\" => return PropertyValue::Bool(true),\n            \"false\" | \"no\" | \"0\" => return PropertyValue::Bool(false),\n            _ => {}\n        }\n        // Default to string\n        PropertyValue::String(s.to_string())\n    }\n}\n\nimpl std::fmt::Display for PropertyValue {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            PropertyValue::Int(v) => write!(f, \"{}\", v),\n            PropertyValue::Float(v) => write!(f, \"{}\", v),\n            PropertyValue::String(v) => write!(f, \"{}\", v),\n            PropertyValue::Bool(v) => write!(f, \"{}\", v),\n        }\n    }\n}\n\nimpl From<i64> for PropertyValue {\n    fn from(v: i64) -> Self {\n        PropertyValue::Int(v)\n    }\n}\n\nimpl From<f64> for PropertyValue {\n    fn from(v: f64) -> Self {\n        PropertyValue::Float(v)\n    }\n}\n\nimpl From<String> for PropertyValue {\n    fn from(v: String) -> Self {\n        PropertyValue::String(v)\n    }\n}\n\nimpl From<&str> for PropertyValue {\n    fn from(v: &str) -> Self {\n        PropertyValue::String(v.to_string())\n    }\n}\n\nimpl From<bool> for PropertyValue {\n    fn from(v: bool) -> Self {\n        PropertyValue::Bool(v)\n    }\n}\n\n/// Collection of properties for an article.\npub type Properties = HashMap<String, PropertyValue>;\n\n/// Article configuration loaded from OFML data.\n///\n/// An article represents a configured product with specific dimensions,\n/// materials, and options selected.\n#[derive(Debug, Clone)]\npub struct ArticleConfig {\n    /// Article number (e.g., \"1600x800\")\n    pub article_nr: String,\n    /// Product/ODB name for geometry lookup\n    pub odb_name: String,\n    /// Resolved properties for this article\n    properties: Properties,\n    /// Default values for properties\n    defaults: Properties,\n}\n\nimpl ArticleConfig {\n    /// Create a new article configuration.\n    pub fn new(article_nr: impl Into<String>, odb_name: impl Into<String>) -> Self {\n        Self {\n            article_nr: article_nr.into(),\n            odb_name: odb_name.into(),\n            properties: HashMap::new(),\n            defaults: HashMap::new(),\n        }\n    }\n\n    /// Set a property value.\n    pub fn set(&mut self, name: impl Into<String>, value: impl Into<PropertyValue>) {\n        self.properties.insert(name.into(), value.into());\n    }\n\n    /// Set a default value for a property.\n    pub fn set_default(&mut self, name: impl Into<String>, value: impl Into<PropertyValue>) {\n        self.defaults.insert(name.into(), value.into());\n    }\n\n    /// Get a property value, falling back to default if not set.\n    pub fn get(&self, name: &str) -> Option<&PropertyValue> {\n        self.properties\n            .get(name)\n            .or_else(|| self.defaults.get(name))\n    }\n\n    /// Get a property value as i64, with optional default.\n    pub fn get_int(&self, name: &str, default: i64) -> i64 {\n        self.get(name).and_then(|v| v.as_int()).unwrap_or(default)\n    }\n\n    /// Get a property value as f64, with optional default.\n    pub fn get_float(&self, name: &str, default: f64) -> f64 {\n        self.get(name).and_then(|v| v.as_float()).unwrap_or(default)\n    }\n\n    /// Get a property value as string, with optional default.\n    pub fn get_string(&self, name: &str, default: &str) -> String {\n        self.get(name)\n            .and_then(|v| v.as_str())\n            .map(|s| s.to_string())\n            .unwrap_or_else(|| default.to_string())\n    }\n\n    /// Get a property value as bool, with optional default.\n    pub fn get_bool(&self, name: &str, default: bool) -> bool {\n        self.get(name).and_then(|v| v.as_bool()).unwrap_or(default)\n    }\n\n    /// Check if a property exists.\n    pub fn has(&self, name: &str) -> bool {\n        self.properties.contains_key(name) || self.defaults.contains_key(name)\n    }\n\n    /// Get all property names.\n    pub fn property_names(&self) -> Vec<&String> {\n        let mut names: Vec<_> = self.properties.keys().collect();\n        for key in self.defaults.keys() {\n            if !self.properties.contains_key(key) {\n                names.push(key);\n            }\n        }\n        names\n    }\n\n    /// Convert properties to f64 map for EBASE evaluation.\n    pub fn to_f64_map(&self) -> HashMap<String, f64> {\n        let mut result = HashMap::new();\n        for (name, value) in &self.defaults {\n            if let Some(f) = value.as_float() {\n                result.insert(name.clone(), f);\n            }\n        }\n        for (name, value) in &self.properties {\n            if let Some(f) = value.as_float() {\n                result.insert(name.clone(), f);\n            }\n        }\n        result\n    }\n}\n\n/// Product variant definition.\n///\n/// A variant represents a specific configuration option for a product,\n/// such as size, color, or material.\n#[derive(Debug, Clone)]\npub struct Variant {\n    /// Variant identifier\n    pub id: String,\n    /// Display name\n    pub name: String,\n    /// Property overrides for this variant\n    pub properties: Properties,\n    /// Whether this variant is available\n    pub available: bool,\n}\n\nimpl Variant {\n    /// Create a new variant.\n    pub fn new(id: impl Into<String>, name: impl Into<String>) -> Self {\n        Self {\n            id: id.into(),\n            name: name.into(),\n            properties: HashMap::new(),\n            available: true,\n        }\n    }\n\n    /// Add a property override.\n    pub fn with_property(\n        mut self,\n        name: impl Into<String>,\n        value: impl Into<PropertyValue>,\n    ) -> Self {\n        self.properties.insert(name.into(), value.into());\n        self\n    }\n\n    /// Set availability.\n    pub fn with_available(mut self, available: bool) -> Self {\n        self.available = available;\n        self\n    }\n}\n\n/// Variant group - collection of mutually exclusive variants.\n#[derive(Debug, Clone)]\npub struct VariantGroup {\n    /// Group identifier (e.g., \"size\", \"color\")\n    pub id: String,\n    /// Display name\n    pub name: String,\n    /// Available variants in this group\n    pub variants: Vec<Variant>,\n    /// Currently selected variant index\n    pub selected: Option<usize>,\n}\n\nimpl VariantGroup {\n    /// Create a new variant group.\n    pub fn new(id: impl Into<String>, name: impl Into<String>) -> Self {\n        Self {\n            id: id.into(),\n            name: name.into(),\n            variants: Vec::new(),\n            selected: None,\n        }\n    }\n\n    /// Add a variant to the group.\n    pub fn add_variant(&mut self, variant: Variant) {\n        self.variants.push(variant);\n    }\n\n    /// Select a variant by ID.\n    pub fn select(&mut self, variant_id: &str) -> Result<(), ArticleError> {\n        let index = self\n            .variants\n            .iter()\n            .position(|v| v.id == variant_id)\n            .ok_or_else(|| ArticleError::InvalidConfiguration {\n                article: self.id.clone(),\n                message: format!(\"Variant '{}' not found in group '{}'\", variant_id, self.id),\n            })?;\n\n        if !self.variants[index].available {\n            return Err(ArticleError::InvalidConfiguration {\n                article: self.id.clone(),\n                message: format!(\"Variant '{}' is not available\", variant_id),\n            });\n        }\n\n        self.selected = Some(index);\n        Ok(())\n    }\n\n    /// Get the selected variant.\n    pub fn get_selected(&self) -> Option<&Variant> {\n        self.selected.and_then(|i| self.variants.get(i))\n    }\n}\n\n/// Standard dimension property names used in OFML.\npub const DIM_WIDTH: &str = \"M__BREITE\";\npub const DIM_DEPTH: &str = \"M__TIEFE\";\npub const DIM_HEIGHT: &str = \"M__HOEHE\";\n\n/// Standard material property names.\npub const MAT_BASIC: &str = \"SH__BASIC\";\npub const MAT_COLOR_PREFIX: &str = \"CO__\";\n\n/// Article loader that creates configurations from OFML data.\n#[derive(Debug, Default)]\npub struct ArticleLoader {\n    /// Default property values\n    defaults: Properties,\n}\n\nimpl ArticleLoader {\n    /// Create a new article loader.\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Set a default property value.\n    pub fn set_default(&mut self, name: impl Into<String>, value: impl Into<PropertyValue>) {\n        self.defaults.insert(name.into(), value.into());\n    }\n\n    /// Create an article configuration from properties.\n    pub fn create_article(\n        &self,\n        article_nr: &str,\n        odb_name: &str,\n        properties: Properties,\n    ) -> ArticleConfig {\n        let mut config = ArticleConfig::new(article_nr, odb_name);\n\n        // Apply defaults\n        for (name, value) in &self.defaults {\n            config.set_default(name.clone(), value.clone());\n        }\n\n        // Apply properties\n        for (name, value) in properties {\n            config.set(name, value);\n        }\n\n        config\n    }\n\n    /// Create a standard desk article with width/depth/height.\n    pub fn create_desk_article(\n        &self,\n        article_nr: &str,\n        width_mm: i64,\n        depth_mm: i64,\n        height_mm: i64,\n    ) -> ArticleConfig {\n        let mut properties = Properties::new();\n        properties.insert(\"M__BREITE\".to_string(), PropertyValue::Int(width_mm));\n        properties.insert(\"M__TIEFE\".to_string(), PropertyValue::Int(depth_mm));\n        properties.insert(\"M__HOEHE\".to_string(), PropertyValue::Int(height_mm));\n\n        self.create_article(article_nr, article_nr, properties)\n    }\n\n    /// Load an article from EBASE articles table record.\n    ///\n    /// Expected record columns: article_nr, odb_name, and property columns.\n    pub fn load_from_ebase_record(&self, record: &crate::ebase::Record) -> Option<ArticleConfig> {\n        use crate::ebase::Value;\n\n        let article_nr = record\n            .get(\"article_nr\")\n            .or_else(|| record.get(\"art_nr\"))\n            .and_then(|v| v.as_str())?\n            .to_string();\n\n        let odb_name = record\n            .get(\"odb_name\")\n            .or_else(|| record.get(\"odb\"))\n            .and_then(|v| v.as_str())\n            .unwrap_or(&article_nr)\n            .to_string();\n\n        let mut properties = Properties::new();\n\n        // Load all properties from the record\n        for (key, value) in record {\n            if key == \"article_nr\" || key == \"art_nr\" || key == \"odb_name\" || key == \"odb\" {\n                continue;\n            }\n\n            let prop_value = match value {\n                Value::Int(i) => PropertyValue::Int(*i),\n                Value::UInt(u) => PropertyValue::Int(*u as i64),\n                Value::Float(f) => PropertyValue::Float(*f),\n                Value::String(s) => PropertyValue::from_string(s),\n                _ => continue,\n            };\n\n            properties.insert(key.clone(), prop_value);\n        }\n\n        Some(self.create_article(&article_nr, &odb_name, properties))\n    }\n}\n\nimpl ArticleConfig {\n    /// Get dimension properties in millimeters.\n    ///\n    /// Returns [width, depth, height] from M__BREITE, M__TIEFE, M__HOEHE properties.\n    pub fn get_dimensions_mm(&self) -> [i64; 3] {\n        [\n            self.get_int(DIM_WIDTH, 1000),\n            self.get_int(DIM_DEPTH, 600),\n            self.get_int(DIM_HEIGHT, 740),\n        ]\n    }\n\n    /// Get dimension properties in meters (for geometry).\n    ///\n    /// Converts from millimeters to meters.\n    pub fn get_dimensions_m(&self) -> [f64; 3] {\n        let dims = self.get_dimensions_mm();\n        [\n            dims[0] as f64 / 1000.0,\n            dims[1] as f64 / 1000.0,\n            dims[2] as f64 / 1000.0,\n        ]\n    }\n\n    /// Set dimension properties.\n    pub fn set_dimensions_mm(&mut self, width: i64, depth: i64, height: i64) {\n        self.set(DIM_WIDTH, width);\n        self.set(DIM_DEPTH, depth);\n        self.set(DIM_HEIGHT, height);\n    }\n\n    /// Get the basic material/surface code.\n    pub fn get_basic_material(&self) -> Option<String> {\n        self.get(MAT_BASIC)\n            .and_then(|v| v.as_str())\n            .map(|s| s.to_string())\n    }\n\n    /// Set the basic material/surface code.\n    pub fn set_basic_material(&mut self, material: impl Into<String>) {\n        self.set(MAT_BASIC, material.into());\n    }\n\n    /// Get a color property by suffix (e.g., \"TISCH\" for CO__TISCH).\n    pub fn get_color(&self, suffix: &str) -> Option<String> {\n        let key = format!(\"{}{}\", MAT_COLOR_PREFIX, suffix);\n        self.get(&key)\n            .and_then(|v| v.as_str())\n            .map(|s| s.to_string())\n    }\n\n    /// Set a color property by suffix.\n    pub fn set_color(&mut self, suffix: &str, color: impl Into<String>) {\n        let key = format!(\"{}{}\", MAT_COLOR_PREFIX, suffix);\n        self.set(key, color.into());\n    }\n\n    /// Get all color properties.\n    pub fn get_colors(&self) -> HashMap<String, String> {\n        let mut colors = HashMap::new();\n        for name in self.property_names() {\n            if let Some(suffix) = name.strip_prefix(MAT_COLOR_PREFIX) {\n                if let Some(value) = self.get(name).and_then(|v| v.as_str()) {\n                    colors.insert(suffix.to_string(), value.to_string());\n                }\n            }\n        }\n        colors\n    }\n\n    /// Evaluate a visibility expression.\n    ///\n    /// Visibility expressions can be:\n    /// - Empty or \"1\" ‚Üí visible\n    /// - \"0\" ‚Üí not visible\n    /// - Property references like \"${PROP:-default}\" ‚Üí evaluate with properties\n    pub fn evaluate_visibility(&self, expr: &str) -> bool {\n        let expr = expr.trim();\n\n        // Empty or \"1\" means visible\n        if expr.is_empty() || expr == \"1\" || expr.to_lowercase() == \"true\" {\n            return true;\n        }\n\n        // \"0\" means not visible\n        if expr == \"0\" || expr.to_lowercase() == \"false\" {\n            return false;\n        }\n\n        // Try to evaluate as EBASE expression\n        let props = self.to_f64_map();\n        let mut evaluator = crate::ebase_expr::EbaseEvaluator::new();\n        match evaluator.evaluate_to_number(expr, &props) {\n            Ok(val) => val != 0.0,\n            Err(_) => true, // Default to visible on error\n        }\n    }\n\n    /// Apply variant properties to this configuration.\n    ///\n    /// This updates the configuration with the variant's property overrides.\n    pub fn apply_variant(&mut self, variant: &Variant) {\n        for (name, value) in &variant.properties {\n            self.set(name.clone(), value.clone());\n        }\n    }\n\n    /// Apply variant group selection.\n    ///\n    /// Returns error if no variant is selected.\n    pub fn apply_variant_group(&mut self, group: &VariantGroup) -> Result<(), ArticleError> {\n        let variant = group\n            .get_selected()\n            .ok_or_else(|| ArticleError::InvalidConfiguration {\n                article: self.article_nr.clone(),\n                message: format!(\"No variant selected in group '{}'\", group.id),\n            })?;\n        self.apply_variant(variant);\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_property_value_conversion() {\n        let int_val = PropertyValue::Int(42);\n        assert_eq!(int_val.as_int(), Some(42));\n        assert_eq!(int_val.as_float(), Some(42.0));\n        assert_eq!(int_val.as_bool(), Some(true));\n\n        let float_val = PropertyValue::Float(3.14);\n        assert_eq!(float_val.as_float(), Some(3.14));\n        assert_eq!(float_val.as_int(), Some(3));\n\n        let string_val = PropertyValue::String(\"test\".to_string());\n        assert_eq!(string_val.as_str(), Some(\"test\"));\n        assert_eq!(string_val.as_int(), None);\n\n        let bool_val = PropertyValue::Bool(true);\n        assert_eq!(bool_val.as_bool(), Some(true));\n    }\n\n    #[test]\n    fn test_property_value_from_string() {\n        assert_eq!(PropertyValue::from_string(\"42\"), PropertyValue::Int(42));\n        assert_eq!(\n            PropertyValue::from_string(\"3.14\"),\n            PropertyValue::Float(3.14)\n        );\n        assert_eq!(\n            PropertyValue::from_string(\"true\"),\n            PropertyValue::Bool(true)\n        );\n        assert_eq!(\n            PropertyValue::from_string(\"hello\"),\n            PropertyValue::String(\"hello\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_article_config() {\n        let mut config = ArticleConfig::new(\"1600x800\", \"desk_1600x800\");\n        config.set(\"M__BREITE\", 1600i64);\n        config.set(\"M__TIEFE\", 800i64);\n        config.set_default(\"M__HOEHE\", 740i64);\n\n        assert_eq!(config.get_int(\"M__BREITE\", 0), 1600);\n        assert_eq!(config.get_int(\"M__TIEFE\", 0), 800);\n        assert_eq!(config.get_int(\"M__HOEHE\", 0), 740); // from default\n        assert_eq!(config.get_int(\"MISSING\", 100), 100); // fallback\n    }\n\n    #[test]\n    fn test_to_f64_map() {\n        let mut config = ArticleConfig::new(\"test\", \"test\");\n        config.set(\"WIDTH\", 1600i64);\n        config.set(\"HEIGHT\", 740.0f64);\n        config.set(\"NAME\", \"desk\");\n\n        let map = config.to_f64_map();\n        assert_eq!(map.get(\"WIDTH\"), Some(&1600.0));\n        assert_eq!(map.get(\"HEIGHT\"), Some(&740.0));\n        assert!(map.get(\"NAME\").is_none()); // strings not included\n    }\n\n    #[test]\n    fn test_variant() {\n        let variant = Variant::new(\"large\", \"Large (1800x900)\")\n            .with_property(\"M__BREITE\", 1800i64)\n            .with_property(\"M__TIEFE\", 900i64);\n\n        assert_eq!(variant.id, \"large\");\n        assert!(variant.available);\n        assert_eq!(\n            variant.properties.get(\"M__BREITE\"),\n            Some(&PropertyValue::Int(1800))\n        );\n    }\n\n    #[test]\n    fn test_variant_group() {\n        let mut group = VariantGroup::new(\"size\", \"Size\");\n        group.add_variant(Variant::new(\"small\", \"Small\"));\n        group.add_variant(Variant::new(\"medium\", \"Medium\"));\n        group.add_variant(Variant::new(\"large\", \"Large\"));\n\n        assert!(group.select(\"medium\").is_ok());\n        assert_eq!(\n            group.get_selected().map(|v| &v.id),\n            Some(&\"medium\".to_string())\n        );\n\n        assert!(group.select(\"invalid\").is_err());\n    }\n\n    #[test]\n    fn test_article_loader() {\n        let mut loader = ArticleLoader::new();\n        loader.set_default(\"M__HOEHE\", 740i64);\n\n        let article = loader.create_desk_article(\"1600x800\", 1600, 800, 740);\n        assert_eq!(article.get_int(\"M__BREITE\", 0), 1600);\n        assert_eq!(article.get_int(\"M__TIEFE\", 0), 800);\n        assert_eq!(article.get_int(\"M__HOEHE\", 0), 740);\n    }\n\n    #[test]\n    fn test_dimension_resolution() {\n        let mut config = ArticleConfig::new(\"test\", \"test\");\n        config.set_dimensions_mm(1600, 800, 740);\n\n        let dims_mm = config.get_dimensions_mm();\n        assert_eq!(dims_mm, [1600, 800, 740]);\n\n        let dims_m = config.get_dimensions_m();\n        assert!((dims_m[0] - 1.6).abs() < 0.001);\n        assert!((dims_m[1] - 0.8).abs() < 0.001);\n        assert!((dims_m[2] - 0.74).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_material_resolution() {\n        let mut config = ArticleConfig::new(\"test\", \"test\");\n        config.set_basic_material(\"wood_oak\");\n        config.set_color(\"TISCH\", \"white\");\n        config.set_color(\"GESTELL\", \"chrome\");\n\n        assert_eq!(config.get_basic_material(), Some(\"wood_oak\".to_string()));\n        assert_eq!(config.get_color(\"TISCH\"), Some(\"white\".to_string()));\n        assert_eq!(config.get_color(\"GESTELL\"), Some(\"chrome\".to_string()));\n\n        let colors = config.get_colors();\n        assert_eq!(colors.len(), 2);\n        assert_eq!(colors.get(\"TISCH\"), Some(&\"white\".to_string()));\n    }\n\n    #[test]\n    fn test_visibility_evaluation() {\n        let mut config = ArticleConfig::new(\"test\", \"test\");\n        config.set(\"M__BREITE\", 1600i64);\n        config.set(\"SHOW_OPTION\", 1i64);\n\n        // Simple cases\n        assert!(config.evaluate_visibility(\"\"));\n        assert!(config.evaluate_visibility(\"1\"));\n        assert!(config.evaluate_visibility(\"true\"));\n        assert!(!config.evaluate_visibility(\"0\"));\n        assert!(!config.evaluate_visibility(\"false\"));\n\n        // Expression evaluation\n        assert!(config.evaluate_visibility(\"${SHOW_OPTION:-0}\"));\n    }\n\n    #[test]\n    fn test_variant_application() {\n        let mut config = ArticleConfig::new(\"test\", \"test\");\n        config.set_dimensions_mm(1600, 800, 740);\n\n        let variant = Variant::new(\"large\", \"Large\")\n            .with_property(\"M__BREITE\", 1800i64)\n            .with_property(\"M__TIEFE\", 900i64);\n\n        config.apply_variant(&variant);\n\n        assert_eq!(config.get_int(\"M__BREITE\", 0), 1800);\n        assert_eq!(config.get_int(\"M__TIEFE\", 0), 900);\n        assert_eq!(config.get_int(\"M__HOEHE\", 0), 740); // Unchanged\n    }\n\n    #[test]\n    fn test_variant_group_application() {\n        let mut config = ArticleConfig::new(\"test\", \"test\");\n        config.set_dimensions_mm(1600, 800, 740);\n\n        let mut group = VariantGroup::new(\"size\", \"Size\");\n        group.add_variant(Variant::new(\"small\", \"Small\").with_property(\"M__BREITE\", 1200i64));\n        group.add_variant(Variant::new(\"large\", \"Large\").with_property(\"M__BREITE\", 1800i64));\n\n        group.select(\"large\").unwrap();\n        config.apply_variant_group(&group).unwrap();\n\n        assert_eq!(config.get_int(\"M__BREITE\", 0), 1800);\n    }\n\n    #[test]\n    fn test_load_from_ebase_record() {\n        use crate::ebase::{Record, Value};\n\n        let mut record = Record::new();\n        record.insert(\n            \"article_nr\".to_string(),\n            Value::String(\"desk_001\".to_string()),\n        );\n        record.insert(\n            \"odb_name\".to_string(),\n            Value::String(\"desk_model\".to_string()),\n        );\n        record.insert(\"M__BREITE\".to_string(), Value::Int(1600));\n        record.insert(\"M__TIEFE\".to_string(), Value::Int(800));\n\n        let loader = ArticleLoader::new();\n        let config = loader.load_from_ebase_record(&record).unwrap();\n\n        assert_eq!(config.article_nr, \"desk_001\");\n        assert_eq!(config.odb_name, \"desk_model\");\n        assert_eq!(config.get_int(\"M__BREITE\", 0), 1600);\n        assert_eq!(config.get_int(\"M__TIEFE\", 0), 800);\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":21}},{"line":29,"address":[],"length":0,"stats":{"Line":21}},{"line":30,"address":[],"length":0,"stats":{"Line":38}},{"line":31,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":7}},{"line":38,"address":[],"length":0,"stats":{"Line":7}},{"line":39,"address":[],"length":0,"stats":{"Line":8}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":6}},{"line":47,"address":[],"length":0,"stats":{"Line":6}},{"line":48,"address":[],"length":0,"stats":{"Line":12}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":4}},{"line":65,"address":[],"length":0,"stats":{"Line":5}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":4}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":5}},{"line":75,"address":[],"length":0,"stats":{"Line":3}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":22}},{"line":96,"address":[],"length":0,"stats":{"Line":22}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":3}},{"line":108,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":9}},{"line":147,"address":[],"length":0,"stats":{"Line":27}},{"line":148,"address":[],"length":0,"stats":{"Line":27}},{"line":149,"address":[],"length":0,"stats":{"Line":9}},{"line":150,"address":[],"length":0,"stats":{"Line":9}},{"line":155,"address":[],"length":0,"stats":{"Line":27}},{"line":156,"address":[],"length":0,"stats":{"Line":162}},{"line":160,"address":[],"length":0,"stats":{"Line":2}},{"line":161,"address":[],"length":0,"stats":{"Line":12}},{"line":165,"address":[],"length":0,"stats":{"Line":24}},{"line":166,"address":[],"length":0,"stats":{"Line":24}},{"line":167,"address":[],"length":0,"stats":{"Line":48}},{"line":168,"address":[],"length":0,"stats":{"Line":30}},{"line":172,"address":[],"length":0,"stats":{"Line":19}},{"line":173,"address":[],"length":0,"stats":{"Line":150}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":1}},{"line":201,"address":[],"length":0,"stats":{"Line":5}},{"line":202,"address":[],"length":0,"stats":{"Line":2}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":1}},{"line":211,"address":[],"length":0,"stats":{"Line":2}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":213,"address":[],"length":0,"stats":{"Line":2}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":17}},{"line":219,"address":[],"length":0,"stats":{"Line":13}},{"line":220,"address":[],"length":0,"stats":{"Line":16}},{"line":223,"address":[],"length":0,"stats":{"Line":2}},{"line":245,"address":[],"length":0,"stats":{"Line":7}},{"line":247,"address":[],"length":0,"stats":{"Line":21}},{"line":248,"address":[],"length":0,"stats":{"Line":14}},{"line":249,"address":[],"length":0,"stats":{"Line":7}},{"line":255,"address":[],"length":0,"stats":{"Line":6}},{"line":260,"address":[],"length":0,"stats":{"Line":36}},{"line":261,"address":[],"length":0,"stats":{"Line":6}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":2}},{"line":288,"address":[],"length":0,"stats":{"Line":6}},{"line":289,"address":[],"length":0,"stats":{"Line":6}},{"line":290,"address":[],"length":0,"stats":{"Line":2}},{"line":296,"address":[],"length":0,"stats":{"Line":5}},{"line":297,"address":[],"length":0,"stats":{"Line":15}},{"line":301,"address":[],"length":0,"stats":{"Line":3}},{"line":302,"address":[],"length":0,"stats":{"Line":5}},{"line":303,"address":[],"length":0,"stats":{"Line":3}},{"line":305,"address":[],"length":0,"stats":{"Line":17}},{"line":306,"address":[],"length":0,"stats":{"Line":3}},{"line":307,"address":[],"length":0,"stats":{"Line":2}},{"line":308,"address":[],"length":0,"stats":{"Line":2}},{"line":311,"address":[],"length":0,"stats":{"Line":2}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":2}},{"line":319,"address":[],"length":0,"stats":{"Line":2}},{"line":323,"address":[],"length":0,"stats":{"Line":2}},{"line":324,"address":[],"length":0,"stats":{"Line":10}},{"line":346,"address":[],"length":0,"stats":{"Line":2}},{"line":347,"address":[],"length":0,"stats":{"Line":2}},{"line":351,"address":[],"length":0,"stats":{"Line":1}},{"line":352,"address":[],"length":0,"stats":{"Line":6}},{"line":356,"address":[],"length":0,"stats":{"Line":2}},{"line":362,"address":[],"length":0,"stats":{"Line":8}},{"line":365,"address":[],"length":0,"stats":{"Line":6}},{"line":366,"address":[],"length":0,"stats":{"Line":5}},{"line":370,"address":[],"length":0,"stats":{"Line":22}},{"line":371,"address":[],"length":0,"stats":{"Line":15}},{"line":374,"address":[],"length":0,"stats":{"Line":2}},{"line":378,"address":[],"length":0,"stats":{"Line":1}},{"line":385,"address":[],"length":0,"stats":{"Line":2}},{"line":386,"address":[],"length":0,"stats":{"Line":5}},{"line":387,"address":[],"length":0,"stats":{"Line":5}},{"line":388,"address":[],"length":0,"stats":{"Line":5}},{"line":390,"address":[],"length":0,"stats":{"Line":5}},{"line":396,"address":[],"length":0,"stats":{"Line":1}},{"line":399,"address":[],"length":0,"stats":{"Line":2}},{"line":401,"address":[],"length":0,"stats":{"Line":1}},{"line":402,"address":[],"length":0,"stats":{"Line":3}},{"line":405,"address":[],"length":0,"stats":{"Line":2}},{"line":407,"address":[],"length":0,"stats":{"Line":1}},{"line":408,"address":[],"length":0,"stats":{"Line":3}},{"line":409,"address":[],"length":0,"stats":{"Line":2}},{"line":412,"address":[],"length":0,"stats":{"Line":2}},{"line":415,"address":[],"length":0,"stats":{"Line":13}},{"line":416,"address":[],"length":0,"stats":{"Line":12}},{"line":417,"address":[],"length":0,"stats":{"Line":2}},{"line":420,"address":[],"length":0,"stats":{"Line":4}},{"line":421,"address":[],"length":0,"stats":{"Line":4}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":10}},{"line":431,"address":[],"length":0,"stats":{"Line":4}},{"line":439,"address":[],"length":0,"stats":{"Line":2}},{"line":441,"address":[],"length":0,"stats":{"Line":8}},{"line":442,"address":[],"length":0,"stats":{"Line":8}},{"line":443,"address":[],"length":0,"stats":{"Line":4}},{"line":450,"address":[],"length":0,"stats":{"Line":1}},{"line":451,"address":[],"length":0,"stats":{"Line":3}},{"line":453,"address":[],"length":0,"stats":{"Line":2}},{"line":454,"address":[],"length":0,"stats":{"Line":1}},{"line":455,"address":[],"length":0,"stats":{"Line":1}},{"line":460,"address":[],"length":0,"stats":{"Line":3}},{"line":461,"address":[],"length":0,"stats":{"Line":9}},{"line":462,"address":[],"length":0,"stats":{"Line":9}},{"line":463,"address":[],"length":0,"stats":{"Line":9}},{"line":467,"address":[],"length":0,"stats":{"Line":1}},{"line":468,"address":[],"length":0,"stats":{"Line":3}},{"line":469,"address":[],"length":0,"stats":{"Line":3}},{"line":470,"address":[],"length":0,"stats":{"Line":3}},{"line":474,"address":[],"length":0,"stats":{"Line":1}},{"line":475,"address":[],"length":0,"stats":{"Line":4}},{"line":479,"address":[],"length":0,"stats":{"Line":2}},{"line":480,"address":[],"length":0,"stats":{"Line":6}},{"line":481,"address":[],"length":0,"stats":{"Line":6}},{"line":482,"address":[],"length":0,"stats":{"Line":6}},{"line":483,"address":[],"length":0,"stats":{"Line":6}},{"line":487,"address":[],"length":0,"stats":{"Line":2}},{"line":488,"address":[],"length":0,"stats":{"Line":6}},{"line":489,"address":[],"length":0,"stats":{"Line":10}},{"line":493,"address":[],"length":0,"stats":{"Line":1}},{"line":494,"address":[],"length":0,"stats":{"Line":2}},{"line":495,"address":[],"length":0,"stats":{"Line":5}},{"line":496,"address":[],"length":0,"stats":{"Line":5}},{"line":497,"address":[],"length":0,"stats":{"Line":16}},{"line":498,"address":[],"length":0,"stats":{"Line":10}},{"line":502,"address":[],"length":0,"stats":{"Line":1}},{"line":511,"address":[],"length":0,"stats":{"Line":6}},{"line":512,"address":[],"length":0,"stats":{"Line":18}},{"line":515,"address":[],"length":0,"stats":{"Line":21}},{"line":516,"address":[],"length":0,"stats":{"Line":3}},{"line":520,"address":[],"length":0,"stats":{"Line":5}},{"line":521,"address":[],"length":0,"stats":{"Line":2}},{"line":525,"address":[],"length":0,"stats":{"Line":3}},{"line":526,"address":[],"length":0,"stats":{"Line":2}},{"line":527,"address":[],"length":0,"stats":{"Line":3}},{"line":528,"address":[],"length":0,"stats":{"Line":2}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":2}},{"line":537,"address":[],"length":0,"stats":{"Line":14}},{"line":538,"address":[],"length":0,"stats":{"Line":15}},{"line":545,"address":[],"length":0,"stats":{"Line":1}},{"line":546,"address":[],"length":0,"stats":{"Line":2}},{"line":548,"address":[],"length":0,"stats":{"Line":1}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":3}},{"line":553,"address":[],"length":0,"stats":{"Line":1}}],"covered":171,"coverable":209},{"path":["/","workspace","crates","ofml-lib","src","ast.rs"],"content":"//! AST (Abstract Syntax Tree) types for OFML\n//! Based on OFML 2.0 specification Sections 3.5-3.8\n\nuse std::fmt;\n\n/// Source location for error reporting\n#[derive(Debug, Clone, Default)]\npub struct Span {\n    pub start: usize,\n    pub end: usize,\n}\n\nimpl Span {\n    pub fn new(start: usize, end: usize) -> Self {\n        Self { start, end }\n    }\n}\n\n/// A node with source location\n#[derive(Debug, Clone)]\npub struct Spanned<T> {\n    pub node: T,\n    pub span: Span,\n}\n\nimpl<T> Spanned<T> {\n    pub fn new(node: T, span: Span) -> Self {\n        Self { node, span }\n    }\n}\n\n// ============================================================\n// Top-Level Constructs\n// ============================================================\n\n/// A complete translation unit (source file)\n#[derive(Debug, Clone, Default)]\npub struct TranslationUnit {\n    pub package: Option<QualifiedName>,\n    pub imports: Vec<ImportDecl>,\n    pub statements: Vec<Stmt>,\n}\n\n/// Package declaration: `package ::vitra::workit;`\npub type PackageDecl = QualifiedName;\n\n/// Import declaration: `import ::ofml::oi::*;`\n#[derive(Debug, Clone)]\npub struct ImportDecl {\n    pub path: QualifiedName,\n    pub wildcard: bool, // ends with ::*\n    pub span: Span,\n}\n\n/// Qualified name: `::vitra::workit::ClassName`\n#[derive(Debug, Clone)]\npub struct QualifiedName {\n    pub absolute: bool, // starts with ::\n    pub parts: Vec<String>,\n    pub span: Span,\n}\n\nimpl fmt::Display for QualifiedName {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if self.absolute {\n            write!(f, \"::\")?;\n        }\n        write!(f, \"{}\", self.parts.join(\"::\"))\n    }\n}\n\n// ============================================================\n// Class Declaration\n// ============================================================\n\n/// Class declaration\n#[derive(Debug, Clone)]\npub struct ClassDecl {\n    pub modifiers: Vec<Modifier>,\n    pub name: String,\n    pub parent: Option<QualifiedName>,\n    pub members: Vec<ClassMember>,\n    pub span: Span,\n}\n\n/// Class member (variable, function, or rule)\n#[derive(Debug, Clone)]\npub enum ClassMember {\n    Var(VarDecl),\n    Func(FuncDecl),\n    Rule(RuleDecl),\n    /// Expression statement (e.g., hash initialization: `sAddTables[@W140] = [...]`)\n    Expr(Expr),\n}\n\n/// Access modifier\n#[derive(Debug, Clone, PartialEq)]\npub enum Modifier {\n    Public,\n    Private,\n    Protected,\n    Static,\n    Final,\n    Abstract,\n    Native,\n    Transient,\n}\n\n// ============================================================\n// Variable Declaration\n// ============================================================\n\n/// Variable declaration: `var x = expr;`\n#[derive(Debug, Clone)]\npub struct VarDecl {\n    pub modifiers: Vec<Modifier>,\n    pub name: String,\n    pub initializer: Option<Expr>,\n    pub span: Span,\n}\n\n// ============================================================\n// Function Declaration\n// ============================================================\n\n/// Function declaration: `func name(params) { body }`\n#[derive(Debug, Clone)]\npub struct FuncDecl {\n    pub modifiers: Vec<Modifier>,\n    pub name: String,\n    pub params: Vec<String>,\n    pub variadic: bool,      // has ... parameter\n    pub body: Option<Block>, // None for native functions\n    pub span: Span,\n}\n\n/// Rule declaration: `rule name(params) { body }`\n#[derive(Debug, Clone)]\npub struct RuleDecl {\n    pub name: String,\n    pub params: Vec<String>,\n    pub body: Block,\n    pub span: Span,\n}\n\n// ============================================================\n// Statements\n// ============================================================\n\n/// Statement\n#[derive(Debug, Clone)]\npub enum Stmt {\n    /// Single variable declaration\n    Var(VarDecl),\n    /// Multiple variable declarations: `var a, b = 1, c;`\n    VarList(Vec<VarDecl>),\n    /// Class declaration\n    Class(ClassDecl),\n    /// Function declaration\n    Func(FuncDecl),\n    /// Expression statement\n    Expr(Expr),\n    /// Block statement\n    Block(Block),\n    /// If statement\n    If(IfStmt),\n    /// Switch statement\n    Switch(SwitchStmt),\n    /// While loop\n    While(WhileStmt),\n    /// Do-while loop\n    DoWhile(DoWhileStmt),\n    /// For loop\n    For(ForStmt),\n    /// Foreach loop\n    Foreach(ForeachStmt),\n    /// Return statement\n    Return(Option<Expr>),\n    /// Break statement\n    Break(Option<String>), // optional label\n    /// Continue statement\n    Continue(Option<String>), // optional label\n    /// Throw statement\n    Throw(Expr),\n    /// Try-catch-finally\n    Try(TryStmt),\n    /// Empty statement\n    Empty,\n}\n\n/// Block: `{ statements }`\n#[derive(Debug, Clone)]\npub struct Block {\n    pub stmts: Vec<Stmt>,\n    pub span: Span,\n}\n\n/// If statement: `if (expr) stmt [else stmt]`\n#[derive(Debug, Clone)]\npub struct IfStmt {\n    pub condition: Expr,\n    pub then_branch: Box<Stmt>,\n    pub else_branch: Option<Box<Stmt>>,\n    pub span: Span,\n}\n\n/// Switch statement\n#[derive(Debug, Clone)]\npub struct SwitchStmt {\n    pub label: Option<String>,\n    pub expr: Expr,\n    pub cases: Vec<SwitchCase>,\n    pub span: Span,\n}\n\n/// Switch case or default\n#[derive(Debug, Clone)]\npub struct SwitchCase {\n    pub value: Option<Expr>, // None for default\n    pub stmts: Vec<Stmt>,\n}\n\n/// While loop: `while (expr) stmt`\n#[derive(Debug, Clone)]\npub struct WhileStmt {\n    pub label: Option<String>,\n    pub condition: Expr,\n    pub body: Box<Stmt>,\n    pub span: Span,\n}\n\n/// Do-while loop: `do stmt while (expr);`\n#[derive(Debug, Clone)]\npub struct DoWhileStmt {\n    pub label: Option<String>,\n    pub body: Box<Stmt>,\n    pub condition: Expr,\n    pub span: Span,\n}\n\n/// For loop: `for (init; cond; update) stmt`\n#[derive(Debug, Clone)]\npub struct ForStmt {\n    pub label: Option<String>,\n    pub init: Option<Box<Stmt>>,\n    pub condition: Option<Expr>,\n    pub update: Option<Expr>,\n    pub body: Box<Stmt>,\n    pub span: Span,\n}\n\n/// Foreach loop: `foreach (var; expr) stmt`\n#[derive(Debug, Clone)]\npub struct ForeachStmt {\n    pub label: Option<String>,\n    pub var_name: String,\n    pub iterable: Expr,\n    pub body: Box<Stmt>,\n    pub span: Span,\n}\n\n/// Try-catch-finally\n#[derive(Debug, Clone)]\npub struct TryStmt {\n    pub try_block: Block,\n    pub catch_var: Option<String>,\n    pub catch_block: Option<Block>,\n    pub finally_block: Option<Block>,\n    pub span: Span,\n}\n\n// ============================================================\n// Expressions\n// ============================================================\n\n/// Expression\n#[derive(Debug, Clone)]\npub enum Expr {\n    /// Integer literal\n    Int(i64),\n    /// Float literal\n    Float(f64),\n    /// String literal\n    String(String),\n    /// Symbol literal: @name\n    Symbol(String),\n    /// NULL\n    Null,\n    /// Self reference\n    SelfRef,\n    /// Super reference\n    SuperRef,\n    /// Identifier\n    Ident(String),\n    /// Qualified name: ::pkg::name\n    QualifiedName(QualifiedName),\n    /// Array/Vector literal: [a, b, c]\n    Array(Vec<Expr>),\n    /// List literal: @(a, b, c)\n    List(Vec<Expr>),\n    /// Binary operation\n    Binary(BinaryExpr),\n    /// Unary operation\n    Unary(UnaryExpr),\n    /// Conditional expression: cond ? then : else\n    Conditional(ConditionalExpr),\n    /// Assignment\n    Assign(AssignExpr),\n    /// Function call: func(args)\n    Call(CallExpr),\n    /// Index access: `expr[index]`\n    Index(IndexExpr),\n    /// Range access: `expr[start:end]`\n    Range(RangeExpr),\n    /// Member access: expr.name\n    Member(MemberExpr),\n    /// Instanceof check: expr instanceof Type\n    Instanceof(InstanceofExpr),\n    /// Parenthesized expression\n    Paren(Box<Expr>),\n}\n\n/// Binary expression\n#[derive(Debug, Clone)]\npub struct BinaryExpr {\n    pub left: Box<Expr>,\n    pub op: BinaryOp,\n    pub right: Box<Expr>,\n}\n\n/// Binary operators\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum BinaryOp {\n    // Arithmetic\n    Add,\n    Sub,\n    Mul,\n    Div,\n    Mod,\n    // Comparison\n    Eq,\n    Ne,\n    Lt,\n    Le,\n    Gt,\n    Ge,\n    PatternMatch, // ~=\n    // Logical\n    And,\n    Or,\n    // Bitwise\n    BitAnd,\n    BitOr,\n    BitXor,\n    Shl,\n    Shr,\n    Ushr, // >>>\n    // Min/Max\n    Min, // <?\n    Max, // >?\n}\n\n/// Unary expression\n#[derive(Debug, Clone)]\npub struct UnaryExpr {\n    pub op: UnaryOp,\n    pub operand: Box<Expr>,\n}\n\n/// Unary operators\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum UnaryOp {\n    Neg,     // -\n    Pos,     // +\n    Not,     // !\n    BitNot,  // ~\n    Test,    // !!\n    Resolve, // $\n    PreInc,  // ++x\n    PreDec,  // --x\n    PostInc, // x++\n    PostDec, // x--\n}\n\n/// Conditional expression: cond ? then : else\n#[derive(Debug, Clone)]\npub struct ConditionalExpr {\n    pub condition: Box<Expr>,\n    pub then_expr: Box<Expr>,\n    pub else_expr: Box<Expr>,\n}\n\n/// Assignment expression\n#[derive(Debug, Clone)]\npub struct AssignExpr {\n    pub target: Box<Expr>,\n    pub op: AssignOp,\n    pub value: Box<Expr>,\n}\n\n/// Assignment operators\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum AssignOp {\n    Assign,       // =\n    AddAssign,    // +=\n    SubAssign,    // -=\n    MulAssign,    // *=\n    DivAssign,    // /=\n    ModAssign,    // %=\n    ShlAssign,    // <<=\n    ShrAssign,    // >>=\n    UshrAssign,   // >>>=\n    BitAndAssign, // &=\n    BitOrAssign,  // |=\n    BitXorAssign, // ^=\n}\n\n/// Function call\n#[derive(Debug, Clone)]\npub struct CallExpr {\n    pub callee: Box<Expr>,\n    pub args: Vec<Expr>,\n}\n\n/// Index access: `expr[index]`\n#[derive(Debug, Clone)]\npub struct IndexExpr {\n    pub object: Box<Expr>,\n    pub index: Box<Expr>,\n}\n\n/// Range access: `expr[start:end]`\n#[derive(Debug, Clone)]\npub struct RangeExpr {\n    pub object: Box<Expr>,\n    pub start: Option<Box<Expr>>,\n    pub end: Option<Box<Expr>>,\n}\n\n/// Member access: expr.name\n#[derive(Debug, Clone)]\npub struct MemberExpr {\n    pub object: Box<Expr>,\n    pub member: String,\n}\n\n/// Instanceof expression\n#[derive(Debug, Clone)]\npub struct InstanceofExpr {\n    pub expr: Box<Expr>,\n    pub type_name: Box<Expr>,\n}\n\n// ============================================================\n// Utility Implementations\n// ============================================================\n\nimpl From<i64> for Expr {\n    fn from(n: i64) -> Self {\n        Expr::Int(n)\n    }\n}\n\nimpl From<f64> for Expr {\n    fn from(n: f64) -> Self {\n        Expr::Float(n)\n    }\n}\n\nimpl From<String> for Expr {\n    fn from(s: String) -> Self {\n        Expr::String(s)\n    }\n}\n\nimpl From<&str> for Expr {\n    fn from(s: &str) -> Self {\n        Expr::String(s.to_string())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_span_new() {\n        let span = Span::new(10, 20);\n        assert_eq!(span.start, 10);\n        assert_eq!(span.end, 20);\n    }\n\n    #[test]\n    fn test_span_default() {\n        let span = Span::default();\n        assert_eq!(span.start, 0);\n        assert_eq!(span.end, 0);\n    }\n\n    #[test]\n    fn test_span_debug_clone() {\n        let span = Span::new(5, 15);\n        let debug = format!(\"{:?}\", span);\n        assert!(debug.contains(\"Span\"));\n        let cloned = span.clone();\n        assert_eq!(cloned.start, span.start);\n        assert_eq!(cloned.end, span.end);\n    }\n\n    #[test]\n    fn test_spanned_new() {\n        let spanned = Spanned::new(42i64, Span::new(0, 5));\n        assert_eq!(spanned.node, 42);\n        assert_eq!(spanned.span.start, 0);\n        assert_eq!(spanned.span.end, 5);\n    }\n\n    #[test]\n    fn test_qualified_name_display_absolute() {\n        let name = QualifiedName {\n            absolute: true,\n            parts: vec![\"vitra\".to_string(), \"workit\".to_string(), \"Table\".to_string()],\n            span: Span::default(),\n        };\n        assert_eq!(format!(\"{}\", name), \"::vitra::workit::Table\");\n    }\n\n    #[test]\n    fn test_qualified_name_display_relative() {\n        let name = QualifiedName {\n            absolute: false,\n            parts: vec![\"local\".to_string(), \"Class\".to_string()],\n            span: Span::default(),\n        };\n        assert_eq!(format!(\"{}\", name), \"local::Class\");\n    }\n\n    #[test]\n    fn test_qualified_name_display_single() {\n        let name = QualifiedName {\n            absolute: false,\n            parts: vec![\"MyClass\".to_string()],\n            span: Span::default(),\n        };\n        assert_eq!(format!(\"{}\", name), \"MyClass\");\n    }\n\n    #[test]\n    fn test_import_decl() {\n        let import = ImportDecl {\n            path: QualifiedName {\n                absolute: true,\n                parts: vec![\"ofml\".to_string(), \"oi\".to_string()],\n                span: Span::default(),\n            },\n            wildcard: true,\n            span: Span::new(0, 20),\n        };\n        assert!(import.wildcard);\n        assert_eq!(format!(\"{}\", import.path), \"::ofml::oi\");\n    }\n\n    #[test]\n    fn test_expr_from_i64() {\n        let expr: Expr = 42i64.into();\n        match expr {\n            Expr::Int(n) => assert_eq!(n, 42),\n            _ => panic!(\"Expected Int\"),\n        }\n    }\n\n    #[test]\n    fn test_expr_from_f64() {\n        let expr: Expr = 3.14f64.into();\n        match expr {\n            Expr::Float(n) => assert!((n - 3.14).abs() < f64::EPSILON),\n            _ => panic!(\"Expected Float\"),\n        }\n    }\n\n    #[test]\n    fn test_expr_from_string() {\n        let expr: Expr = String::from(\"hello\").into();\n        match expr {\n            Expr::String(s) => assert_eq!(s, \"hello\"),\n            _ => panic!(\"Expected String\"),\n        }\n    }\n\n    #[test]\n    fn test_expr_from_str() {\n        let expr: Expr = \"world\".into();\n        match expr {\n            Expr::String(s) => assert_eq!(s, \"world\"),\n            _ => panic!(\"Expected String\"),\n        }\n    }\n\n    #[test]\n    fn test_translation_unit_default() {\n        let tu = TranslationUnit::default();\n        assert!(tu.package.is_none());\n        assert!(tu.imports.is_empty());\n        assert!(tu.statements.is_empty());\n    }\n\n    #[test]\n    fn test_modifier_eq() {\n        assert_eq!(Modifier::Public, Modifier::Public);\n        assert_ne!(Modifier::Public, Modifier::Private);\n        assert_eq!(Modifier::Static, Modifier::Static);\n    }\n\n    #[test]\n    fn test_binary_op_debug() {\n        let op = BinaryOp::Add;\n        let debug = format!(\"{:?}\", op);\n        assert!(debug.contains(\"Add\"));\n    }\n\n    #[test]\n    fn test_unary_op_debug() {\n        let op = UnaryOp::Not;\n        let debug = format!(\"{:?}\", op);\n        assert!(debug.contains(\"Not\"));\n    }\n\n    #[test]\n    fn test_assign_op_eq() {\n        assert_eq!(AssignOp::Assign, AssignOp::Assign);\n        assert_ne!(AssignOp::Assign, AssignOp::AddAssign);\n    }\n\n    #[test]\n    fn test_class_decl_debug() {\n        let class = ClassDecl {\n            modifiers: vec![Modifier::Public],\n            name: \"MyClass\".to_string(),\n            parent: None,\n            members: vec![],\n            span: Span::default(),\n        };\n        let debug = format!(\"{:?}\", class);\n        assert!(debug.contains(\"MyClass\"));\n    }\n\n    #[test]\n    fn test_var_decl() {\n        let var = VarDecl {\n            modifiers: vec![Modifier::Private],\n            name: \"counter\".to_string(),\n            initializer: Some(Expr::Int(0)),\n            span: Span::new(10, 30),\n        };\n        assert_eq!(var.name, \"counter\");\n        assert!(var.initializer.is_some());\n    }\n\n    #[test]\n    fn test_func_decl() {\n        let func = FuncDecl {\n            modifiers: vec![Modifier::Public],\n            name: \"calculate\".to_string(),\n            params: vec![\"a\".to_string(), \"b\".to_string()],\n            variadic: false,\n            body: Some(Block {\n                stmts: vec![],\n                span: Span::default(),\n            }),\n            span: Span::default(),\n        };\n        assert_eq!(func.name, \"calculate\");\n        assert_eq!(func.params.len(), 2);\n        assert!(!func.variadic);\n    }\n\n    #[test]\n    fn test_func_decl_variadic() {\n        let func = FuncDecl {\n            modifiers: vec![],\n            name: \"varargs\".to_string(),\n            params: vec![\"args\".to_string()],\n            variadic: true,\n            body: None,\n            span: Span::default(),\n        };\n        assert!(func.variadic);\n        assert!(func.body.is_none());\n    }\n\n    #[test]\n    fn test_block_stmt() {\n        let block = Block {\n            stmts: vec![\n                Stmt::Expr(Expr::Int(1)),\n                Stmt::Expr(Expr::Int(2)),\n            ],\n            span: Span::new(0, 100),\n        };\n        assert_eq!(block.stmts.len(), 2);\n    }\n\n    #[test]\n    fn test_call_expr() {\n        let call = CallExpr {\n            callee: Box::new(Expr::Ident(\"print\".to_string())),\n            args: vec![Expr::String(\"hello\".to_string())],\n        };\n        assert_eq!(call.args.len(), 1);\n    }\n\n    #[test]\n    fn test_index_expr() {\n        let index = IndexExpr {\n            object: Box::new(Expr::Ident(\"arr\".to_string())),\n            index: Box::new(Expr::Int(0)),\n        };\n        let debug = format!(\"{:?}\", index);\n        assert!(debug.contains(\"IndexExpr\"));\n    }\n\n    #[test]\n    fn test_member_expr() {\n        let member = MemberExpr {\n            object: Box::new(Expr::Ident(\"obj\".to_string())),\n            member: \"field\".to_string(),\n        };\n        assert_eq!(member.member, \"field\");\n    }\n\n    #[test]\n    fn test_instanceof_expr() {\n        let instance = InstanceofExpr {\n            expr: Box::new(Expr::Ident(\"x\".to_string())),\n            type_name: Box::new(Expr::Ident(\"MyClass\".to_string())),\n        };\n        let debug = format!(\"{:?}\", instance);\n        assert!(debug.contains(\"InstanceofExpr\"));\n    }\n\n    #[test]\n    fn test_if_stmt() {\n        let if_stmt = IfStmt {\n            condition: Expr::Int(1), // Non-zero as truthy condition\n            then_branch: Box::new(Stmt::Empty),\n            else_branch: None,\n            span: Span::default(),\n        };\n        assert!(if_stmt.else_branch.is_none());\n    }\n\n    #[test]\n    fn test_while_stmt() {\n        let while_stmt = WhileStmt {\n            label: None,\n            condition: Expr::Int(1),\n            body: Box::new(Stmt::Empty),\n            span: Span::default(),\n        };\n        let debug = format!(\"{:?}\", while_stmt);\n        assert!(debug.contains(\"WhileStmt\"));\n    }\n\n    #[test]\n    fn test_for_stmt() {\n        let for_stmt = ForStmt {\n            label: None,\n            init: None,\n            condition: Some(Expr::Int(1)),\n            update: None,\n            body: Box::new(Stmt::Empty),\n            span: Span::default(),\n        };\n        assert!(for_stmt.init.is_none());\n        assert!(for_stmt.condition.is_some());\n    }\n\n    #[test]\n    fn test_switch_case() {\n        let case = SwitchCase {\n            value: Some(Expr::Int(1)),\n            stmts: vec![Stmt::Break(None)],\n        };\n        assert!(case.value.is_some());\n        assert_eq!(case.stmts.len(), 1);\n    }\n\n    #[test]\n    fn test_try_stmt() {\n        let try_stmt = TryStmt {\n            try_block: Block {\n                stmts: vec![],\n                span: Span::default(),\n            },\n            catch_var: Some(\"e\".to_string()),\n            catch_block: Some(Block {\n                stmts: vec![],\n                span: Span::default(),\n            }),\n            finally_block: None,\n            span: Span::default(),\n        };\n        assert!(try_stmt.catch_var.is_some());\n        assert!(try_stmt.finally_block.is_none());\n    }\n\n    #[test]\n    fn test_all_binary_ops() {\n        let ops = vec![\n            BinaryOp::Add, BinaryOp::Sub, BinaryOp::Mul, BinaryOp::Div, BinaryOp::Mod,\n            BinaryOp::Lt, BinaryOp::Le, BinaryOp::Gt, BinaryOp::Ge, BinaryOp::Eq, BinaryOp::Ne,\n            BinaryOp::And, BinaryOp::Or, BinaryOp::BitAnd, BinaryOp::BitOr, BinaryOp::BitXor,\n            BinaryOp::Shl, BinaryOp::Shr, BinaryOp::Ushr, BinaryOp::Min, BinaryOp::Max,\n            BinaryOp::PatternMatch,\n        ];\n        for op in &ops {\n            let debug = format!(\"{:?}\", op);\n            assert!(!debug.is_empty());\n        }\n    }\n\n    #[test]\n    fn test_all_unary_ops() {\n        let ops = vec![\n            UnaryOp::Neg, UnaryOp::Pos, UnaryOp::Not, UnaryOp::BitNot,\n            UnaryOp::Test, UnaryOp::Resolve,\n            UnaryOp::PreInc, UnaryOp::PreDec, UnaryOp::PostInc, UnaryOp::PostDec,\n        ];\n        for op in &ops {\n            let debug = format!(\"{:?}\", op);\n            assert!(!debug.is_empty());\n        }\n    }\n\n    #[test]\n    fn test_all_assign_ops() {\n        let ops = vec![\n            AssignOp::Assign, AssignOp::AddAssign, AssignOp::SubAssign,\n            AssignOp::MulAssign, AssignOp::DivAssign, AssignOp::ModAssign,\n            AssignOp::ShlAssign, AssignOp::ShrAssign, AssignOp::UshrAssign,\n            AssignOp::BitAndAssign, AssignOp::BitOrAssign, AssignOp::BitXorAssign,\n        ];\n        for op in &ops {\n            let cloned = *op;\n            assert_eq!(cloned, *op);\n        }\n    }\n\n    #[test]\n    fn test_rule_decl() {\n        let rule = RuleDecl {\n            name: \"onPropertyChange\".to_string(),\n            params: vec![\"prop\".to_string()],\n            body: Block {\n                stmts: vec![],\n                span: Span::default(),\n            },\n            span: Span::default(),\n        };\n        assert_eq!(rule.name, \"onPropertyChange\");\n    }\n\n    #[test]\n    fn test_class_member_variants() {\n        let var_member = ClassMember::Var(VarDecl {\n            modifiers: vec![],\n            name: \"x\".to_string(),\n            initializer: None,\n            span: Span::default(),\n        });\n        let debug = format!(\"{:?}\", var_member);\n        assert!(debug.contains(\"Var\"));\n\n        let func_member = ClassMember::Func(FuncDecl {\n            modifiers: vec![],\n            name: \"f\".to_string(),\n            params: vec![],\n            variadic: false,\n            body: None,\n            span: Span::default(),\n        });\n        let debug = format!(\"{:?}\", func_member);\n        assert!(debug.contains(\"Func\"));\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":1085}},{"line":27,"address":[],"length":0,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":27}},{"line":65,"address":[],"length":0,"stats":{"Line":27}},{"line":66,"address":[],"length":0,"stats":{"Line":24}},{"line":68,"address":[],"length":0,"stats":{"Line":135}},{"line":459,"address":[],"length":0,"stats":{"Line":1}},{"line":460,"address":[],"length":0,"stats":{"Line":1}},{"line":465,"address":[],"length":0,"stats":{"Line":1}},{"line":466,"address":[],"length":0,"stats":{"Line":1}},{"line":471,"address":[],"length":0,"stats":{"Line":1}},{"line":472,"address":[],"length":0,"stats":{"Line":1}},{"line":477,"address":[],"length":0,"stats":{"Line":1}},{"line":478,"address":[],"length":0,"stats":{"Line":1}}],"covered":14,"coverable":14},{"path":["/","workspace","crates","ofml-lib","src","attachment.rs"],"content":"//! Attachment Points System - Product composition and connection points.\n//!\n//! This module implements attachment points for connecting products together.\n//! Attachment points are loaded from EBASE tables: attpt, oppattpt, stdattpt.\n\nuse crate::errors::AttachmentError;\n\n/// Attachment point type.\n#[derive(Debug, Clone, PartialEq, Eq, Default)]\npub enum AttachmentType {\n    /// Standard attachment point (from stdattpt table)\n    #[default]\n    Standard,\n    /// Opposite attachment point (from oppattpt table)\n    Opposite,\n    /// Product-specific attachment point (from attpt table)\n    Custom,\n}\n\nimpl AttachmentType {\n    /// Get the table name for this type.\n    pub fn table_name(&self) -> &'static str {\n        match self {\n            AttachmentType::Standard => \"stdattpt\",\n            AttachmentType::Opposite => \"oppattpt\",\n            AttachmentType::Custom => \"attpt\",\n        }\n    }\n}\n\n/// Attachment point definition.\n#[derive(Debug, Clone)]\npub struct AttachmentPoint {\n    /// Point name/identifier\n    pub name: String,\n    /// Local position [x, y, z]\n    pub position: [f64; 3],\n    /// Attachment direction [dx, dy, dz] (unit vector)\n    pub direction: [f64; 3],\n    /// Point type\n    pub point_type: AttachmentType,\n    /// Compatibility tags for matching\n    pub tags: Vec<String>,\n}\n\nimpl AttachmentPoint {\n    /// Create a new attachment point.\n    pub fn new(name: impl Into<String>, position: [f64; 3], direction: [f64; 3]) -> Self {\n        Self {\n            name: name.into(),\n            position,\n            direction,\n            point_type: AttachmentType::default(),\n            tags: Vec::new(),\n        }\n    }\n\n    /// Set the point type.\n    pub fn with_type(mut self, point_type: AttachmentType) -> Self {\n        self.point_type = point_type;\n        self\n    }\n\n    /// Add a compatibility tag.\n    pub fn with_tag(mut self, tag: impl Into<String>) -> Self {\n        self.tags.push(tag.into());\n        self\n    }\n\n    /// Add multiple compatibility tags.\n    pub fn with_tags(mut self, tags: Vec<String>) -> Self {\n        self.tags.extend(tags);\n        self\n    }\n\n    /// Check if this point is compatible with another.\n    ///\n    /// Points are compatible if they share at least one tag or if\n    /// one is a standard point and the other is opposite.\n    pub fn is_compatible(&self, other: &AttachmentPoint) -> bool {\n        // Check type compatibility\n        let type_compatible = matches!(\n            (&self.point_type, &other.point_type),\n            (AttachmentType::Standard, AttachmentType::Opposite)\n                | (AttachmentType::Opposite, AttachmentType::Standard)\n        );\n\n        if type_compatible {\n            return true;\n        }\n\n        // Check tag compatibility\n        for tag in &self.tags {\n            if other.tags.contains(tag) {\n                return true;\n            }\n        }\n\n        false\n    }\n\n    /// Validate the direction vector (should be unit length).\n    pub fn validate(&self) -> Result<(), AttachmentError> {\n        let len =\n            (self.direction[0].powi(2) + self.direction[1].powi(2) + self.direction[2].powi(2))\n                .sqrt();\n\n        if (len - 1.0).abs() > 0.01 {\n            return Err(AttachmentError::InvalidDirection);\n        }\n\n        Ok(())\n    }\n\n    /// Normalize the direction vector.\n    pub fn normalize_direction(&mut self) {\n        let len =\n            (self.direction[0].powi(2) + self.direction[1].powi(2) + self.direction[2].powi(2))\n                .sqrt();\n\n        if len > 0.0 {\n            self.direction[0] /= len;\n            self.direction[1] /= len;\n            self.direction[2] /= len;\n        }\n    }\n\n    /// Transform position to world coordinates.\n    pub fn world_position(&self, transform: &[[f64; 4]; 4]) -> [f64; 3] {\n        let x = self.position[0];\n        let y = self.position[1];\n        let z = self.position[2];\n\n        [\n            transform[0][0] * x + transform[0][1] * y + transform[0][2] * z + transform[0][3],\n            transform[1][0] * x + transform[1][1] * y + transform[1][2] * z + transform[1][3],\n            transform[2][0] * x + transform[2][1] * y + transform[2][2] * z + transform[2][3],\n        ]\n    }\n\n    /// Transform direction to world coordinates.\n    pub fn world_direction(&self, transform: &[[f64; 4]; 4]) -> [f64; 3] {\n        let dx = self.direction[0];\n        let dy = self.direction[1];\n        let dz = self.direction[2];\n\n        // Transform direction (no translation)\n        let mut result = [\n            transform[0][0] * dx + transform[0][1] * dy + transform[0][2] * dz,\n            transform[1][0] * dx + transform[1][1] * dy + transform[1][2] * dz,\n            transform[2][0] * dx + transform[2][1] * dy + transform[2][2] * dz,\n        ];\n\n        // Normalize\n        let len = (result[0].powi(2) + result[1].powi(2) + result[2].powi(2)).sqrt();\n        if len > 0.0 {\n            result[0] /= len;\n            result[1] /= len;\n            result[2] /= len;\n        }\n\n        result\n    }\n}\n\n/// Collection of attachment points.\n#[derive(Debug, Clone, Default)]\npub struct AttachmentPointSet {\n    /// All attachment points\n    points: Vec<AttachmentPoint>,\n}\n\nimpl AttachmentPointSet {\n    /// Create a new empty set.\n    pub fn new() -> Self {\n        Self { points: Vec::new() }\n    }\n\n    /// Add an attachment point.\n    pub fn add(&mut self, point: AttachmentPoint) {\n        self.points.push(point);\n    }\n\n    /// Get a point by name.\n    pub fn get(&self, name: &str) -> Option<&AttachmentPoint> {\n        self.points.iter().find(|p| p.name == name)\n    }\n\n    /// Get a mutable point by name.\n    pub fn get_mut(&mut self, name: &str) -> Option<&mut AttachmentPoint> {\n        self.points.iter_mut().find(|p| p.name == name)\n    }\n\n    /// Get all points.\n    pub fn all(&self) -> &[AttachmentPoint] {\n        &self.points\n    }\n\n    /// Get points by type.\n    pub fn by_type(&self, point_type: AttachmentType) -> Vec<&AttachmentPoint> {\n        self.points\n            .iter()\n            .filter(|p| p.point_type == point_type)\n            .collect()\n    }\n\n    /// Get points with a specific tag.\n    pub fn by_tag(&self, tag: &str) -> Vec<&AttachmentPoint> {\n        self.points\n            .iter()\n            .filter(|p| p.tags.iter().any(|t| t == tag))\n            .collect()\n    }\n\n    /// Find compatible point pairs between this set and another.\n    pub fn find_compatible_pairs<'a>(\n        &'a self,\n        other: &'a AttachmentPointSet,\n    ) -> Vec<(&'a AttachmentPoint, &'a AttachmentPoint)> {\n        let mut pairs = Vec::new();\n\n        for self_point in &self.points {\n            for other_point in &other.points {\n                if self_point.is_compatible(other_point) {\n                    pairs.push((self_point, other_point));\n                }\n            }\n        }\n\n        pairs\n    }\n\n    /// Number of points.\n    pub fn len(&self) -> usize {\n        self.points.len()\n    }\n\n    /// Check if empty.\n    pub fn is_empty(&self) -> bool {\n        self.points.is_empty()\n    }\n\n    /// Clear all points.\n    pub fn clear(&mut self) {\n        self.points.clear();\n    }\n\n    /// Remove a point by name.\n    pub fn remove(&mut self, name: &str) -> Option<AttachmentPoint> {\n        if let Some(pos) = self.points.iter().position(|p| p.name == name) {\n            Some(self.points.remove(pos))\n        } else {\n            None\n        }\n    }\n\n    /// Get point names.\n    pub fn names(&self) -> Vec<&str> {\n        self.points.iter().map(|p| p.name.as_str()).collect()\n    }\n}\n\n/// Load attachment points from an EBASE record.\n///\n/// Parses attachment point data from attpt, oppattpt, or stdattpt tables.\npub fn load_attachment_from_record(\n    record: &crate::ebase::Record,\n    point_type: AttachmentType,\n) -> Option<AttachmentPoint> {\n    use crate::ebase::Value;\n\n    let name = record\n        .get(\"name\")\n        .or_else(|| record.get(\"attpt_name\"))\n        .and_then(|v| v.as_str())?\n        .to_string();\n\n    let get_float = |key: &str| -> f64 { record.get(key).and_then(|v| v.as_f64()).unwrap_or(0.0) };\n\n    let x = get_float(\"x\").max(get_float(\"pos_x\"));\n    let y = get_float(\"y\").max(get_float(\"pos_y\"));\n    let z = get_float(\"z\").max(get_float(\"pos_z\"));\n\n    let dx = record\n        .get(\"dx\")\n        .or_else(|| record.get(\"dir_x\"))\n        .and_then(|v| v.as_f64())\n        .unwrap_or(0.0);\n    let dy = record\n        .get(\"dy\")\n        .or_else(|| record.get(\"dir_y\"))\n        .and_then(|v| v.as_f64())\n        .unwrap_or(0.0);\n    let mut dz = record\n        .get(\"dz\")\n        .or_else(|| record.get(\"dir_z\"))\n        .and_then(|v| v.as_f64())\n        .unwrap_or(0.0);\n\n    // Default direction to +Z if all components are 0\n    if dx == 0.0 && dy == 0.0 && dz == 0.0 {\n        dz = 1.0;\n    }\n\n    let mut point = AttachmentPoint::new(name, [x, y, z], [dx, dy, dz]).with_type(point_type);\n    point.normalize_direction();\n\n    // Load tags if present\n    if let Some(Value::String(tags)) = record.get(\"tags\").or_else(|| record.get(\"tag\")) {\n        for tag in tags.split(',') {\n            let tag = tag.trim();\n            if !tag.is_empty() {\n                point.tags.push(tag.to_string());\n            }\n        }\n    }\n\n    Some(point)\n}\n\n/// Load attachment points from EBASE attpt table.\npub fn load_attpt_table(reader: &mut crate::ebase::EBaseReader) -> Vec<AttachmentPoint> {\n    load_attachment_table(reader, \"attpt\", AttachmentType::Custom)\n}\n\n/// Load attachment points from EBASE oppattpt table.\npub fn load_oppattpt_table(reader: &mut crate::ebase::EBaseReader) -> Vec<AttachmentPoint> {\n    load_attachment_table(reader, \"oppattpt\", AttachmentType::Opposite)\n}\n\n/// Load attachment points from EBASE stdattpt table.\npub fn load_stdattpt_table(reader: &mut crate::ebase::EBaseReader) -> Vec<AttachmentPoint> {\n    load_attachment_table(reader, \"stdattpt\", AttachmentType::Standard)\n}\n\n/// Load attachment points from a specific EBASE table.\nfn load_attachment_table(\n    reader: &mut crate::ebase::EBaseReader,\n    table_name: &str,\n    point_type: AttachmentType,\n) -> Vec<AttachmentPoint> {\n    if !reader.tables.contains_key(table_name) {\n        return Vec::new();\n    }\n\n    match reader.read_records(table_name, None) {\n        Ok(records) => records\n            .iter()\n            .filter_map(|r| load_attachment_from_record(r, point_type.clone()))\n            .collect(),\n        Err(_) => Vec::new(),\n    }\n}\n\n/// Load all attachment points from an EBASE file into an AttachmentPointSet.\npub fn load_all_attachments(reader: &mut crate::ebase::EBaseReader) -> AttachmentPointSet {\n    let mut set = AttachmentPointSet::new();\n\n    // Load from all three tables\n    for point in load_attpt_table(reader) {\n        set.add(point);\n    }\n    for point in load_oppattpt_table(reader) {\n        set.add(point);\n    }\n    for point in load_stdattpt_table(reader) {\n        set.add(point);\n    }\n\n    set\n}\n\n/// Builder for creating attachment points from EBASE data.\npub struct AttachmentPointBuilder {\n    point: AttachmentPoint,\n}\n\nimpl AttachmentPointBuilder {\n    /// Start building a new attachment point.\n    pub fn new(name: impl Into<String>) -> Self {\n        Self {\n            point: AttachmentPoint::new(name, [0.0, 0.0, 0.0], [0.0, 0.0, 1.0]),\n        }\n    }\n\n    /// Set position.\n    pub fn position(mut self, x: f64, y: f64, z: f64) -> Self {\n        self.point.position = [x, y, z];\n        self\n    }\n\n    /// Set direction.\n    pub fn direction(mut self, dx: f64, dy: f64, dz: f64) -> Self {\n        self.point.direction = [dx, dy, dz];\n        self.point.normalize_direction();\n        self\n    }\n\n    /// Set type.\n    pub fn point_type(mut self, point_type: AttachmentType) -> Self {\n        self.point.point_type = point_type;\n        self\n    }\n\n    /// Add tag.\n    pub fn tag(mut self, tag: impl Into<String>) -> Self {\n        self.point.tags.push(tag.into());\n        self\n    }\n\n    /// Build the attachment point.\n    pub fn build(self) -> AttachmentPoint {\n        self.point\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_attachment_point_creation() {\n        let point = AttachmentPoint::new(\"test_point\", [10.0, 20.0, 30.0], [0.0, 0.0, 1.0]);\n\n        assert_eq!(point.name, \"test_point\");\n        assert_eq!(point.position, [10.0, 20.0, 30.0]);\n        assert_eq!(point.direction, [0.0, 0.0, 1.0]);\n        assert_eq!(point.point_type, AttachmentType::Standard);\n    }\n\n    #[test]\n    fn test_attachment_point_builder() {\n        let point = AttachmentPointBuilder::new(\"builder_point\")\n            .position(100.0, 200.0, 300.0)\n            .direction(1.0, 0.0, 0.0)\n            .point_type(AttachmentType::Custom)\n            .tag(\"connector\")\n            .build();\n\n        assert_eq!(point.name, \"builder_point\");\n        assert_eq!(point.position, [100.0, 200.0, 300.0]);\n        assert_eq!(point.point_type, AttachmentType::Custom);\n        assert!(point.tags.contains(&\"connector\".to_string()));\n    }\n\n    #[test]\n    fn test_attachment_point_validation() {\n        let valid = AttachmentPoint::new(\"valid\", [0.0, 0.0, 0.0], [0.0, 0.0, 1.0]);\n        assert!(valid.validate().is_ok());\n\n        let invalid = AttachmentPoint::new(\"invalid\", [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]);\n        assert!(invalid.validate().is_err());\n    }\n\n    #[test]\n    fn test_attachment_point_normalize() {\n        let mut point = AttachmentPoint::new(\"test\", [0.0, 0.0, 0.0], [3.0, 4.0, 0.0]);\n        point.normalize_direction();\n\n        assert!((point.direction[0] - 0.6).abs() < 0.001);\n        assert!((point.direction[1] - 0.8).abs() < 0.001);\n        assert!(point.validate().is_ok());\n    }\n\n    #[test]\n    fn test_attachment_compatibility() {\n        let standard = AttachmentPoint::new(\"std\", [0.0, 0.0, 0.0], [0.0, 0.0, 1.0])\n            .with_type(AttachmentType::Standard);\n        let opposite = AttachmentPoint::new(\"opp\", [0.0, 0.0, 0.0], [0.0, 0.0, -1.0])\n            .with_type(AttachmentType::Opposite);\n        let custom1 = AttachmentPoint::new(\"c1\", [0.0, 0.0, 0.0], [0.0, 0.0, 1.0])\n            .with_type(AttachmentType::Custom)\n            .with_tag(\"power\");\n        let custom2 = AttachmentPoint::new(\"c2\", [0.0, 0.0, 0.0], [0.0, 0.0, 1.0])\n            .with_type(AttachmentType::Custom)\n            .with_tag(\"power\");\n\n        // Standard and Opposite are compatible\n        assert!(standard.is_compatible(&opposite));\n        assert!(opposite.is_compatible(&standard));\n\n        // Custom with same tag are compatible\n        assert!(custom1.is_compatible(&custom2));\n\n        // Standard and Custom (no matching tags) are not compatible\n        assert!(!standard.is_compatible(&custom1));\n    }\n\n    #[test]\n    fn test_attachment_point_set() {\n        let mut set = AttachmentPointSet::new();\n\n        set.add(\n            AttachmentPoint::new(\"p1\", [0.0, 0.0, 0.0], [0.0, 0.0, 1.0])\n                .with_type(AttachmentType::Standard),\n        );\n        set.add(\n            AttachmentPoint::new(\"p2\", [100.0, 0.0, 0.0], [0.0, 0.0, 1.0])\n                .with_type(AttachmentType::Custom)\n                .with_tag(\"connector\"),\n        );\n\n        assert_eq!(set.len(), 2);\n        assert!(set.get(\"p1\").is_some());\n        assert!(set.get(\"p3\").is_none());\n\n        let standard = set.by_type(AttachmentType::Standard);\n        assert_eq!(standard.len(), 1);\n\n        let tagged = set.by_tag(\"connector\");\n        assert_eq!(tagged.len(), 1);\n    }\n\n    #[test]\n    fn test_find_compatible_pairs() {\n        let mut set1 = AttachmentPointSet::new();\n        set1.add(\n            AttachmentPoint::new(\"std1\", [0.0, 0.0, 0.0], [0.0, 0.0, 1.0])\n                .with_type(AttachmentType::Standard),\n        );\n\n        let mut set2 = AttachmentPointSet::new();\n        set2.add(\n            AttachmentPoint::new(\"opp1\", [0.0, 0.0, 0.0], [0.0, 0.0, -1.0])\n                .with_type(AttachmentType::Opposite),\n        );\n\n        let pairs = set1.find_compatible_pairs(&set2);\n        assert_eq!(pairs.len(), 1);\n        assert_eq!(pairs[0].0.name, \"std1\");\n        assert_eq!(pairs[0].1.name, \"opp1\");\n    }\n\n    #[test]\n    fn test_world_transform() {\n        let point = AttachmentPoint::new(\"test\", [1.0, 0.0, 0.0], [1.0, 0.0, 0.0]);\n\n        // Translation matrix\n        let transform = [\n            [1.0, 0.0, 0.0, 10.0],\n            [0.0, 1.0, 0.0, 20.0],\n            [0.0, 0.0, 1.0, 30.0],\n            [0.0, 0.0, 0.0, 1.0],\n        ];\n\n        let world_pos = point.world_position(&transform);\n        assert!((world_pos[0] - 11.0).abs() < 0.001);\n        assert!((world_pos[1] - 20.0).abs() < 0.001);\n        assert!((world_pos[2] - 30.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_load_attachment_from_record() {\n        use crate::ebase::{Record, Value};\n\n        let mut record = Record::new();\n        record.insert(\"name\".to_string(), Value::String(\"connector_1\".to_string()));\n        record.insert(\"x\".to_string(), Value::Float(10.0));\n        record.insert(\"y\".to_string(), Value::Float(20.0));\n        record.insert(\"z\".to_string(), Value::Float(30.0));\n        record.insert(\"dx\".to_string(), Value::Float(1.0));\n        record.insert(\"dy\".to_string(), Value::Float(0.0));\n        record.insert(\"dz\".to_string(), Value::Float(0.0));\n        record.insert(\"tags\".to_string(), Value::String(\"power, data\".to_string()));\n\n        let point = load_attachment_from_record(&record, AttachmentType::Custom).unwrap();\n\n        assert_eq!(point.name, \"connector_1\");\n        assert_eq!(point.position, [10.0, 20.0, 30.0]);\n        assert!((point.direction[0] - 1.0).abs() < 0.001);\n        assert_eq!(point.point_type, AttachmentType::Custom);\n        assert!(point.tags.contains(&\"power\".to_string()));\n        assert!(point.tags.contains(&\"data\".to_string()));\n    }\n\n    #[test]\n    fn test_load_attachment_missing_name() {\n        use crate::ebase::{Record, Value};\n\n        let mut record = Record::new();\n        record.insert(\"x\".to_string(), Value::Float(10.0));\n\n        // Should return None when name is missing\n        let point = load_attachment_from_record(&record, AttachmentType::Standard);\n        assert!(point.is_none());\n    }\n\n    #[test]\n    fn test_attachment_type_table_name() {\n        assert_eq!(AttachmentType::Standard.table_name(), \"stdattpt\");\n        assert_eq!(AttachmentType::Opposite.table_name(), \"oppattpt\");\n        assert_eq!(AttachmentType::Custom.table_name(), \"attpt\");\n    }\n\n    #[test]\n    fn test_attachment_type_default() {\n        let default_type: AttachmentType = Default::default();\n        assert_eq!(default_type, AttachmentType::Standard);\n    }\n\n    #[test]\n    fn test_attachment_type_clone() {\n        let original = AttachmentType::Opposite;\n        let cloned = original.clone();\n        assert_eq!(cloned, AttachmentType::Opposite);\n    }\n\n    #[test]\n    fn test_attachment_type_debug() {\n        let std = AttachmentType::Standard;\n        assert_eq!(format!(\"{:?}\", std), \"Standard\");\n        let opp = AttachmentType::Opposite;\n        assert_eq!(format!(\"{:?}\", opp), \"Opposite\");\n        let cust = AttachmentType::Custom;\n        assert_eq!(format!(\"{:?}\", cust), \"Custom\");\n    }\n\n    #[test]\n    fn test_attachment_point_with_type() {\n        let point = AttachmentPoint::new(\"p\", [0.0; 3], [0.0, 0.0, 1.0])\n            .with_type(AttachmentType::Opposite);\n        assert_eq!(point.point_type, AttachmentType::Opposite);\n    }\n\n    #[test]\n    fn test_attachment_point_with_tags() {\n        let point = AttachmentPoint::new(\"p\", [0.0; 3], [0.0, 0.0, 1.0])\n            .with_tags(vec![\"tag1\".to_string(), \"tag2\".to_string()]);\n        assert_eq!(point.tags.len(), 2);\n        assert!(point.tags.contains(&\"tag1\".to_string()));\n        assert!(point.tags.contains(&\"tag2\".to_string()));\n    }\n\n    #[test]\n    fn test_attachment_point_clone() {\n        let point = AttachmentPoint::new(\"cloneable\", [1.0, 2.0, 3.0], [0.0, 1.0, 0.0])\n            .with_type(AttachmentType::Custom)\n            .with_tag(\"clone_tag\");\n        let cloned = point.clone();\n\n        assert_eq!(cloned.name, \"cloneable\");\n        assert_eq!(cloned.position, [1.0, 2.0, 3.0]);\n        assert_eq!(cloned.direction, [0.0, 1.0, 0.0]);\n        assert_eq!(cloned.point_type, AttachmentType::Custom);\n        assert!(cloned.tags.contains(&\"clone_tag\".to_string()));\n    }\n\n    #[test]\n    fn test_attachment_point_debug() {\n        let point = AttachmentPoint::new(\"debug_test\", [0.0; 3], [0.0, 0.0, 1.0]);\n        let debug_str = format!(\"{:?}\", point);\n        assert!(debug_str.contains(\"debug_test\"));\n    }\n\n    #[test]\n    fn test_validate_non_unit_direction() {\n        // Direction too long\n        let long_dir = AttachmentPoint::new(\"test\", [0.0; 3], [2.0, 0.0, 0.0]);\n        assert!(long_dir.validate().is_err());\n\n        // Direction too short\n        let short_dir = AttachmentPoint::new(\"test\", [0.0; 3], [0.1, 0.0, 0.0]);\n        assert!(short_dir.validate().is_err());\n    }\n\n    #[test]\n    fn test_normalize_zero_direction() {\n        let mut point = AttachmentPoint::new(\"zero\", [0.0; 3], [0.0, 0.0, 0.0]);\n        point.normalize_direction();\n        // Direction should remain zero (no normalization possible)\n        assert_eq!(point.direction, [0.0, 0.0, 0.0]);\n    }\n\n    #[test]\n    fn test_world_direction_transform() {\n        // Test a simple 90-degree rotation around Z axis\n        let point = AttachmentPoint::new(\"test\", [0.0; 3], [1.0, 0.0, 0.0]);\n\n        // 90-degree rotation around Z\n        let transform = [\n            [0.0, -1.0, 0.0, 0.0],\n            [1.0, 0.0, 0.0, 0.0],\n            [0.0, 0.0, 1.0, 0.0],\n            [0.0, 0.0, 0.0, 1.0],\n        ];\n\n        let world_dir = point.world_direction(&transform);\n        // [1, 0, 0] rotated 90 degrees around Z should give [0, 1, 0]\n        assert!((world_dir[0] - 0.0).abs() < 0.001);\n        assert!((world_dir[1] - 1.0).abs() < 0.001);\n        assert!((world_dir[2] - 0.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_world_direction_zero_result() {\n        let point = AttachmentPoint::new(\"test\", [0.0; 3], [0.0, 0.0, 1.0]);\n\n        // Transform that projects onto xy plane (zeroing the direction if it was Z)\n        let transform = [\n            [0.0, 0.0, 0.0, 0.0],\n            [0.0, 0.0, 0.0, 0.0],\n            [0.0, 0.0, 0.0, 0.0],\n            [0.0, 0.0, 0.0, 1.0],\n        ];\n\n        let world_dir = point.world_direction(&transform);\n        // Result should be [0, 0, 0] since normalization can't be done\n        assert_eq!(world_dir, [0.0, 0.0, 0.0]);\n    }\n\n    #[test]\n    fn test_is_compatible_no_tags() {\n        let p1 = AttachmentPoint::new(\"p1\", [0.0; 3], [0.0, 0.0, 1.0])\n            .with_type(AttachmentType::Custom);\n        let p2 = AttachmentPoint::new(\"p2\", [0.0; 3], [0.0, 0.0, 1.0])\n            .with_type(AttachmentType::Custom);\n\n        // Custom types without shared tags are not compatible\n        assert!(!p1.is_compatible(&p2));\n    }\n\n    #[test]\n    fn test_is_compatible_different_tags() {\n        let p1 = AttachmentPoint::new(\"p1\", [0.0; 3], [0.0, 0.0, 1.0])\n            .with_type(AttachmentType::Custom)\n            .with_tag(\"power\");\n        let p2 = AttachmentPoint::new(\"p2\", [0.0; 3], [0.0, 0.0, 1.0])\n            .with_type(AttachmentType::Custom)\n            .with_tag(\"data\");\n\n        assert!(!p1.is_compatible(&p2));\n    }\n\n    #[test]\n    fn test_is_compatible_multiple_tags() {\n        let p1 = AttachmentPoint::new(\"p1\", [0.0; 3], [0.0, 0.0, 1.0])\n            .with_type(AttachmentType::Custom)\n            .with_tags(vec![\"a\".to_string(), \"b\".to_string(), \"c\".to_string()]);\n        let p2 = AttachmentPoint::new(\"p2\", [0.0; 3], [0.0, 0.0, 1.0])\n            .with_type(AttachmentType::Custom)\n            .with_tags(vec![\"x\".to_string(), \"y\".to_string(), \"c\".to_string()]);\n\n        // Share tag \"c\"\n        assert!(p1.is_compatible(&p2));\n    }\n\n    #[test]\n    fn test_attachment_point_set_default() {\n        let set: AttachmentPointSet = Default::default();\n        assert!(set.is_empty());\n        assert_eq!(set.len(), 0);\n    }\n\n    #[test]\n    fn test_attachment_point_set_clone() {\n        let mut set = AttachmentPointSet::new();\n        set.add(AttachmentPoint::new(\"p1\", [0.0; 3], [0.0, 0.0, 1.0]));\n\n        let cloned = set.clone();\n        assert_eq!(cloned.len(), 1);\n        assert!(cloned.get(\"p1\").is_some());\n    }\n\n    #[test]\n    fn test_attachment_point_set_debug() {\n        let set = AttachmentPointSet::new();\n        let debug_str = format!(\"{:?}\", set);\n        assert!(debug_str.contains(\"AttachmentPointSet\"));\n    }\n\n    #[test]\n    fn test_attachment_point_set_get_mut() {\n        let mut set = AttachmentPointSet::new();\n        set.add(AttachmentPoint::new(\"mutable\", [0.0; 3], [0.0, 0.0, 1.0]));\n\n        if let Some(point) = set.get_mut(\"mutable\") {\n            point.position = [1.0, 2.0, 3.0];\n        }\n\n        let point = set.get(\"mutable\").unwrap();\n        assert_eq!(point.position, [1.0, 2.0, 3.0]);\n    }\n\n    #[test]\n    fn test_attachment_point_set_get_mut_not_found() {\n        let mut set = AttachmentPointSet::new();\n        assert!(set.get_mut(\"nonexistent\").is_none());\n    }\n\n    #[test]\n    fn test_attachment_point_set_all() {\n        let mut set = AttachmentPointSet::new();\n        set.add(AttachmentPoint::new(\"p1\", [0.0; 3], [0.0, 0.0, 1.0]));\n        set.add(AttachmentPoint::new(\"p2\", [1.0; 3], [0.0, 0.0, 1.0]));\n\n        let all = set.all();\n        assert_eq!(all.len(), 2);\n    }\n\n    #[test]\n    fn test_attachment_point_set_clear() {\n        let mut set = AttachmentPointSet::new();\n        set.add(AttachmentPoint::new(\"p1\", [0.0; 3], [0.0, 0.0, 1.0]));\n        set.add(AttachmentPoint::new(\"p2\", [1.0; 3], [0.0, 0.0, 1.0]));\n\n        assert_eq!(set.len(), 2);\n        set.clear();\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_attachment_point_set_remove() {\n        let mut set = AttachmentPointSet::new();\n        set.add(AttachmentPoint::new(\"removable\", [0.0; 3], [0.0, 0.0, 1.0]));\n\n        let removed = set.remove(\"removable\");\n        assert!(removed.is_some());\n        assert_eq!(removed.unwrap().name, \"removable\");\n        assert!(set.is_empty());\n    }\n\n    #[test]\n    fn test_attachment_point_set_remove_not_found() {\n        let mut set = AttachmentPointSet::new();\n        set.add(AttachmentPoint::new(\"keep\", [0.0; 3], [0.0, 0.0, 1.0]));\n\n        let removed = set.remove(\"nonexistent\");\n        assert!(removed.is_none());\n        assert_eq!(set.len(), 1);\n    }\n\n    #[test]\n    fn test_attachment_point_set_names() {\n        let mut set = AttachmentPointSet::new();\n        set.add(AttachmentPoint::new(\"alpha\", [0.0; 3], [0.0, 0.0, 1.0]));\n        set.add(AttachmentPoint::new(\"beta\", [1.0; 3], [0.0, 0.0, 1.0]));\n\n        let names = set.names();\n        assert_eq!(names.len(), 2);\n        assert!(names.contains(&\"alpha\"));\n        assert!(names.contains(&\"beta\"));\n    }\n\n    #[test]\n    fn test_attachment_point_set_by_type_empty() {\n        let set = AttachmentPointSet::new();\n        let result = set.by_type(AttachmentType::Standard);\n        assert!(result.is_empty());\n    }\n\n    #[test]\n    fn test_attachment_point_set_by_tag_empty() {\n        let set = AttachmentPointSet::new();\n        let result = set.by_tag(\"nonexistent\");\n        assert!(result.is_empty());\n    }\n\n    #[test]\n    fn test_attachment_point_set_by_tag_no_match() {\n        let mut set = AttachmentPointSet::new();\n        set.add(\n            AttachmentPoint::new(\"p1\", [0.0; 3], [0.0, 0.0, 1.0])\n                .with_tag(\"power\")\n        );\n\n        let result = set.by_tag(\"data\");\n        assert!(result.is_empty());\n    }\n\n    #[test]\n    fn test_find_compatible_pairs_empty_sets() {\n        let set1 = AttachmentPointSet::new();\n        let set2 = AttachmentPointSet::new();\n\n        let pairs = set1.find_compatible_pairs(&set2);\n        assert!(pairs.is_empty());\n    }\n\n    #[test]\n    fn test_find_compatible_pairs_no_matches() {\n        let mut set1 = AttachmentPointSet::new();\n        set1.add(\n            AttachmentPoint::new(\"p1\", [0.0; 3], [0.0, 0.0, 1.0])\n                .with_type(AttachmentType::Custom)\n                .with_tag(\"type_a\")\n        );\n\n        let mut set2 = AttachmentPointSet::new();\n        set2.add(\n            AttachmentPoint::new(\"p2\", [0.0; 3], [0.0, 0.0, 1.0])\n                .with_type(AttachmentType::Custom)\n                .with_tag(\"type_b\")\n        );\n\n        let pairs = set1.find_compatible_pairs(&set2);\n        assert!(pairs.is_empty());\n    }\n\n    #[test]\n    fn test_find_compatible_pairs_multiple() {\n        let mut set1 = AttachmentPointSet::new();\n        set1.add(\n            AttachmentPoint::new(\"std1\", [0.0; 3], [0.0, 0.0, 1.0])\n                .with_type(AttachmentType::Standard)\n        );\n        set1.add(\n            AttachmentPoint::new(\"std2\", [1.0; 3], [0.0, 0.0, 1.0])\n                .with_type(AttachmentType::Standard)\n        );\n\n        let mut set2 = AttachmentPointSet::new();\n        set2.add(\n            AttachmentPoint::new(\"opp1\", [0.0; 3], [0.0, 0.0, -1.0])\n                .with_type(AttachmentType::Opposite)\n        );\n\n        let pairs = set1.find_compatible_pairs(&set2);\n        // 2 standard x 1 opposite = 2 pairs\n        assert_eq!(pairs.len(), 2);\n    }\n\n    #[test]\n    fn test_load_attachment_from_record_with_attpt_name() {\n        use crate::ebase::{Record, Value};\n\n        let mut record = Record::new();\n        record.insert(\"attpt_name\".to_string(), Value::String(\"alt_name\".to_string()));\n        record.insert(\"pos_x\".to_string(), Value::Float(5.0));\n        record.insert(\"pos_y\".to_string(), Value::Float(10.0));\n        record.insert(\"pos_z\".to_string(), Value::Float(15.0));\n        record.insert(\"dir_x\".to_string(), Value::Float(0.0));\n        record.insert(\"dir_y\".to_string(), Value::Float(1.0));\n        record.insert(\"dir_z\".to_string(), Value::Float(0.0));\n\n        let point = load_attachment_from_record(&record, AttachmentType::Standard).unwrap();\n\n        assert_eq!(point.name, \"alt_name\");\n        assert_eq!(point.position, [5.0, 10.0, 15.0]);\n        assert!((point.direction[1] - 1.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_load_attachment_from_record_zero_direction() {\n        use crate::ebase::{Record, Value};\n\n        let mut record = Record::new();\n        record.insert(\"name\".to_string(), Value::String(\"zero_dir\".to_string()));\n        // No direction specified - should default to +Z\n\n        let point = load_attachment_from_record(&record, AttachmentType::Custom).unwrap();\n\n        // Direction should be normalized +Z\n        assert!((point.direction[2] - 1.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_load_attachment_from_record_with_tag_singular() {\n        use crate::ebase::{Record, Value};\n\n        let mut record = Record::new();\n        record.insert(\"name\".to_string(), Value::String(\"tagged\".to_string()));\n        record.insert(\"tag\".to_string(), Value::String(\"single_tag\".to_string()));\n\n        let point = load_attachment_from_record(&record, AttachmentType::Custom).unwrap();\n\n        assert!(point.tags.contains(&\"single_tag\".to_string()));\n    }\n\n    #[test]\n    fn test_builder_direction_normalizes() {\n        let point = AttachmentPointBuilder::new(\"normalized\")\n            .direction(3.0, 4.0, 0.0)  // Should be normalized to [0.6, 0.8, 0]\n            .build();\n\n        assert!((point.direction[0] - 0.6).abs() < 0.001);\n        assert!((point.direction[1] - 0.8).abs() < 0.001);\n        assert!((point.direction[2]).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_builder_complete() {\n        let point = AttachmentPointBuilder::new(\"complete\")\n            .position(10.0, 20.0, 30.0)\n            .direction(0.0, 0.0, 1.0)\n            .point_type(AttachmentType::Opposite)\n            .tag(\"power\")\n            .tag(\"data\")\n            .build();\n\n        assert_eq!(point.name, \"complete\");\n        assert_eq!(point.position, [10.0, 20.0, 30.0]);\n        assert_eq!(point.direction, [0.0, 0.0, 1.0]);\n        assert_eq!(point.point_type, AttachmentType::Opposite);\n        assert_eq!(point.tags.len(), 2);\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":3}},{"line":23,"address":[],"length":0,"stats":{"Line":3}},{"line":24,"address":[],"length":0,"stats":{"Line":1}},{"line":25,"address":[],"length":0,"stats":{"Line":1}},{"line":26,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":51}},{"line":50,"address":[],"length":0,"stats":{"Line":153}},{"line":53,"address":[],"length":0,"stats":{"Line":51}},{"line":54,"address":[],"length":0,"stats":{"Line":51}},{"line":59,"address":[],"length":0,"stats":{"Line":25}},{"line":60,"address":[],"length":0,"stats":{"Line":25}},{"line":61,"address":[],"length":0,"stats":{"Line":25}},{"line":65,"address":[],"length":0,"stats":{"Line":9}},{"line":66,"address":[],"length":0,"stats":{"Line":36}},{"line":67,"address":[],"length":0,"stats":{"Line":9}},{"line":71,"address":[],"length":0,"stats":{"Line":3}},{"line":72,"address":[],"length":0,"stats":{"Line":9}},{"line":73,"address":[],"length":0,"stats":{"Line":3}},{"line":80,"address":[],"length":0,"stats":{"Line":11}},{"line":82,"address":[],"length":0,"stats":{"Line":17}},{"line":83,"address":[],"length":0,"stats":{"Line":22}},{"line":88,"address":[],"length":0,"stats":{"Line":11}},{"line":89,"address":[],"length":0,"stats":{"Line":5}},{"line":93,"address":[],"length":0,"stats":{"Line":16}},{"line":94,"address":[],"length":0,"stats":{"Line":12}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":4}},{"line":103,"address":[],"length":0,"stats":{"Line":5}},{"line":104,"address":[],"length":0,"stats":{"Line":5}},{"line":105,"address":[],"length":0,"stats":{"Line":20}},{"line":108,"address":[],"length":0,"stats":{"Line":5}},{"line":109,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":9}},{"line":117,"address":[],"length":0,"stats":{"Line":9}},{"line":118,"address":[],"length":0,"stats":{"Line":36}},{"line":121,"address":[],"length":0,"stats":{"Line":17}},{"line":122,"address":[],"length":0,"stats":{"Line":16}},{"line":123,"address":[],"length":0,"stats":{"Line":16}},{"line":124,"address":[],"length":0,"stats":{"Line":8}},{"line":129,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":5}},{"line":136,"address":[],"length":0,"stats":{"Line":5}},{"line":137,"address":[],"length":0,"stats":{"Line":4}},{"line":142,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":4}},{"line":144,"address":[],"length":0,"stats":{"Line":4}},{"line":145,"address":[],"length":0,"stats":{"Line":4}},{"line":148,"address":[],"length":0,"stats":{"Line":4}},{"line":149,"address":[],"length":0,"stats":{"Line":8}},{"line":150,"address":[],"length":0,"stats":{"Line":8}},{"line":151,"address":[],"length":0,"stats":{"Line":6}},{"line":155,"address":[],"length":0,"stats":{"Line":12}},{"line":156,"address":[],"length":0,"stats":{"Line":3}},{"line":157,"address":[],"length":0,"stats":{"Line":2}},{"line":158,"address":[],"length":0,"stats":{"Line":2}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":175,"address":[],"length":0,"stats":{"Line":21}},{"line":176,"address":[],"length":0,"stats":{"Line":21}},{"line":180,"address":[],"length":0,"stats":{"Line":20}},{"line":181,"address":[],"length":0,"stats":{"Line":60}},{"line":185,"address":[],"length":0,"stats":{"Line":4}},{"line":186,"address":[],"length":0,"stats":{"Line":18}},{"line":190,"address":[],"length":0,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":6}},{"line":195,"address":[],"length":0,"stats":{"Line":1}},{"line":196,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":2}},{"line":201,"address":[],"length":0,"stats":{"Line":2}},{"line":203,"address":[],"length":0,"stats":{"Line":6}},{"line":208,"address":[],"length":0,"stats":{"Line":3}},{"line":209,"address":[],"length":0,"stats":{"Line":3}},{"line":211,"address":[],"length":0,"stats":{"Line":13}},{"line":216,"address":[],"length":0,"stats":{"Line":4}},{"line":220,"address":[],"length":0,"stats":{"Line":8}},{"line":222,"address":[],"length":0,"stats":{"Line":12}},{"line":223,"address":[],"length":0,"stats":{"Line":12}},{"line":224,"address":[],"length":0,"stats":{"Line":15}},{"line":225,"address":[],"length":0,"stats":{"Line":9}},{"line":230,"address":[],"length":0,"stats":{"Line":4}},{"line":234,"address":[],"length":0,"stats":{"Line":5}},{"line":235,"address":[],"length":0,"stats":{"Line":10}},{"line":239,"address":[],"length":0,"stats":{"Line":3}},{"line":240,"address":[],"length":0,"stats":{"Line":6}},{"line":244,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":2}},{"line":249,"address":[],"length":0,"stats":{"Line":2}},{"line":250,"address":[],"length":0,"stats":{"Line":9}},{"line":251,"address":[],"length":0,"stats":{"Line":2}},{"line":253,"address":[],"length":0,"stats":{"Line":1}},{"line":258,"address":[],"length":0,"stats":{"Line":1}},{"line":259,"address":[],"length":0,"stats":{"Line":7}},{"line":266,"address":[],"length":0,"stats":{"Line":5}},{"line":272,"address":[],"length":0,"stats":{"Line":9}},{"line":274,"address":[],"length":0,"stats":{"Line":11}},{"line":275,"address":[],"length":0,"stats":{"Line":14}},{"line":278,"address":[],"length":0,"stats":{"Line":184}},{"line":280,"address":[],"length":0,"stats":{"Line":16}},{"line":281,"address":[],"length":0,"stats":{"Line":16}},{"line":282,"address":[],"length":0,"stats":{"Line":16}},{"line":284,"address":[],"length":0,"stats":{"Line":8}},{"line":286,"address":[],"length":0,"stats":{"Line":13}},{"line":287,"address":[],"length":0,"stats":{"Line":8}},{"line":289,"address":[],"length":0,"stats":{"Line":8}},{"line":291,"address":[],"length":0,"stats":{"Line":13}},{"line":292,"address":[],"length":0,"stats":{"Line":8}},{"line":294,"address":[],"length":0,"stats":{"Line":8}},{"line":296,"address":[],"length":0,"stats":{"Line":13}},{"line":297,"address":[],"length":0,"stats":{"Line":8}},{"line":301,"address":[],"length":0,"stats":{"Line":11}},{"line":302,"address":[],"length":0,"stats":{"Line":2}},{"line":305,"address":[],"length":0,"stats":{"Line":36}},{"line":306,"address":[],"length":0,"stats":{"Line":8}},{"line":309,"address":[],"length":0,"stats":{"Line":27}},{"line":310,"address":[],"length":0,"stats":{"Line":7}},{"line":311,"address":[],"length":0,"stats":{"Line":9}},{"line":312,"address":[],"length":0,"stats":{"Line":6}},{"line":313,"address":[],"length":0,"stats":{"Line":9}},{"line":318,"address":[],"length":0,"stats":{"Line":4}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":3}},{"line":382,"address":[],"length":0,"stats":{"Line":9}},{"line":387,"address":[],"length":0,"stats":{"Line":2}},{"line":388,"address":[],"length":0,"stats":{"Line":4}},{"line":389,"address":[],"length":0,"stats":{"Line":2}},{"line":393,"address":[],"length":0,"stats":{"Line":3}},{"line":394,"address":[],"length":0,"stats":{"Line":6}},{"line":395,"address":[],"length":0,"stats":{"Line":6}},{"line":396,"address":[],"length":0,"stats":{"Line":3}},{"line":400,"address":[],"length":0,"stats":{"Line":2}},{"line":401,"address":[],"length":0,"stats":{"Line":2}},{"line":402,"address":[],"length":0,"stats":{"Line":2}},{"line":406,"address":[],"length":0,"stats":{"Line":3}},{"line":407,"address":[],"length":0,"stats":{"Line":12}},{"line":408,"address":[],"length":0,"stats":{"Line":3}},{"line":412,"address":[],"length":0,"stats":{"Line":3}},{"line":413,"address":[],"length":0,"stats":{"Line":3}}],"covered":140,"coverable":162},{"path":["/","workspace","crates","ofml-lib","src","ebase.rs"],"content":"//! EBase file format reader for OFML data files.\n//!\n//! EBase is a proprietary binary database format used by EasternGraphics\n//! in their OFML (Open Furniture Modeling Language) data files.\n//!\n//! Based on reverse engineering of ebase.dll from pCon.DataClient.\n\nuse std::collections::HashMap;\nuse std::fs::File;\nuse std::io::{self, BufReader, Read, Seek, SeekFrom};\nuse std::path::Path;\n\n/// Magic bytes for EBase files\nconst MAGIC: &[u8] = b\"EBDBF\\x00\";\nconst HEADER_SIZE: usize = 0x34; // 52 bytes\n\n/// Error types for EBase operations\n#[derive(Debug)]\npub enum EBaseError {\n    Io(io::Error),\n    InvalidMagic,\n    UnsupportedVersion(u16),\n    InvalidOffset,\n    InvalidTable(String),\n    ParseError(String),\n}\n\nimpl From<io::Error> for EBaseError {\n    fn from(err: io::Error) -> Self {\n        EBaseError::Io(err)\n    }\n}\n\nimpl std::fmt::Display for EBaseError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            EBaseError::Io(e) => write!(f, \"IO error: {}\", e),\n            EBaseError::InvalidMagic => write!(f, \"Invalid EBase magic\"),\n            EBaseError::UnsupportedVersion(v) => write!(f, \"Unsupported version: {}\", v),\n            EBaseError::InvalidOffset => write!(f, \"Invalid offset\"),\n            EBaseError::InvalidTable(name) => write!(f, \"Invalid table: {}\", name),\n            EBaseError::ParseError(msg) => write!(f, \"Parse error: {}\", msg),\n        }\n    }\n}\n\nimpl std::error::Error for EBaseError {}\n\n/// Column data types in EBase tables\n#[derive(Debug, Clone, Copy, PartialEq)]\n#[repr(u16)]\npub enum ColumnType {\n    Int8Signed = 1,\n    Int8Unsigned = 2,\n    Int16Signed = 3,\n    Int16Unsigned = 4,\n    Int32Signed = 5,\n    Int32Unsigned = 6,\n    Float32 = 7,\n    Float64 = 8,\n    StringInline = 9,\n    StringOffset = 10,\n    Blob = 11,\n}\n\nimpl ColumnType {\n    fn from_u16(value: u16) -> Option<Self> {\n        match value {\n            1 => Some(ColumnType::Int8Signed),\n            2 => Some(ColumnType::Int8Unsigned),\n            3 => Some(ColumnType::Int16Signed),\n            4 => Some(ColumnType::Int16Unsigned),\n            5 => Some(ColumnType::Int32Signed),\n            6 => Some(ColumnType::Int32Unsigned),\n            7 => Some(ColumnType::Float32),\n            8 => Some(ColumnType::Float64),\n            9 => Some(ColumnType::StringInline),\n            10 => Some(ColumnType::StringOffset),\n            11 => Some(ColumnType::Blob),\n            _ => None,\n        }\n    }\n\n    fn size(&self) -> usize {\n        match self {\n            ColumnType::Int8Signed | ColumnType::Int8Unsigned => 1,\n            ColumnType::Int16Signed | ColumnType::Int16Unsigned => 2,\n            ColumnType::Int32Signed | ColumnType::Int32Unsigned => 4,\n            ColumnType::Float32 => 4,\n            ColumnType::Float64 => 8,\n            ColumnType::StringInline => 0, // Variable\n            ColumnType::StringOffset | ColumnType::Blob => 4,\n        }\n    }\n}\n\n/// A column definition in an EBase table\n#[derive(Debug, Clone)]\npub struct Column {\n    pub name: String,\n    pub type_id: u16,\n    pub offset: u16,\n    pub size: usize,\n    pub flags: u16,\n}\n\nimpl Column {\n    pub fn column_type(&self) -> Option<ColumnType> {\n        ColumnType::from_u16(self.type_id)\n    }\n}\n\n/// An EBase table with columns and record info\n#[derive(Debug, Clone)]\npub struct Table {\n    pub name: String,\n    pub columns: Vec<Column>,\n    pub record_count: u32,\n    pub record_size: u16,\n    pub data_offset: u32,\n}\n\n/// A value from an EBase record\n#[derive(Debug, Clone)]\npub enum Value {\n    Int(i64),\n    UInt(u64),\n    Float(f64),\n    String(String),\n    Blob(u32),\n    Null,\n}\n\nimpl Value {\n    pub fn as_str(&self) -> Option<&str> {\n        match self {\n            Value::String(s) => Some(s),\n            _ => None,\n        }\n    }\n\n    pub fn as_i64(&self) -> Option<i64> {\n        match self {\n            Value::Int(i) => Some(*i),\n            Value::UInt(u) => Some(*u as i64),\n            _ => None,\n        }\n    }\n\n    pub fn as_f64(&self) -> Option<f64> {\n        match self {\n            Value::Float(f) => Some(*f),\n            Value::Int(i) => Some(*i as f64),\n            Value::UInt(u) => Some(*u as f64),\n            _ => None,\n        }\n    }\n}\n\n/// A record (row) from an EBase table\npub type Record = HashMap<String, Value>;\n\n/// EBase database reader\npub struct EBaseReader {\n    reader: BufReader<File>,\n    pub major_version: u16,\n    pub minor_version: u16,\n    pub tables: HashMap<String, Table>,\n    string_pool_offset: u32,\n    string_pool_size: u32,\n    string_cache: HashMap<u32, String>,\n}\n\nimpl EBaseReader {\n    /// Open an EBase database file\n    pub fn open<P: AsRef<Path>>(path: P) -> Result<Self, EBaseError> {\n        let file = File::open(path)?;\n        let mut reader = BufReader::new(file);\n\n        // Read and validate magic\n        let mut magic = [0u8; 6];\n        reader.read_exact(&mut magic)?;\n        if magic != MAGIC {\n            return Err(EBaseError::InvalidMagic);\n        }\n\n        // Read header\n        let mut header = [0u8; HEADER_SIZE - 6];\n        reader.read_exact(&mut header)?;\n\n        // Parse header (all big-endian)\n        let major_version = u16::from_be_bytes([header[2], header[3]]);\n        let minor_version = u16::from_be_bytes([header[4], header[5]]);\n\n        if major_version != 1 {\n            return Err(EBaseError::UnsupportedVersion(major_version));\n        }\n\n        let string_pool_offset =\n            u32::from_be_bytes([header[14], header[15], header[16], header[17]]);\n        let string_data_size = u32::from_be_bytes([header[34], header[35], header[36], header[37]]);\n        let num_tables = u32::from_be_bytes([header[38], header[39], header[40], header[41]]);\n\n        let mut db = EBaseReader {\n            reader,\n            major_version,\n            minor_version,\n            tables: HashMap::new(),\n            string_pool_offset,\n            string_pool_size: string_data_size,\n            string_cache: HashMap::new(),\n        };\n\n        // Parse table directory (starts at 0x38)\n        db.parse_table_directory(num_tables, 0x38)?;\n\n        Ok(db)\n    }\n\n    /// Read a length-prefixed string from the string pool\n    fn read_string_at(&mut self, offset: u32) -> Result<String, EBaseError> {\n        if offset == 0 {\n            return Ok(String::new());\n        }\n\n        // Check cache\n        if let Some(s) = self.string_cache.get(&offset) {\n            return Ok(s.clone());\n        }\n\n        // Validate offset is within string pool\n        if self.string_pool_offset > 0 {\n            let pool_end = self.string_pool_offset + self.string_pool_size;\n            if offset < self.string_pool_offset || offset >= pool_end {\n                return Ok(String::new());\n            }\n        }\n\n        // Save position, read string, restore position\n        let pos = self.reader.stream_position()?;\n        self.reader.seek(SeekFrom::Start(offset as u64))?;\n\n        // Read length prefix (2 bytes BE)\n        let mut len_bytes = [0u8; 2];\n        if self.reader.read_exact(&mut len_bytes).is_err() {\n            self.reader.seek(SeekFrom::Start(pos))?;\n            return Ok(String::new());\n        }\n        let str_len = u16::from_be_bytes(len_bytes) as usize;\n\n        if str_len == 0 || str_len > 65535 || str_len > self.string_pool_size as usize {\n            self.reader.seek(SeekFrom::Start(pos))?;\n            return Ok(String::new());\n        }\n\n        // Read string data\n        let mut data = vec![0u8; str_len];\n        if self.reader.read_exact(&mut data).is_err() {\n            self.reader.seek(SeekFrom::Start(pos))?;\n            return Ok(String::new());\n        }\n\n        self.reader.seek(SeekFrom::Start(pos))?;\n\n        // Decode as UTF-8 or Latin-1\n        let result = String::from_utf8(data.clone())\n            .unwrap_or_else(|_| data.iter().map(|&b| b as char).collect())\n            .trim_end_matches('\\0')\n            .to_string();\n\n        self.string_cache.insert(offset, result.clone());\n        Ok(result)\n    }\n\n    /// Parse the table directory\n    fn parse_table_directory(\n        &mut self,\n        num_tables: u32,\n        dir_offset: u32,\n    ) -> Result<(), EBaseError> {\n        if num_tables == 0 || dir_offset == 0 {\n            return Ok(());\n        }\n\n        for i in 0..num_tables {\n            self.reader\n                .seek(SeekFrom::Start((dir_offset + i * 8) as u64))?;\n\n            let mut entry = [0u8; 8];\n            self.reader.read_exact(&mut entry)?;\n\n            let name_offset = u32::from_be_bytes([entry[0], entry[1], entry[2], entry[3]]);\n            let table_def_offset = u32::from_be_bytes([entry[4], entry[5], entry[6], entry[7]]);\n\n            let table_name = self.read_string_at(name_offset)?;\n            if !table_name.is_empty() && table_def_offset > 0 {\n                if let Ok(table) = self.parse_table_definition(&table_name, table_def_offset) {\n                    self.tables.insert(table_name, table);\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Parse a table definition\n    fn parse_table_definition(&mut self, name: &str, offset: u32) -> Result<Table, EBaseError> {\n        self.reader.seek(SeekFrom::Start(offset as u64))?;\n\n        let mut header = [0u8; 36];\n        self.reader.read_exact(&mut header)?;\n\n        let record_count = u32::from_be_bytes([header[4], header[5], header[6], header[7]]);\n        let column_count = u16::from_be_bytes([header[8], header[9]]);\n        let record_size = u16::from_be_bytes([header[10], header[11]]);\n        let column_def_offset =\n            u32::from_be_bytes([header[16], header[17], header[18], header[19]]);\n        let data_start = u32::from_be_bytes([header[20], header[21], header[22], header[23]]);\n\n        // Parse columns\n        let mut columns = Vec::new();\n        if column_count > 0 && column_def_offset > 0 {\n            self.reader\n                .seek(SeekFrom::Start(column_def_offset as u64))?;\n\n            for _ in 0..column_count {\n                let mut col_data = [0u8; 32];\n                self.reader.read_exact(&mut col_data)?;\n\n                let col_name_offset =\n                    u32::from_be_bytes([col_data[0], col_data[1], col_data[2], col_data[3]]);\n                let col_type = u16::from_be_bytes([col_data[4], col_data[5]]);\n                let col_flags = u16::from_be_bytes([col_data[6], col_data[7]]);\n                let col_offset = u16::from_be_bytes([col_data[8], col_data[9]]);\n\n                let col_name = self.read_string_at(col_name_offset)?;\n                let col_size = ColumnType::from_u16(col_type)\n                    .map(|t| t.size())\n                    .unwrap_or(4);\n\n                columns.push(Column {\n                    name: col_name,\n                    type_id: col_type,\n                    offset: col_offset,\n                    size: col_size,\n                    flags: col_flags,\n                });\n            }\n        }\n\n        Ok(Table {\n            name: name.to_string(),\n            columns,\n            record_count,\n            record_size,\n            data_offset: data_start,\n        })\n    }\n\n    /// Read records from a table\n    pub fn read_records(\n        &mut self,\n        table_name: &str,\n        limit: Option<usize>,\n    ) -> Result<Vec<Record>, EBaseError> {\n        let table = self\n            .tables\n            .get(table_name)\n            .ok_or_else(|| EBaseError::InvalidTable(table_name.to_string()))?\n            .clone();\n\n        if table.record_count == 0 || table.data_offset == 0 {\n            return Ok(Vec::new());\n        }\n\n        let count = limit.map_or(table.record_count as usize, |l| {\n            l.min(table.record_count as usize)\n        });\n        let mut records = Vec::with_capacity(count);\n\n        for i in 0..count {\n            let record_offset = table.data_offset as u64 + (i as u64 * table.record_size as u64);\n            self.reader.seek(SeekFrom::Start(record_offset))?;\n\n            let mut record_data = vec![0u8; table.record_size as usize];\n            self.reader.read_exact(&mut record_data)?;\n\n            let mut record = Record::new();\n            for col in &table.columns {\n                let value = self.parse_column_value(&record_data, col)?;\n                record.insert(col.name.clone(), value);\n            }\n            records.push(record);\n        }\n\n        Ok(records)\n    }\n\n    /// Parse a column value from record data\n    fn parse_column_value(\n        &mut self,\n        record_data: &[u8],\n        col: &Column,\n    ) -> Result<Value, EBaseError> {\n        let offset = col.offset as usize;\n        if offset >= record_data.len() {\n            return Ok(Value::Null);\n        }\n\n        match col.type_id {\n            1 => {\n                // INT8_SIGNED\n                Ok(Value::Int(record_data[offset] as i8 as i64))\n            }\n            2 => {\n                // INT8_UNSIGNED\n                Ok(Value::UInt(record_data[offset] as u64))\n            }\n            3 => {\n                // INT16_SIGNED\n                if offset + 2 > record_data.len() {\n                    return Ok(Value::Null);\n                }\n                let val = i16::from_be_bytes([record_data[offset], record_data[offset + 1]]);\n                Ok(Value::Int(val as i64))\n            }\n            4 => {\n                // INT16_UNSIGNED\n                if offset + 2 > record_data.len() {\n                    return Ok(Value::Null);\n                }\n                let val = u16::from_be_bytes([record_data[offset], record_data[offset + 1]]);\n                Ok(Value::UInt(val as u64))\n            }\n            5 => {\n                // INT32_SIGNED\n                if offset + 4 > record_data.len() {\n                    return Ok(Value::Null);\n                }\n                let val = i32::from_be_bytes([\n                    record_data[offset],\n                    record_data[offset + 1],\n                    record_data[offset + 2],\n                    record_data[offset + 3],\n                ]);\n                Ok(Value::Int(val as i64))\n            }\n            6 => {\n                // INT32_UNSIGNED\n                if offset + 4 > record_data.len() {\n                    return Ok(Value::Null);\n                }\n                let val = u32::from_be_bytes([\n                    record_data[offset],\n                    record_data[offset + 1],\n                    record_data[offset + 2],\n                    record_data[offset + 3],\n                ]);\n                Ok(Value::UInt(val as u64))\n            }\n            7 => {\n                // FLOAT32\n                if offset + 4 > record_data.len() {\n                    return Ok(Value::Null);\n                }\n                let val = f32::from_be_bytes([\n                    record_data[offset],\n                    record_data[offset + 1],\n                    record_data[offset + 2],\n                    record_data[offset + 3],\n                ]);\n                Ok(Value::Float(val as f64))\n            }\n            8 => {\n                // FLOAT64\n                if offset + 8 > record_data.len() {\n                    return Ok(Value::Null);\n                }\n                let val = f64::from_be_bytes([\n                    record_data[offset],\n                    record_data[offset + 1],\n                    record_data[offset + 2],\n                    record_data[offset + 3],\n                    record_data[offset + 4],\n                    record_data[offset + 5],\n                    record_data[offset + 6],\n                    record_data[offset + 7],\n                ]);\n                Ok(Value::Float(val))\n            }\n            9 => {\n                // STRING_INLINE\n                let end = record_data[offset..]\n                    .iter()\n                    .position(|&b| b == 0)\n                    .map(|p| offset + p)\n                    .unwrap_or(record_data.len());\n                let data = &record_data[offset..end];\n                let s = String::from_utf8(data.to_vec())\n                    .unwrap_or_else(|_| data.iter().map(|&b| b as char).collect());\n                Ok(Value::String(s))\n            }\n            10 => {\n                // STRING_OFFSET\n                if offset + 4 > record_data.len() {\n                    return Ok(Value::Null);\n                }\n                let str_offset = u32::from_be_bytes([\n                    record_data[offset],\n                    record_data[offset + 1],\n                    record_data[offset + 2],\n                    record_data[offset + 3],\n                ]);\n                if str_offset == 0 {\n                    Ok(Value::String(String::new()))\n                } else {\n                    Ok(Value::String(self.read_string_at(str_offset)?))\n                }\n            }\n            11 => {\n                // BLOB\n                if offset + 4 > record_data.len() {\n                    return Ok(Value::Null);\n                }\n                let val = u32::from_be_bytes([\n                    record_data[offset],\n                    record_data[offset + 1],\n                    record_data[offset + 2],\n                    record_data[offset + 3],\n                ]);\n                Ok(Value::Blob(val))\n            }\n            _ => Ok(Value::Null),\n        }\n    }\n\n    /// Get table names\n    pub fn table_names(&self) -> Vec<&str> {\n        self.tables.keys().map(|s| s.as_str()).collect()\n    }\n\n    /// Get a table definition\n    pub fn get_table(&self, name: &str) -> Option<&Table> {\n        self.tables.get(name)\n    }\n}\n\n/// ODB3D record - 3D object definition\n#[derive(Debug, Clone)]\npub struct Odb3dRecord {\n    pub odb_name: String,\n    pub obj_name: String,\n    pub visible: String,\n    pub x_offs: String,\n    pub y_offs: String,\n    pub z_offs: String,\n    pub x_rot: String,\n    pub y_rot: String,\n    pub z_rot: String,\n    pub ctor: String,\n    pub mat: String,\n    pub attrib: String,\n    pub link: String,\n}\n\nimpl Odb3dRecord {\n    /// Parse from a record HashMap\n    pub fn from_record(record: &Record) -> Option<Self> {\n        Some(Odb3dRecord {\n            odb_name: record.get(\"odb_name\")?.as_str()?.to_string(),\n            obj_name: record.get(\"obj_name\")?.as_str().unwrap_or(\"\").to_string(),\n            visible: record.get(\"visible\")?.as_str().unwrap_or(\"\").to_string(),\n            x_offs: record.get(\"x_offs\")?.as_str().unwrap_or(\"0\").to_string(),\n            y_offs: record.get(\"y_offs\")?.as_str().unwrap_or(\"0\").to_string(),\n            z_offs: record.get(\"z_offs\")?.as_str().unwrap_or(\"0\").to_string(),\n            x_rot: record.get(\"x_rot\")?.as_str().unwrap_or(\"0\").to_string(),\n            y_rot: record.get(\"y_rot\")?.as_str().unwrap_or(\"0\").to_string(),\n            z_rot: record.get(\"z_rot\")?.as_str().unwrap_or(\"0\").to_string(),\n            ctor: record.get(\"ctor\")?.as_str().unwrap_or(\"\").to_string(),\n            mat: record.get(\"mat\")?.as_str().unwrap_or(\"\").to_string(),\n            attrib: record.get(\"attrib\")?.as_str().unwrap_or(\"\").to_string(),\n            link: record.get(\"link\")?.as_str().unwrap_or(\"\").to_string(),\n        })\n    }\n\n    /// Parse the constructor to extract geometry file name\n    /// Format: \"filename\" scale_x scale_y scale_z imp\n    /// or: \"::package::path::filename\" scale_x scale_y scale_z imp\n    pub fn parse_ctor(&self) -> Option<(String, [f32; 3])> {\n        let ctor = self.ctor.trim();\n        if ctor.is_empty() || ctor == \"top\" {\n            return None;\n        }\n\n        // Extract quoted filename\n        if !ctor.starts_with('\"') {\n            return None;\n        }\n\n        let end_quote = ctor[1..].find('\"')?;\n        let mut filename = &ctor[1..=end_quote];\n\n        // Strip package path prefix (e.g., \"::gsx::ac::filename\" -> \"filename\")\n        if filename.starts_with(\"::\") {\n            if let Some(pos) = filename.rfind(\"::\") {\n                filename = &filename[pos + 2..];\n            }\n        }\n\n        // Parse scale factors after filename\n        let rest = &ctor[end_quote + 2..];\n        let parts: Vec<&str> = rest.split_whitespace().collect();\n\n        let scale = if parts.len() >= 3 {\n            [\n                parts[0].parse().unwrap_or(1.0),\n                parts[1].parse().unwrap_or(1.0),\n                parts[2].parse().unwrap_or(1.0),\n            ]\n        } else {\n            [1.0, 1.0, 1.0]\n        };\n\n        Some((filename.to_string(), scale))\n    }\n\n    /// Parse offset as float (simple numeric values only)\n    /// For expressions with variables, use `evaluate_offset()` instead.\n    pub fn parse_offset(&self) -> [f32; 3] {\n        [\n            self.x_offs.parse().unwrap_or(0.0),\n            self.y_offs.parse().unwrap_or(0.0),\n            self.z_offs.parse().unwrap_or(0.0),\n        ]\n    }\n\n    /// Parse rotation as float (simple numeric values only)\n    /// For expressions with variables, use `evaluate_rotation()` instead.\n    pub fn parse_rotation(&self) -> [f32; 3] {\n        [\n            self.x_rot.parse().unwrap_or(0.0),\n            self.y_rot.parse().unwrap_or(0.0),\n            self.z_rot.parse().unwrap_or(0.0),\n        ]\n    }\n\n    /// Evaluate offset expressions with variable substitution.\n    ///\n    /// Offset fields can contain PostScript expressions like:\n    /// - Simple numbers: `0.5`, `-0.3`\n    /// - Variable references: `${M__BREITE:-1000} 1000 /`\n    /// - Function calls: `f_offset`\n    ///\n    /// Returns the evaluated [x, y, z] offset in meters.\n    pub fn evaluate_offset(&self, props: &std::collections::HashMap<String, f64>) -> [f32; 3] {\n        use crate::ebase_expr::EbaseEvaluator;\n\n        let eval_field = |field: &str| -> f32 {\n            let trimmed = field.trim();\n            if trimmed.is_empty() {\n                return 0.0;\n            }\n\n            // Try simple float parse first (most common case)\n            if let Ok(val) = trimmed.parse::<f32>() {\n                return val;\n            }\n\n            // Try expression evaluation\n            let mut evaluator = EbaseEvaluator::new();\n            match evaluator.evaluate_to_number(trimmed, props) {\n                Ok(val) => val as f32,\n                Err(_) => 0.0, // Default to 0 on error\n            }\n        };\n\n        [\n            eval_field(&self.x_offs),\n            eval_field(&self.y_offs),\n            eval_field(&self.z_offs),\n        ]\n    }\n\n    /// Evaluate rotation expressions with variable substitution.\n    ///\n    /// Rotation fields can contain PostScript expressions.\n    /// Rotation is applied in order: X ‚Üí Y ‚Üí Z (each affects subsequent axes).\n    /// Angles are in degrees, counter-clockwise positive.\n    ///\n    /// Returns the evaluated [x, y, z] rotation in degrees.\n    pub fn evaluate_rotation(&self, props: &std::collections::HashMap<String, f64>) -> [f32; 3] {\n        use crate::ebase_expr::EbaseEvaluator;\n\n        let eval_field = |field: &str| -> f32 {\n            let trimmed = field.trim();\n            if trimmed.is_empty() {\n                return 0.0;\n            }\n\n            // Try simple float parse first\n            if let Ok(val) = trimmed.parse::<f32>() {\n                return val;\n            }\n\n            // Try expression evaluation\n            let mut evaluator = EbaseEvaluator::new();\n            match evaluator.evaluate_to_number(trimmed, props) {\n                Ok(val) => val as f32,\n                Err(_) => 0.0,\n            }\n        };\n\n        [\n            eval_field(&self.x_rot),\n            eval_field(&self.y_rot),\n            eval_field(&self.z_rot),\n        ]\n    }\n}\n\n/// Read ODB3D records from an ebase file\npub fn read_odb3d(path: &Path) -> Result<Vec<Odb3dRecord>, EBaseError> {\n    let mut reader = EBaseReader::open(path)?;\n\n    if !reader.tables.contains_key(\"odb3d\") {\n        return Ok(Vec::new());\n    }\n\n    let records = reader.read_records(\"odb3d\", None)?;\n    let mut result = Vec::new();\n\n    for record in &records {\n        if let Some(odb_record) = Odb3dRecord::from_record(record) {\n            // Skip empty records\n            if !odb_record.odb_name.is_empty() || !odb_record.obj_name.is_empty() {\n                result.push(odb_record);\n            }\n        }\n    }\n\n    Ok(result)\n}\n\n/// ODB2D record - 2D object definition for floor plan views\n#[derive(Debug, Clone)]\npub struct Odb2dRecord {\n    /// Object database name reference\n    pub odb_name: String,\n    /// Object instance name\n    pub obj_name: String,\n    /// Visibility expression\n    pub visible: String,\n    /// 2D primitive type (lines, polygon, rect, circle, arc, text, etc.)\n    pub prim_type: String,\n    /// X coordinates (comma-separated for multi-point primitives)\n    pub x_coords: String,\n    /// Y coordinates (comma-separated for multi-point primitives)\n    pub y_coords: String,\n    /// Width (for rect, ellipse)\n    pub width: String,\n    /// Height (for rect, ellipse)\n    pub height: String,\n    /// Radius (for circle, arc)\n    pub radius: String,\n    /// Start angle for arcs (degrees)\n    pub start_angle: String,\n    /// End/sweep angle for arcs (degrees)\n    pub end_angle: String,\n    /// Text content (for text primitives)\n    pub text: String,\n    /// Font size (for text primitives)\n    pub font_size: String,\n    /// Layer name for visibility control\n    pub layer: String,\n    /// Line color expression\n    pub color: String,\n    /// Fill color expression\n    pub fill_color: String,\n    /// Line width\n    pub line_width: String,\n    /// Line style (solid, dashed, dotted)\n    pub line_style: String,\n    /// Custom attributes\n    pub attrib: String,\n}\n\nimpl Odb2dRecord {\n    /// Parse from a record HashMap\n    pub fn from_record(record: &Record) -> Option<Self> {\n        Some(Odb2dRecord {\n            odb_name: record\n                .get(\"odb_name\")\n                .and_then(|v| v.as_str())\n                .unwrap_or(\"\")\n                .to_string(),\n            obj_name: record\n                .get(\"obj_name\")\n                .and_then(|v| v.as_str())\n                .unwrap_or(\"\")\n                .to_string(),\n            visible: record\n                .get(\"visible\")\n                .and_then(|v| v.as_str())\n                .unwrap_or(\"\")\n                .to_string(),\n            prim_type: record\n                .get(\"prim_type\")\n                .and_then(|v| v.as_str())\n                .or_else(|| record.get(\"type\").and_then(|v| v.as_str()))\n                .unwrap_or(\"\")\n                .to_string(),\n            x_coords: record\n                .get(\"x_coords\")\n                .and_then(|v| v.as_str())\n                .or_else(|| record.get(\"x\").and_then(|v| v.as_str()))\n                .or_else(|| record.get(\"x1\").and_then(|v| v.as_str()))\n                .unwrap_or(\"\")\n                .to_string(),\n            y_coords: record\n                .get(\"y_coords\")\n                .and_then(|v| v.as_str())\n                .or_else(|| record.get(\"y\").and_then(|v| v.as_str()))\n                .or_else(|| record.get(\"y1\").and_then(|v| v.as_str()))\n                .unwrap_or(\"\")\n                .to_string(),\n            width: record\n                .get(\"width\")\n                .and_then(|v| v.as_str())\n                .or_else(|| record.get(\"w\").and_then(|v| v.as_str()))\n                .unwrap_or(\"\")\n                .to_string(),\n            height: record\n                .get(\"height\")\n                .and_then(|v| v.as_str())\n                .or_else(|| record.get(\"h\").and_then(|v| v.as_str()))\n                .unwrap_or(\"\")\n                .to_string(),\n            radius: record\n                .get(\"radius\")\n                .and_then(|v| v.as_str())\n                .or_else(|| record.get(\"r\").and_then(|v| v.as_str()))\n                .unwrap_or(\"\")\n                .to_string(),\n            start_angle: record\n                .get(\"start_angle\")\n                .and_then(|v| v.as_str())\n                .or_else(|| record.get(\"angle1\").and_then(|v| v.as_str()))\n                .unwrap_or(\"\")\n                .to_string(),\n            end_angle: record\n                .get(\"end_angle\")\n                .and_then(|v| v.as_str())\n                .or_else(|| record.get(\"angle2\").and_then(|v| v.as_str()))\n                .unwrap_or(\"\")\n                .to_string(),\n            text: record\n                .get(\"text\")\n                .and_then(|v| v.as_str())\n                .or_else(|| record.get(\"label\").and_then(|v| v.as_str()))\n                .unwrap_or(\"\")\n                .to_string(),\n            font_size: record\n                .get(\"font_size\")\n                .and_then(|v| v.as_str())\n                .or_else(|| record.get(\"fsize\").and_then(|v| v.as_str()))\n                .unwrap_or(\"10\")\n                .to_string(),\n            layer: record\n                .get(\"layer\")\n                .and_then(|v| v.as_str())\n                .unwrap_or(\"default\")\n                .to_string(),\n            color: record\n                .get(\"color\")\n                .and_then(|v| v.as_str())\n                .unwrap_or(\"\")\n                .to_string(),\n            fill_color: record\n                .get(\"fill_color\")\n                .and_then(|v| v.as_str())\n                .or_else(|| record.get(\"fill\").and_then(|v| v.as_str()))\n                .unwrap_or(\"\")\n                .to_string(),\n            line_width: record\n                .get(\"line_width\")\n                .and_then(|v| v.as_str())\n                .or_else(|| record.get(\"lwidth\").and_then(|v| v.as_str()))\n                .unwrap_or(\"1\")\n                .to_string(),\n            line_style: record\n                .get(\"line_style\")\n                .and_then(|v| v.as_str())\n                .or_else(|| record.get(\"lstyle\").and_then(|v| v.as_str()))\n                .unwrap_or(\"solid\")\n                .to_string(),\n            attrib: record\n                .get(\"attrib\")\n                .and_then(|v| v.as_str())\n                .unwrap_or(\"\")\n                .to_string(),\n        })\n    }\n\n    /// Parse X coordinates as a vector of floats\n    pub fn parse_x_coords(&self) -> Vec<f64> {\n        self.parse_coords(&self.x_coords)\n    }\n\n    /// Parse Y coordinates as a vector of floats\n    pub fn parse_y_coords(&self) -> Vec<f64> {\n        self.parse_coords(&self.y_coords)\n    }\n\n    fn parse_coords(&self, s: &str) -> Vec<f64> {\n        s.split([',', ' '])\n            .filter(|s| !s.is_empty())\n            .filter_map(|s| s.trim().parse().ok())\n            .collect()\n    }\n\n    /// Parse width as float\n    pub fn parse_width(&self) -> f64 {\n        self.width.trim().parse().unwrap_or(0.0)\n    }\n\n    /// Parse height as float\n    pub fn parse_height(&self) -> f64 {\n        self.height.trim().parse().unwrap_or(0.0)\n    }\n\n    /// Parse radius as float\n    pub fn parse_radius(&self) -> f64 {\n        self.radius.trim().parse().unwrap_or(0.0)\n    }\n\n    /// Parse start angle as float (degrees)\n    pub fn parse_start_angle(&self) -> f64 {\n        self.start_angle.trim().parse().unwrap_or(0.0)\n    }\n\n    /// Parse end angle as float (degrees)\n    pub fn parse_end_angle(&self) -> f64 {\n        self.end_angle.trim().parse().unwrap_or(360.0)\n    }\n\n    /// Parse font size as float\n    pub fn parse_font_size(&self) -> f64 {\n        self.font_size.trim().parse().unwrap_or(10.0)\n    }\n\n    /// Parse line width as float\n    pub fn parse_line_width(&self) -> f32 {\n        self.line_width.trim().parse().unwrap_or(1.0)\n    }\n\n    /// Parse color string \"r g b\" or \"r g b a\" to [f32; 4]\n    pub fn parse_color(&self) -> [f32; 4] {\n        Self::parse_color_string(&self.color)\n    }\n\n    /// Parse fill color string\n    pub fn parse_fill_color(&self) -> Option<[f32; 4]> {\n        if self.fill_color.is_empty() {\n            None\n        } else {\n            Some(Self::parse_color_string(&self.fill_color))\n        }\n    }\n\n    fn parse_color_string(s: &str) -> [f32; 4] {\n        let parts: Vec<f32> = s\n            .split_whitespace()\n            .filter_map(|p| p.parse().ok())\n            .collect();\n        match parts.len() {\n            0 => [0.0, 0.0, 0.0, 1.0],\n            1 => [parts[0], parts[0], parts[0], 1.0],\n            2 => [parts[0], parts[1], 0.0, 1.0],\n            3 => [parts[0], parts[1], parts[2], 1.0],\n            _ => [parts[0], parts[1], parts[2], parts[3]],\n        }\n    }\n\n    /// Get line style enum value\n    pub fn get_line_style(&self) -> &str {\n        match self.line_style.to_lowercase().as_str() {\n            \"dashed\" | \"dash\" => \"dashed\",\n            \"dotted\" | \"dot\" => \"dotted\",\n            \"dashdot\" | \"dash-dot\" => \"dashdot\",\n            _ => \"solid\",\n        }\n    }\n}\n\n/// Read ODB2D records from an ebase file\npub fn read_odb2d(path: &Path) -> Result<Vec<Odb2dRecord>, EBaseError> {\n    let mut reader = EBaseReader::open(path)?;\n\n    if !reader.tables.contains_key(\"odb2d\") {\n        return Ok(Vec::new());\n    }\n\n    let records = reader.read_records(\"odb2d\", None)?;\n    let mut result = Vec::new();\n\n    for record in &records {\n        if let Some(odb_record) = Odb2dRecord::from_record(record) {\n            // Skip completely empty records\n            if !odb_record.odb_name.is_empty() || !odb_record.prim_type.is_empty() {\n                result.push(odb_record);\n            }\n        }\n    }\n\n    Ok(result)\n}\n\n/// Function definition from funcs table\n#[derive(Debug, Clone)]\npub struct FuncDef {\n    pub name: String,\n    pub body: String,\n}\n\n/// OCD (Object Control Data) record for product configuration\n#[derive(Debug, Clone)]\npub struct OcdRecord {\n    /// Record fields as key-value pairs\n    pub fields: HashMap<String, String>,\n}\n\nimpl OcdRecord {\n    /// Create from a generic record\n    pub fn from_record(record: &Record) -> Self {\n        let fields = record\n            .iter()\n            .map(|(k, v)| (k.clone(), v.as_str().unwrap_or(\"\").to_string()))\n            .collect();\n        Self { fields }\n    }\n\n    /// Get a field value\n    pub fn get(&self, key: &str) -> Option<&str> {\n        self.fields.get(key).map(|s| s.as_str())\n    }\n}\n\n/// Read OCD (Object Control Data) records from an ebase file\n///\n/// OCD files contain configuration data for products including:\n/// - @Category entries for product categorization\n/// - @MatPackage entries for material packages\n/// - @ShowAddAttPts entries for attachment point visibility\n/// - Other control parameters\npub fn read_ocd(path: &Path, table_name: &str) -> Result<Vec<OcdRecord>, EBaseError> {\n    let mut reader = EBaseReader::open(path)?;\n\n    // Try common OCD table names\n    let table_names = if table_name.is_empty() {\n        vec![\"ocd\", \"control\", \"data\"]\n    } else {\n        vec![table_name]\n    };\n\n    for name in table_names {\n        if reader.tables.contains_key(name) {\n            let records = reader.read_records(name, None)?;\n            return Ok(records\n                .into_iter()\n                .map(|r| OcdRecord::from_record(&r))\n                .collect());\n        }\n    }\n\n    // No OCD table found, return empty\n    Ok(Vec::new())\n}\n\n/// Read function definitions from an ebase file\npub fn read_funcs(path: &Path) -> Result<Vec<FuncDef>, EBaseError> {\n    let mut reader = EBaseReader::open(path)?;\n\n    if !reader.tables.contains_key(\"funcs\") {\n        return Ok(Vec::new());\n    }\n\n    let records = reader.read_records(\"funcs\", None)?;\n    let mut result = Vec::new();\n\n    for record in &records {\n        let name = record\n            .get(\"name\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"\")\n            .to_string();\n        let body = record\n            .get(\"body\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"\")\n            .to_string();\n\n        if !name.is_empty() {\n            result.push(FuncDef { name, body });\n        }\n    }\n\n    Ok(result)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_column_type_size() {\n        assert_eq!(ColumnType::Int8Signed.size(), 1);\n        assert_eq!(ColumnType::Int16Signed.size(), 2);\n        assert_eq!(ColumnType::Int32Signed.size(), 4);\n        assert_eq!(ColumnType::Float64.size(), 8);\n        assert_eq!(ColumnType::StringOffset.size(), 4);\n    }\n\n    #[test]\n    fn test_parse_ctor() {\n        let record = Odb3dRecord {\n            odb_name: \"test\".to_string(),\n            obj_name: \"o1\".to_string(),\n            visible: \"\".to_string(),\n            x_offs: \"0\".to_string(),\n            y_offs: \"0.5\".to_string(),\n            z_offs: \"0\".to_string(),\n            x_rot: \"0\".to_string(),\n            y_rot: \"0\".to_string(),\n            z_rot: \"0\".to_string(),\n            ctor: \"\\\"sbucosmod3_t31_openunit40_glass\\\" 1 1 1 imp\".to_string(),\n            mat: \"\".to_string(),\n            attrib: \"\".to_string(),\n            link: \"\".to_string(),\n        };\n\n        let (filename, scale) = record.parse_ctor().unwrap();\n        assert_eq!(filename, \"sbucosmod3_t31_openunit40_glass\");\n        assert_eq!(scale, [1.0, 1.0, 1.0]);\n    }\n\n    #[test]\n    fn test_odb2d_record_coords() {\n        let mut record_map = Record::new();\n        record_map.insert(\"odb_name\".to_string(), Value::String(\"test_2d\".to_string()));\n        record_map.insert(\n            \"prim_type\".to_string(),\n            Value::String(\"polygon\".to_string()),\n        );\n        record_map.insert(\n            \"x_coords\".to_string(),\n            Value::String(\"0,100,100,0\".to_string()),\n        );\n        record_map.insert(\n            \"y_coords\".to_string(),\n            Value::String(\"0,0,50,50\".to_string()),\n        );\n        record_map.insert(\n            \"color\".to_string(),\n            Value::String(\"0.5 0.5 0.5\".to_string()),\n        );\n\n        let record = Odb2dRecord::from_record(&record_map).unwrap();\n        assert_eq!(record.odb_name, \"test_2d\");\n        assert_eq!(record.prim_type, \"polygon\");\n\n        let x = record.parse_x_coords();\n        assert_eq!(x, vec![0.0, 100.0, 100.0, 0.0]);\n\n        let y = record.parse_y_coords();\n        assert_eq!(y, vec![0.0, 0.0, 50.0, 50.0]);\n\n        let color = record.parse_color();\n        assert!((color[0] - 0.5).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_odb2d_record_rect() {\n        let mut record_map = Record::new();\n        record_map.insert(\"prim_type\".to_string(), Value::String(\"rect\".to_string()));\n        record_map.insert(\"x\".to_string(), Value::String(\"10\".to_string()));\n        record_map.insert(\"y\".to_string(), Value::String(\"20\".to_string()));\n        record_map.insert(\"width\".to_string(), Value::String(\"100\".to_string()));\n        record_map.insert(\"height\".to_string(), Value::String(\"50\".to_string()));\n\n        let record = Odb2dRecord::from_record(&record_map).unwrap();\n        assert_eq!(record.prim_type, \"rect\");\n        assert_eq!(record.parse_x_coords(), vec![10.0]);\n        assert_eq!(record.parse_y_coords(), vec![20.0]);\n        assert_eq!(record.parse_width(), 100.0);\n        assert_eq!(record.parse_height(), 50.0);\n    }\n\n    #[test]\n    fn test_odb2d_record_circle() {\n        let mut record_map = Record::new();\n        record_map.insert(\"prim_type\".to_string(), Value::String(\"circle\".to_string()));\n        record_map.insert(\"x\".to_string(), Value::String(\"50\".to_string()));\n        record_map.insert(\"y\".to_string(), Value::String(\"50\".to_string()));\n        record_map.insert(\"r\".to_string(), Value::String(\"25\".to_string()));\n\n        let record = Odb2dRecord::from_record(&record_map).unwrap();\n        assert_eq!(record.prim_type, \"circle\");\n        assert_eq!(record.parse_radius(), 25.0);\n    }\n\n    #[test]\n    fn test_odb2d_record_arc() {\n        let mut record_map = Record::new();\n        record_map.insert(\"prim_type\".to_string(), Value::String(\"arc\".to_string()));\n        record_map.insert(\"x\".to_string(), Value::String(\"50\".to_string()));\n        record_map.insert(\"y\".to_string(), Value::String(\"50\".to_string()));\n        record_map.insert(\"r\".to_string(), Value::String(\"25\".to_string()));\n        record_map.insert(\"angle1\".to_string(), Value::String(\"0\".to_string()));\n        record_map.insert(\"angle2\".to_string(), Value::String(\"90\".to_string()));\n\n        let record = Odb2dRecord::from_record(&record_map).unwrap();\n        assert_eq!(record.prim_type, \"arc\");\n        assert_eq!(record.parse_start_angle(), 0.0);\n        assert_eq!(record.parse_end_angle(), 90.0);\n    }\n\n    #[test]\n    fn test_odb2d_record_text() {\n        let mut record_map = Record::new();\n        record_map.insert(\"prim_type\".to_string(), Value::String(\"text\".to_string()));\n        record_map.insert(\"x\".to_string(), Value::String(\"10\".to_string()));\n        record_map.insert(\"y\".to_string(), Value::String(\"20\".to_string()));\n        record_map.insert(\"text\".to_string(), Value::String(\"Hello World\".to_string()));\n        record_map.insert(\"font_size\".to_string(), Value::String(\"12\".to_string()));\n\n        let record = Odb2dRecord::from_record(&record_map).unwrap();\n        assert_eq!(record.prim_type, \"text\");\n        assert_eq!(record.text, \"Hello World\");\n        assert_eq!(record.parse_font_size(), 12.0);\n    }\n\n    #[test]\n    fn test_odb2d_record_line_style() {\n        let mut record_map = Record::new();\n        record_map.insert(\"prim_type\".to_string(), Value::String(\"lines\".to_string()));\n        record_map.insert(\n            \"line_style\".to_string(),\n            Value::String(\"dashed\".to_string()),\n        );\n        record_map.insert(\"line_width\".to_string(), Value::String(\"2.5\".to_string()));\n\n        let record = Odb2dRecord::from_record(&record_map).unwrap();\n        assert_eq!(record.get_line_style(), \"dashed\");\n        assert!((record.parse_line_width() - 2.5).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_odb2d_color_parsing() {\n        // RGB color\n        let color = Odb2dRecord::parse_color_string(\"0.8 0.4 0.2\");\n        assert!((color[0] - 0.8).abs() < 0.001);\n        assert!((color[1] - 0.4).abs() < 0.001);\n        assert!((color[2] - 0.2).abs() < 0.001);\n        assert!((color[3] - 1.0).abs() < 0.001); // Default alpha\n\n        // RGBA color\n        let color = Odb2dRecord::parse_color_string(\"0.5 0.5 0.5 0.7\");\n        assert!((color[3] - 0.7).abs() < 0.001);\n\n        // Single value (grayscale)\n        let color = Odb2dRecord::parse_color_string(\"0.5\");\n        assert!((color[0] - 0.5).abs() < 0.001);\n        assert!((color[1] - 0.5).abs() < 0.001);\n\n        // Empty string\n        let color = Odb2dRecord::parse_color_string(\"\");\n        assert!((color[0] - 0.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_odb2d_two_component_color() {\n        // Two components (partial color)\n        let color = Odb2dRecord::parse_color_string(\"0.5 0.3\");\n        assert!((color[0] - 0.5).abs() < 0.001);\n        assert!((color[1] - 0.3).abs() < 0.001);\n        assert!((color[2] - 0.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_odb2d_fill_color() {\n        let mut record_map = Record::new();\n        record_map.insert(\"prim_type\".to_string(), Value::String(\"rect\".to_string()));\n        record_map.insert(\"fill_color\".to_string(), Value::String(\"0.8 0.2 0.1\".to_string()));\n\n        let record = Odb2dRecord::from_record(&record_map).unwrap();\n        let fill_color = record.parse_fill_color().unwrap();\n        assert!((fill_color[0] - 0.8).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_odb2d_fill_color_empty() {\n        let mut record_map = Record::new();\n        record_map.insert(\"prim_type\".to_string(), Value::String(\"rect\".to_string()));\n\n        let record = Odb2dRecord::from_record(&record_map).unwrap();\n        assert!(record.parse_fill_color().is_none());\n    }\n\n    #[test]\n    fn test_odb2d_line_style_variants() {\n        // Test dotted\n        let mut record_map = Record::new();\n        record_map.insert(\"line_style\".to_string(), Value::String(\"dotted\".to_string()));\n        let record = Odb2dRecord::from_record(&record_map).unwrap();\n        assert_eq!(record.get_line_style(), \"dotted\");\n\n        // Test dot (alias)\n        let mut record_map = Record::new();\n        record_map.insert(\"line_style\".to_string(), Value::String(\"dot\".to_string()));\n        let record = Odb2dRecord::from_record(&record_map).unwrap();\n        assert_eq!(record.get_line_style(), \"dotted\");\n\n        // Test dashdot\n        let mut record_map = Record::new();\n        record_map.insert(\"line_style\".to_string(), Value::String(\"dashdot\".to_string()));\n        let record = Odb2dRecord::from_record(&record_map).unwrap();\n        assert_eq!(record.get_line_style(), \"dashdot\");\n\n        // Test dash-dot (alias)\n        let mut record_map = Record::new();\n        record_map.insert(\"line_style\".to_string(), Value::String(\"dash-dot\".to_string()));\n        let record = Odb2dRecord::from_record(&record_map).unwrap();\n        assert_eq!(record.get_line_style(), \"dashdot\");\n\n        // Test solid (default)\n        let mut record_map = Record::new();\n        record_map.insert(\"line_style\".to_string(), Value::String(\"solid\".to_string()));\n        let record = Odb2dRecord::from_record(&record_map).unwrap();\n        assert_eq!(record.get_line_style(), \"solid\");\n\n        // Test unknown (defaults to solid)\n        let mut record_map = Record::new();\n        record_map.insert(\"line_style\".to_string(), Value::String(\"unknown\".to_string()));\n        let record = Odb2dRecord::from_record(&record_map).unwrap();\n        assert_eq!(record.get_line_style(), \"solid\");\n    }\n\n    #[test]\n    fn test_odb3d_record_debug_clone() {\n        let record = Odb3dRecord {\n            odb_name: \"test\".to_string(),\n            obj_name: \"obj\".to_string(),\n            visible: \"1\".to_string(),\n            x_offs: \"0\".to_string(),\n            y_offs: \"0\".to_string(),\n            z_offs: \"0\".to_string(),\n            x_rot: \"0\".to_string(),\n            y_rot: \"0\".to_string(),\n            z_rot: \"0\".to_string(),\n            ctor: \"test.geo\".to_string(),\n            mat: \"mat1\".to_string(),\n            attrib: \"attr\".to_string(),\n            link: \"link\".to_string(),\n        };\n\n        let debug_str = format!(\"{:?}\", record);\n        assert!(debug_str.contains(\"test\"));\n\n        let cloned = record.clone();\n        assert_eq!(cloned.odb_name, \"test\");\n    }\n\n    #[test]\n    fn test_odb3d_record_parse_offset() {\n        let record = Odb3dRecord {\n            odb_name: \"test\".to_string(),\n            obj_name: \"obj\".to_string(),\n            visible: \"\".to_string(),\n            x_offs: \"10.5\".to_string(),\n            y_offs: \"20.3\".to_string(),\n            z_offs: \"30.1\".to_string(),\n            x_rot: \"0\".to_string(),\n            y_rot: \"0\".to_string(),\n            z_rot: \"0\".to_string(),\n            ctor: \"\".to_string(),\n            mat: \"\".to_string(),\n            attrib: \"\".to_string(),\n            link: \"\".to_string(),\n        };\n\n        let offset = record.parse_offset();\n        assert!((offset[0] - 10.5).abs() < 0.001);\n        assert!((offset[1] - 20.3).abs() < 0.001);\n        assert!((offset[2] - 30.1).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_odb3d_record_parse_rotation() {\n        let record = Odb3dRecord {\n            odb_name: \"test\".to_string(),\n            obj_name: \"obj\".to_string(),\n            visible: \"\".to_string(),\n            x_offs: \"0\".to_string(),\n            y_offs: \"0\".to_string(),\n            z_offs: \"0\".to_string(),\n            x_rot: \"45\".to_string(),\n            y_rot: \"90\".to_string(),\n            z_rot: \"180\".to_string(),\n            ctor: \"\".to_string(),\n            mat: \"\".to_string(),\n            attrib: \"\".to_string(),\n            link: \"\".to_string(),\n        };\n\n        let rotation = record.parse_rotation();\n        assert!((rotation[0] - 45.0).abs() < 0.001);\n        assert!((rotation[1] - 90.0).abs() < 0.001);\n        assert!((rotation[2] - 180.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_odb3d_record_visible_field() {\n        // Test visible field values\n        let record = Odb3dRecord {\n            odb_name: \"test\".to_string(),\n            obj_name: \"obj\".to_string(),\n            visible: \"\".to_string(),\n            x_offs: \"0\".to_string(),\n            y_offs: \"0\".to_string(),\n            z_offs: \"0\".to_string(),\n            x_rot: \"0\".to_string(),\n            y_rot: \"0\".to_string(),\n            z_rot: \"0\".to_string(),\n            ctor: \"\".to_string(),\n            mat: \"\".to_string(),\n            attrib: \"\".to_string(),\n            link: \"\".to_string(),\n        };\n        assert_eq!(record.visible, \"\");\n\n        // \"1\" is visible\n        let mut record2 = record.clone();\n        record2.visible = \"1\".to_string();\n        assert_eq!(record2.visible, \"1\");\n\n        // \"0\" is not visible\n        record2.visible = \"0\".to_string();\n        assert_eq!(record2.visible, \"0\");\n    }\n\n    #[test]\n    fn test_odb3d_record_parse_ctor_none() {\n        let record = Odb3dRecord {\n            odb_name: \"test\".to_string(),\n            obj_name: \"obj\".to_string(),\n            visible: \"\".to_string(),\n            x_offs: \"0\".to_string(),\n            y_offs: \"0\".to_string(),\n            z_offs: \"0\".to_string(),\n            x_rot: \"0\".to_string(),\n            y_rot: \"0\".to_string(),\n            z_rot: \"0\".to_string(),\n            ctor: \"\".to_string(),  // Empty ctor\n            mat: \"\".to_string(),\n            attrib: \"\".to_string(),\n            link: \"\".to_string(),\n        };\n\n        assert!(record.parse_ctor().is_none());\n    }\n\n    #[test]\n    fn test_odb2d_record_debug_clone() {\n        let mut record_map = Record::new();\n        record_map.insert(\"odb_name\".to_string(), Value::String(\"test\".to_string()));\n        record_map.insert(\"prim_type\".to_string(), Value::String(\"polygon\".to_string()));\n\n        let record = Odb2dRecord::from_record(&record_map).unwrap();\n        let debug_str = format!(\"{:?}\", record);\n        assert!(debug_str.contains(\"test\"));\n\n        let cloned = record.clone();\n        assert_eq!(cloned.odb_name, \"test\");\n    }\n\n    #[test]\n    fn test_odb2d_record_from_record_none() {\n        // Record without prim_type (but might have odb_name)\n        let mut record_map = Record::new();\n        record_map.insert(\"other_field\".to_string(), Value::String(\"value\".to_string()));\n\n        let record = Odb2dRecord::from_record(&record_map);\n        assert!(record.is_some());  // Should still create a record\n    }\n\n    #[test]\n    fn test_value_as_i64() {\n        assert_eq!(Value::Int(42).as_i64(), Some(42));\n        assert_eq!(Value::UInt(10).as_i64(), Some(10));  // UInt converts to i64\n        assert_eq!(Value::Float(3.14).as_i64(), None);  // Float doesn't convert\n        assert_eq!(Value::String(\"123\".to_string()).as_i64(), None);\n    }\n\n    #[test]\n    fn test_value_as_f64() {\n        assert_eq!(Value::Float(3.14).as_f64(), Some(3.14));\n        assert_eq!(Value::Int(42).as_f64(), Some(42.0));\n        assert_eq!(Value::UInt(5).as_f64(), Some(5.0));\n        assert_eq!(Value::String(\"3.14\".to_string()).as_f64(), None);\n    }\n\n    #[test]\n    fn test_value_as_str() {\n        assert_eq!(Value::String(\"test\".to_string()).as_str(), Some(\"test\"));\n        assert_eq!(Value::Int(42).as_str(), None);\n    }\n\n    #[test]\n    fn test_value_debug() {\n        let val = Value::Int(42);\n        let debug_str = format!(\"{:?}\", val);\n        assert!(debug_str.contains(\"Int\"));\n    }\n\n    #[test]\n    fn test_value_clone() {\n        let val = Value::String(\"test\".to_string());\n        let cloned = val.clone();\n        assert_eq!(val.as_str(), cloned.as_str());\n    }\n\n    #[test]\n    fn test_column_type_debug() {\n        let col_type = ColumnType::Int32Signed;\n        let debug_str = format!(\"{:?}\", col_type);\n        assert!(debug_str.contains(\"Int32Signed\"));\n    }\n\n    #[test]\n    fn test_column_type_clone() {\n        let col_type = ColumnType::Float64;\n        let cloned = col_type.clone();\n        assert_eq!(cloned.size(), 8);\n    }\n\n    #[test]\n    fn test_column_type_all_sizes() {\n        assert_eq!(ColumnType::Int8Unsigned.size(), 1);\n        assert_eq!(ColumnType::Int16Unsigned.size(), 2);\n        assert_eq!(ColumnType::Int32Unsigned.size(), 4);\n        assert_eq!(ColumnType::Float32.size(), 4);\n    }\n\n    #[test]\n    fn test_func_def_debug_clone() {\n        let func = FuncDef {\n            name: \"testFunc\".to_string(),\n            body: \"return 42\".to_string(),\n        };\n\n        let debug_str = format!(\"{:?}\", func);\n        assert!(debug_str.contains(\"testFunc\"));\n\n        let cloned = func.clone();\n        assert_eq!(cloned.name, \"testFunc\");\n        assert_eq!(cloned.body, \"return 42\");\n    }\n\n    #[test]\n    fn test_ocd_record_from_record() {\n        let mut record_map = Record::new();\n        record_map.insert(\"key1\".to_string(), Value::String(\"value1\".to_string()));\n        record_map.insert(\"key2\".to_string(), Value::Int(42));\n\n        let ocd_record = OcdRecord::from_record(&record_map);\n        assert_eq!(ocd_record.get(\"key1\"), Some(\"value1\"));\n        // Int values get converted to empty string via as_str() returning None\n        // The actual value depends on the implementation\n        assert!(ocd_record.get(\"key2\").is_some());\n    }\n\n    #[test]\n    fn test_ocd_record_get_missing() {\n        let record = OcdRecord {\n            fields: HashMap::new(),\n        };\n        assert!(record.get(\"missing\").is_none());\n    }\n\n    #[test]\n    fn test_ocd_record_debug_clone() {\n        let mut fields = HashMap::new();\n        fields.insert(\"key\".to_string(), \"value\".to_string());\n        let record = OcdRecord { fields };\n\n        let debug_str = format!(\"{:?}\", record);\n        assert!(debug_str.contains(\"OcdRecord\"));\n\n        let cloned = record.clone();\n        assert_eq!(cloned.get(\"key\"), Some(\"value\"));\n    }\n\n    #[test]\n    fn test_ebase_error_display() {\n        let io_err = EBaseError::Io(std::io::Error::new(std::io::ErrorKind::NotFound, \"file not found\"));\n        let display_str = format!(\"{}\", io_err);\n        assert!(display_str.contains(\"IO error\"));  // Note: \"IO error\" not \"I/O error\"\n\n        let parse_err = EBaseError::ParseError(\"invalid data\".to_string());\n        let display_str = format!(\"{}\", parse_err);\n        assert!(display_str.contains(\"invalid data\") || display_str.contains(\"Parse\"));\n\n        let invalid_table = EBaseError::InvalidTable(\"missing\".to_string());\n        let display_str = format!(\"{}\", invalid_table);\n        assert!(display_str.contains(\"missing\") || display_str.contains(\"Invalid table\"));\n    }\n\n    #[test]\n    fn test_ebase_error_debug() {\n        let err = EBaseError::InvalidMagic;\n        let debug_str = format!(\"{:?}\", err);\n        assert!(debug_str.contains(\"InvalidMagic\"));\n    }\n\n    #[test]\n    fn test_ebase_error_unsupported_version() {\n        let err = EBaseError::UnsupportedVersion(999);\n        let debug_str = format!(\"{:?}\", err);\n        assert!(debug_str.contains(\"999\"));\n    }\n\n    #[test]\n    fn test_ebase_error_invalid_offset() {\n        let err = EBaseError::InvalidOffset;\n        let debug_str = format!(\"{:?}\", err);\n        assert!(debug_str.contains(\"InvalidOffset\"));\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":3}},{"line":30,"address":[],"length":0,"stats":{"Line":3}},{"line":35,"address":[],"length":0,"stats":{"Line":4}},{"line":36,"address":[],"length":0,"stats":{"Line":4}},{"line":37,"address":[],"length":0,"stats":{"Line":8}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":4}},{"line":67,"address":[],"length":0,"stats":{"Line":22594}},{"line":68,"address":[],"length":0,"stats":{"Line":22594}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":795}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":654}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":3144}},{"line":75,"address":[],"length":0,"stats":{"Line":92}},{"line":76,"address":[],"length":0,"stats":{"Line":436}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":17473}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":22604}},{"line":85,"address":[],"length":0,"stats":{"Line":22604}},{"line":86,"address":[],"length":0,"stats":{"Line":797}},{"line":87,"address":[],"length":0,"stats":{"Line":656}},{"line":88,"address":[],"length":0,"stats":{"Line":3146}},{"line":89,"address":[],"length":0,"stats":{"Line":93}},{"line":90,"address":[],"length":0,"stats":{"Line":438}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":17474}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":584424}},{"line":136,"address":[],"length":0,"stats":{"Line":584424}},{"line":137,"address":[],"length":0,"stats":{"Line":1168844}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":142,"address":[],"length":0,"stats":{"Line":155031}},{"line":143,"address":[],"length":0,"stats":{"Line":155031}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":310056}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":31175}},{"line":151,"address":[],"length":0,"stats":{"Line":31175}},{"line":152,"address":[],"length":0,"stats":{"Line":62344}},{"line":153,"address":[],"length":0,"stats":{"Line":2}},{"line":154,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":176,"address":[],"length":0,"stats":{"Line":172}},{"line":177,"address":[],"length":0,"stats":{"Line":516}},{"line":178,"address":[],"length":0,"stats":{"Line":507}},{"line":181,"address":[],"length":0,"stats":{"Line":338}},{"line":182,"address":[],"length":0,"stats":{"Line":507}},{"line":183,"address":[],"length":0,"stats":{"Line":169}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":338}},{"line":189,"address":[],"length":0,"stats":{"Line":507}},{"line":192,"address":[],"length":0,"stats":{"Line":507}},{"line":193,"address":[],"length":0,"stats":{"Line":507}},{"line":195,"address":[],"length":0,"stats":{"Line":169}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":169}},{"line":200,"address":[],"length":0,"stats":{"Line":676}},{"line":201,"address":[],"length":0,"stats":{"Line":845}},{"line":202,"address":[],"length":0,"stats":{"Line":845}},{"line":208,"address":[],"length":0,"stats":{"Line":338}},{"line":211,"address":[],"length":0,"stats":{"Line":169}},{"line":215,"address":[],"length":0,"stats":{"Line":507}},{"line":217,"address":[],"length":0,"stats":{"Line":169}},{"line":221,"address":[],"length":0,"stats":{"Line":640969}},{"line":222,"address":[],"length":0,"stats":{"Line":640969}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":1811163}},{"line":228,"address":[],"length":0,"stats":{"Line":529225}},{"line":232,"address":[],"length":0,"stats":{"Line":111744}},{"line":233,"address":[],"length":0,"stats":{"Line":79944}},{"line":234,"address":[],"length":0,"stats":{"Line":69424}},{"line":235,"address":[],"length":0,"stats":{"Line":20715}},{"line":240,"address":[],"length":0,"stats":{"Line":273087}},{"line":241,"address":[],"length":0,"stats":{"Line":273087}},{"line":244,"address":[],"length":0,"stats":{"Line":182058}},{"line":245,"address":[],"length":0,"stats":{"Line":273087}},{"line":246,"address":[],"length":0,"stats":{"Line":5007}},{"line":247,"address":[],"length":0,"stats":{"Line":1669}},{"line":249,"address":[],"length":0,"stats":{"Line":178720}},{"line":251,"address":[],"length":0,"stats":{"Line":229368}},{"line":252,"address":[],"length":0,"stats":{"Line":69099}},{"line":253,"address":[],"length":0,"stats":{"Line":23033}},{"line":257,"address":[],"length":0,"stats":{"Line":198981}},{"line":258,"address":[],"length":0,"stats":{"Line":198981}},{"line":259,"address":[],"length":0,"stats":{"Line":9}},{"line":260,"address":[],"length":0,"stats":{"Line":3}},{"line":263,"address":[],"length":0,"stats":{"Line":198972}},{"line":266,"address":[],"length":0,"stats":{"Line":265296}},{"line":267,"address":[],"length":0,"stats":{"Line":4112756}},{"line":271,"address":[],"length":0,"stats":{"Line":331620}},{"line":272,"address":[],"length":0,"stats":{"Line":66324}},{"line":276,"address":[],"length":0,"stats":{"Line":169}},{"line":281,"address":[],"length":0,"stats":{"Line":338}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":3547}},{"line":286,"address":[],"length":0,"stats":{"Line":3378}},{"line":287,"address":[],"length":0,"stats":{"Line":6756}},{"line":289,"address":[],"length":0,"stats":{"Line":6756}},{"line":290,"address":[],"length":0,"stats":{"Line":10134}},{"line":292,"address":[],"length":0,"stats":{"Line":16890}},{"line":293,"address":[],"length":0,"stats":{"Line":16890}},{"line":295,"address":[],"length":0,"stats":{"Line":13512}},{"line":296,"address":[],"length":0,"stats":{"Line":6756}},{"line":297,"address":[],"length":0,"stats":{"Line":16890}},{"line":298,"address":[],"length":0,"stats":{"Line":10134}},{"line":303,"address":[],"length":0,"stats":{"Line":169}},{"line":307,"address":[],"length":0,"stats":{"Line":3378}},{"line":308,"address":[],"length":0,"stats":{"Line":10134}},{"line":310,"address":[],"length":0,"stats":{"Line":6756}},{"line":311,"address":[],"length":0,"stats":{"Line":10134}},{"line":313,"address":[],"length":0,"stats":{"Line":16890}},{"line":314,"address":[],"length":0,"stats":{"Line":10134}},{"line":315,"address":[],"length":0,"stats":{"Line":10134}},{"line":316,"address":[],"length":0,"stats":{"Line":3378}},{"line":317,"address":[],"length":0,"stats":{"Line":13512}},{"line":318,"address":[],"length":0,"stats":{"Line":16890}},{"line":321,"address":[],"length":0,"stats":{"Line":6756}},{"line":322,"address":[],"length":0,"stats":{"Line":6756}},{"line":323,"address":[],"length":0,"stats":{"Line":3378}},{"line":324,"address":[],"length":0,"stats":{"Line":6756}},{"line":326,"address":[],"length":0,"stats":{"Line":3378}},{"line":327,"address":[],"length":0,"stats":{"Line":45188}},{"line":328,"address":[],"length":0,"stats":{"Line":67782}},{"line":330,"address":[],"length":0,"stats":{"Line":22594}},{"line":331,"address":[],"length":0,"stats":{"Line":90376}},{"line":332,"address":[],"length":0,"stats":{"Line":67782}},{"line":333,"address":[],"length":0,"stats":{"Line":67782}},{"line":334,"address":[],"length":0,"stats":{"Line":67782}},{"line":336,"address":[],"length":0,"stats":{"Line":90376}},{"line":337,"address":[],"length":0,"stats":{"Line":67782}},{"line":338,"address":[],"length":0,"stats":{"Line":67782}},{"line":341,"address":[],"length":0,"stats":{"Line":67782}},{"line":342,"address":[],"length":0,"stats":{"Line":45188}},{"line":343,"address":[],"length":0,"stats":{"Line":45188}},{"line":344,"address":[],"length":0,"stats":{"Line":45188}},{"line":345,"address":[],"length":0,"stats":{"Line":22594}},{"line":346,"address":[],"length":0,"stats":{"Line":22594}},{"line":351,"address":[],"length":0,"stats":{"Line":3378}},{"line":352,"address":[],"length":0,"stats":{"Line":10134}},{"line":353,"address":[],"length":0,"stats":{"Line":6756}},{"line":354,"address":[],"length":0,"stats":{"Line":6756}},{"line":355,"address":[],"length":0,"stats":{"Line":3378}},{"line":356,"address":[],"length":0,"stats":{"Line":3378}},{"line":361,"address":[],"length":0,"stats":{"Line":1310}},{"line":366,"address":[],"length":0,"stats":{"Line":2620}},{"line":367,"address":[],"length":0,"stats":{"Line":1310}},{"line":368,"address":[],"length":0,"stats":{"Line":2620}},{"line":369,"address":[],"length":0,"stats":{"Line":1310}},{"line":372,"address":[],"length":0,"stats":{"Line":2278}},{"line":373,"address":[],"length":0,"stats":{"Line":342}},{"line":376,"address":[],"length":0,"stats":{"Line":3909}},{"line":377,"address":[],"length":0,"stats":{"Line":111}},{"line":379,"address":[],"length":0,"stats":{"Line":2904}},{"line":381,"address":[],"length":0,"stats":{"Line":110739}},{"line":382,"address":[],"length":0,"stats":{"Line":329313}},{"line":383,"address":[],"length":0,"stats":{"Line":329313}},{"line":385,"address":[],"length":0,"stats":{"Line":329313}},{"line":386,"address":[],"length":0,"stats":{"Line":329313}},{"line":388,"address":[],"length":0,"stats":{"Line":219542}},{"line":389,"address":[],"length":0,"stats":{"Line":1794929}},{"line":390,"address":[],"length":0,"stats":{"Line":4212895}},{"line":391,"address":[],"length":0,"stats":{"Line":4212895}},{"line":393,"address":[],"length":0,"stats":{"Line":329313}},{"line":396,"address":[],"length":0,"stats":{"Line":968}},{"line":400,"address":[],"length":0,"stats":{"Line":842579}},{"line":405,"address":[],"length":0,"stats":{"Line":1685158}},{"line":406,"address":[],"length":0,"stats":{"Line":1685158}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":842579}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":45523}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":61874}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":92811}},{"line":433,"address":[],"length":0,"stats":{"Line":30937}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":176826}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":265239}},{"line":454,"address":[],"length":0,"stats":{"Line":176826}},{"line":455,"address":[],"length":0,"stats":{"Line":176826}},{"line":456,"address":[],"length":0,"stats":{"Line":88413}},{"line":457,"address":[],"length":0,"stats":{"Line":88413}},{"line":459,"address":[],"length":0,"stats":{"Line":88413}},{"line":463,"address":[],"length":0,"stats":{"Line":5670}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":8505}},{"line":467,"address":[],"length":0,"stats":{"Line":5670}},{"line":468,"address":[],"length":0,"stats":{"Line":5670}},{"line":469,"address":[],"length":0,"stats":{"Line":2835}},{"line":470,"address":[],"length":0,"stats":{"Line":2835}},{"line":472,"address":[],"length":0,"stats":{"Line":2835}},{"line":476,"address":[],"length":0,"stats":{"Line":56648}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":84972}},{"line":480,"address":[],"length":0,"stats":{"Line":56648}},{"line":481,"address":[],"length":0,"stats":{"Line":56648}},{"line":482,"address":[],"length":0,"stats":{"Line":56648}},{"line":483,"address":[],"length":0,"stats":{"Line":56648}},{"line":484,"address":[],"length":0,"stats":{"Line":56648}},{"line":485,"address":[],"length":0,"stats":{"Line":56648}},{"line":486,"address":[],"length":0,"stats":{"Line":28324}},{"line":487,"address":[],"length":0,"stats":{"Line":28324}},{"line":489,"address":[],"length":0,"stats":{"Line":28324}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":1293094}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":1939641}},{"line":509,"address":[],"length":0,"stats":{"Line":1293094}},{"line":510,"address":[],"length":0,"stats":{"Line":1293094}},{"line":511,"address":[],"length":0,"stats":{"Line":646547}},{"line":512,"address":[],"length":0,"stats":{"Line":646547}},{"line":514,"address":[],"length":0,"stats":{"Line":646547}},{"line":515,"address":[],"length":0,"stats":{"Line":31550}},{"line":517,"address":[],"length":0,"stats":{"Line":1844991}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":2}},{"line":590,"address":[],"length":0,"stats":{"Line":4}},{"line":591,"address":[],"length":0,"stats":{"Line":5}},{"line":592,"address":[],"length":0,"stats":{"Line":1}},{"line":596,"address":[],"length":0,"stats":{"Line":1}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":3}},{"line":601,"address":[],"length":0,"stats":{"Line":2}},{"line":604,"address":[],"length":0,"stats":{"Line":2}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":2}},{"line":612,"address":[],"length":0,"stats":{"Line":5}},{"line":614,"address":[],"length":0,"stats":{"Line":2}},{"line":616,"address":[],"length":0,"stats":{"Line":4}},{"line":617,"address":[],"length":0,"stats":{"Line":4}},{"line":618,"address":[],"length":0,"stats":{"Line":2}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":2}},{"line":629,"address":[],"length":0,"stats":{"Line":1}},{"line":631,"address":[],"length":0,"stats":{"Line":3}},{"line":632,"address":[],"length":0,"stats":{"Line":3}},{"line":633,"address":[],"length":0,"stats":{"Line":1}},{"line":639,"address":[],"length":0,"stats":{"Line":1}},{"line":641,"address":[],"length":0,"stats":{"Line":3}},{"line":642,"address":[],"length":0,"stats":{"Line":3}},{"line":643,"address":[],"length":0,"stats":{"Line":1}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":24}},{"line":791,"address":[],"length":0,"stats":{"Line":24}},{"line":792,"address":[],"length":0,"stats":{"Line":48}},{"line":793,"address":[],"length":0,"stats":{"Line":28}},{"line":794,"address":[],"length":0,"stats":{"Line":48}},{"line":795,"address":[],"length":0,"stats":{"Line":24}},{"line":796,"address":[],"length":0,"stats":{"Line":24}},{"line":797,"address":[],"length":0,"stats":{"Line":48}},{"line":798,"address":[],"length":0,"stats":{"Line":24}},{"line":799,"address":[],"length":0,"stats":{"Line":48}},{"line":800,"address":[],"length":0,"stats":{"Line":24}},{"line":801,"address":[],"length":0,"stats":{"Line":24}},{"line":802,"address":[],"length":0,"stats":{"Line":48}},{"line":803,"address":[],"length":0,"stats":{"Line":24}},{"line":804,"address":[],"length":0,"stats":{"Line":48}},{"line":805,"address":[],"length":0,"stats":{"Line":24}},{"line":806,"address":[],"length":0,"stats":{"Line":24}},{"line":807,"address":[],"length":0,"stats":{"Line":48}},{"line":808,"address":[],"length":0,"stats":{"Line":58}},{"line":809,"address":[],"length":0,"stats":{"Line":52}},{"line":810,"address":[],"length":0,"stats":{"Line":48}},{"line":811,"address":[],"length":0,"stats":{"Line":24}},{"line":812,"address":[],"length":0,"stats":{"Line":24}},{"line":813,"address":[],"length":0,"stats":{"Line":48}},{"line":814,"address":[],"length":0,"stats":{"Line":30}},{"line":815,"address":[],"length":0,"stats":{"Line":126}},{"line":816,"address":[],"length":0,"stats":{"Line":72}},{"line":817,"address":[],"length":0,"stats":{"Line":48}},{"line":818,"address":[],"length":0,"stats":{"Line":24}},{"line":819,"address":[],"length":0,"stats":{"Line":24}},{"line":820,"address":[],"length":0,"stats":{"Line":48}},{"line":821,"address":[],"length":0,"stats":{"Line":30}},{"line":822,"address":[],"length":0,"stats":{"Line":126}},{"line":823,"address":[],"length":0,"stats":{"Line":72}},{"line":824,"address":[],"length":0,"stats":{"Line":48}},{"line":825,"address":[],"length":0,"stats":{"Line":24}},{"line":826,"address":[],"length":0,"stats":{"Line":24}},{"line":827,"address":[],"length":0,"stats":{"Line":48}},{"line":828,"address":[],"length":0,"stats":{"Line":30}},{"line":829,"address":[],"length":0,"stats":{"Line":108}},{"line":830,"address":[],"length":0,"stats":{"Line":48}},{"line":831,"address":[],"length":0,"stats":{"Line":24}},{"line":832,"address":[],"length":0,"stats":{"Line":24}},{"line":833,"address":[],"length":0,"stats":{"Line":48}},{"line":834,"address":[],"length":0,"stats":{"Line":30}},{"line":835,"address":[],"length":0,"stats":{"Line":108}},{"line":836,"address":[],"length":0,"stats":{"Line":48}},{"line":837,"address":[],"length":0,"stats":{"Line":24}},{"line":838,"address":[],"length":0,"stats":{"Line":24}},{"line":839,"address":[],"length":0,"stats":{"Line":48}},{"line":840,"address":[],"length":0,"stats":{"Line":24}},{"line":841,"address":[],"length":0,"stats":{"Line":128}},{"line":842,"address":[],"length":0,"stats":{"Line":48}},{"line":843,"address":[],"length":0,"stats":{"Line":24}},{"line":844,"address":[],"length":0,"stats":{"Line":24}},{"line":845,"address":[],"length":0,"stats":{"Line":48}},{"line":846,"address":[],"length":0,"stats":{"Line":24}},{"line":847,"address":[],"length":0,"stats":{"Line":122}},{"line":848,"address":[],"length":0,"stats":{"Line":48}},{"line":849,"address":[],"length":0,"stats":{"Line":24}},{"line":850,"address":[],"length":0,"stats":{"Line":24}},{"line":851,"address":[],"length":0,"stats":{"Line":48}},{"line":852,"address":[],"length":0,"stats":{"Line":24}},{"line":853,"address":[],"length":0,"stats":{"Line":122}},{"line":854,"address":[],"length":0,"stats":{"Line":48}},{"line":855,"address":[],"length":0,"stats":{"Line":24}},{"line":856,"address":[],"length":0,"stats":{"Line":24}},{"line":857,"address":[],"length":0,"stats":{"Line":48}},{"line":858,"address":[],"length":0,"stats":{"Line":28}},{"line":859,"address":[],"length":0,"stats":{"Line":112}},{"line":860,"address":[],"length":0,"stats":{"Line":48}},{"line":861,"address":[],"length":0,"stats":{"Line":24}},{"line":862,"address":[],"length":0,"stats":{"Line":24}},{"line":863,"address":[],"length":0,"stats":{"Line":48}},{"line":864,"address":[],"length":0,"stats":{"Line":28}},{"line":865,"address":[],"length":0,"stats":{"Line":112}},{"line":866,"address":[],"length":0,"stats":{"Line":48}},{"line":867,"address":[],"length":0,"stats":{"Line":24}},{"line":868,"address":[],"length":0,"stats":{"Line":24}},{"line":869,"address":[],"length":0,"stats":{"Line":48}},{"line":870,"address":[],"length":0,"stats":{"Line":26}},{"line":871,"address":[],"length":0,"stats":{"Line":48}},{"line":872,"address":[],"length":0,"stats":{"Line":24}},{"line":873,"address":[],"length":0,"stats":{"Line":24}},{"line":874,"address":[],"length":0,"stats":{"Line":48}},{"line":875,"address":[],"length":0,"stats":{"Line":28}},{"line":876,"address":[],"length":0,"stats":{"Line":48}},{"line":877,"address":[],"length":0,"stats":{"Line":24}},{"line":878,"address":[],"length":0,"stats":{"Line":24}},{"line":879,"address":[],"length":0,"stats":{"Line":48}},{"line":880,"address":[],"length":0,"stats":{"Line":28}},{"line":881,"address":[],"length":0,"stats":{"Line":112}},{"line":882,"address":[],"length":0,"stats":{"Line":48}},{"line":883,"address":[],"length":0,"stats":{"Line":24}},{"line":884,"address":[],"length":0,"stats":{"Line":24}},{"line":885,"address":[],"length":0,"stats":{"Line":48}},{"line":886,"address":[],"length":0,"stats":{"Line":28}},{"line":887,"address":[],"length":0,"stats":{"Line":112}},{"line":888,"address":[],"length":0,"stats":{"Line":48}},{"line":889,"address":[],"length":0,"stats":{"Line":24}},{"line":890,"address":[],"length":0,"stats":{"Line":24}},{"line":891,"address":[],"length":0,"stats":{"Line":48}},{"line":892,"address":[],"length":0,"stats":{"Line":40}},{"line":893,"address":[],"length":0,"stats":{"Line":88}},{"line":894,"address":[],"length":0,"stats":{"Line":48}},{"line":895,"address":[],"length":0,"stats":{"Line":24}},{"line":896,"address":[],"length":0,"stats":{"Line":24}},{"line":897,"address":[],"length":0,"stats":{"Line":48}},{"line":898,"address":[],"length":0,"stats":{"Line":24}},{"line":899,"address":[],"length":0,"stats":{"Line":48}},{"line":900,"address":[],"length":0,"stats":{"Line":24}},{"line":905,"address":[],"length":0,"stats":{"Line":9}},{"line":906,"address":[],"length":0,"stats":{"Line":27}},{"line":910,"address":[],"length":0,"stats":{"Line":9}},{"line":911,"address":[],"length":0,"stats":{"Line":27}},{"line":914,"address":[],"length":0,"stats":{"Line":18}},{"line":915,"address":[],"length":0,"stats":{"Line":54}},{"line":916,"address":[],"length":0,"stats":{"Line":90}},{"line":917,"address":[],"length":0,"stats":{"Line":126}},{"line":922,"address":[],"length":0,"stats":{"Line":3}},{"line":923,"address":[],"length":0,"stats":{"Line":9}},{"line":927,"address":[],"length":0,"stats":{"Line":3}},{"line":928,"address":[],"length":0,"stats":{"Line":9}},{"line":932,"address":[],"length":0,"stats":{"Line":3}},{"line":933,"address":[],"length":0,"stats":{"Line":9}},{"line":937,"address":[],"length":0,"stats":{"Line":1}},{"line":938,"address":[],"length":0,"stats":{"Line":3}},{"line":942,"address":[],"length":0,"stats":{"Line":1}},{"line":943,"address":[],"length":0,"stats":{"Line":3}},{"line":947,"address":[],"length":0,"stats":{"Line":2}},{"line":948,"address":[],"length":0,"stats":{"Line":6}},{"line":952,"address":[],"length":0,"stats":{"Line":4}},{"line":953,"address":[],"length":0,"stats":{"Line":12}},{"line":957,"address":[],"length":0,"stats":{"Line":4}},{"line":958,"address":[],"length":0,"stats":{"Line":8}},{"line":962,"address":[],"length":0,"stats":{"Line":5}},{"line":963,"address":[],"length":0,"stats":{"Line":10}},{"line":964,"address":[],"length":0,"stats":{"Line":3}},{"line":966,"address":[],"length":0,"stats":{"Line":2}},{"line":970,"address":[],"length":0,"stats":{"Line":11}},{"line":971,"address":[],"length":0,"stats":{"Line":33}},{"line":973,"address":[],"length":0,"stats":{"Line":77}},{"line":975,"address":[],"length":0,"stats":{"Line":11}},{"line":976,"address":[],"length":0,"stats":{"Line":3}},{"line":977,"address":[],"length":0,"stats":{"Line":3}},{"line":978,"address":[],"length":0,"stats":{"Line":2}},{"line":979,"address":[],"length":0,"stats":{"Line":15}},{"line":980,"address":[],"length":0,"stats":{"Line":4}},{"line":985,"address":[],"length":0,"stats":{"Line":10}},{"line":986,"address":[],"length":0,"stats":{"Line":10}},{"line":987,"address":[],"length":0,"stats":{"Line":20}},{"line":988,"address":[],"length":0,"stats":{"Line":17}},{"line":989,"address":[],"length":0,"stats":{"Line":13}},{"line":990,"address":[],"length":0,"stats":{"Line":4}},{"line":996,"address":[],"length":0,"stats":{"Line":0}},{"line":997,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1000,"address":[],"length":0,"stats":{"Line":0}},{"line":1003,"address":[],"length":0,"stats":{"Line":0}},{"line":1004,"address":[],"length":0,"stats":{"Line":0}},{"line":1006,"address":[],"length":0,"stats":{"Line":0}},{"line":1007,"address":[],"length":0,"stats":{"Line":0}},{"line":1009,"address":[],"length":0,"stats":{"Line":0}},{"line":1010,"address":[],"length":0,"stats":{"Line":0}},{"line":1015,"address":[],"length":0,"stats":{"Line":0}},{"line":1034,"address":[],"length":0,"stats":{"Line":1}},{"line":1035,"address":[],"length":0,"stats":{"Line":2}},{"line":1037,"address":[],"length":0,"stats":{"Line":13}},{"line":1043,"address":[],"length":0,"stats":{"Line":4}},{"line":1044,"address":[],"length":0,"stats":{"Line":22}},{"line":1055,"address":[],"length":0,"stats":{"Line":2}},{"line":1056,"address":[],"length":0,"stats":{"Line":6}},{"line":1059,"address":[],"length":0,"stats":{"Line":0}},{"line":1060,"address":[],"length":0,"stats":{"Line":0}},{"line":1062,"address":[],"length":0,"stats":{"Line":0}},{"line":1065,"address":[],"length":0,"stats":{"Line":0}},{"line":1066,"address":[],"length":0,"stats":{"Line":0}},{"line":1067,"address":[],"length":0,"stats":{"Line":0}},{"line":1068,"address":[],"length":0,"stats":{"Line":0}},{"line":1069,"address":[],"length":0,"stats":{"Line":0}},{"line":1070,"address":[],"length":0,"stats":{"Line":0}},{"line":1071,"address":[],"length":0,"stats":{"Line":0}},{"line":1076,"address":[],"length":0,"stats":{"Line":0}},{"line":1080,"address":[],"length":0,"stats":{"Line":0}},{"line":1081,"address":[],"length":0,"stats":{"Line":0}},{"line":1083,"address":[],"length":0,"stats":{"Line":0}},{"line":1084,"address":[],"length":0,"stats":{"Line":0}},{"line":1087,"address":[],"length":0,"stats":{"Line":0}},{"line":1088,"address":[],"length":0,"stats":{"Line":0}},{"line":1090,"address":[],"length":0,"stats":{"Line":0}},{"line":1091,"address":[],"length":0,"stats":{"Line":0}},{"line":1093,"address":[],"length":0,"stats":{"Line":0}},{"line":1096,"address":[],"length":0,"stats":{"Line":0}},{"line":1098,"address":[],"length":0,"stats":{"Line":0}},{"line":1102,"address":[],"length":0,"stats":{"Line":0}},{"line":1103,"address":[],"length":0,"stats":{"Line":0}},{"line":1107,"address":[],"length":0,"stats":{"Line":0}}],"covered":382,"coverable":531},{"path":["/","workspace","crates","ofml-lib","src","ebase_expr.rs"],"content":"//! EBASE Expression Evaluator - PostScript-like stack machine.\n//!\n//! This module implements evaluation of EBASE `ctor` field expressions\n//! used in odb3d tables to determine geometry loading mode.\n//!\n//! ## Expression Syntax\n//!\n//! EBASE expressions use PostScript-like syntax:\n//! - Stack-based: operators follow operands\n//! - Variables: `${VAR:-default}` syntax\n//! - Operators: `imp`, `clsref`, `egms`, arithmetic, conditionals\n//!\n//! ## Examples\n//!\n//! ```text\n//! # Import geometry with scale\n//! \"table_top\" 1 1 1 imp\n//!\n//! # CLS class instantiation with calculated parameters\n//! ${M__BREITE:-100} 1000 / \"::ofml::go::GoYLTrans\" clsref\n//!\n//! # Conditional geometry\n//! ${VARIANT} @left == { \"left_panel\" } { \"right_panel\" } ifelse 1 1 1 imp\n//! ```\n\nuse std::collections::HashMap;\n\nuse crate::errors::EbaseExprError;\n\n/// A value on the EBASE expression stack.\n#[derive(Debug, Clone, PartialEq)]\npub enum EbaseValue {\n    /// Integer value\n    Int(i64),\n    /// Floating-point value\n    Float(f64),\n    /// String value (quoted text)\n    String(String),\n    /// Boolean value\n    Bool(bool),\n    /// Procedure block (deferred execution)\n    Proc(Vec<EbaseToken>),\n}\n\nimpl EbaseValue {\n    /// Convert to f64, if possible.\n    pub fn as_f64(&self) -> Option<f64> {\n        match self {\n            EbaseValue::Float(f) => Some(*f),\n            EbaseValue::Int(i) => Some(*i as f64),\n            _ => None,\n        }\n    }\n\n    /// Convert to string representation.\n    pub fn as_string(&self) -> String {\n        match self {\n            EbaseValue::Int(i) => i.to_string(),\n            EbaseValue::Float(f) => f.to_string(),\n            EbaseValue::String(s) => s.clone(),\n            EbaseValue::Bool(b) => b.to_string(),\n            EbaseValue::Proc(_) => \"<procedure>\".to_string(),\n        }\n    }\n\n    /// Get type name for error messages.\n    pub fn type_name(&self) -> &'static str {\n        match self {\n            EbaseValue::Int(_) => \"integer\",\n            EbaseValue::Float(_) => \"float\",\n            EbaseValue::String(_) => \"string\",\n            EbaseValue::Bool(_) => \"boolean\",\n            EbaseValue::Proc(_) => \"procedure\",\n        }\n    }\n}\n\n/// Token types in EBASE expressions.\n#[derive(Debug, Clone, PartialEq)]\npub enum EbaseToken {\n    /// Numeric literal (integer or float)\n    Number(f64),\n    /// Quoted string literal\n    String(String),\n    /// Identifier (variable name or operator)\n    Ident(String),\n    /// Symbol (starts with @)\n    Symbol(String),\n    /// Executable block start `{`\n    BlockStart,\n    /// Executable block end `}`\n    BlockEnd,\n}\n\n/// Result of evaluating an odb3d.ctor expression.\n#[derive(Debug, Clone)]\npub enum EbaseResult {\n    /// Direct geometry import: \"filename\" sx sy sz imp\n    Import {\n        /// Geometry filename (without extension)\n        filename: String,\n        /// Scale factors [sx, sy, sz]\n        scale: [f32; 3],\n    },\n    /// CLS class instantiation: params... \"ClassName\" clsref\n    ClsRef {\n        /// Fully qualified class name (e.g., \"::ofml::go::GoYLTrans\")\n        class: String,\n        /// Constructor parameters\n        params: Vec<f64>,\n    },\n    /// EGMS geometry reference: \"objectname\" egms\n    Egms {\n        /// EGMS object name\n        name: String,\n    },\n    /// No geometry result (expression evaluated for side effects)\n    None,\n}\n\n/// PostScript-like stack machine for EBASE expressions.\n///\n/// # Example\n///\n/// ```\n/// use ofml_lib::ebase_expr::{EbaseEvaluator, EbaseResult};\n/// use std::collections::HashMap;\n///\n/// let mut evaluator = EbaseEvaluator::new();\n/// let props = HashMap::new();\n/// let result = evaluator.evaluate(r#\"\"table_top\" 1 1 1 imp\"#, &props).unwrap();\n///\n/// match result {\n///     EbaseResult::Import { filename, scale } => {\n///         assert_eq!(filename, \"table_top\");\n///         assert_eq!(scale, [1.0, 1.0, 1.0]);\n///     }\n///     _ => panic!(\"Expected Import result\"),\n/// }\n/// ```\npub struct EbaseEvaluator {\n    /// Operand stack\n    stack: Vec<EbaseValue>,\n    /// Variable bindings\n    variables: HashMap<String, EbaseValue>,\n    /// Final evaluation result\n    result: Option<EbaseResult>,\n}\n\nimpl EbaseEvaluator {\n    /// Create a new evaluator.\n    pub fn new() -> Self {\n        Self {\n            stack: Vec::new(),\n            variables: HashMap::new(),\n            result: None,\n        }\n    }\n\n    /// Evaluate an EBASE expression with the given property values.\n    ///\n    /// # Arguments\n    ///\n    /// * `expression` - The EBASE expression string\n    /// * `properties` - Property values for variable substitution\n    ///\n    /// # Returns\n    ///\n    /// The result of evaluating the expression (Import, ClsRef, Egms, or None).\n    pub fn evaluate(\n        &mut self,\n        expression: &str,\n        properties: &HashMap<String, f64>,\n    ) -> Result<EbaseResult, EbaseExprError> {\n        // Reset state\n        self.stack.clear();\n        self.result = None;\n\n        // Substitute variables\n        let substituted = self.substitute_variables(expression, properties)?;\n\n        // Tokenize\n        let tokens = self.tokenize(&substituted)?;\n\n        // Execute\n        self.execute(&tokens)?;\n\n        Ok(self.result.clone().unwrap_or(EbaseResult::None))\n    }\n\n    /// Evaluate a simple numeric expression.\n    ///\n    /// This is used for offset/rotation fields that contain arithmetic expressions\n    /// rather than geometry loading commands (imp, clsref, egms).\n    ///\n    /// # Examples\n    ///\n    /// ```ignore\n    /// let mut eval = EbaseEvaluator::new();\n    /// let props = HashMap::new();\n    ///\n    /// // Simple number\n    /// assert_eq!(eval.evaluate_to_number(\"0.5\", &props).unwrap(), 0.5);\n    ///\n    /// // Arithmetic expression\n    /// assert_eq!(eval.evaluate_to_number(\"1000 1000 /\", &props).unwrap(), 1.0);\n    ///\n    /// // With variables\n    /// let mut props = HashMap::new();\n    /// props.insert(\"WIDTH\".to_string(), 1600.0);\n    /// assert_eq!(eval.evaluate_to_number(\"${WIDTH:-1000} 1000 /\", &props).unwrap(), 1.6);\n    /// ```\n    pub fn evaluate_to_number(\n        &mut self,\n        expression: &str,\n        properties: &HashMap<String, f64>,\n    ) -> Result<f64, EbaseExprError> {\n        // Reset state\n        self.stack.clear();\n        self.result = None;\n\n        // Substitute variables\n        let substituted = self.substitute_variables(expression, properties)?;\n\n        // Tokenize\n        let tokens = self.tokenize(&substituted)?;\n\n        // Execute\n        self.execute(&tokens)?;\n\n        // Get the numeric result from the stack\n        if let Some(val) = self.stack.pop() {\n            val.as_f64().ok_or_else(|| EbaseExprError::TypeError {\n                expected: \"number\",\n                found: val.type_name().to_string(),\n            })\n        } else {\n            // If stack is empty, try to parse the substituted expression directly\n            // This handles simple cases like \"0.5\" that might not push to stack\n            substituted\n                .trim()\n                .parse::<f64>()\n                .map_err(|_| EbaseExprError::StackUnderflow {\n                    expected: 1,\n                    found: 0,\n                })\n        }\n    }\n\n    /// Substitute ${VAR:-default} patterns in the expression.\n    fn substitute_variables(\n        &self,\n        expression: &str,\n        properties: &HashMap<String, f64>,\n    ) -> Result<String, EbaseExprError> {\n        let mut result = String::new();\n        let mut chars = expression.chars().peekable();\n\n        while let Some(c) = chars.next() {\n            if c == '$' && chars.peek() == Some(&'{') {\n                chars.next(); // consume '{'\n\n                // Read variable name\n                let mut var_name = String::new();\n                let mut default_value = None;\n\n                loop {\n                    match chars.next() {\n                        Some(':') if chars.peek() == Some(&'-') => {\n                            chars.next(); // consume '-'\n                            let mut default = String::new();\n                            loop {\n                                match chars.next() {\n                                    Some('}') => break,\n                                    Some(c) => default.push(c),\n                                    None => {\n                                        return Err(EbaseExprError::VariableSubstitution(\n                                            \"Unterminated variable substitution\".to_string(),\n                                        ))\n                                    }\n                                }\n                            }\n                            default_value = Some(default);\n                            break;\n                        }\n                        Some('}') => break,\n                        Some(c) => var_name.push(c),\n                        None => {\n                            return Err(EbaseExprError::VariableSubstitution(\n                                \"Unterminated variable substitution\".to_string(),\n                            ))\n                        }\n                    }\n                }\n\n                // Look up variable\n                if let Some(value) = properties.get(&var_name) {\n                    result.push_str(&value.to_string());\n                } else if let Some(default) = default_value {\n                    result.push_str(&default);\n                } else {\n                    return Err(EbaseExprError::VariableSubstitution(format!(\n                        \"Variable '{}' not found and no default provided\",\n                        var_name\n                    )));\n                }\n            } else {\n                result.push(c);\n            }\n        }\n\n        Ok(result)\n    }\n\n    /// Tokenize the expression string.\n    fn tokenize(&self, expression: &str) -> Result<Vec<EbaseToken>, EbaseExprError> {\n        let mut tokens = Vec::new();\n        let mut chars = expression.chars().peekable();\n\n        while let Some(&c) = chars.peek() {\n            match c {\n                // Whitespace\n                ' ' | '\\t' | '\\n' | '\\r' => {\n                    chars.next();\n                }\n\n                // Block delimiters\n                '{' => {\n                    chars.next();\n                    tokens.push(EbaseToken::BlockStart);\n                }\n                '}' => {\n                    chars.next();\n                    tokens.push(EbaseToken::BlockEnd);\n                }\n\n                // String literal\n                '\"' => {\n                    chars.next();\n                    let mut s = String::new();\n                    loop {\n                        match chars.next() {\n                            Some('\"') => break,\n                            Some('\\\\') => {\n                                if let Some(escaped) = chars.next() {\n                                    s.push(match escaped {\n                                        'n' => '\\n',\n                                        't' => '\\t',\n                                        '\\\\' => '\\\\',\n                                        '\"' => '\"',\n                                        other => other,\n                                    });\n                                }\n                            }\n                            Some(c) => s.push(c),\n                            None => {\n                                return Err(EbaseExprError::TokenError {\n                                    position: 0,\n                                    message: \"Unterminated string literal\".to_string(),\n                                })\n                            }\n                        }\n                    }\n                    tokens.push(EbaseToken::String(s));\n                }\n\n                // Symbol (starts with @)\n                '@' => {\n                    chars.next();\n                    let mut name = String::new();\n                    while let Some(&c) = chars.peek() {\n                        if c.is_alphanumeric() || c == '_' {\n                            name.push(c);\n                            chars.next();\n                        } else {\n                            break;\n                        }\n                    }\n                    tokens.push(EbaseToken::Symbol(name));\n                }\n\n                // Number (including negative)\n                c if c.is_ascii_digit() || c == '-' || c == '.' => {\n                    let mut num_str = String::new();\n\n                    // Handle negative sign\n                    if c == '-' {\n                        num_str.push(c);\n                        chars.next();\n                        // Check if next char is a digit or dot\n                        if chars\n                            .peek()\n                            .is_none_or(|&c| !c.is_ascii_digit() && c != '.')\n                        {\n                            // It's the 'neg' or subtraction operator, not a negative number\n                            tokens.push(EbaseToken::Ident(\"-\".to_string()));\n                            continue;\n                        }\n                    }\n\n                    while let Some(&c) = chars.peek() {\n                        if c.is_ascii_digit() || c == '.' || c == 'e' || c == 'E' {\n                            num_str.push(c);\n                            chars.next();\n                        } else {\n                            break;\n                        }\n                    }\n\n                    match num_str.parse::<f64>() {\n                        Ok(n) => tokens.push(EbaseToken::Number(n)),\n                        Err(_) => {\n                            return Err(EbaseExprError::TokenError {\n                                position: 0,\n                                message: format!(\"Invalid number: {}\", num_str),\n                            })\n                        }\n                    }\n                }\n\n                // Identifier\n                c if c.is_alphabetic() || c == '_' => {\n                    let mut ident = String::new();\n                    while let Some(&c) = chars.peek() {\n                        if c.is_alphanumeric() || c == '_' {\n                            ident.push(c);\n                            chars.next();\n                        } else {\n                            break;\n                        }\n                    }\n                    tokens.push(EbaseToken::Ident(ident));\n                }\n\n                // Operators\n                '+' | '*' | '/' => {\n                    chars.next();\n                    tokens.push(EbaseToken::Ident(c.to_string()));\n                }\n\n                // Comparison operators\n                '=' | '!' | '<' | '>' => {\n                    chars.next();\n                    let mut op = c.to_string();\n                    if chars.peek() == Some(&'=') {\n                        chars.next();\n                        op.push('=');\n                    }\n                    tokens.push(EbaseToken::Ident(op));\n                }\n\n                _ => {\n                    return Err(EbaseExprError::TokenError {\n                        position: 0,\n                        message: format!(\"Unexpected character: {}\", c),\n                    })\n                }\n            }\n        }\n\n        Ok(tokens)\n    }\n\n    /// Execute the tokenized expression.\n    fn execute(&mut self, tokens: &[EbaseToken]) -> Result<(), EbaseExprError> {\n        let mut i = 0;\n\n        while i < tokens.len() {\n            match &tokens[i] {\n                EbaseToken::Number(n) => {\n                    self.stack.push(EbaseValue::Float(*n));\n                }\n                EbaseToken::String(s) => {\n                    self.stack.push(EbaseValue::String(s.clone()));\n                }\n                EbaseToken::Symbol(s) => {\n                    self.stack.push(EbaseValue::String(format!(\"@{}\", s)));\n                }\n                EbaseToken::BlockStart => {\n                    // Collect tokens until matching BlockEnd\n                    let mut block_tokens = Vec::new();\n                    let mut depth = 1;\n                    i += 1;\n                    while i < tokens.len() && depth > 0 {\n                        match &tokens[i] {\n                            EbaseToken::BlockStart => {\n                                depth += 1;\n                                block_tokens.push(tokens[i].clone());\n                            }\n                            EbaseToken::BlockEnd => {\n                                depth -= 1;\n                                if depth > 0 {\n                                    block_tokens.push(tokens[i].clone());\n                                }\n                            }\n                            _ => {\n                                block_tokens.push(tokens[i].clone());\n                            }\n                        }\n                        i += 1;\n                    }\n                    if depth != 0 {\n                        return Err(EbaseExprError::InvalidProcedure(\n                            \"Unbalanced braces\".to_string(),\n                        ));\n                    }\n                    self.stack.push(EbaseValue::Proc(block_tokens));\n                    continue; // Skip the i += 1 at the end\n                }\n                EbaseToken::BlockEnd => {\n                    return Err(EbaseExprError::InvalidProcedure(\n                        \"Unexpected '}'\".to_string(),\n                    ));\n                }\n                EbaseToken::Ident(op) => {\n                    self.execute_operator(op)?;\n                }\n            }\n            i += 1;\n        }\n\n        Ok(())\n    }\n\n    /// Execute a single operator.\n    fn execute_operator(&mut self, op: &str) -> Result<(), EbaseExprError> {\n        match op {\n            // Geometry operators\n            \"imp\" => {\n                let sz = self.pop_number()?;\n                let sy = self.pop_number()?;\n                let sx = self.pop_number()?;\n                let filename = self.pop_string()?;\n                self.result = Some(EbaseResult::Import {\n                    filename,\n                    scale: [sx as f32, sy as f32, sz as f32],\n                });\n            }\n            \"clsref\" => {\n                let class = self.pop_string()?;\n                // Collect all remaining numbers as parameters\n                let mut params = Vec::new();\n                loop {\n                    match self.stack.last() {\n                        Some(EbaseValue::Float(n)) => {\n                            params.push(*n);\n                            self.stack.pop();\n                        }\n                        Some(EbaseValue::Int(n)) => {\n                            params.push(*n as f64);\n                            self.stack.pop();\n                        }\n                        _ => break,\n                    }\n                }\n                params.reverse();\n                self.result = Some(EbaseResult::ClsRef { class, params });\n            }\n            \"egms\" => {\n                let name = self.pop_string()?;\n                self.result = Some(EbaseResult::Egms { name });\n            }\n\n            // Arithmetic operators\n            \"+\" | \"add\" => {\n                let b = self.pop_number()?;\n                let a = self.pop_number()?;\n                self.stack.push(EbaseValue::Float(a + b));\n            }\n            \"-\" | \"sub\" => {\n                let b = self.pop_number()?;\n                let a = self.pop_number()?;\n                self.stack.push(EbaseValue::Float(a - b));\n            }\n            \"*\" | \"mul\" => {\n                let b = self.pop_number()?;\n                let a = self.pop_number()?;\n                self.stack.push(EbaseValue::Float(a * b));\n            }\n            \"/\" | \"div\" => {\n                let b = self.pop_number()?;\n                if b == 0.0 {\n                    return Err(EbaseExprError::DivisionByZero);\n                }\n                let a = self.pop_number()?;\n                self.stack.push(EbaseValue::Float(a / b));\n            }\n            \"neg\" => {\n                let a = self.pop_number()?;\n                self.stack.push(EbaseValue::Float(-a));\n            }\n\n            // Comparison operators\n            \"==\" | \"eq\" => {\n                let b = self.pop_value()?;\n                let a = self.pop_value()?;\n                let result = match (&a, &b) {\n                    (EbaseValue::Float(x), EbaseValue::Float(y)) => (x - y).abs() < 1e-10,\n                    (EbaseValue::Int(x), EbaseValue::Int(y)) => x == y,\n                    (EbaseValue::String(x), EbaseValue::String(y)) => x == y,\n                    (EbaseValue::Bool(x), EbaseValue::Bool(y)) => x == y,\n                    _ => false,\n                };\n                self.stack.push(EbaseValue::Bool(result));\n            }\n            \"!=\" | \"ne\" => {\n                let b = self.pop_value()?;\n                let a = self.pop_value()?;\n                let result = match (&a, &b) {\n                    (EbaseValue::Float(x), EbaseValue::Float(y)) => (x - y).abs() >= 1e-10,\n                    (EbaseValue::Int(x), EbaseValue::Int(y)) => x != y,\n                    (EbaseValue::String(x), EbaseValue::String(y)) => x != y,\n                    (EbaseValue::Bool(x), EbaseValue::Bool(y)) => x != y,\n                    _ => true,\n                };\n                self.stack.push(EbaseValue::Bool(result));\n            }\n            \"<\" | \"lt\" => {\n                let b = self.pop_number()?;\n                let a = self.pop_number()?;\n                self.stack.push(EbaseValue::Bool(a < b));\n            }\n            \">\" | \"gt\" => {\n                let b = self.pop_number()?;\n                let a = self.pop_number()?;\n                self.stack.push(EbaseValue::Bool(a > b));\n            }\n            \"<=\" | \"le\" => {\n                let b = self.pop_number()?;\n                let a = self.pop_number()?;\n                self.stack.push(EbaseValue::Bool(a <= b));\n            }\n            \">=\" | \"ge\" => {\n                let b = self.pop_number()?;\n                let a = self.pop_number()?;\n                self.stack.push(EbaseValue::Bool(a >= b));\n            }\n\n            // Logical operators\n            \"and\" => {\n                let b = self.pop_bool()?;\n                let a = self.pop_bool()?;\n                self.stack.push(EbaseValue::Bool(a && b));\n            }\n            \"or\" => {\n                let b = self.pop_bool()?;\n                let a = self.pop_bool()?;\n                self.stack.push(EbaseValue::Bool(a || b));\n            }\n            \"not\" => {\n                let a = self.pop_bool()?;\n                self.stack.push(EbaseValue::Bool(!a));\n            }\n\n            // Conditional operators\n            \"if\" => {\n                let proc = self.pop_proc()?;\n                let cond = self.pop_bool()?;\n                if cond {\n                    self.execute(&proc)?;\n                }\n            }\n            \"ifelse\" => {\n                let else_proc = self.pop_proc()?;\n                let then_proc = self.pop_proc()?;\n                let cond = self.pop_bool()?;\n                if cond {\n                    self.execute(&then_proc)?;\n                } else {\n                    self.execute(&else_proc)?;\n                }\n            }\n\n            // Stack operations\n            \"dup\" => {\n                let v = self.pop_value()?;\n                self.stack.push(v.clone());\n                self.stack.push(v);\n            }\n            \"pop\" => {\n                self.pop_value()?;\n            }\n            \"exch\" => {\n                let b = self.pop_value()?;\n                let a = self.pop_value()?;\n                self.stack.push(b);\n                self.stack.push(a);\n            }\n\n            _ => {\n                // Check if it's a variable reference\n                if let Some(value) = self.variables.get(op) {\n                    self.stack.push(value.clone());\n                } else {\n                    return Err(EbaseExprError::UnknownOperator(op.to_string()));\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Pop a number from the stack.\n    fn pop_number(&mut self) -> Result<f64, EbaseExprError> {\n        match self.stack.pop() {\n            Some(EbaseValue::Float(n)) => Ok(n),\n            Some(EbaseValue::Int(n)) => Ok(n as f64),\n            Some(v) => Err(EbaseExprError::TypeError {\n                expected: \"number\",\n                found: v.type_name().to_string(),\n            }),\n            None => Err(EbaseExprError::StackUnderflow {\n                expected: 1,\n                found: 0,\n            }),\n        }\n    }\n\n    /// Pop a string from the stack.\n    fn pop_string(&mut self) -> Result<String, EbaseExprError> {\n        match self.stack.pop() {\n            Some(EbaseValue::String(s)) => Ok(s),\n            Some(v) => Err(EbaseExprError::TypeError {\n                expected: \"string\",\n                found: v.type_name().to_string(),\n            }),\n            None => Err(EbaseExprError::StackUnderflow {\n                expected: 1,\n                found: 0,\n            }),\n        }\n    }\n\n    /// Pop a boolean from the stack.\n    fn pop_bool(&mut self) -> Result<bool, EbaseExprError> {\n        match self.stack.pop() {\n            Some(EbaseValue::Bool(b)) => Ok(b),\n            Some(v) => Err(EbaseExprError::TypeError {\n                expected: \"boolean\",\n                found: v.type_name().to_string(),\n            }),\n            None => Err(EbaseExprError::StackUnderflow {\n                expected: 1,\n                found: 0,\n            }),\n        }\n    }\n\n    /// Pop a procedure from the stack.\n    fn pop_proc(&mut self) -> Result<Vec<EbaseToken>, EbaseExprError> {\n        match self.stack.pop() {\n            Some(EbaseValue::Proc(tokens)) => Ok(tokens),\n            Some(v) => Err(EbaseExprError::TypeError {\n                expected: \"procedure\",\n                found: v.type_name().to_string(),\n            }),\n            None => Err(EbaseExprError::StackUnderflow {\n                expected: 1,\n                found: 0,\n            }),\n        }\n    }\n\n    /// Pop any value from the stack.\n    fn pop_value(&mut self) -> Result<EbaseValue, EbaseExprError> {\n        self.stack.pop().ok_or(EbaseExprError::StackUnderflow {\n            expected: 1,\n            found: 0,\n        })\n    }\n}\n\nimpl Default for EbaseEvaluator {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_simple_import() {\n        let mut evaluator = EbaseEvaluator::new();\n        let props = HashMap::new();\n        let result = evaluator\n            .evaluate(r#\"\"table_top\" 1 1 1 imp\"#, &props)\n            .unwrap();\n\n        match result {\n            EbaseResult::Import { filename, scale } => {\n                assert_eq!(filename, \"table_top\");\n                assert_eq!(scale, [1.0, 1.0, 1.0]);\n            }\n            _ => panic!(\"Expected Import result\"),\n        }\n    }\n\n    #[test]\n    fn test_import_with_scale() {\n        let mut evaluator = EbaseEvaluator::new();\n        let props = HashMap::new();\n        let result = evaluator\n            .evaluate(r#\"\"panel\" 0.5 2.0 1.5 imp\"#, &props)\n            .unwrap();\n\n        match result {\n            EbaseResult::Import { filename, scale } => {\n                assert_eq!(filename, \"panel\");\n                assert_eq!(scale, [0.5, 2.0, 1.5]);\n            }\n            _ => panic!(\"Expected Import result\"),\n        }\n    }\n\n    #[test]\n    fn test_clsref() {\n        let mut evaluator = EbaseEvaluator::new();\n        let props = HashMap::new();\n        let result = evaluator\n            .evaluate(r#\"100 200 300 \"::ofml::go::GoYLTrans\" clsref\"#, &props)\n            .unwrap();\n\n        match result {\n            EbaseResult::ClsRef { class, params } => {\n                assert_eq!(class, \"::ofml::go::GoYLTrans\");\n                assert_eq!(params, vec![100.0, 200.0, 300.0]);\n            }\n            _ => panic!(\"Expected ClsRef result\"),\n        }\n    }\n\n    #[test]\n    fn test_egms() {\n        let mut evaluator = EbaseEvaluator::new();\n        let props = HashMap::new();\n        let result = evaluator.evaluate(r#\"\"chair_model\" egms\"#, &props).unwrap();\n\n        match result {\n            EbaseResult::Egms { name } => {\n                assert_eq!(name, \"chair_model\");\n            }\n            _ => panic!(\"Expected Egms result\"),\n        }\n    }\n\n    #[test]\n    fn test_variable_substitution() {\n        let mut evaluator = EbaseEvaluator::new();\n        let mut props = HashMap::new();\n        props.insert(\"M__BREITE\".to_string(), 1600.0);\n\n        let result = evaluator\n            .evaluate(r#\"\"panel\" ${M__BREITE:-100} 1000 / 1 1 imp\"#, &props)\n            .unwrap();\n\n        match result {\n            EbaseResult::Import { filename, scale } => {\n                assert_eq!(filename, \"panel\");\n                assert!((scale[0] - 1.6).abs() < 0.001);\n            }\n            _ => panic!(\"Expected Import result\"),\n        }\n    }\n\n    #[test]\n    fn test_variable_default_value() {\n        let mut evaluator = EbaseEvaluator::new();\n        let props = HashMap::new();\n\n        let result = evaluator\n            .evaluate(r#\"\"panel\" ${M__BREITE:-100} 1000 / 1 1 imp\"#, &props)\n            .unwrap();\n\n        match result {\n            EbaseResult::Import { filename, scale } => {\n                assert_eq!(filename, \"panel\");\n                assert!((scale[0] - 0.1).abs() < 0.001);\n            }\n            _ => panic!(\"Expected Import result\"),\n        }\n    }\n\n    #[test]\n    fn test_arithmetic() {\n        let mut evaluator = EbaseEvaluator::new();\n        let props = HashMap::new();\n\n        // Test with calculation\n        let result = evaluator\n            .evaluate(r#\"\"test\" 10 5 + 100 / 1 1 imp\"#, &props)\n            .unwrap();\n\n        match result {\n            EbaseResult::Import { scale, .. } => {\n                assert!((scale[0] - 0.15).abs() < 0.001);\n            }\n            _ => panic!(\"Expected Import result\"),\n        }\n    }\n\n    #[test]\n    fn test_conditional_if() {\n        let mut evaluator = EbaseEvaluator::new();\n        let props = HashMap::new();\n\n        // True condition - should execute proc\n        let result = evaluator\n            .evaluate(r#\"1 1 == { \"true_case\" } if 1 1 1 imp\"#, &props)\n            .unwrap();\n\n        match result {\n            EbaseResult::Import { filename, .. } => {\n                assert_eq!(filename, \"true_case\");\n            }\n            _ => panic!(\"Expected Import result\"),\n        }\n    }\n\n    #[test]\n    fn test_conditional_ifelse() {\n        let mut evaluator = EbaseEvaluator::new();\n        let props = HashMap::new();\n\n        // False condition - should execute else proc\n        let result = evaluator\n            .evaluate(\n                r#\"1 2 == { \"true_case\" } { \"false_case\" } ifelse 1 1 1 imp\"#,\n                &props,\n            )\n            .unwrap();\n\n        match result {\n            EbaseResult::Import { filename, .. } => {\n                assert_eq!(filename, \"false_case\");\n            }\n            _ => panic!(\"Expected Import result\"),\n        }\n    }\n\n    #[test]\n    fn test_stack_underflow() {\n        let mut evaluator = EbaseEvaluator::new();\n        let props = HashMap::new();\n\n        let result = evaluator.evaluate(\"1 imp\", &props);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_unknown_operator() {\n        let mut evaluator = EbaseEvaluator::new();\n        let props = HashMap::new();\n\n        let result = evaluator.evaluate(\"unknown_op\", &props);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_division_by_zero() {\n        let mut evaluator = EbaseEvaluator::new();\n        let props = HashMap::new();\n\n        let result = evaluator.evaluate(\"10 0 /\", &props);\n        assert!(matches!(result, Err(EbaseExprError::DivisionByZero)));\n    }\n\n    #[test]\n    fn test_comparison_operators() {\n        let mut evaluator = EbaseEvaluator::new();\n        let props = HashMap::new();\n\n        // Less than\n        evaluator.stack.clear();\n        evaluator.evaluate(\"5 10 <\", &props).unwrap();\n        assert_eq!(evaluator.stack.pop(), Some(EbaseValue::Bool(true)));\n\n        // Greater than\n        evaluator.stack.clear();\n        evaluator.evaluate(\"10 5 >\", &props).unwrap();\n        assert_eq!(evaluator.stack.pop(), Some(EbaseValue::Bool(true)));\n\n        // Equal\n        evaluator.stack.clear();\n        evaluator.evaluate(\"5 5 ==\", &props).unwrap();\n        assert_eq!(evaluator.stack.pop(), Some(EbaseValue::Bool(true)));\n\n        // Not equal\n        evaluator.stack.clear();\n        evaluator.evaluate(\"5 10 !=\", &props).unwrap();\n        assert_eq!(evaluator.stack.pop(), Some(EbaseValue::Bool(true)));\n    }\n\n    #[test]\n    fn test_evaluate_to_number_simple() {\n        let mut evaluator = EbaseEvaluator::new();\n        let props = HashMap::new();\n\n        // Simple number\n        assert!((evaluator.evaluate_to_number(\"0.5\", &props).unwrap() - 0.5).abs() < 1e-10);\n        assert!((evaluator.evaluate_to_number(\"-0.3\", &props).unwrap() - (-0.3)).abs() < 1e-10);\n        assert!((evaluator.evaluate_to_number(\"0\", &props).unwrap() - 0.0).abs() < 1e-10);\n    }\n\n    #[test]\n    fn test_evaluate_to_number_arithmetic() {\n        let mut evaluator = EbaseEvaluator::new();\n        let props = HashMap::new();\n\n        // Division (common in OFML: 1000 1000 / = 1.0)\n        assert!((evaluator.evaluate_to_number(\"1000 1000 /\", &props).unwrap() - 1.0).abs() < 1e-10);\n\n        // Multiplication\n        assert!((evaluator.evaluate_to_number(\"0.5 2 *\", &props).unwrap() - 1.0).abs() < 1e-10);\n\n        // Addition\n        assert!((evaluator.evaluate_to_number(\"0.3 0.2 +\", &props).unwrap() - 0.5).abs() < 1e-10);\n\n        // Negation\n        assert!((evaluator.evaluate_to_number(\"0.5 neg\", &props).unwrap() - (-0.5)).abs() < 1e-10);\n    }\n\n    #[test]\n    fn test_evaluate_to_number_with_variables() {\n        let mut evaluator = EbaseEvaluator::new();\n        let mut props = HashMap::new();\n        props.insert(\"M__BREITE\".to_string(), 1600.0);\n        props.insert(\"M__TIEFE\".to_string(), 800.0);\n\n        // Variable substitution with default\n        let result = evaluator\n            .evaluate_to_number(\"${M__BREITE:-1000} 1000 /\", &props)\n            .unwrap();\n        assert!((result - 1.6).abs() < 1e-10);\n\n        // Variable without value uses default\n        let result2 = evaluator\n            .evaluate_to_number(\"${UNKNOWN:-500} 1000 /\", &props)\n            .unwrap();\n        assert!((result2 - 0.5).abs() < 1e-10);\n    }\n\n    #[test]\n    fn test_ebase_value_as_f64() {\n        assert_eq!(EbaseValue::Float(1.5).as_f64(), Some(1.5));\n        assert_eq!(EbaseValue::Int(42).as_f64(), Some(42.0));\n        assert_eq!(EbaseValue::String(\"hello\".to_string()).as_f64(), None);\n        assert_eq!(EbaseValue::Bool(true).as_f64(), None);\n        assert_eq!(EbaseValue::Proc(vec![]).as_f64(), None);\n    }\n\n    #[test]\n    fn test_ebase_value_as_string() {\n        assert_eq!(EbaseValue::Float(1.5).as_string(), \"1.5\");\n        assert_eq!(EbaseValue::Int(42).as_string(), \"42\");\n        assert_eq!(EbaseValue::String(\"hello\".to_string()).as_string(), \"hello\");\n        assert_eq!(EbaseValue::Bool(true).as_string(), \"true\");\n        assert_eq!(EbaseValue::Bool(false).as_string(), \"false\");\n        assert_eq!(EbaseValue::Proc(vec![]).as_string(), \"<procedure>\");\n    }\n\n    #[test]\n    fn test_ebase_value_type_name() {\n        assert_eq!(EbaseValue::Float(1.5).type_name(), \"float\");\n        assert_eq!(EbaseValue::Int(42).type_name(), \"integer\");\n        assert_eq!(EbaseValue::String(\"hello\".to_string()).type_name(), \"string\");\n        assert_eq!(EbaseValue::Bool(true).type_name(), \"boolean\");\n        assert_eq!(EbaseValue::Proc(vec![]).type_name(), \"procedure\");\n    }\n\n    #[test]\n    fn test_ebase_result_none() {\n        let mut evaluator = EbaseEvaluator::new();\n        let props = HashMap::new();\n\n        // Expression that doesn't produce import/clsref/egms\n        let result = evaluator.evaluate(\"5 5 +\", &props).unwrap();\n        assert!(matches!(result, EbaseResult::None));\n    }\n\n    #[test]\n    fn test_arithmetic_subtraction() {\n        let mut evaluator = EbaseEvaluator::new();\n        let props = HashMap::new();\n\n        evaluator.stack.clear();\n        evaluator.evaluate(\"10 3 -\", &props).unwrap();\n        assert_eq!(evaluator.stack.pop(), Some(EbaseValue::Float(7.0)));\n    }\n\n    #[test]\n    fn test_stack_swap() {\n        let mut evaluator = EbaseEvaluator::new();\n        let props = HashMap::new();\n\n        evaluator.evaluate(\"1 2 exch\", &props).unwrap();\n        assert_eq!(evaluator.stack.pop(), Some(EbaseValue::Float(1.0)));\n        assert_eq!(evaluator.stack.pop(), Some(EbaseValue::Float(2.0)));\n    }\n\n    #[test]\n    fn test_stack_dup() {\n        let mut evaluator = EbaseEvaluator::new();\n        let props = HashMap::new();\n\n        evaluator.evaluate(\"5 dup\", &props).unwrap();\n        assert_eq!(evaluator.stack.pop(), Some(EbaseValue::Float(5.0)));\n        assert_eq!(evaluator.stack.pop(), Some(EbaseValue::Float(5.0)));\n    }\n\n    #[test]\n    fn test_stack_pop_op() {\n        let mut evaluator = EbaseEvaluator::new();\n        let props = HashMap::new();\n\n        evaluator.evaluate(\"1 2 3 pop\", &props).unwrap();\n        // Only 1 and 2 should remain\n        assert_eq!(evaluator.stack.len(), 2);\n    }\n\n    #[test]\n    fn test_ebase_token_debug() {\n        let token = EbaseToken::Number(42.0);\n        let debug_str = format!(\"{:?}\", token);\n        assert!(debug_str.contains(\"Number\"));\n    }\n\n    #[test]\n    fn test_ebase_result_debug() {\n        let result = EbaseResult::Import {\n            filename: \"test.geo\".to_string(),\n            scale: [1.0, 1.0, 1.0],\n        };\n        let debug_str = format!(\"{:?}\", result);\n        assert!(debug_str.contains(\"Import\"));\n    }\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":15}},{"line":48,"address":[],"length":0,"stats":{"Line":15}},{"line":49,"address":[],"length":0,"stats":{"Line":22}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":6}},{"line":57,"address":[],"length":0,"stats":{"Line":6}},{"line":58,"address":[],"length":0,"stats":{"Line":3}},{"line":59,"address":[],"length":0,"stats":{"Line":3}},{"line":60,"address":[],"length":0,"stats":{"Line":3}},{"line":61,"address":[],"length":0,"stats":{"Line":6}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":5}},{"line":68,"address":[],"length":0,"stats":{"Line":5}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":26}},{"line":154,"address":[],"length":0,"stats":{"Line":52}},{"line":155,"address":[],"length":0,"stats":{"Line":26}},{"line":170,"address":[],"length":0,"stats":{"Line":25}},{"line":176,"address":[],"length":0,"stats":{"Line":50}},{"line":177,"address":[],"length":0,"stats":{"Line":50}},{"line":180,"address":[],"length":0,"stats":{"Line":125}},{"line":183,"address":[],"length":0,"stats":{"Line":100}},{"line":186,"address":[],"length":0,"stats":{"Line":78}},{"line":188,"address":[],"length":0,"stats":{"Line":66}},{"line":213,"address":[],"length":0,"stats":{"Line":10}},{"line":219,"address":[],"length":0,"stats":{"Line":20}},{"line":220,"address":[],"length":0,"stats":{"Line":20}},{"line":223,"address":[],"length":0,"stats":{"Line":50}},{"line":226,"address":[],"length":0,"stats":{"Line":40}},{"line":229,"address":[],"length":0,"stats":{"Line":30}},{"line":232,"address":[],"length":0,"stats":{"Line":20}},{"line":233,"address":[],"length":0,"stats":{"Line":30}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":35}},{"line":256,"address":[],"length":0,"stats":{"Line":70}},{"line":257,"address":[],"length":0,"stats":{"Line":140}},{"line":259,"address":[],"length":0,"stats":{"Line":917}},{"line":260,"address":[],"length":0,"stats":{"Line":446}},{"line":261,"address":[],"length":0,"stats":{"Line":10}},{"line":264,"address":[],"length":0,"stats":{"Line":10}},{"line":265,"address":[],"length":0,"stats":{"Line":10}},{"line":268,"address":[],"length":0,"stats":{"Line":100}},{"line":269,"address":[],"length":0,"stats":{"Line":10}},{"line":270,"address":[],"length":0,"stats":{"Line":10}},{"line":271,"address":[],"length":0,"stats":{"Line":10}},{"line":273,"address":[],"length":0,"stats":{"Line":19}},{"line":274,"address":[],"length":0,"stats":{"Line":5}},{"line":275,"address":[],"length":0,"stats":{"Line":56}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":10}},{"line":284,"address":[],"length":0,"stats":{"Line":5}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":180}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":16}},{"line":298,"address":[],"length":0,"stats":{"Line":9}},{"line":299,"address":[],"length":0,"stats":{"Line":9}},{"line":300,"address":[],"length":0,"stats":{"Line":4}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":872}},{"line":312,"address":[],"length":0,"stats":{"Line":35}},{"line":316,"address":[],"length":0,"stats":{"Line":35}},{"line":317,"address":[],"length":0,"stats":{"Line":70}},{"line":318,"address":[],"length":0,"stats":{"Line":140}},{"line":320,"address":[],"length":0,"stats":{"Line":487}},{"line":321,"address":[],"length":0,"stats":{"Line":37}},{"line":323,"address":[],"length":0,"stats":{"Line":96}},{"line":324,"address":[],"length":0,"stats":{"Line":96}},{"line":328,"address":[],"length":0,"stats":{"Line":3}},{"line":329,"address":[],"length":0,"stats":{"Line":9}},{"line":330,"address":[],"length":0,"stats":{"Line":6}},{"line":332,"address":[],"length":0,"stats":{"Line":3}},{"line":333,"address":[],"length":0,"stats":{"Line":9}},{"line":334,"address":[],"length":0,"stats":{"Line":6}},{"line":339,"address":[],"length":0,"stats":{"Line":22}},{"line":340,"address":[],"length":0,"stats":{"Line":22}},{"line":342,"address":[],"length":0,"stats":{"Line":107}},{"line":343,"address":[],"length":0,"stats":{"Line":11}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":384}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":33}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":454}},{"line":384,"address":[],"length":0,"stats":{"Line":152}},{"line":387,"address":[],"length":0,"stats":{"Line":76}},{"line":388,"address":[],"length":0,"stats":{"Line":6}},{"line":389,"address":[],"length":0,"stats":{"Line":4}},{"line":391,"address":[],"length":0,"stats":{"Line":2}},{"line":393,"address":[],"length":0,"stats":{"Line":3}},{"line":396,"address":[],"length":0,"stats":{"Line":3}},{"line":397,"address":[],"length":0,"stats":{"Line":1}},{"line":401,"address":[],"length":0,"stats":{"Line":422}},{"line":402,"address":[],"length":0,"stats":{"Line":778}},{"line":403,"address":[],"length":0,"stats":{"Line":552}},{"line":404,"address":[],"length":0,"stats":{"Line":138}},{"line":406,"address":[],"length":0,"stats":{"Line":71}},{"line":410,"address":[],"length":0,"stats":{"Line":75}},{"line":411,"address":[],"length":0,"stats":{"Line":300}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":129}},{"line":423,"address":[],"length":0,"stats":{"Line":36}},{"line":424,"address":[],"length":0,"stats":{"Line":156}},{"line":425,"address":[],"length":0,"stats":{"Line":211}},{"line":426,"address":[],"length":0,"stats":{"Line":272}},{"line":427,"address":[],"length":0,"stats":{"Line":68}},{"line":429,"address":[],"length":0,"stats":{"Line":2}},{"line":432,"address":[],"length":0,"stats":{"Line":54}},{"line":436,"address":[],"length":0,"stats":{"Line":13}},{"line":437,"address":[],"length":0,"stats":{"Line":39}},{"line":438,"address":[],"length":0,"stats":{"Line":39}},{"line":443,"address":[],"length":0,"stats":{"Line":12}},{"line":444,"address":[],"length":0,"stats":{"Line":18}},{"line":445,"address":[],"length":0,"stats":{"Line":10}},{"line":446,"address":[],"length":0,"stats":{"Line":12}},{"line":447,"address":[],"length":0,"stats":{"Line":4}},{"line":449,"address":[],"length":0,"stats":{"Line":18}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":35}},{"line":465,"address":[],"length":0,"stats":{"Line":37}},{"line":466,"address":[],"length":0,"stats":{"Line":74}},{"line":468,"address":[],"length":0,"stats":{"Line":320}},{"line":469,"address":[],"length":0,"stats":{"Line":126}},{"line":470,"address":[],"length":0,"stats":{"Line":150}},{"line":471,"address":[],"length":0,"stats":{"Line":150}},{"line":473,"address":[],"length":0,"stats":{"Line":20}},{"line":474,"address":[],"length":0,"stats":{"Line":30}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":6}},{"line":482,"address":[],"length":0,"stats":{"Line":6}},{"line":483,"address":[],"length":0,"stats":{"Line":3}},{"line":484,"address":[],"length":0,"stats":{"Line":27}},{"line":485,"address":[],"length":0,"stats":{"Line":6}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":3}},{"line":492,"address":[],"length":0,"stats":{"Line":3}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":3}},{"line":497,"address":[],"length":0,"stats":{"Line":9}},{"line":500,"address":[],"length":0,"stats":{"Line":6}},{"line":502,"address":[],"length":0,"stats":{"Line":3}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":9}},{"line":508,"address":[],"length":0,"stats":{"Line":3}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":38}},{"line":516,"address":[],"length":0,"stats":{"Line":117}},{"line":519,"address":[],"length":0,"stats":{"Line":120}},{"line":522,"address":[],"length":0,"stats":{"Line":34}},{"line":526,"address":[],"length":0,"stats":{"Line":38}},{"line":527,"address":[],"length":0,"stats":{"Line":38}},{"line":529,"address":[],"length":0,"stats":{"Line":38}},{"line":530,"address":[],"length":0,"stats":{"Line":27}},{"line":531,"address":[],"length":0,"stats":{"Line":27}},{"line":532,"address":[],"length":0,"stats":{"Line":24}},{"line":533,"address":[],"length":0,"stats":{"Line":24}},{"line":534,"address":[],"length":0,"stats":{"Line":16}},{"line":535,"address":[],"length":0,"stats":{"Line":16}},{"line":536,"address":[],"length":0,"stats":{"Line":16}},{"line":539,"address":[],"length":0,"stats":{"Line":29}},{"line":540,"address":[],"length":0,"stats":{"Line":3}},{"line":542,"address":[],"length":0,"stats":{"Line":2}},{"line":544,"address":[],"length":0,"stats":{"Line":8}},{"line":545,"address":[],"length":0,"stats":{"Line":6}},{"line":546,"address":[],"length":0,"stats":{"Line":12}},{"line":547,"address":[],"length":0,"stats":{"Line":3}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":1}},{"line":556,"address":[],"length":0,"stats":{"Line":1}},{"line":557,"address":[],"length":0,"stats":{"Line":2}},{"line":559,"address":[],"length":0,"stats":{"Line":28}},{"line":560,"address":[],"length":0,"stats":{"Line":3}},{"line":561,"address":[],"length":0,"stats":{"Line":2}},{"line":565,"address":[],"length":0,"stats":{"Line":50}},{"line":566,"address":[],"length":0,"stats":{"Line":12}},{"line":567,"address":[],"length":0,"stats":{"Line":12}},{"line":568,"address":[],"length":0,"stats":{"Line":12}},{"line":570,"address":[],"length":0,"stats":{"Line":45}},{"line":571,"address":[],"length":0,"stats":{"Line":3}},{"line":572,"address":[],"length":0,"stats":{"Line":3}},{"line":573,"address":[],"length":0,"stats":{"Line":3}},{"line":575,"address":[],"length":0,"stats":{"Line":42}},{"line":576,"address":[],"length":0,"stats":{"Line":6}},{"line":577,"address":[],"length":0,"stats":{"Line":6}},{"line":578,"address":[],"length":0,"stats":{"Line":6}},{"line":580,"address":[],"length":0,"stats":{"Line":33}},{"line":581,"address":[],"length":0,"stats":{"Line":21}},{"line":582,"address":[],"length":0,"stats":{"Line":7}},{"line":583,"address":[],"length":0,"stats":{"Line":1}},{"line":585,"address":[],"length":0,"stats":{"Line":18}},{"line":586,"address":[],"length":0,"stats":{"Line":18}},{"line":588,"address":[],"length":0,"stats":{"Line":13}},{"line":589,"address":[],"length":0,"stats":{"Line":3}},{"line":590,"address":[],"length":0,"stats":{"Line":3}},{"line":594,"address":[],"length":0,"stats":{"Line":21}},{"line":595,"address":[],"length":0,"stats":{"Line":9}},{"line":596,"address":[],"length":0,"stats":{"Line":9}},{"line":597,"address":[],"length":0,"stats":{"Line":9}},{"line":598,"address":[],"length":0,"stats":{"Line":9}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":9}},{"line":606,"address":[],"length":0,"stats":{"Line":17}},{"line":607,"address":[],"length":0,"stats":{"Line":3}},{"line":608,"address":[],"length":0,"stats":{"Line":3}},{"line":609,"address":[],"length":0,"stats":{"Line":3}},{"line":610,"address":[],"length":0,"stats":{"Line":3}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":3}},{"line":618,"address":[],"length":0,"stats":{"Line":15}},{"line":619,"address":[],"length":0,"stats":{"Line":3}},{"line":620,"address":[],"length":0,"stats":{"Line":3}},{"line":621,"address":[],"length":0,"stats":{"Line":3}},{"line":623,"address":[],"length":0,"stats":{"Line":13}},{"line":624,"address":[],"length":0,"stats":{"Line":3}},{"line":625,"address":[],"length":0,"stats":{"Line":3}},{"line":626,"address":[],"length":0,"stats":{"Line":3}},{"line":628,"address":[],"length":0,"stats":{"Line":12}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":12}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":6}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":6}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":6}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":6}},{"line":657,"address":[],"length":0,"stats":{"Line":3}},{"line":658,"address":[],"length":0,"stats":{"Line":3}},{"line":659,"address":[],"length":0,"stats":{"Line":1}},{"line":660,"address":[],"length":0,"stats":{"Line":3}},{"line":663,"address":[],"length":0,"stats":{"Line":5}},{"line":664,"address":[],"length":0,"stats":{"Line":3}},{"line":665,"address":[],"length":0,"stats":{"Line":3}},{"line":666,"address":[],"length":0,"stats":{"Line":3}},{"line":667,"address":[],"length":0,"stats":{"Line":1}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":3}},{"line":675,"address":[],"length":0,"stats":{"Line":4}},{"line":676,"address":[],"length":0,"stats":{"Line":3}},{"line":677,"address":[],"length":0,"stats":{"Line":4}},{"line":678,"address":[],"length":0,"stats":{"Line":3}},{"line":680,"address":[],"length":0,"stats":{"Line":3}},{"line":681,"address":[],"length":0,"stats":{"Line":2}},{"line":683,"address":[],"length":0,"stats":{"Line":2}},{"line":684,"address":[],"length":0,"stats":{"Line":3}},{"line":685,"address":[],"length":0,"stats":{"Line":3}},{"line":686,"address":[],"length":0,"stats":{"Line":3}},{"line":687,"address":[],"length":0,"stats":{"Line":3}},{"line":692,"address":[],"length":0,"stats":{"Line":2}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":1}},{"line":700,"address":[],"length":0,"stats":{"Line":35}},{"line":704,"address":[],"length":0,"stats":{"Line":58}},{"line":705,"address":[],"length":0,"stats":{"Line":116}},{"line":706,"address":[],"length":0,"stats":{"Line":114}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":1}},{"line":713,"address":[],"length":0,"stats":{"Line":1}},{"line":714,"address":[],"length":0,"stats":{"Line":1}},{"line":720,"address":[],"length":0,"stats":{"Line":10}},{"line":721,"address":[],"length":0,"stats":{"Line":20}},{"line":722,"address":[],"length":0,"stats":{"Line":20}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":2}},{"line":736,"address":[],"length":0,"stats":{"Line":4}},{"line":737,"address":[],"length":0,"stats":{"Line":4}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":3}},{"line":751,"address":[],"length":0,"stats":{"Line":6}},{"line":752,"address":[],"length":0,"stats":{"Line":6}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":12}},{"line":766,"address":[],"length":0,"stats":{"Line":48}},{"line":767,"address":[],"length":0,"stats":{"Line":12}},{"line":768,"address":[],"length":0,"stats":{"Line":12}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}}],"covered":252,"coverable":348},{"path":["/","workspace","crates","ofml-lib","src","env.rs"],"content":"//! Environment for variable scoping\n\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::rc::Rc;\n\nuse crate::value::Value;\n\n/// A scope containing variable bindings\n#[derive(Clone)]\npub struct Scope {\n    /// Variables in this scope\n    vars: HashMap<String, Value>,\n    /// Parent scope (for lexical scoping)\n    parent: Option<Rc<RefCell<Scope>>>,\n}\n\nimpl Scope {\n    /// Create a new global scope\n    pub fn new() -> Self {\n        Self {\n            vars: HashMap::new(),\n            parent: None,\n        }\n    }\n\n    /// Create a child scope\n    pub fn child(parent: Rc<RefCell<Scope>>) -> Self {\n        Self {\n            vars: HashMap::new(),\n            parent: Some(parent),\n        }\n    }\n\n    /// Define a variable in this scope\n    pub fn define(&mut self, name: &str, value: Value) {\n        self.vars.insert(name.to_string(), value);\n    }\n\n    /// Get a variable (searches parent scopes)\n    pub fn get(&self, name: &str) -> Option<Value> {\n        if let Some(val) = self.vars.get(name) {\n            Some(val.clone())\n        } else if let Some(ref parent) = self.parent {\n            parent.borrow().get(name)\n        } else {\n            None\n        }\n    }\n\n    /// Set a variable (searches parent scopes)\n    pub fn set(&mut self, name: &str, value: Value) -> bool {\n        if self.vars.contains_key(name) {\n            self.vars.insert(name.to_string(), value);\n            true\n        } else if let Some(ref parent) = self.parent {\n            parent.borrow_mut().set(name, value)\n        } else {\n            false\n        }\n    }\n\n    /// Check if variable exists\n    pub fn has(&self, name: &str) -> bool {\n        if self.vars.contains_key(name) {\n            true\n        } else if let Some(ref parent) = self.parent {\n            parent.borrow().has(name)\n        } else {\n            false\n        }\n    }\n}\n\nimpl Default for Scope {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Environment manages the scope stack\npub struct Environment {\n    /// Current scope\n    current: Rc<RefCell<Scope>>,\n    /// Global scope (always accessible)\n    global: Rc<RefCell<Scope>>,\n}\n\nimpl Environment {\n    /// Create a new environment\n    pub fn new() -> Self {\n        let global = Rc::new(RefCell::new(Scope::new()));\n        Self {\n            current: global.clone(),\n            global,\n        }\n    }\n\n    /// Push a new scope\n    pub fn push_scope(&mut self) {\n        let new_scope = Scope::child(self.current.clone());\n        self.current = Rc::new(RefCell::new(new_scope));\n    }\n\n    /// Pop the current scope\n    pub fn pop_scope(&mut self) {\n        let parent = self.current.borrow().parent.clone();\n        if let Some(p) = parent {\n            self.current = p;\n        }\n    }\n\n    /// Define a variable in current scope\n    pub fn define(&mut self, name: &str, value: Value) {\n        self.current.borrow_mut().define(name, value);\n    }\n\n    /// Define a global variable\n    pub fn define_global(&mut self, name: &str, value: Value) {\n        self.global.borrow_mut().define(name, value);\n    }\n\n    /// Get a variable\n    pub fn get(&self, name: &str) -> Option<Value> {\n        self.current\n            .borrow()\n            .get(name)\n            .or_else(|| self.global.borrow().get(name))\n    }\n\n    /// Set a variable\n    pub fn set(&mut self, name: &str, value: Value) -> bool {\n        self.current.borrow_mut().set(name, value.clone())\n            || self.global.borrow_mut().set(name, value)\n    }\n\n    /// Get or define (for assignment to undefined variables)\n    pub fn set_or_define(&mut self, name: &str, value: Value) {\n        if !self.set(name, value.clone()) {\n            self.define(name, value);\n        }\n    }\n}\n\nimpl Default for Environment {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_scope_new() {\n        let scope = Scope::new();\n        assert!(scope.parent.is_none());\n        assert!(scope.vars.is_empty());\n    }\n\n    #[test]\n    fn test_scope_default() {\n        let scope = Scope::default();\n        assert!(scope.parent.is_none());\n    }\n\n    #[test]\n    fn test_scope_define_get() {\n        let mut scope = Scope::new();\n        scope.define(\"x\", Value::Int(42));\n\n        let val = scope.get(\"x\");\n        assert!(val.is_some());\n        match val.unwrap() {\n            Value::Int(n) => assert_eq!(n, 42),\n            _ => panic!(\"Expected Int\"),\n        }\n    }\n\n    #[test]\n    fn test_scope_get_not_found() {\n        let scope = Scope::new();\n        assert!(scope.get(\"nonexistent\").is_none());\n    }\n\n    #[test]\n    fn test_scope_child() {\n        let parent = Rc::new(RefCell::new(Scope::new()));\n        parent.borrow_mut().define(\"x\", Value::Int(10));\n\n        let child = Scope::child(parent.clone());\n\n        // Child can access parent's variables\n        let val = child.get(\"x\");\n        assert!(val.is_some());\n    }\n\n    #[test]\n    fn test_scope_child_shadows_parent() {\n        let parent = Rc::new(RefCell::new(Scope::new()));\n        parent.borrow_mut().define(\"x\", Value::Int(10));\n\n        let mut child = Scope::child(parent.clone());\n        child.define(\"x\", Value::Int(20));\n\n        // Child's value shadows parent\n        match child.get(\"x\").unwrap() {\n            Value::Int(n) => assert_eq!(n, 20),\n            _ => panic!(\"Expected Int\"),\n        }\n    }\n\n    #[test]\n    fn test_scope_set_local() {\n        let mut scope = Scope::new();\n        scope.define(\"x\", Value::Int(1));\n\n        let result = scope.set(\"x\", Value::Int(2));\n        assert!(result);\n\n        match scope.get(\"x\").unwrap() {\n            Value::Int(n) => assert_eq!(n, 2),\n            _ => panic!(\"Expected Int\"),\n        }\n    }\n\n    #[test]\n    fn test_scope_set_not_found() {\n        let mut scope = Scope::new();\n        let result = scope.set(\"y\", Value::Int(1));\n        assert!(!result);\n    }\n\n    #[test]\n    fn test_scope_set_in_parent() {\n        let parent = Rc::new(RefCell::new(Scope::new()));\n        parent.borrow_mut().define(\"x\", Value::Int(10));\n\n        let mut child = Scope::child(parent.clone());\n        let result = child.set(\"x\", Value::Int(20));\n        assert!(result);\n\n        // Parent's value should be updated\n        let val = parent.borrow().get(\"x\").unwrap();\n        match val {\n            Value::Int(n) => assert_eq!(n, 20),\n            _ => panic!(\"Expected Int\"),\n        }\n    }\n\n    #[test]\n    fn test_scope_has_local() {\n        let mut scope = Scope::new();\n        assert!(!scope.has(\"x\"));\n\n        scope.define(\"x\", Value::Int(1));\n        assert!(scope.has(\"x\"));\n    }\n\n    #[test]\n    fn test_scope_has_in_parent() {\n        let parent = Rc::new(RefCell::new(Scope::new()));\n        parent.borrow_mut().define(\"x\", Value::Int(10));\n\n        let child = Scope::child(parent.clone());\n        assert!(child.has(\"x\"));\n        assert!(!child.has(\"y\"));\n    }\n\n    #[test]\n    fn test_scope_clone() {\n        let mut scope = Scope::new();\n        scope.define(\"x\", Value::Int(42));\n\n        let cloned = scope.clone();\n        match cloned.get(\"x\").unwrap() {\n            Value::Int(n) => assert_eq!(n, 42),\n            _ => panic!(\"Expected Int\"),\n        }\n    }\n\n    #[test]\n    fn test_environment_new() {\n        let env = Environment::new();\n        assert!(env.get(\"anything\").is_none());\n    }\n\n    #[test]\n    fn test_environment_default() {\n        let env = Environment::default();\n        assert!(env.get(\"anything\").is_none());\n    }\n\n    #[test]\n    fn test_environment_define_get() {\n        let mut env = Environment::new();\n        env.define(\"x\", Value::Int(100));\n\n        match env.get(\"x\").unwrap() {\n            Value::Int(n) => assert_eq!(n, 100),\n            _ => panic!(\"Expected Int\"),\n        }\n    }\n\n    #[test]\n    fn test_environment_define_global() {\n        let mut env = Environment::new();\n        env.define_global(\"global_x\", Value::Int(500));\n\n        // Push a new scope\n        env.push_scope();\n\n        // Global should still be accessible\n        match env.get(\"global_x\").unwrap() {\n            Value::Int(n) => assert_eq!(n, 500),\n            _ => panic!(\"Expected Int\"),\n        }\n    }\n\n    #[test]\n    fn test_environment_push_pop_scope() {\n        let mut env = Environment::new();\n        env.define(\"outer\", Value::Int(1));\n\n        env.push_scope();\n        env.define(\"inner\", Value::Int(2));\n\n        // Both are accessible\n        assert!(env.get(\"outer\").is_some());\n        assert!(env.get(\"inner\").is_some());\n\n        env.pop_scope();\n\n        // Only outer should be accessible now\n        assert!(env.get(\"outer\").is_some());\n        assert!(env.get(\"inner\").is_none());\n    }\n\n    #[test]\n    fn test_environment_set() {\n        let mut env = Environment::new();\n        env.define(\"x\", Value::Int(1));\n\n        let result = env.set(\"x\", Value::Int(10));\n        assert!(result);\n\n        match env.get(\"x\").unwrap() {\n            Value::Int(n) => assert_eq!(n, 10),\n            _ => panic!(\"Expected Int\"),\n        }\n    }\n\n    #[test]\n    fn test_environment_set_not_found() {\n        let mut env = Environment::new();\n        let result = env.set(\"nonexistent\", Value::Int(1));\n        assert!(!result);\n    }\n\n    #[test]\n    fn test_environment_set_or_define_existing() {\n        let mut env = Environment::new();\n        env.define(\"x\", Value::Int(1));\n\n        env.set_or_define(\"x\", Value::Int(100));\n\n        match env.get(\"x\").unwrap() {\n            Value::Int(n) => assert_eq!(n, 100),\n            _ => panic!(\"Expected Int\"),\n        }\n    }\n\n    #[test]\n    fn test_environment_set_or_define_new() {\n        let mut env = Environment::new();\n\n        env.set_or_define(\"y\", Value::Int(200));\n\n        match env.get(\"y\").unwrap() {\n            Value::Int(n) => assert_eq!(n, 200),\n            _ => panic!(\"Expected Int\"),\n        }\n    }\n\n    #[test]\n    fn test_environment_nested_scopes() {\n        let mut env = Environment::new();\n        env.define(\"level0\", Value::Int(0));\n\n        env.push_scope();\n        env.define(\"level1\", Value::Int(1));\n\n        env.push_scope();\n        env.define(\"level2\", Value::Int(2));\n\n        // All levels accessible\n        assert!(env.get(\"level0\").is_some());\n        assert!(env.get(\"level1\").is_some());\n        assert!(env.get(\"level2\").is_some());\n\n        env.pop_scope();\n        assert!(env.get(\"level2\").is_none());\n\n        env.pop_scope();\n        assert!(env.get(\"level1\").is_none());\n\n        // level0 is still there\n        assert!(env.get(\"level0\").is_some());\n    }\n\n    #[test]\n    fn test_environment_pop_global_scope() {\n        let mut env = Environment::new();\n        env.define(\"x\", Value::Int(1));\n\n        // Popping the global scope should be a no-op\n        env.pop_scope();\n\n        // x should still be accessible\n        assert!(env.get(\"x\").is_some());\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":155}},{"line":22,"address":[],"length":0,"stats":{"Line":155}},{"line":28,"address":[],"length":0,"stats":{"Line":132}},{"line":30,"address":[],"length":0,"stats":{"Line":132}},{"line":31,"address":[],"length":0,"stats":{"Line":132}},{"line":36,"address":[],"length":0,"stats":{"Line":22169}},{"line":37,"address":[],"length":0,"stats":{"Line":110845}},{"line":41,"address":[],"length":0,"stats":{"Line":601}},{"line":42,"address":[],"length":0,"stats":{"Line":1607}},{"line":43,"address":[],"length":0,"stats":{"Line":405}},{"line":44,"address":[],"length":0,"stats":{"Line":373}},{"line":45,"address":[],"length":0,"stats":{"Line":354}},{"line":47,"address":[],"length":0,"stats":{"Line":19}},{"line":52,"address":[],"length":0,"stats":{"Line":166}},{"line":53,"address":[],"length":0,"stats":{"Line":498}},{"line":54,"address":[],"length":0,"stats":{"Line":410}},{"line":55,"address":[],"length":0,"stats":{"Line":82}},{"line":56,"address":[],"length":0,"stats":{"Line":163}},{"line":57,"address":[],"length":0,"stats":{"Line":237}},{"line":59,"address":[],"length":0,"stats":{"Line":5}},{"line":64,"address":[],"length":0,"stats":{"Line":6}},{"line":65,"address":[],"length":0,"stats":{"Line":18}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":6}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":143}},{"line":92,"address":[],"length":0,"stats":{"Line":572}},{"line":94,"address":[],"length":0,"stats":{"Line":286}},{"line":100,"address":[],"length":0,"stats":{"Line":128}},{"line":101,"address":[],"length":0,"stats":{"Line":512}},{"line":102,"address":[],"length":0,"stats":{"Line":512}},{"line":106,"address":[],"length":0,"stats":{"Line":128}},{"line":107,"address":[],"length":0,"stats":{"Line":384}},{"line":108,"address":[],"length":0,"stats":{"Line":382}},{"line":109,"address":[],"length":0,"stats":{"Line":127}},{"line":114,"address":[],"length":0,"stats":{"Line":184}},{"line":115,"address":[],"length":0,"stats":{"Line":552}},{"line":119,"address":[],"length":0,"stats":{"Line":21976}},{"line":120,"address":[],"length":0,"stats":{"Line":65928}},{"line":124,"address":[],"length":0,"stats":{"Line":408}},{"line":125,"address":[],"length":0,"stats":{"Line":816}},{"line":127,"address":[],"length":0,"stats":{"Line":408}},{"line":128,"address":[],"length":0,"stats":{"Line":435}},{"line":132,"address":[],"length":0,"stats":{"Line":82}},{"line":133,"address":[],"length":0,"stats":{"Line":328}},{"line":134,"address":[],"length":0,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":80}},{"line":139,"address":[],"length":0,"stats":{"Line":321}},{"line":140,"address":[],"length":0,"stats":{"Line":3}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":147,"address":[],"length":0,"stats":{"Line":1}}],"covered":54,"coverable":54},{"path":["/","workspace","crates","ofml-lib","src","errors.rs"],"content":"//! Error types for the OFML interpreter.\n//!\n//! This module provides unified error handling using `thiserror` for all\n//! components of the OFML interpreter engine.\n\nuse thiserror::Error;\n\n/// Errors that can occur during EBASE expression evaluation.\n#[derive(Debug, Error)]\npub enum EbaseExprError {\n    /// Unknown operator encountered in expression\n    #[error(\"Unknown operator: {0}\")]\n    UnknownOperator(String),\n\n    /// Stack underflow during operation\n    #[error(\"Stack underflow: expected {expected} values, found {found}\")]\n    StackUnderflow { expected: usize, found: usize },\n\n    /// Type mismatch during operation\n    #[error(\"Type error: expected {expected}, found {found}\")]\n    TypeError {\n        expected: &'static str,\n        found: String,\n    },\n\n    /// Variable substitution failed\n    #[error(\"Variable substitution failed: {0}\")]\n    VariableSubstitution(String),\n\n    /// Invalid procedure block\n    #[error(\"Invalid procedure block: {0}\")]\n    InvalidProcedure(String),\n\n    /// Division by zero\n    #[error(\"Division by zero\")]\n    DivisionByZero,\n\n    /// Tokenization error\n    #[error(\"Tokenization error at position {position}: {message}\")]\n    TokenError { position: usize, message: String },\n}\n\n/// Errors that can occur during material handling.\n#[derive(Debug, Error)]\npub enum MaterialError {\n    /// MAT file parsing error\n    #[error(\"MAT file parse error at line {line}: {message}\")]\n    ParseError { line: usize, message: String },\n\n    /// Material not found\n    #[error(\"Material not found: {0}\")]\n    NotFound(String),\n\n    /// Texture loading error\n    #[error(\"Texture loading error for '{filename}': {message}\")]\n    TextureError { filename: String, message: String },\n\n    /// Texture load error (during image decoding)\n    #[error(\"Failed to load texture '{filename}': {message}\")]\n    TextureLoadError { filename: String, message: String },\n\n    /// Invalid material property\n    #[error(\"Invalid material property '{property}': {message}\")]\n    InvalidProperty { property: String, message: String },\n\n    /// IO error\n    #[error(\"IO error: {0}\")]\n    IoError(#[from] std::io::Error),\n}\n\n/// Errors that can occur during OFML class instantiation.\n#[derive(Debug, Error)]\npub enum OfmlClassError {\n    /// Unknown class\n    #[error(\"Unknown OFML class: {0}\")]\n    UnknownClass(String),\n\n    /// Invalid parameter count\n    #[error(\"Class {class} expected {expected} parameters, got {got}\")]\n    InvalidParamCount {\n        class: String,\n        expected: usize,\n        got: usize,\n    },\n\n    /// Invalid parameter type\n    #[error(\"Class {class} parameter {index}: expected {expected}, got {got}\")]\n    InvalidParamType {\n        class: String,\n        index: usize,\n        expected: &'static str,\n        got: String,\n    },\n\n    /// Transformation error\n    #[error(\"Transformation error in {class}: {message}\")]\n    TransformError { class: String, message: String },\n}\n\n/// Errors that can occur during property handling.\n#[derive(Debug, Error)]\npub enum PropertyError {\n    /// Property not found\n    #[error(\"Property not found: {0}\")]\n    NotFound(String),\n\n    /// Invalid property value\n    #[error(\"Invalid value for property '{property}': {message}\")]\n    InvalidValue { property: String, message: String },\n\n    /// Property is read-only\n    #[error(\"Property '{0}' is read-only\")]\n    ReadOnly(String),\n\n    /// Property validation failed\n    #[error(\"Validation failed for property '{property}': {message}\")]\n    ValidationFailed { property: String, message: String },\n}\n\n/// Errors that can occur during 2D geometry operations.\n#[derive(Debug, Error)]\npub enum Geometry2DError {\n    /// Invalid primitive\n    #[error(\"Invalid 2D primitive: {0}\")]\n    InvalidPrimitive(String),\n\n    /// Transform error\n    #[error(\"Transform error: {0}\")]\n    TransformError(String),\n\n    /// SVG export error\n    #[error(\"SVG export error: {0}\")]\n    SvgExportError(String),\n\n    /// Invalid attribute\n    #[error(\"Invalid attribute '{attribute}': {message}\")]\n    InvalidAttribute { attribute: String, message: String },\n}\n\n/// Errors that can occur during attachment point handling.\n#[derive(Debug, Error)]\npub enum AttachmentError {\n    /// Attachment point not found\n    #[error(\"Attachment point not found: {0}\")]\n    NotFound(String),\n\n    /// Invalid attachment direction\n    #[error(\"Invalid attachment direction: must be unit vector\")]\n    InvalidDirection,\n\n    /// Incompatible attachment types\n    #[error(\"Incompatible attachment types: {point1} and {point2}\")]\n    IncompatibleTypes { point1: String, point2: String },\n}\n\n/// Errors that can occur during article configuration.\n#[derive(Debug, Error)]\npub enum ArticleError {\n    /// Article not found\n    #[error(\"Article not found: {0}\")]\n    NotFound(String),\n\n    /// Missing required property\n    #[error(\"Missing required property '{property}' for article '{article}'\")]\n    MissingProperty { article: String, property: String },\n\n    /// Invalid article configuration\n    #[error(\"Invalid configuration for article '{article}': {message}\")]\n    InvalidConfiguration { article: String, message: String },\n\n    /// ODB record not found\n    #[error(\"ODB record not found for '{0}'\")]\n    OdbNotFound(String),\n}\n\n/// Errors that can occur during GObject operations.\n#[derive(Debug, Error)]\npub enum GObjectError {\n    /// Parse error\n    #[error(\"GObject parse error: {0}\")]\n    ParseError(String),\n\n    /// Type conversion error\n    #[error(\"Cannot convert {from} to {to}\")]\n    ConversionError { from: String, to: String },\n\n    /// Invalid operation\n    #[error(\"Invalid operation on {type_name}: {operation}\")]\n    InvalidOperation {\n        type_name: String,\n        operation: String,\n    },\n\n    /// Index out of bounds\n    #[error(\"Index {index} out of bounds for sequence of length {length}\")]\n    IndexOutOfBounds { index: usize, length: usize },\n\n    /// Key not found in dictionary\n    #[error(\"Key not found in dictionary: {0}\")]\n    KeyNotFound(String),\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_ebase_expr_error_display() {\n        let err = EbaseExprError::UnknownOperator(\"foo\".to_string());\n        assert_eq!(format!(\"{}\", err), \"Unknown operator: foo\");\n\n        let err = EbaseExprError::StackUnderflow {\n            expected: 2,\n            found: 1,\n        };\n        assert_eq!(\n            format!(\"{}\", err),\n            \"Stack underflow: expected 2 values, found 1\"\n        );\n\n        let err = EbaseExprError::TypeError {\n            expected: \"number\",\n            found: \"string\".to_string(),\n        };\n        assert_eq!(\n            format!(\"{}\", err),\n            \"Type error: expected number, found string\"\n        );\n    }\n\n    #[test]\n    fn test_material_error_display() {\n        let err = MaterialError::NotFound(\"wood_oak\".to_string());\n        assert_eq!(format!(\"{}\", err), \"Material not found: wood_oak\");\n    }\n\n    #[test]\n    fn test_ofml_class_error_display() {\n        let err = OfmlClassError::UnknownClass(\"::unknown::Class\".to_string());\n        assert_eq!(format!(\"{}\", err), \"Unknown OFML class: ::unknown::Class\");\n\n        let err = OfmlClassError::InvalidParamCount {\n            class: \"GoYLTrans\".to_string(),\n            expected: 3,\n            got: 2,\n        };\n        assert_eq!(\n            format!(\"{}\", err),\n            \"Class GoYLTrans expected 3 parameters, got 2\"\n        );\n    }\n\n    #[test]\n    fn test_property_error_display() {\n        let err = PropertyError::NotFound(\"M__BREITE\".to_string());\n        assert_eq!(format!(\"{}\", err), \"Property not found: M__BREITE\");\n\n        let err = PropertyError::ReadOnly(\"readonly_prop\".to_string());\n        assert_eq!(format!(\"{}\", err), \"Property 'readonly_prop' is read-only\");\n    }\n\n    #[test]\n    fn test_gobject_error_display() {\n        let err = GObjectError::KeyNotFound(\"missing_key\".to_string());\n        assert_eq!(\n            format!(\"{}\", err),\n            \"Key not found in dictionary: missing_key\"\n        );\n\n        let err = GObjectError::IndexOutOfBounds {\n            index: 5,\n            length: 3,\n        };\n        assert_eq!(\n            format!(\"{}\", err),\n            \"Index 5 out of bounds for sequence of length 3\"\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","src","geometry.rs"],"content":"//! Geometry handling for OFML - 3DS/OBJ parsing and GLTF export\n\nuse byteorder::{LittleEndian, ReadBytesExt};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::io::{self, BufRead, BufReader, Cursor, Read, Seek, SeekFrom};\n\n/// 3DS Chunk IDs\nmod chunk {\n    pub const MAIN: u16 = 0x4D4D;\n    pub const EDITOR_3D: u16 = 0x3D3D;\n    pub const OBJECT: u16 = 0x4000;\n    pub const TRIMESH: u16 = 0x4100;\n    pub const VERTICES: u16 = 0x4110;\n    pub const FACES: u16 = 0x4120;\n    pub const FACE_MATERIAL: u16 = 0x4130;\n    pub const TEX_COORDS: u16 = 0x4140;\n    pub const MESH_MATRIX: u16 = 0x4160;\n    pub const MATERIAL: u16 = 0xAFFF;\n    pub const MAT_NAME: u16 = 0xA000;\n    pub const MAT_AMBIENT: u16 = 0xA010;\n    pub const MAT_DIFFUSE: u16 = 0xA020;\n    pub const MAT_SPECULAR: u16 = 0xA030;\n    pub const COLOR_24: u16 = 0x0011;\n    pub const COLOR_F: u16 = 0x0010;\n    pub const LIN_COLOR_24: u16 = 0x0012;\n}\n\n/// A 3D vertex\n#[derive(Debug, Clone, Copy, Default, Serialize, Deserialize)]\npub struct Vertex {\n    pub x: f32,\n    pub y: f32,\n    pub z: f32,\n}\n\nimpl Vertex {\n    pub fn new(x: f32, y: f32, z: f32) -> Self {\n        Self { x, y, z }\n    }\n\n    /// Convert from 3DS coordinate system (Z-up) to GLTF (Y-up)\n    pub fn to_gltf_coords(&self) -> Self {\n        Self {\n            x: self.x,\n            y: self.z,  // 3DS Z becomes GLTF Y\n            z: -self.y, // 3DS Y becomes GLTF -Z\n        }\n    }\n}\n\n/// A triangle face\n#[derive(Debug, Clone, Copy, Default)]\npub struct Face {\n    pub a: u16,\n    pub b: u16,\n    pub c: u16,\n    pub flags: u16,\n}\n\n/// Coordinate system for mesh vertices\n#[derive(Debug, Clone, Copy, Default, PartialEq)]\npub enum CoordSystem {\n    /// 3DS coordinate system (Z-up, Y-into-screen)\n    #[default]\n    Zup3DS,\n    /// GLTF/OFML coordinate system (Y-up, Z-out-of-screen)\n    YupGltf,\n}\n\n/// A mesh object (geometry data from 3DS, OBJ, GEO, or procedural generation)\n#[derive(Debug, Clone, Default)]\npub struct Mesh {\n    pub name: String,\n    pub vertices: Vec<Vertex>,\n    pub normals: Vec<Vertex>,\n    pub faces: Vec<Face>,\n    pub tex_coords: Vec<[f32; 2]>,\n    pub material_name: Option<String>,\n    pub transform: [f32; 12], // 4x3 transformation matrix\n    /// Coordinate system of the vertices (determines if conversion is needed)\n    pub coord_system: CoordSystem,\n}\n\n/// Backwards-compatible type alias\n#[deprecated(note = \"Use `Mesh` instead\")]\npub type Mesh3DS = Mesh;\n\n/// Material from 3DS file\n#[derive(Debug, Clone, Default)]\npub struct Material3DS {\n    pub name: String,\n    pub ambient: [f32; 3],\n    pub diffuse: [f32; 3],\n    pub specular: [f32; 3],\n    /// Optional texture filename for the diffuse channel\n    pub texture: Option<String>,\n    /// Metallic factor for PBR (0.0 = dielectric, 1.0 = metal)\n    pub metallic: f32,\n    /// Roughness factor for PBR (0.0 = smooth, 1.0 = rough)\n    pub roughness: f32,\n}\n\n/// Embedded texture data for GLB export\n#[derive(Debug, Clone)]\npub struct EmbeddedTexture {\n    /// Texture name\n    pub name: String,\n    /// PNG-encoded image data\n    pub data: Vec<u8>,\n    /// Image width\n    pub width: u32,\n    /// Image height\n    pub height: u32,\n}\n\n/// A 3DS scene\n#[derive(Debug, Clone, Default)]\npub struct Scene3DS {\n    pub meshes: Vec<Mesh>,\n    pub materials: HashMap<String, Material3DS>,\n    /// Embedded textures for GLB export\n    pub textures: Vec<EmbeddedTexture>,\n}\n\n/// Axis-aligned bounding box\n#[derive(Debug, Clone, Copy, PartialEq)]\npub struct BoundingBox {\n    pub min: [f32; 3],\n    pub max: [f32; 3],\n}\n\nimpl BoundingBox {\n    /// Create an empty bounding box\n    pub fn empty() -> Self {\n        BoundingBox {\n            min: [f32::INFINITY, f32::INFINITY, f32::INFINITY],\n            max: [f32::NEG_INFINITY, f32::NEG_INFINITY, f32::NEG_INFINITY],\n        }\n    }\n\n    /// Check if bounding box is valid (not empty)\n    pub fn is_valid(&self) -> bool {\n        self.min[0] <= self.max[0] && self.min[1] <= self.max[1] && self.min[2] <= self.max[2]\n    }\n\n    /// Get dimensions (width, height, depth)\n    pub fn dimensions(&self) -> [f32; 3] {\n        if !self.is_valid() {\n            return [0.0, 0.0, 0.0];\n        }\n        [\n            self.max[0] - self.min[0],\n            self.max[1] - self.min[1],\n            self.max[2] - self.min[2],\n        ]\n    }\n\n    /// Get center point\n    pub fn center(&self) -> [f32; 3] {\n        if !self.is_valid() {\n            return [0.0, 0.0, 0.0];\n        }\n        [\n            (self.min[0] + self.max[0]) / 2.0,\n            (self.min[1] + self.max[1]) / 2.0,\n            (self.min[2] + self.max[2]) / 2.0,\n        ]\n    }\n\n    /// Expand to include a point\n    pub fn expand(&mut self, point: [f32; 3]) {\n        self.min[0] = self.min[0].min(point[0]);\n        self.min[1] = self.min[1].min(point[1]);\n        self.min[2] = self.min[2].min(point[2]);\n        self.max[0] = self.max[0].max(point[0]);\n        self.max[1] = self.max[1].max(point[1]);\n        self.max[2] = self.max[2].max(point[2]);\n    }\n\n    /// Merge with another bounding box\n    pub fn merge(&mut self, other: &BoundingBox) {\n        if !other.is_valid() {\n            return;\n        }\n        self.expand(other.min);\n        self.expand(other.max);\n    }\n\n    /// Check if dimensions match expected values within tolerance (in mm)\n    pub fn dimensions_match(&self, expected_mm: [f32; 3], tolerance_mm: f32) -> bool {\n        let dims = self.dimensions();\n        let _tolerance = tolerance_mm / 1000.0; // Convert to meters (reserved for future use)\n        (dims[0] * 1000.0 - expected_mm[0]).abs() <= tolerance_mm\n            && (dims[1] * 1000.0 - expected_mm[1]).abs() <= tolerance_mm\n            && (dims[2] * 1000.0 - expected_mm[2]).abs() <= tolerance_mm\n    }\n}\n\nimpl Mesh {\n    /// Calculate bounding box of the mesh\n    pub fn bounding_box(&self) -> BoundingBox {\n        let mut bbox = BoundingBox::empty();\n        for v in &self.vertices {\n            bbox.expand([v.x, v.y, v.z]);\n        }\n        bbox\n    }\n}\n\nimpl Scene3DS {\n    /// Calculate bounding box of the entire scene\n    pub fn bounding_box(&self) -> BoundingBox {\n        let mut bbox = BoundingBox::empty();\n        for mesh in &self.meshes {\n            bbox.merge(&mesh.bounding_box());\n        }\n        bbox\n    }\n\n    /// Get total vertex count\n    pub fn vertex_count(&self) -> usize {\n        self.meshes.iter().map(|m| m.vertices.len()).sum()\n    }\n\n    /// Get total face count\n    pub fn face_count(&self) -> usize {\n        self.meshes.iter().map(|m| m.faces.len()).sum()\n    }\n}\n\n/// Error type for geometry operations\n#[derive(Debug, thiserror::Error)]\npub enum GeometryError {\n    #[error(\"IO error: {0}\")]\n    Io(#[from] io::Error),\n    #[error(\"Invalid 3DS file: {0}\")]\n    Invalid3DS(String),\n    #[error(\"Invalid OBJ file: {0}\")]\n    InvalidOBJ(String),\n    #[error(\"Invalid GEO file: {0}\")]\n    InvalidGeo(String),\n    #[error(\"ZIP error: {0}\")]\n    Zip(#[from] zip::result::ZipError),\n}\n\n/// Supported geometry file formats\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum GeometryFormat {\n    /// 3D Studio format (.3ds)\n    ThreeDS,\n    /// Wavefront OBJ format (.obj)\n    Obj,\n    /// GEO/OFF format (.geo, .off)\n    Geo,\n    /// Unknown format\n    Unknown,\n}\n\nimpl GeometryFormat {\n    /// Detect format from file extension\n    pub fn from_extension(filename: &str) -> Self {\n        let lower = filename.to_lowercase();\n        if lower.ends_with(\".3ds\") {\n            GeometryFormat::ThreeDS\n        } else if lower.ends_with(\".obj\") {\n            GeometryFormat::Obj\n        } else if lower.ends_with(\".geo\") || lower.ends_with(\".off\") {\n            GeometryFormat::Geo\n        } else {\n            GeometryFormat::Unknown\n        }\n    }\n\n    /// Detect format from file content (magic bytes)\n    pub fn from_content(data: &[u8]) -> Self {\n        if data.len() < 2 {\n            return GeometryFormat::Unknown;\n        }\n\n        // Check for 3DS magic bytes (0x4D4D - MAIN chunk)\n        if data.len() >= 2 && data[0] == 0x4D && data[1] == 0x4D {\n            return GeometryFormat::ThreeDS;\n        }\n\n        // Check for OBJ file (starts with common OBJ commands)\n        if let Ok(text) = std::str::from_utf8(&data[..data.len().min(1024)]) {\n            let text = text.trim_start();\n            // OBJ files typically start with comments (#), mtllib, o, v, or g\n            if text.starts_with('#')\n                || text.starts_with(\"mtllib\")\n                || text.starts_with(\"o \")\n                || text.starts_with(\"v \")\n                || text.starts_with(\"g \")\n                || text.starts_with(\"vn \")\n                || text.starts_with(\"vt \")\n            {\n                return GeometryFormat::Obj;\n            }\n\n            // GEO/OFF files start with vertex/face counts or \"OFF\"\n            if text.starts_with(\"OFF\") {\n                return GeometryFormat::Geo;\n            }\n\n            // Check if first line looks like \"num_verts num_faces\" (GEO format)\n            let first_line = text.lines().next().unwrap_or(\"\");\n            let parts: Vec<&str> = first_line.split_whitespace().collect();\n            if parts.len() >= 2\n                && parts[0].parse::<usize>().is_ok()\n                && parts[1].parse::<usize>().is_ok()\n            {\n                return GeometryFormat::Geo;\n            }\n        }\n\n        GeometryFormat::Unknown\n    }\n\n    /// Detect format using both extension and content\n    pub fn detect(filename: &str, data: &[u8]) -> Self {\n        // First try extension\n        let from_ext = Self::from_extension(filename);\n        if from_ext != GeometryFormat::Unknown {\n            return from_ext;\n        }\n\n        // Fall back to content detection\n        Self::from_content(data)\n    }\n}\n\n/// Parse geometry data with automatic format detection\npub fn parse_geometry_auto(filename: &str, data: &[u8]) -> Result<Scene3DS, GeometryError> {\n    let format = GeometryFormat::detect(filename, data);\n\n    match format {\n        GeometryFormat::ThreeDS => parse_3ds(data),\n        GeometryFormat::Obj => parse_obj(data),\n        GeometryFormat::Geo => parse_geo(data),\n        GeometryFormat::Unknown => {\n            // Try each parser in order\n            if let Ok(scene) = parse_3ds(data) {\n                return Ok(scene);\n            }\n            if let Ok(scene) = parse_obj(data) {\n                return Ok(scene);\n            }\n            if let Ok(scene) = parse_geo(data) {\n                return Ok(scene);\n            }\n            Err(GeometryError::Invalid3DS(\n                \"Unknown geometry format\".to_string(),\n            ))\n        }\n    }\n}\n\n/// Parse a 3DS file\npub fn parse_3ds(data: &[u8]) -> Result<Scene3DS, GeometryError> {\n    let mut cursor = Cursor::new(data);\n    let mut scene = Scene3DS::default();\n\n    // Check main chunk\n    let main_id = cursor.read_u16::<LittleEndian>()?;\n    if main_id != chunk::MAIN {\n        return Err(GeometryError::Invalid3DS(format!(\n            \"Invalid main chunk: {:04X}\",\n            main_id\n        )));\n    }\n    let _main_len = cursor.read_u32::<LittleEndian>()?;\n\n    // Parse chunks\n    parse_chunks(&mut cursor, data.len() as u64, &mut scene)?;\n\n    Ok(scene)\n}\n\nfn parse_chunks<R: Read + Seek>(\n    reader: &mut R,\n    end_pos: u64,\n    scene: &mut Scene3DS,\n) -> Result<(), GeometryError> {\n    while reader.stream_position()? + 6 <= end_pos {\n        let chunk_id = reader.read_u16::<LittleEndian>()?;\n        let chunk_len = reader.read_u32::<LittleEndian>()?;\n        let chunk_end = reader.stream_position()? + (chunk_len as u64 - 6);\n\n        match chunk_id {\n            chunk::EDITOR_3D => {\n                parse_chunks(reader, chunk_end, scene)?;\n            }\n            chunk::OBJECT => {\n                let mesh = parse_object(reader, chunk_end)?;\n                scene.meshes.push(mesh);\n            }\n            chunk::MATERIAL => {\n                let material = parse_material(reader, chunk_end)?;\n                scene.materials.insert(material.name.clone(), material);\n            }\n            _ => {\n                // Skip unknown chunk\n                reader.seek(SeekFrom::Start(chunk_end))?;\n            }\n        }\n\n        if reader.stream_position()? >= end_pos {\n            break;\n        }\n    }\n    Ok(())\n}\n\nfn parse_object<R: Read + Seek>(reader: &mut R, end_pos: u64) -> Result<Mesh, GeometryError> {\n    let mut mesh = Mesh::default();\n\n    // Read null-terminated object name\n    let mut name_bytes = Vec::new();\n    loop {\n        let b = reader.read_u8()?;\n        if b == 0 {\n            break;\n        }\n        name_bytes.push(b);\n    }\n    mesh.name = String::from_utf8_lossy(&name_bytes).to_string();\n\n    // Parse sub-chunks\n    while reader.stream_position()? + 6 <= end_pos {\n        let chunk_id = reader.read_u16::<LittleEndian>()?;\n        let chunk_len = reader.read_u32::<LittleEndian>()?;\n        let chunk_end = reader.stream_position()? + (chunk_len as u64 - 6);\n\n        match chunk_id {\n            chunk::TRIMESH => {\n                parse_trimesh(reader, chunk_end, &mut mesh)?;\n            }\n            _ => {\n                reader.seek(SeekFrom::Start(chunk_end))?;\n            }\n        }\n    }\n\n    Ok(mesh)\n}\n\nfn parse_trimesh<R: Read + Seek>(\n    reader: &mut R,\n    end_pos: u64,\n    mesh: &mut Mesh,\n) -> Result<(), GeometryError> {\n    while reader.stream_position()? + 6 <= end_pos {\n        let chunk_id = reader.read_u16::<LittleEndian>()?;\n        let chunk_len = reader.read_u32::<LittleEndian>()?;\n        let chunk_end = reader.stream_position()? + (chunk_len as u64 - 6);\n\n        match chunk_id {\n            chunk::VERTICES => {\n                let count = reader.read_u16::<LittleEndian>()? as usize;\n                mesh.vertices.reserve(count);\n                for _ in 0..count {\n                    let x = reader.read_f32::<LittleEndian>()?;\n                    let y = reader.read_f32::<LittleEndian>()?;\n                    let z = reader.read_f32::<LittleEndian>()?;\n                    mesh.vertices.push(Vertex::new(x, y, z));\n                }\n            }\n            chunk::FACES => {\n                let count = reader.read_u16::<LittleEndian>()? as usize;\n                mesh.faces.reserve(count);\n                for _ in 0..count {\n                    let a = reader.read_u16::<LittleEndian>()?;\n                    let b = reader.read_u16::<LittleEndian>()?;\n                    let c = reader.read_u16::<LittleEndian>()?;\n                    let flags = reader.read_u16::<LittleEndian>()?;\n                    mesh.faces.push(Face { a, b, c, flags });\n                }\n            }\n            chunk::TEX_COORDS => {\n                let count = reader.read_u16::<LittleEndian>()? as usize;\n                mesh.tex_coords.reserve(count);\n                for _ in 0..count {\n                    let u = reader.read_f32::<LittleEndian>()?;\n                    let v = reader.read_f32::<LittleEndian>()?;\n                    mesh.tex_coords.push([u, v]);\n                }\n            }\n            chunk::MESH_MATRIX => {\n                for i in 0..12 {\n                    mesh.transform[i] = reader.read_f32::<LittleEndian>()?;\n                }\n            }\n            chunk::FACE_MATERIAL => {\n                // Read material name\n                let mut name_bytes = Vec::new();\n                loop {\n                    let b = reader.read_u8()?;\n                    if b == 0 {\n                        break;\n                    }\n                    name_bytes.push(b);\n                }\n                mesh.material_name = Some(String::from_utf8_lossy(&name_bytes).to_string());\n                // Skip face indices for now\n                reader.seek(SeekFrom::Start(chunk_end))?;\n            }\n            _ => {\n                reader.seek(SeekFrom::Start(chunk_end))?;\n            }\n        }\n    }\n\n    Ok(())\n}\n\nfn parse_material<R: Read + Seek>(\n    reader: &mut R,\n    end_pos: u64,\n) -> Result<Material3DS, GeometryError> {\n    let mut material = Material3DS::default();\n\n    while reader.stream_position()? + 6 <= end_pos {\n        let chunk_id = reader.read_u16::<LittleEndian>()?;\n        let chunk_len = reader.read_u32::<LittleEndian>()?;\n        let chunk_end = reader.stream_position()? + (chunk_len as u64 - 6);\n\n        match chunk_id {\n            chunk::MAT_NAME => {\n                let mut name_bytes = Vec::new();\n                loop {\n                    let b = reader.read_u8()?;\n                    if b == 0 {\n                        break;\n                    }\n                    name_bytes.push(b);\n                }\n                material.name = String::from_utf8_lossy(&name_bytes).to_string();\n            }\n            chunk::MAT_AMBIENT => {\n                material.ambient = parse_color(reader, chunk_end)?;\n            }\n            chunk::MAT_DIFFUSE => {\n                material.diffuse = parse_color(reader, chunk_end)?;\n            }\n            chunk::MAT_SPECULAR => {\n                material.specular = parse_color(reader, chunk_end)?;\n            }\n            _ => {\n                reader.seek(SeekFrom::Start(chunk_end))?;\n            }\n        }\n    }\n\n    Ok(material)\n}\n\nfn parse_color<R: Read + Seek>(reader: &mut R, end_pos: u64) -> Result<[f32; 3], GeometryError> {\n    let mut color = [0.5f32; 3];\n\n    while reader.stream_position()? + 6 <= end_pos {\n        let chunk_id = reader.read_u16::<LittleEndian>()?;\n        let chunk_len = reader.read_u32::<LittleEndian>()?;\n        let chunk_end = reader.stream_position()? + (chunk_len as u64 - 6);\n\n        match chunk_id {\n            chunk::COLOR_24 | chunk::LIN_COLOR_24 => {\n                let r = reader.read_u8()?;\n                let g = reader.read_u8()?;\n                let b = reader.read_u8()?;\n                color = [r as f32 / 255.0, g as f32 / 255.0, b as f32 / 255.0];\n            }\n            chunk::COLOR_F => {\n                color[0] = reader.read_f32::<LittleEndian>()?;\n                color[1] = reader.read_f32::<LittleEndian>()?;\n                color[2] = reader.read_f32::<LittleEndian>()?;\n            }\n            _ => {\n                reader.seek(SeekFrom::Start(chunk_end))?;\n            }\n        }\n    }\n\n    Ok(color)\n}\n\n// =============================================================================\n// OBJ Parser\n// =============================================================================\n\n/// Parse an OBJ file from bytes\n/// OBJ files use Y-up coordinate system by convention\npub fn parse_obj(data: &[u8]) -> Result<Scene3DS, GeometryError> {\n    let reader = BufReader::new(Cursor::new(data));\n\n    let mut vertices: Vec<Vertex> = Vec::new();\n    let mut tex_coords: Vec<[f32; 2]> = Vec::new();\n    let mut normals: Vec<Vertex> = Vec::new();\n    let mut faces: Vec<Face> = Vec::new();\n    let mut mesh_name = String::new();\n    let mut current_material: Option<String> = None;\n\n    for line in reader.lines() {\n        let line = line.map_err(|e| GeometryError::InvalidOBJ(e.to_string()))?;\n        let line = line.trim();\n\n        // Skip comments and empty lines\n        if line.is_empty() || line.starts_with('#') {\n            continue;\n        }\n\n        let parts: Vec<&str> = line.split_whitespace().collect();\n        if parts.is_empty() {\n            continue;\n        }\n\n        match parts[0] {\n            \"v\" if parts.len() >= 4 => {\n                // Vertex position: v x y z [w]\n                let x: f32 = parts[1].parse().unwrap_or(0.0);\n                let y: f32 = parts[2].parse().unwrap_or(0.0);\n                let z: f32 = parts[3].parse().unwrap_or(0.0);\n                vertices.push(Vertex::new(x, y, z));\n            }\n            \"vt\" if parts.len() >= 3 => {\n                // Texture coordinate: vt u v [w]\n                let u: f32 = parts[1].parse().unwrap_or(0.0);\n                let v: f32 = parts[2].parse().unwrap_or(0.0);\n                tex_coords.push([u, v]);\n            }\n            \"vn\" if parts.len() >= 4 => {\n                // Vertex normal: vn x y z\n                let x: f32 = parts[1].parse().unwrap_or(0.0);\n                let y: f32 = parts[2].parse().unwrap_or(0.0);\n                let z: f32 = parts[3].parse().unwrap_or(0.0);\n                normals.push(Vertex::new(x, y, z));\n            }\n            \"f\" if parts.len() >= 4 => {\n                // Face: f v1[/vt1][/vn1] v2[/vt2][/vn2] v3[/vt3][/vn3] ...\n                // Parse face indices (OBJ indices are 1-based)\n                let mut face_verts: Vec<u16> = Vec::new();\n                for part in &parts[1..] {\n                    let indices: Vec<&str> = part.split('/').collect();\n                    if let Ok(v_idx) = indices[0].parse::<i32>() {\n                        // Handle negative indices (relative to current vertex count)\n                        let idx = if v_idx < 0 {\n                            (vertices.len() as i32 + v_idx) as u16\n                        } else {\n                            (v_idx - 1) as u16 // Convert to 0-based\n                        };\n                        face_verts.push(idx);\n                    }\n                }\n\n                // Triangulate polygon (fan triangulation)\n                if face_verts.len() >= 3 {\n                    for i in 1..face_verts.len() - 1 {\n                        faces.push(Face {\n                            a: face_verts[0],\n                            b: face_verts[i],\n                            c: face_verts[i + 1],\n                            flags: 0,\n                        });\n                    }\n                }\n            }\n            \"g\" | \"o\" if parts.len() >= 2 => {\n                // Group/object name\n                mesh_name = parts[1..].join(\"_\");\n            }\n            \"usemtl\" if parts.len() >= 2 => {\n                current_material = Some(parts[1].to_string());\n            }\n            _ => {} // Ignore unknown commands\n        }\n    }\n\n    if vertices.is_empty() {\n        return Err(GeometryError::InvalidOBJ(\"No vertices found\".to_string()));\n    }\n\n    let mesh = Mesh {\n        name: if mesh_name.is_empty() {\n            \"obj_mesh\".to_string()\n        } else {\n            mesh_name\n        },\n        vertices,\n        normals,\n        faces,\n        tex_coords,\n        material_name: current_material,\n        transform: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0],\n        coord_system: CoordSystem::YupGltf, // OBJ uses Y-up by convention\n    };\n\n    Ok(Scene3DS {\n        meshes: vec![mesh],\n        materials: HashMap::new(),\n        textures: Vec::new(),\n    })\n}\n\n// =============================================================================\n// GEO Parser\n// =============================================================================\n\n/// Parse a GEO file\n///\n/// # Format\n/// - Line 1: `num_vertices num_faces flags`\n/// - Lines 2 to num_vertices+1: `X Y Z` (vertex coordinates)\n/// - Remaining lines: `3 v1 v2 v3` (triangle faces, 1-indexed)\npub fn parse_geo(data: &[u8]) -> Result<Scene3DS, GeometryError> {\n    let reader = BufReader::new(Cursor::new(data));\n    let mut lines = reader.lines();\n\n    // Parse header\n    let header = lines\n        .next()\n        .ok_or_else(|| GeometryError::InvalidGeo(\"Empty file\".to_string()))?\n        .map_err(|e| GeometryError::InvalidGeo(e.to_string()))?;\n\n    let header_parts: Vec<&str> = header.split_whitespace().collect();\n    if header_parts.len() < 2 {\n        return Err(GeometryError::InvalidGeo(\"Invalid header\".to_string()));\n    }\n\n    let num_vertices: usize = header_parts[0]\n        .parse()\n        .map_err(|_| GeometryError::InvalidGeo(\"Invalid vertex count\".to_string()))?;\n    let num_faces: usize = header_parts[1]\n        .parse()\n        .map_err(|_| GeometryError::InvalidGeo(\"Invalid face count\".to_string()))?;\n\n    // Parse vertices\n    let mut vertices = Vec::with_capacity(num_vertices);\n    for _ in 0..num_vertices {\n        let line = lines\n            .next()\n            .ok_or_else(|| GeometryError::InvalidGeo(\"Unexpected end of file\".to_string()))?\n            .map_err(|e| GeometryError::InvalidGeo(e.to_string()))?;\n\n        let parts: Vec<&str> = line.split_whitespace().collect();\n        if parts.len() < 3 {\n            return Err(GeometryError::InvalidGeo(\"Invalid vertex line\".to_string()));\n        }\n\n        let x: f32 = parts[0].parse().unwrap_or(0.0);\n        let y: f32 = parts[1].parse().unwrap_or(0.0);\n        let z: f32 = parts[2].parse().unwrap_or(0.0);\n\n        // GEO format appears to use Y-up already (like OBJ)\n        vertices.push(Vertex::new(x, y, z));\n    }\n\n    // Parse faces\n    let mut faces = Vec::with_capacity(num_faces);\n    for line in lines {\n        let line = line.map_err(|e| GeometryError::InvalidGeo(e.to_string()))?;\n        let parts: Vec<&str> = line.split_whitespace().collect();\n\n        if parts.len() < 4 || parts[0] != \"3\" {\n            continue; // Skip non-triangle lines\n        }\n\n        // GEO uses 1-indexed vertices\n        let v1: u16 = parts[1].parse::<u16>().unwrap_or(1).saturating_sub(1);\n        let v2: u16 = parts[2].parse::<u16>().unwrap_or(1).saturating_sub(1);\n        let v3: u16 = parts[3].parse::<u16>().unwrap_or(1).saturating_sub(1);\n\n        faces.push(Face {\n            a: v1,\n            b: v2,\n            c: v3,\n            flags: 0,\n        });\n    }\n\n    let mesh = Mesh {\n        name: \"geo_mesh\".to_string(),\n        vertices,\n        normals: Vec::new(),\n        faces,\n        tex_coords: Vec::new(),\n        material_name: None,\n        transform: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0], // Identity matrix\n        coord_system: CoordSystem::YupGltf, // GEO files appear to use Y-up like OBJ\n    };\n\n    Ok(Scene3DS {\n        meshes: vec![mesh],\n        materials: HashMap::new(),\n        textures: Vec::new(),\n    })\n}\n\n/// Load a GEO file from disk\npub fn load_geo(path: &std::path::Path) -> Result<Scene3DS, GeometryError> {\n    let data = std::fs::read(path)?;\n    parse_geo(&data)\n}\n\n/// Load an OBJ file from disk\npub fn load_obj(path: &std::path::Path) -> Result<Scene3DS, GeometryError> {\n    let data = std::fs::read(path)?;\n    parse_obj(&data)\n}\n\n/// Parse a Sch√∂nbuch .mat material file\n/// Format:\n/// mat NAME\n/// amb R G B\n/// dif R G B\n/// spe R G B\n/// tex image jpg FILENAME (optional)\n/// roughness VALUE (optional)\n/// metallic VALUE (optional)\npub fn parse_mat(data: &[u8]) -> Result<Material3DS, GeometryError> {\n    let text = String::from_utf8_lossy(data);\n    let mut name = String::new();\n    let mut ambient = [0.5f32, 0.5, 0.5];\n    let mut diffuse = [0.7f32, 0.7, 0.7];\n    let mut specular = [0.0f32, 0.0, 0.0];\n\n    for line in text.lines() {\n        let parts: Vec<&str> = line.split_whitespace().collect();\n        if parts.is_empty() {\n            continue;\n        }\n\n        match parts[0] {\n            \"mat\" if parts.len() > 1 => {\n                name = parts[1].to_string();\n            }\n            \"amb\" if parts.len() >= 4 => {\n                ambient = [\n                    parts[1].parse().unwrap_or(0.5),\n                    parts[2].parse().unwrap_or(0.5),\n                    parts[3].parse().unwrap_or(0.5),\n                ];\n            }\n            \"dif\" if parts.len() >= 4 => {\n                diffuse = [\n                    parts[1].parse().unwrap_or(0.7),\n                    parts[2].parse().unwrap_or(0.7),\n                    parts[3].parse().unwrap_or(0.7),\n                ];\n            }\n            \"spe\" if parts.len() >= 4 => {\n                specular = [\n                    parts[1].parse().unwrap_or(0.0),\n                    parts[2].parse().unwrap_or(0.0),\n                    parts[3].parse().unwrap_or(0.0),\n                ];\n            }\n            _ => {}\n        }\n    }\n\n    if name.is_empty() {\n        return Err(GeometryError::InvalidGeo(\n            \"No material name found\".to_string(),\n        ));\n    }\n\n    Ok(Material3DS {\n        name,\n        ambient,\n        diffuse,\n        specular,\n        texture: None,\n        metallic: 0.0,\n        roughness: 0.5,\n    })\n}\n\n/// Load a .mat file from disk\npub fn load_mat(path: &std::path::Path) -> Result<Material3DS, GeometryError> {\n    let data = std::fs::read(path)?;\n    parse_mat(&data)\n}\n\n/// Load an OBJ file from an ALB archive\npub fn load_obj_from_alb(\n    alb_path: &std::path::Path,\n    pattern: &str,\n) -> Result<Scene3DS, GeometryError> {\n    let password = b\"Gur#Ynzo$Yvrf%Qbja&Ba*Oebnqjnl.\";\n    let file = std::fs::File::open(alb_path)?;\n    let mut archive = zip::ZipArchive::new(file)?;\n\n    for i in 0..archive.len() {\n        let mut file = match archive.by_index_decrypt(i, password) {\n            Ok(f) => f,\n            Err(_) => continue,\n        };\n\n        let name = file.name().to_lowercase();\n        if name.ends_with(\".obj\") && name.contains(&pattern.to_lowercase()) {\n            let mut data = Vec::new();\n            file.read_to_end(&mut data)?;\n            return parse_obj(&data);\n        }\n    }\n\n    Err(GeometryError::InvalidOBJ(format!(\n        \"No OBJ file matching '{}'\",\n        pattern\n    )))\n}\n\n/// Load an OBJ file from an ALB archive, normalized (center XZ, ground Y)\npub fn load_obj_from_alb_normalized(\n    alb_path: &std::path::Path,\n    pattern: &str,\n) -> Result<Scene3DS, GeometryError> {\n    let mut scene = load_obj_from_alb(alb_path, pattern)?;\n    for mesh in &mut scene.meshes {\n        mesh.normalize();\n    }\n    Ok(scene)\n}\n\n/// Load any supported 3D format from ALB (3DS or OBJ)\n/// Parts are normalized (centered XZ, grounded Y) for consistent positioning\npub fn load_geometry_from_alb(\n    alb_path: &std::path::Path,\n    pattern: &str,\n) -> Result<Scene3DS, GeometryError> {\n    // Try 3DS first - normalize for consistent positioning\n    if let Ok(scene) = load_from_alb_normalized(alb_path, pattern) {\n        return Ok(scene);\n    }\n\n    // Fall back to OBJ - also normalize (OBJ may be pre-centered but normalize for consistency)\n    load_obj_from_alb_normalized(alb_path, pattern)\n}\n\n/// Load any supported 3D format from ALB (3DS or OBJ) - raw coordinates\n/// Only converts coordinate system, does not normalize.\n/// Use this when setAlignment() will be used to control positioning.\n/// Returns the scene and the bounds BEFORE any normalization.\npub fn load_geometry_from_alb_raw(\n    alb_path: &std::path::Path,\n    pattern: &str,\n) -> Result<(Scene3DS, [[f32; 3]; 2]), GeometryError> {\n    // Try 3DS first\n    if let Ok(scene) = load_from_alb_yup_only(alb_path, pattern) {\n        // Calculate bounds from raw geometry\n        let bounds = calculate_scene_bounds(&scene);\n        return Ok((scene, bounds));\n    }\n\n    // Fall back to OBJ\n    let scene = load_obj_from_alb(alb_path, pattern)?;\n    let bounds = calculate_scene_bounds(&scene);\n    Ok((scene, bounds))\n}\n\n/// Calculate the bounding box of all meshes in a scene\nfn calculate_scene_bounds(scene: &Scene3DS) -> [[f32; 3]; 2] {\n    let mut min = [f32::MAX; 3];\n    let mut max = [f32::MIN; 3];\n\n    for mesh in &scene.meshes {\n        for v in &mesh.vertices {\n            min[0] = min[0].min(v.x);\n            min[1] = min[1].min(v.y);\n            min[2] = min[2].min(v.z);\n            max[0] = max[0].max(v.x);\n            max[1] = max[1].max(v.y);\n            max[2] = max[2].max(v.z);\n        }\n    }\n\n    if min[0] == f32::MAX {\n        [[0.0; 3], [0.0; 3]]\n    } else {\n        [min, max]\n    }\n}\n\n// =============================================================================\n// GLTF/GLB Export\n// =============================================================================\n//\n// This section provides functionality to export Scene3DS to GLTF/GLB format.\n//\n// ## Features\n//\n// - **Binary GLB format**: Self-contained file with embedded geometry and textures\n// - **PBR Materials**: Full PBR support with metallic-roughness workflow\n// - **Embedded Textures**: PNG textures embedded in the GLB binary buffer\n// - **Bounding Boxes**: Per-mesh min/max bounds for culling and LOD\n// - **Coordinate Conversion**: Automatic Z-up to Y-up conversion\n// - **Large Mesh Support**: Automatic u16/u32 index selection\n//\n// ## Usage\n//\n// ```rust,ignore\n// use ofml_lib::geometry::{Scene3DS, scene_to_glb};\n//\n// let scene: Scene3DS = /* load geometry */;\n// let glb_data = scene_to_glb(&scene)?;\n// std::fs::write(\"output.glb\", glb_data)?;\n// ```\n//\n// ## Validation\n//\n// Exported GLB files conform to glTF 2.0 specification and can be validated with:\n// - Khronos glTF Validator (https://github.khronos.org/glTF-Validator/)\n// - Three.js GLTFLoader\n// - Blender glTF importer\n\n/// GLTF document root structure (internal).\n#[derive(Serialize)]\nstruct GltfDocument {\n    asset: GltfAsset,\n    scenes: Vec<GltfScene>,\n    nodes: Vec<GltfNode>,\n    meshes: Vec<GltfMesh>,\n    accessors: Vec<GltfAccessor>,\n    #[serde(rename = \"bufferViews\")]\n    buffer_views: Vec<GltfBufferView>,\n    buffers: Vec<GltfBuffer>,\n    #[serde(skip_serializing_if = \"Vec::is_empty\")]\n    materials: Vec<GltfMaterial>,\n}\n\n#[derive(Serialize)]\nstruct GltfAsset {\n    version: String,\n    generator: String,\n}\n\n#[derive(Serialize)]\nstruct GltfScene {\n    nodes: Vec<usize>,\n}\n\n#[derive(Serialize)]\nstruct GltfNode {\n    mesh: Option<usize>,\n    name: Option<String>,\n}\n\n#[derive(Serialize)]\nstruct GltfMesh {\n    primitives: Vec<GltfPrimitive>,\n    name: Option<String>,\n}\n\n#[derive(Serialize)]\nstruct GltfPrimitive {\n    attributes: GltfAttributes,\n    indices: usize,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    material: Option<usize>,\n}\n\n#[derive(Serialize)]\nstruct GltfAttributes {\n    #[serde(rename = \"POSITION\")]\n    position: usize,\n    #[serde(rename = \"NORMAL\", skip_serializing_if = \"Option::is_none\")]\n    normal: Option<usize>,\n}\n\n#[derive(Serialize)]\nstruct GltfAccessor {\n    #[serde(rename = \"bufferView\")]\n    buffer_view: usize,\n    #[serde(rename = \"componentType\")]\n    component_type: u32,\n    count: usize,\n    #[serde(rename = \"type\")]\n    accessor_type: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    min: Option<Vec<f32>>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    max: Option<Vec<f32>>,\n}\n\n#[derive(Serialize)]\nstruct GltfBufferView {\n    buffer: usize,\n    #[serde(rename = \"byteOffset\")]\n    byte_offset: usize,\n    #[serde(rename = \"byteLength\")]\n    byte_length: usize,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    target: Option<u32>,\n}\n\n#[derive(Serialize)]\nstruct GltfBuffer {\n    uri: String,\n    #[serde(rename = \"byteLength\")]\n    byte_length: usize,\n}\n\n#[derive(Serialize)]\nstruct GltfMaterial {\n    name: Option<String>,\n    #[serde(rename = \"pbrMetallicRoughness\")]\n    pbr: GltfPbr,\n}\n\n#[derive(Serialize)]\nstruct GltfPbr {\n    #[serde(rename = \"baseColorFactor\")]\n    base_color_factor: [f32; 4],\n    #[serde(rename = \"metallicFactor\")]\n    metallic_factor: f32,\n    #[serde(rename = \"roughnessFactor\")]\n    roughness_factor: f32,\n    #[serde(rename = \"baseColorTexture\", skip_serializing_if = \"Option::is_none\")]\n    base_color_texture: Option<GltfTextureInfo>,\n}\n\n#[derive(Serialize)]\nstruct GltfTextureInfo {\n    index: usize,\n}\n\n#[derive(Serialize)]\nstruct GltfTexture {\n    sampler: usize,\n    source: usize,\n}\n\n#[derive(Serialize)]\nstruct GltfSampler {\n    #[serde(rename = \"magFilter\")]\n    mag_filter: u32,\n    #[serde(rename = \"minFilter\")]\n    min_filter: u32,\n    #[serde(rename = \"wrapS\")]\n    wrap_s: u32,\n    #[serde(rename = \"wrapT\")]\n    wrap_t: u32,\n}\n\n#[derive(Serialize)]\nstruct GltfImage {\n    #[serde(rename = \"bufferView\")]\n    buffer_view: usize,\n    #[serde(rename = \"mimeType\")]\n    mime_type: String,\n}\n\n/// Convert a Scene3DS to GLTF JSON\npub fn scene_to_gltf(scene: &Scene3DS) -> Result<(String, Vec<u8>), GeometryError> {\n    use base64::Engine;\n\n    let mut binary_data = Vec::new();\n    let mut buffer_views = Vec::new();\n    let mut accessors = Vec::new();\n    let mut meshes = Vec::new();\n    let mut nodes = Vec::new();\n    let mut materials = Vec::new();\n    let mut node_indices = Vec::new();\n\n    // Create materials\n    let mut material_map: HashMap<String, usize> = HashMap::new();\n    for (name, mat) in &scene.materials {\n        material_map.insert(name.clone(), materials.len());\n        materials.push(GltfMaterial {\n            name: Some(name.clone()),\n            pbr: GltfPbr {\n                base_color_factor: [mat.diffuse[0], mat.diffuse[1], mat.diffuse[2], 1.0],\n                metallic_factor: mat.metallic,\n                roughness_factor: mat.roughness,\n                base_color_texture: None, // Textures not supported in data URI GLTF\n            },\n        });\n    }\n\n    for mesh in &scene.meshes {\n        if mesh.vertices.is_empty() || mesh.faces.is_empty() {\n            continue;\n        }\n\n        // Convert vertices to GLTF coordinate system only if they're in 3DS format\n        let vertices: Vec<Vertex> = if mesh.coord_system == CoordSystem::Zup3DS {\n            mesh.vertices.iter().map(|v| v.to_gltf_coords()).collect()\n        } else {\n            mesh.vertices.clone()\n        };\n\n        // Compute bounding box\n        let mut min = [f32::MAX; 3];\n        let mut max = [f32::MIN; 3];\n        for v in &vertices {\n            min[0] = min[0].min(v.x);\n            min[1] = min[1].min(v.y);\n            min[2] = min[2].min(v.z);\n            max[0] = max[0].max(v.x);\n            max[1] = max[1].max(v.y);\n            max[2] = max[2].max(v.z);\n        }\n\n        // Add vertex data\n        let vertex_offset = binary_data.len();\n        for v in &vertices {\n            binary_data.extend_from_slice(&v.x.to_le_bytes());\n            binary_data.extend_from_slice(&v.y.to_le_bytes());\n            binary_data.extend_from_slice(&v.z.to_le_bytes());\n        }\n        let vertex_length = binary_data.len() - vertex_offset;\n\n        buffer_views.push(GltfBufferView {\n            buffer: 0,\n            byte_offset: vertex_offset,\n            byte_length: vertex_length,\n            target: Some(34962), // ARRAY_BUFFER\n        });\n\n        let position_accessor = accessors.len();\n        accessors.push(GltfAccessor {\n            buffer_view: buffer_views.len() - 1,\n            component_type: 5126, // FLOAT\n            count: vertices.len(),\n            accessor_type: \"VEC3\".to_string(),\n            min: Some(min.to_vec()),\n            max: Some(max.to_vec()),\n        });\n\n        // Add normal data if available\n        let normal_accessor =\n            if !mesh.normals.is_empty() && mesh.normals.len() == mesh.vertices.len() {\n                // Convert normals to GLTF coordinate system if needed\n                let normals: Vec<Vertex> = if mesh.coord_system == CoordSystem::Zup3DS {\n                    mesh.normals.iter().map(|v| v.to_gltf_coords()).collect()\n                } else {\n                    mesh.normals.clone()\n                };\n\n                let normal_offset = binary_data.len();\n                for n in &normals {\n                    binary_data.extend_from_slice(&n.x.to_le_bytes());\n                    binary_data.extend_from_slice(&n.y.to_le_bytes());\n                    binary_data.extend_from_slice(&n.z.to_le_bytes());\n                }\n                let normal_length = binary_data.len() - normal_offset;\n\n                buffer_views.push(GltfBufferView {\n                    buffer: 0,\n                    byte_offset: normal_offset,\n                    byte_length: normal_length,\n                    target: Some(34962), // ARRAY_BUFFER\n                });\n\n                let accessor_idx = accessors.len();\n                accessors.push(GltfAccessor {\n                    buffer_view: buffer_views.len() - 1,\n                    component_type: 5126, // FLOAT\n                    count: normals.len(),\n                    accessor_type: \"VEC3\".to_string(),\n                    min: None,\n                    max: None,\n                });\n                Some(accessor_idx)\n            } else {\n                None\n            };\n\n        // Add index data (convert to u32 for larger meshes)\n        // Align to 4 bytes\n        while binary_data.len() % 4 != 0 {\n            binary_data.push(0);\n        }\n        let index_offset = binary_data.len();\n        let use_u32 = mesh.vertices.len() > 65535;\n        for face in &mesh.faces {\n            if use_u32 {\n                binary_data.extend_from_slice(&(face.a as u32).to_le_bytes());\n                binary_data.extend_from_slice(&(face.b as u32).to_le_bytes());\n                binary_data.extend_from_slice(&(face.c as u32).to_le_bytes());\n            } else {\n                binary_data.extend_from_slice(&face.a.to_le_bytes());\n                binary_data.extend_from_slice(&face.b.to_le_bytes());\n                binary_data.extend_from_slice(&face.c.to_le_bytes());\n            }\n        }\n        let index_length = binary_data.len() - index_offset;\n\n        buffer_views.push(GltfBufferView {\n            buffer: 0,\n            byte_offset: index_offset,\n            byte_length: index_length,\n            target: Some(34963), // ELEMENT_ARRAY_BUFFER\n        });\n\n        let index_accessor = accessors.len();\n        accessors.push(GltfAccessor {\n            buffer_view: buffer_views.len() - 1,\n            component_type: if use_u32 { 5125 } else { 5123 }, // UNSIGNED_INT or UNSIGNED_SHORT\n            count: mesh.faces.len() * 3,\n            accessor_type: \"SCALAR\".to_string(),\n            min: None,\n            max: None,\n        });\n\n        // Look up material\n        let material_index = mesh\n            .material_name\n            .as_ref()\n            .and_then(|name| material_map.get(name))\n            .copied();\n\n        meshes.push(GltfMesh {\n            primitives: vec![GltfPrimitive {\n                attributes: GltfAttributes {\n                    position: position_accessor,\n                    normal: normal_accessor,\n                },\n                indices: index_accessor,\n                material: material_index,\n            }],\n            name: Some(mesh.name.clone()),\n        });\n\n        node_indices.push(nodes.len());\n        nodes.push(GltfNode {\n            mesh: Some(meshes.len() - 1),\n            name: Some(mesh.name.clone()),\n        });\n    }\n\n    // Create base64 data URI\n    let data_uri = format!(\n        \"data:application/octet-stream;base64,{}\",\n        base64::engine::general_purpose::STANDARD.encode(&binary_data)\n    );\n\n    let document = GltfDocument {\n        asset: GltfAsset {\n            version: \"2.0\".to_string(),\n            generator: \"OFML Interpreter\".to_string(),\n        },\n        scenes: vec![GltfScene {\n            nodes: node_indices,\n        }],\n        nodes,\n        meshes,\n        accessors,\n        buffer_views,\n        buffers: vec![GltfBuffer {\n            uri: data_uri,\n            byte_length: binary_data.len(),\n        }],\n        materials,\n    };\n\n    let json = serde_json::to_string_pretty(&document)\n        .map_err(|e| GeometryError::Invalid3DS(e.to_string()))?;\n\n    Ok((json, binary_data))\n}\n\n/// Convert a Scene3DS to GLB (binary GLTF)\npub fn scene_to_glb(scene: &Scene3DS) -> Result<Vec<u8>, GeometryError> {\n    let mut binary_data = Vec::new();\n    let mut buffer_views = Vec::new();\n    let mut accessors = Vec::new();\n    let mut meshes = Vec::new();\n    let mut nodes = Vec::new();\n    let mut materials = Vec::new();\n    let mut node_indices = Vec::new();\n    let mut images: Vec<GltfImage> = Vec::new();\n    let mut gltf_textures: Vec<GltfTexture> = Vec::new();\n    let mut samplers: Vec<GltfSampler> = Vec::new();\n\n    // Embed textures in binary data and create images/textures\n    let mut texture_name_to_index: HashMap<String, usize> = HashMap::new();\n    if !scene.textures.is_empty() {\n        // Create one default sampler for all textures\n        samplers.push(GltfSampler {\n            mag_filter: 9729, // LINEAR\n            min_filter: 9987, // LINEAR_MIPMAP_LINEAR\n            wrap_s: 10497,    // REPEAT\n            wrap_t: 10497,    // REPEAT\n        });\n\n        for tex in &scene.textures {\n            // Align to 4 bytes\n            while binary_data.len() % 4 != 0 {\n                binary_data.push(0);\n            }\n\n            let tex_offset = binary_data.len();\n            binary_data.extend_from_slice(&tex.data);\n            let tex_length = tex.data.len();\n\n            // Create buffer view for texture\n            let buffer_view_index = buffer_views.len();\n            buffer_views.push(GltfBufferView {\n                buffer: 0,\n                byte_offset: tex_offset,\n                byte_length: tex_length,\n                target: None, // No target for image buffer views\n            });\n\n            // Create image\n            let image_index = images.len();\n            images.push(GltfImage {\n                buffer_view: buffer_view_index,\n                mime_type: \"image/png\".to_string(),\n            });\n\n            // Create texture\n            let texture_index = gltf_textures.len();\n            gltf_textures.push(GltfTexture {\n                sampler: 0, // Use the default sampler\n                source: image_index,\n            });\n\n            texture_name_to_index.insert(tex.name.clone(), texture_index);\n        }\n    }\n\n    // Create materials\n    let mut material_map: HashMap<String, usize> = HashMap::new();\n    for (name, mat) in &scene.materials {\n        material_map.insert(name.clone(), materials.len());\n\n        // Check if material has a texture\n        let base_color_texture = mat\n            .texture\n            .as_ref()\n            .and_then(|tex_name| texture_name_to_index.get(tex_name))\n            .map(|&idx| GltfTextureInfo { index: idx });\n\n        materials.push(GltfMaterial {\n            name: Some(name.clone()),\n            pbr: GltfPbr {\n                base_color_factor: [mat.diffuse[0], mat.diffuse[1], mat.diffuse[2], 1.0],\n                metallic_factor: mat.metallic,\n                roughness_factor: mat.roughness,\n                base_color_texture,\n            },\n        });\n    }\n\n    for mesh in &scene.meshes {\n        if mesh.vertices.is_empty() || mesh.faces.is_empty() {\n            continue;\n        }\n\n        // Convert vertices to GLTF coordinate system only if they're in 3DS format\n        let vertices: Vec<Vertex> = if mesh.coord_system == CoordSystem::Zup3DS {\n            mesh.vertices.iter().map(|v| v.to_gltf_coords()).collect()\n        } else {\n            mesh.vertices.clone()\n        };\n\n        // Compute bounding box\n        let mut min = [f32::MAX; 3];\n        let mut max = [f32::MIN; 3];\n        for v in &vertices {\n            min[0] = min[0].min(v.x);\n            min[1] = min[1].min(v.y);\n            min[2] = min[2].min(v.z);\n            max[0] = max[0].max(v.x);\n            max[1] = max[1].max(v.y);\n            max[2] = max[2].max(v.z);\n        }\n\n        // Add vertex data\n        let vertex_offset = binary_data.len();\n        for v in &vertices {\n            binary_data.extend_from_slice(&v.x.to_le_bytes());\n            binary_data.extend_from_slice(&v.y.to_le_bytes());\n            binary_data.extend_from_slice(&v.z.to_le_bytes());\n        }\n        let vertex_length = binary_data.len() - vertex_offset;\n\n        buffer_views.push(GltfBufferView {\n            buffer: 0,\n            byte_offset: vertex_offset,\n            byte_length: vertex_length,\n            target: Some(34962),\n        });\n\n        let position_accessor = accessors.len();\n        accessors.push(GltfAccessor {\n            buffer_view: buffer_views.len() - 1,\n            component_type: 5126,\n            count: vertices.len(),\n            accessor_type: \"VEC3\".to_string(),\n            min: Some(min.to_vec()),\n            max: Some(max.to_vec()),\n        });\n\n        // Add normal data if available\n        let normal_accessor =\n            if !mesh.normals.is_empty() && mesh.normals.len() == mesh.vertices.len() {\n                let normals: Vec<Vertex> = if mesh.coord_system == CoordSystem::Zup3DS {\n                    mesh.normals.iter().map(|v| v.to_gltf_coords()).collect()\n                } else {\n                    mesh.normals.clone()\n                };\n\n                let normal_offset = binary_data.len();\n                for n in &normals {\n                    binary_data.extend_from_slice(&n.x.to_le_bytes());\n                    binary_data.extend_from_slice(&n.y.to_le_bytes());\n                    binary_data.extend_from_slice(&n.z.to_le_bytes());\n                }\n                let normal_length = binary_data.len() - normal_offset;\n\n                buffer_views.push(GltfBufferView {\n                    buffer: 0,\n                    byte_offset: normal_offset,\n                    byte_length: normal_length,\n                    target: Some(34962),\n                });\n\n                let accessor_idx = accessors.len();\n                accessors.push(GltfAccessor {\n                    buffer_view: buffer_views.len() - 1,\n                    component_type: 5126,\n                    count: normals.len(),\n                    accessor_type: \"VEC3\".to_string(),\n                    min: None,\n                    max: None,\n                });\n                Some(accessor_idx)\n            } else {\n                None\n            };\n\n        // Add index data\n        while binary_data.len() % 4 != 0 {\n            binary_data.push(0);\n        }\n        let index_offset = binary_data.len();\n        let use_u32 = mesh.vertices.len() > 65535;\n        for face in &mesh.faces {\n            if use_u32 {\n                binary_data.extend_from_slice(&(face.a as u32).to_le_bytes());\n                binary_data.extend_from_slice(&(face.b as u32).to_le_bytes());\n                binary_data.extend_from_slice(&(face.c as u32).to_le_bytes());\n            } else {\n                binary_data.extend_from_slice(&face.a.to_le_bytes());\n                binary_data.extend_from_slice(&face.b.to_le_bytes());\n                binary_data.extend_from_slice(&face.c.to_le_bytes());\n            }\n        }\n        let index_length = binary_data.len() - index_offset;\n\n        buffer_views.push(GltfBufferView {\n            buffer: 0,\n            byte_offset: index_offset,\n            byte_length: index_length,\n            target: Some(34963),\n        });\n\n        let index_accessor = accessors.len();\n        accessors.push(GltfAccessor {\n            buffer_view: buffer_views.len() - 1,\n            component_type: if use_u32 { 5125 } else { 5123 },\n            count: mesh.faces.len() * 3,\n            accessor_type: \"SCALAR\".to_string(),\n            min: None,\n            max: None,\n        });\n\n        let material_index = mesh\n            .material_name\n            .as_ref()\n            .and_then(|name| material_map.get(name))\n            .copied();\n\n        meshes.push(GltfMesh {\n            primitives: vec![GltfPrimitive {\n                attributes: GltfAttributes {\n                    position: position_accessor,\n                    normal: normal_accessor,\n                },\n                indices: index_accessor,\n                material: material_index,\n            }],\n            name: Some(mesh.name.clone()),\n        });\n\n        node_indices.push(nodes.len());\n        nodes.push(GltfNode {\n            mesh: Some(meshes.len() - 1),\n            name: Some(mesh.name.clone()),\n        });\n    }\n\n    // Create GLB document (without uri, using buffer index 0)\n    #[derive(Serialize)]\n    struct GlbBuffer {\n        #[serde(rename = \"byteLength\")]\n        byte_length: usize,\n    }\n\n    #[derive(Serialize)]\n    struct GlbDocument {\n        asset: GltfAsset,\n        scenes: Vec<GltfScene>,\n        nodes: Vec<GltfNode>,\n        meshes: Vec<GltfMesh>,\n        accessors: Vec<GltfAccessor>,\n        #[serde(rename = \"bufferViews\")]\n        buffer_views: Vec<GltfBufferView>,\n        buffers: Vec<GlbBuffer>,\n        #[serde(skip_serializing_if = \"Vec::is_empty\")]\n        materials: Vec<GltfMaterial>,\n        #[serde(skip_serializing_if = \"Vec::is_empty\")]\n        images: Vec<GltfImage>,\n        #[serde(skip_serializing_if = \"Vec::is_empty\")]\n        textures: Vec<GltfTexture>,\n        #[serde(skip_serializing_if = \"Vec::is_empty\")]\n        samplers: Vec<GltfSampler>,\n    }\n\n    let document = GlbDocument {\n        asset: GltfAsset {\n            version: \"2.0\".to_string(),\n            generator: \"OFML Interpreter\".to_string(),\n        },\n        scenes: vec![GltfScene {\n            nodes: node_indices,\n        }],\n        nodes,\n        meshes,\n        accessors,\n        buffer_views,\n        buffers: vec![GlbBuffer {\n            byte_length: binary_data.len(),\n        }],\n        materials,\n        images,\n        textures: gltf_textures,\n        samplers,\n    };\n\n    let json =\n        serde_json::to_string(&document).map_err(|e| GeometryError::Invalid3DS(e.to_string()))?;\n    let json_bytes = json.as_bytes();\n\n    // Pad JSON to 4-byte alignment\n    let json_padding = (4 - (json_bytes.len() % 4)) % 4;\n    let json_chunk_len = json_bytes.len() + json_padding;\n\n    // Pad binary to 4-byte alignment\n    let bin_padding = (4 - (binary_data.len() % 4)) % 4;\n    let bin_chunk_len = binary_data.len() + bin_padding;\n\n    // GLB structure: Header (12) + JSON chunk (8 + data) + BIN chunk (8 + data)\n    let total_length = 12 + 8 + json_chunk_len + 8 + bin_chunk_len;\n\n    let mut glb = Vec::with_capacity(total_length);\n\n    // Header\n    glb.extend_from_slice(b\"glTF\"); // magic\n    glb.extend_from_slice(&2u32.to_le_bytes()); // version\n    glb.extend_from_slice(&(total_length as u32).to_le_bytes()); // length\n\n    // JSON chunk\n    glb.extend_from_slice(&(json_chunk_len as u32).to_le_bytes()); // chunk length\n    glb.extend_from_slice(&0x4E4F534Au32.to_le_bytes()); // chunk type \"JSON\"\n    glb.extend_from_slice(json_bytes);\n    glb.resize(glb.len() + json_padding, 0x20); // Space padding for JSON\n\n    // BIN chunk\n    glb.extend_from_slice(&(bin_chunk_len as u32).to_le_bytes()); // chunk length\n    glb.extend_from_slice(&0x004E4942u32.to_le_bytes()); // chunk type \"BIN\\0\"\n    glb.extend_from_slice(&binary_data);\n    glb.resize(glb.len() + bin_padding, 0); // Zero padding for BIN\n\n    Ok(glb)\n}\n\n/// Load a 3DS file from an ALB archive\npub fn load_from_alb(alb_path: &std::path::Path, pattern: &str) -> Result<Scene3DS, GeometryError> {\n    let password = b\"Gur#Ynzo$Yvrf%Qbja&Ba*Oebnqjnl.\";\n    let file = std::fs::File::open(alb_path)?;\n    let mut archive = zip::ZipArchive::new(file)?;\n\n    for i in 0..archive.len() {\n        // Try to decrypt the file - skip if password fails\n        let mut file = match archive.by_index_decrypt(i, password) {\n            Ok(f) => f,\n            Err(_) => continue,\n        };\n\n        let name = file.name().to_lowercase();\n        if name.ends_with(\".3ds\") && name.contains(&pattern.to_lowercase()) {\n            let mut data = Vec::new();\n            file.read_to_end(&mut data)?;\n            return parse_3ds(&data);\n        }\n    }\n\n    Err(GeometryError::Invalid3DS(format!(\n        \"No 3DS file matching '{}'\",\n        pattern\n    )))\n}\n\n/// Load a 3DS file from an ALB archive, convert to Y-up, and normalize (center XZ, ground Y)\n/// This is the standard loading function for OFML furniture parts\npub fn load_from_alb_normalized(\n    alb_path: &std::path::Path,\n    pattern: &str,\n) -> Result<Scene3DS, GeometryError> {\n    let mut scene = load_from_alb(alb_path, pattern)?;\n    for mesh in &mut scene.meshes {\n        mesh.convert_to_yup();\n        mesh.normalize();\n    }\n    Ok(scene)\n}\n\n/// Load a 3DS file from an ALB archive, convert to Y-up only (keep world coordinates)\n/// Use this when 3DS files have world coordinates that should be preserved\npub fn load_from_alb_yup_only(\n    alb_path: &std::path::Path,\n    pattern: &str,\n) -> Result<Scene3DS, GeometryError> {\n    let mut scene = load_from_alb(alb_path, pattern)?;\n    for mesh in &mut scene.meshes {\n        mesh.convert_to_yup();\n        // Don't normalize - keep world coordinates\n    }\n    Ok(scene)\n}\n\n// =============================================================================\n// Assembly Functions\n// =============================================================================\n\nimpl Mesh {\n    /// Translate all vertices by offset\n    pub fn translate(&mut self, offset: [f32; 3]) {\n        for v in &mut self.vertices {\n            v.x += offset[0];\n            v.y += offset[1];\n            v.z += offset[2];\n        }\n    }\n\n    /// Rotate around X axis (in radians)\n    pub fn rotate_x(&mut self, angle: f32) {\n        let cos_a = angle.cos();\n        let sin_a = angle.sin();\n        for v in &mut self.vertices {\n            let y = v.y;\n            let z = v.z;\n            v.y = y * cos_a - z * sin_a;\n            v.z = y * sin_a + z * cos_a;\n        }\n    }\n\n    /// Rotate around Y axis (in radians)\n    pub fn rotate_y(&mut self, angle: f32) {\n        let cos_a = angle.cos();\n        let sin_a = angle.sin();\n        for v in &mut self.vertices {\n            let x = v.x;\n            let z = v.z;\n            v.x = x * cos_a - z * sin_a;\n            v.z = x * sin_a + z * cos_a;\n        }\n    }\n\n    /// Rotate around Z axis (in radians)\n    pub fn rotate_z(&mut self, angle: f32) {\n        let cos_a = angle.cos();\n        let sin_a = angle.sin();\n        for v in &mut self.vertices {\n            let x = v.x;\n            let y = v.y;\n            v.x = x * cos_a - y * sin_a;\n            v.y = x * sin_a + y * cos_a;\n        }\n    }\n\n    /// Scale uniformly\n    pub fn scale(&mut self, factor: f32) {\n        for v in &mut self.vertices {\n            v.x *= factor;\n            v.y *= factor;\n            v.z *= factor;\n        }\n    }\n\n    /// Get bounding box (min, max)\n    pub fn bounds(&self) -> ([f32; 3], [f32; 3]) {\n        let mut min = [f32::MAX; 3];\n        let mut max = [f32::MIN; 3];\n        for v in &self.vertices {\n            min[0] = min[0].min(v.x);\n            min[1] = min[1].min(v.y);\n            min[2] = min[2].min(v.z);\n            max[0] = max[0].max(v.x);\n            max[1] = max[1].max(v.y);\n            max[2] = max[2].max(v.z);\n        }\n        (min, max)\n    }\n\n    /// Center mesh at origin\n    pub fn center(&mut self) {\n        let (min, max) = self.bounds();\n        let center = [\n            (min[0] + max[0]) / 2.0,\n            (min[1] + max[1]) / 2.0,\n            (min[2] + max[2]) / 2.0,\n        ];\n        self.translate([-center[0], -center[1], -center[2]]);\n    }\n\n    /// Move bottom of mesh to Y=0\n    pub fn ground(&mut self) {\n        let (min, _) = self.bounds();\n        self.translate([0.0, -min[1], 0.0]);\n    }\n\n    /// Center horizontally (XZ) and ground (Y=0 at bottom)\n    /// This is the standard normalization for furniture parts\n    pub fn normalize(&mut self) {\n        let (min, max) = self.bounds();\n        // Center in X and Z\n        let center_x = (min[0] + max[0]) / 2.0;\n        let center_z = (min[2] + max[2]) / 2.0;\n        // Ground in Y\n        self.translate([-center_x, -min[1], -center_z]);\n    }\n\n    /// Convert from 3DS coordinate system (Z-up) to GLTF/OFML (Y-up) in place\n    /// This should be called immediately after loading from 3DS file\n    pub fn convert_to_yup(&mut self) {\n        for v in &mut self.vertices {\n            let old_y = v.y;\n            let old_z = v.z;\n            v.y = old_z; // 3DS Z becomes Y (up)\n            v.z = -old_y; // 3DS Y becomes -Z (forward)\n        }\n        self.coord_system = CoordSystem::YupGltf;\n    }\n}\n\n/// Load vertex normals from .vnm file.\n///\n/// VNM files contain per-vertex normal vectors in binary format.\n/// Each normal is stored as 3 floats (12 bytes) in the order: nx, ny, nz.\n///\n/// # Arguments\n///\n/// * `data` - Raw bytes of the .vnm file\n/// * `mesh` - Mesh to apply normals to (normals will be assigned to vertices)\n///\n/// # Returns\n///\n/// The number of normals loaded, or an error.\npub fn load_vnm_normals(data: &[u8], mesh: &mut Mesh) -> Result<usize, GeometryError> {\n    const FLOAT_SIZE: usize = 4;\n    const NORMAL_SIZE: usize = FLOAT_SIZE * 3; // 12 bytes per normal (nx, ny, nz)\n\n    if data.len() < NORMAL_SIZE {\n        return Ok(0);\n    }\n\n    let normal_count = data.len() / NORMAL_SIZE;\n    let mut normals = Vec::with_capacity(normal_count);\n\n    for i in 0..normal_count {\n        let offset = i * NORMAL_SIZE;\n        if offset + NORMAL_SIZE > data.len() {\n            break;\n        }\n\n        let nx = f32::from_le_bytes([\n            data[offset],\n            data[offset + 1],\n            data[offset + 2],\n            data[offset + 3],\n        ]);\n        let ny = f32::from_le_bytes([\n            data[offset + 4],\n            data[offset + 5],\n            data[offset + 6],\n            data[offset + 7],\n        ]);\n        let nz = f32::from_le_bytes([\n            data[offset + 8],\n            data[offset + 9],\n            data[offset + 10],\n            data[offset + 11],\n        ]);\n\n        normals.push(Vertex::new(nx, ny, nz));\n    }\n\n    // Assign normals to mesh (up to the number of vertices)\n    let count = normals.len().min(mesh.vertices.len());\n    mesh.normals = normals.into_iter().take(count).collect();\n\n    Ok(count)\n}\n\n/// Per-face color from IPC file.\n#[derive(Debug, Clone, Copy)]\npub struct FaceColor {\n    pub r: u8,\n    pub g: u8,\n    pub b: u8,\n    pub face_index: u32,\n}\n\n/// Load face colors from .ipc (Index Polygon Colors) file.\n///\n/// IPC files contain per-face color indices. The format is:\n/// - 4 bytes: face index (u32)\n/// - 3 bytes: RGB color\n///\n/// # Arguments\n///\n/// * `data` - Raw bytes of the .ipc file\n///\n/// # Returns\n///\n/// A vector of face colors.\npub fn load_ipc_colors(data: &[u8]) -> Result<Vec<FaceColor>, GeometryError> {\n    const ENTRY_SIZE: usize = 7; // 4 bytes index + 3 bytes RGB\n\n    if data.len() < ENTRY_SIZE {\n        return Ok(Vec::new());\n    }\n\n    let entry_count = data.len() / ENTRY_SIZE;\n    let mut colors = Vec::with_capacity(entry_count);\n\n    for i in 0..entry_count {\n        let offset = i * ENTRY_SIZE;\n        if offset + ENTRY_SIZE > data.len() {\n            break;\n        }\n\n        let face_index = u32::from_le_bytes([\n            data[offset],\n            data[offset + 1],\n            data[offset + 2],\n            data[offset + 3],\n        ]);\n        let r = data[offset + 4];\n        let g = data[offset + 5];\n        let b = data[offset + 6];\n\n        colors.push(FaceColor {\n            r,\n            g,\n            b,\n            face_index,\n        });\n    }\n\n    Ok(colors)\n}\n\n/// Apply IPC colors to face flags for later material assignment.\n///\n/// The face index in each FaceColor is used to identify which face to color.\n/// Colors are stored in the face flags field as packed RGB (for later processing).\npub fn apply_ipc_colors_to_mesh(colors: &[FaceColor], mesh: &mut Mesh) {\n    for color in colors {\n        let idx = color.face_index as usize;\n        if idx < mesh.faces.len() {\n            // Pack RGB into flags for later material processing\n            // Format: 0xRRGGBB00 | face_flags\n            let packed = ((color.r as u16) << 8) | (color.g as u16);\n            mesh.faces[idx].flags = packed;\n        }\n    }\n}\n\n/// Assembly component with transform\n#[derive(Debug, Clone)]\npub struct AssemblyPart {\n    pub mesh: Mesh,\n    pub material: Option<String>,\n}\n\n/// Assembled product\n#[derive(Debug, Clone, Default)]\npub struct Assembly {\n    pub parts: Vec<AssemblyPart>,\n    pub name: String,\n}\n\nimpl Assembly {\n    pub fn new(name: &str) -> Self {\n        Self {\n            parts: Vec::new(),\n            name: name.to_string(),\n        }\n    }\n\n    pub fn add_part(&mut self, mut mesh: Mesh, material: Option<String>) {\n        mesh.center(); // Center each part for easier positioning\n        self.parts.push(AssemblyPart { mesh, material });\n    }\n\n    /// Convert to Scene3DS for export\n    pub fn to_scene(&self) -> Scene3DS {\n        let mut scene = Scene3DS::default();\n        for (i, part) in self.parts.iter().enumerate() {\n            let mut mesh = part.mesh.clone();\n            if mesh.name.is_empty() {\n                mesh.name = format!(\"part_{}\", i);\n            }\n            mesh.material_name = part.material.clone();\n            scene.meshes.push(mesh);\n        }\n        scene\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vertex_coords() {\n        let v = Vertex::new(1.0, 2.0, 3.0);\n        let gltf = v.to_gltf_coords();\n        assert_eq!(gltf.x, 1.0);\n        assert_eq!(gltf.y, 3.0); // Z becomes Y\n        assert_eq!(gltf.z, -2.0); // Y becomes -Z\n    }\n\n    #[test]\n    fn test_geometry_format_from_extension() {\n        assert_eq!(\n            GeometryFormat::from_extension(\"model.3ds\"),\n            GeometryFormat::ThreeDS\n        );\n        assert_eq!(\n            GeometryFormat::from_extension(\"model.3DS\"),\n            GeometryFormat::ThreeDS\n        );\n        assert_eq!(\n            GeometryFormat::from_extension(\"model.obj\"),\n            GeometryFormat::Obj\n        );\n        assert_eq!(\n            GeometryFormat::from_extension(\"model.OBJ\"),\n            GeometryFormat::Obj\n        );\n        assert_eq!(\n            GeometryFormat::from_extension(\"model.geo\"),\n            GeometryFormat::Geo\n        );\n        assert_eq!(\n            GeometryFormat::from_extension(\"model.off\"),\n            GeometryFormat::Geo\n        );\n        assert_eq!(\n            GeometryFormat::from_extension(\"model.txt\"),\n            GeometryFormat::Unknown\n        );\n        assert_eq!(\n            GeometryFormat::from_extension(\"model\"),\n            GeometryFormat::Unknown\n        );\n    }\n\n    #[test]\n    fn test_geometry_format_from_content_3ds() {\n        // 3DS magic bytes 0x4D4D\n        let data_3ds = [0x4D, 0x4D, 0x00, 0x00];\n        assert_eq!(\n            GeometryFormat::from_content(&data_3ds),\n            GeometryFormat::ThreeDS\n        );\n    }\n\n    #[test]\n    fn test_geometry_format_from_content_obj() {\n        let data_obj_vertex = b\"v 1.0 2.0 3.0\\nv 4.0 5.0 6.0\\n\";\n        assert_eq!(\n            GeometryFormat::from_content(data_obj_vertex),\n            GeometryFormat::Obj\n        );\n\n        let data_obj_comment = b\"# OBJ file\\nv 1.0 2.0 3.0\\n\";\n        assert_eq!(\n            GeometryFormat::from_content(data_obj_comment),\n            GeometryFormat::Obj\n        );\n\n        let data_obj_mtl = b\"mtllib material.mtl\\no cube\\n\";\n        assert_eq!(\n            GeometryFormat::from_content(data_obj_mtl),\n            GeometryFormat::Obj\n        );\n    }\n\n    #[test]\n    fn test_geometry_format_from_content_geo() {\n        // GEO format starts with vertex/face counts\n        let data_geo = b\"10 12\\n0 0 0\\n1 0 0\\n\";\n        assert_eq!(GeometryFormat::from_content(data_geo), GeometryFormat::Geo);\n\n        // OFF format\n        let data_off = b\"OFF\\n8 6 0\\n0 0 0\\n\";\n        assert_eq!(GeometryFormat::from_content(data_off), GeometryFormat::Geo);\n    }\n\n    #[test]\n    fn test_geometry_format_detect() {\n        // Extension takes priority\n        let data_3ds = [0x4D, 0x4D, 0x00, 0x00];\n        assert_eq!(\n            GeometryFormat::detect(\"model.obj\", &data_3ds),\n            GeometryFormat::Obj\n        );\n\n        // Content is used when extension is unknown\n        assert_eq!(\n            GeometryFormat::detect(\"model\", &data_3ds),\n            GeometryFormat::ThreeDS\n        );\n    }\n\n    #[test]\n    fn test_geometry_format_unknown() {\n        let data_random = [0x00, 0x01, 0x02, 0x03];\n        assert_eq!(\n            GeometryFormat::from_content(&data_random),\n            GeometryFormat::Unknown\n        );\n\n        let empty: &[u8] = &[];\n        assert_eq!(GeometryFormat::from_content(empty), GeometryFormat::Unknown);\n    }\n\n    #[test]\n    fn test_mesh_rotate_x() {\n        use std::f32::consts::FRAC_PI_2;\n        let mut mesh = Mesh {\n            name: \"test\".to_string(),\n            vertices: vec![Vertex::new(0.0, 1.0, 0.0)],\n            ..Default::default()\n        };\n        mesh.rotate_x(FRAC_PI_2); // 90 degrees\n                                  // Y becomes Z, Z becomes -Y\n        assert!((mesh.vertices[0].y - 0.0).abs() < 0.001);\n        assert!((mesh.vertices[0].z - 1.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_mesh_rotate_y() {\n        use std::f32::consts::FRAC_PI_2;\n        let mut mesh = Mesh {\n            name: \"test\".to_string(),\n            vertices: vec![Vertex::new(1.0, 0.0, 0.0)],\n            ..Default::default()\n        };\n        mesh.rotate_y(FRAC_PI_2); // 90 degrees\n                                  // X becomes Z, Z becomes -X\n        assert!((mesh.vertices[0].x - 0.0).abs() < 0.001);\n        assert!((mesh.vertices[0].z - 1.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_mesh_rotate_z() {\n        use std::f32::consts::FRAC_PI_2;\n        let mut mesh = Mesh {\n            name: \"test\".to_string(),\n            vertices: vec![Vertex::new(1.0, 0.0, 0.0)],\n            ..Default::default()\n        };\n        mesh.rotate_z(FRAC_PI_2); // 90 degrees\n                                  // X becomes Y, Y becomes -X\n        assert!((mesh.vertices[0].x - 0.0).abs() < 0.001);\n        assert!((mesh.vertices[0].y - 1.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_load_vnm_normals() {\n        // Create test VNM data: 2 normals\n        // Normal 1: (1.0, 0.0, 0.0)\n        // Normal 2: (0.0, 1.0, 0.0)\n        let mut data = Vec::new();\n        data.extend_from_slice(&1.0f32.to_le_bytes());\n        data.extend_from_slice(&0.0f32.to_le_bytes());\n        data.extend_from_slice(&0.0f32.to_le_bytes());\n        data.extend_from_slice(&0.0f32.to_le_bytes());\n        data.extend_from_slice(&1.0f32.to_le_bytes());\n        data.extend_from_slice(&0.0f32.to_le_bytes());\n\n        let mut mesh = Mesh {\n            name: \"test\".to_string(),\n            vertices: vec![Vertex::new(0.0, 0.0, 0.0), Vertex::new(1.0, 0.0, 0.0)],\n            ..Default::default()\n        };\n\n        let count = load_vnm_normals(&data, &mut mesh).unwrap();\n        assert_eq!(count, 2);\n        assert_eq!(mesh.normals.len(), 2);\n        assert!((mesh.normals[0].x - 1.0).abs() < 0.001);\n        assert!((mesh.normals[0].y - 0.0).abs() < 0.001);\n        assert!((mesh.normals[1].x - 0.0).abs() < 0.001);\n        assert!((mesh.normals[1].y - 1.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_load_vnm_empty() {\n        let data: Vec<u8> = Vec::new();\n        let mut mesh = Mesh::default();\n        let count = load_vnm_normals(&data, &mut mesh).unwrap();\n        assert_eq!(count, 0);\n    }\n\n    #[test]\n    fn test_load_ipc_colors() {\n        // Create test IPC data: 2 entries\n        // Face 0: RGB(255, 0, 0) - Red\n        // Face 1: RGB(0, 255, 0) - Green\n        let mut data = Vec::new();\n        // Face 0\n        data.extend_from_slice(&0u32.to_le_bytes());\n        data.push(255);\n        data.push(0);\n        data.push(0);\n        // Face 1\n        data.extend_from_slice(&1u32.to_le_bytes());\n        data.push(0);\n        data.push(255);\n        data.push(0);\n\n        let colors = load_ipc_colors(&data).unwrap();\n        assert_eq!(colors.len(), 2);\n        assert_eq!(colors[0].face_index, 0);\n        assert_eq!(colors[0].r, 255);\n        assert_eq!(colors[0].g, 0);\n        assert_eq!(colors[0].b, 0);\n        assert_eq!(colors[1].face_index, 1);\n        assert_eq!(colors[1].r, 0);\n        assert_eq!(colors[1].g, 255);\n        assert_eq!(colors[1].b, 0);\n    }\n\n    #[test]\n    fn test_load_ipc_empty() {\n        let data: Vec<u8> = Vec::new();\n        let colors = load_ipc_colors(&data).unwrap();\n        assert!(colors.is_empty());\n    }\n\n    #[test]\n    fn test_apply_ipc_colors_to_mesh() {\n        let mut mesh = Mesh {\n            name: \"test\".to_string(),\n            faces: vec![\n                Face {\n                    a: 0,\n                    b: 1,\n                    c: 2,\n                    flags: 0,\n                },\n                Face {\n                    a: 2,\n                    b: 3,\n                    c: 0,\n                    flags: 0,\n                },\n            ],\n            ..Default::default()\n        };\n\n        let colors = vec![\n            FaceColor {\n                r: 255,\n                g: 128,\n                face_index: 0,\n                b: 64,\n            },\n            FaceColor {\n                r: 0,\n                g: 255,\n                face_index: 1,\n                b: 128,\n            },\n        ];\n\n        apply_ipc_colors_to_mesh(&colors, &mut mesh);\n\n        // Check that flags were set (packed RGB)\n        assert_ne!(mesh.faces[0].flags, 0);\n        assert_ne!(mesh.faces[1].flags, 0);\n    }\n\n    #[test]\n    fn test_vertex_default() {\n        let v = Vertex::default();\n        assert_eq!(v.x, 0.0);\n        assert_eq!(v.y, 0.0);\n        assert_eq!(v.z, 0.0);\n    }\n\n    #[test]\n    fn test_vertex_debug_clone() {\n        let v = Vertex::new(1.5, 2.5, 3.5);\n        let debug_str = format!(\"{:?}\", v);\n        assert!(debug_str.contains(\"1.5\"));\n\n        let cloned = v.clone();\n        assert_eq!(cloned.x, 1.5);\n    }\n\n    #[test]\n    fn test_face_default() {\n        let f = Face::default();\n        assert_eq!(f.a, 0);\n        assert_eq!(f.b, 0);\n        assert_eq!(f.c, 0);\n        assert_eq!(f.flags, 0);\n    }\n\n    #[test]\n    fn test_face_debug_clone() {\n        let f = Face { a: 1, b: 2, c: 3, flags: 0 };\n        let debug_str = format!(\"{:?}\", f);\n        assert!(debug_str.contains(\"Face\"));\n\n        let cloned = f.clone();\n        assert_eq!(cloned.a, 1);\n    }\n\n    #[test]\n    fn test_mesh_default() {\n        let mesh = Mesh::default();\n        assert!(mesh.name.is_empty() || mesh.name == \"mesh\" || mesh.name == \"\");\n        assert!(mesh.vertices.is_empty());\n        assert!(mesh.faces.is_empty());\n    }\n\n    #[test]\n    fn test_mesh_debug_clone() {\n        let mesh = Mesh {\n            name: \"test_mesh\".to_string(),\n            vertices: vec![Vertex::new(1.0, 2.0, 3.0)],\n            faces: vec![Face { a: 0, b: 0, c: 0, flags: 0 }],\n            ..Default::default()\n        };\n\n        let debug_str = format!(\"{:?}\", mesh);\n        assert!(debug_str.contains(\"test_mesh\"));\n\n        let cloned = mesh.clone();\n        assert_eq!(cloned.name, \"test_mesh\");\n    }\n\n    #[test]\n    fn test_mesh_translate() {\n        let mut mesh = Mesh {\n            name: \"test\".to_string(),\n            vertices: vec![Vertex::new(0.0, 0.0, 0.0)],\n            ..Default::default()\n        };\n\n        mesh.translate([10.0, 20.0, 30.0]);\n        assert_eq!(mesh.vertices[0].x, 10.0);\n        assert_eq!(mesh.vertices[0].y, 20.0);\n        assert_eq!(mesh.vertices[0].z, 30.0);\n    }\n\n    #[test]\n    fn test_mesh_scale() {\n        let mut mesh = Mesh {\n            name: \"test\".to_string(),\n            vertices: vec![Vertex::new(1.0, 2.0, 3.0)],\n            ..Default::default()\n        };\n\n        mesh.scale(2.0);\n        assert_eq!(mesh.vertices[0].x, 2.0);\n        assert_eq!(mesh.vertices[0].y, 4.0);\n        assert_eq!(mesh.vertices[0].z, 6.0);\n    }\n\n    #[test]\n    fn test_material3ds_default() {\n        let mat = Material3DS::default();\n        assert!(mat.name.is_empty() || mat.name == \"default\" || mat.name == \"\");\n    }\n\n    #[test]\n    fn test_material3ds_debug_clone() {\n        let mat = Material3DS {\n            name: \"test_material\".to_string(),\n            ambient: [0.1, 0.2, 0.3],\n            diffuse: [0.4, 0.5, 0.6],\n            specular: [0.7, 0.8, 0.9],\n            texture: Some(\"texture.png\".to_string()),\n            metallic: 0.0,\n            roughness: 0.5,\n        };\n\n        let debug_str = format!(\"{:?}\", mat);\n        assert!(debug_str.contains(\"test_material\"));\n\n        let cloned = mat.clone();\n        assert_eq!(cloned.name, \"test_material\");\n        assert_eq!(cloned.metallic, 0.0);\n        assert_eq!(cloned.roughness, 0.5);\n    }\n\n    #[test]\n    fn test_scene3ds_default() {\n        let scene = Scene3DS::default();\n        assert!(scene.meshes.is_empty());\n        assert!(scene.materials.is_empty());\n    }\n\n    #[test]\n    fn test_scene3ds_vertex_count() {\n        let mut scene = Scene3DS::default();\n        scene.meshes.push(Mesh {\n            name: \"mesh1\".to_string(),\n            vertices: vec![Vertex::new(0.0, 0.0, 0.0), Vertex::new(1.0, 0.0, 0.0)],\n            ..Default::default()\n        });\n        scene.meshes.push(Mesh {\n            name: \"mesh2\".to_string(),\n            vertices: vec![Vertex::new(2.0, 0.0, 0.0)],\n            ..Default::default()\n        });\n\n        assert_eq!(scene.vertex_count(), 3);\n    }\n\n    #[test]\n    fn test_scene3ds_face_count() {\n        let mut scene = Scene3DS::default();\n        scene.meshes.push(Mesh {\n            name: \"mesh1\".to_string(),\n            faces: vec![\n                Face { a: 0, b: 1, c: 2, flags: 0 },\n                Face { a: 2, b: 3, c: 0, flags: 0 },\n            ],\n            ..Default::default()\n        });\n\n        assert_eq!(scene.face_count(), 2);\n    }\n\n    #[test]\n    fn test_bounding_box_empty() {\n        let bbox = BoundingBox::empty();\n        assert!(!bbox.is_valid());\n    }\n\n    #[test]\n    fn test_bounding_box_expand() {\n        let mut bbox = BoundingBox::empty();\n        bbox.expand([0.0, 0.0, 0.0]);\n        bbox.expand([10.0, 5.0, 2.0]);\n        bbox.expand([-5.0, 8.0, -3.0]);\n\n        assert!(bbox.is_valid());\n        assert_eq!(bbox.min, [-5.0, 0.0, -3.0]);\n        assert_eq!(bbox.max, [10.0, 8.0, 2.0]);\n    }\n\n    #[test]\n    fn test_bounding_box_merge() {\n        let mut bbox1 = BoundingBox::empty();\n        bbox1.expand([0.0, 0.0, 0.0]);\n        bbox1.expand([5.0, 5.0, 5.0]);\n\n        let mut bbox2 = BoundingBox::empty();\n        bbox2.expand([3.0, 3.0, 3.0]);\n        bbox2.expand([10.0, 10.0, 10.0]);\n\n        bbox1.merge(&bbox2);\n        assert_eq!(bbox1.min, [0.0, 0.0, 0.0]);\n        assert_eq!(bbox1.max, [10.0, 10.0, 10.0]);\n    }\n\n    #[test]\n    fn test_bounding_box_dimensions() {\n        let bbox = BoundingBox {\n            min: [0.0, 0.0, 0.0],\n            max: [10.0, 5.0, 2.0],\n        };\n\n        let dims = bbox.dimensions();\n        assert_eq!(dims, [10.0, 5.0, 2.0]);\n    }\n\n    #[test]\n    fn test_bounding_box_center() {\n        let bbox = BoundingBox {\n            min: [0.0, 0.0, 0.0],\n            max: [10.0, 6.0, 4.0],\n        };\n\n        let center = bbox.center();\n        assert_eq!(center, [5.0, 3.0, 2.0]);\n    }\n\n    #[test]\n    fn test_bounding_box_debug_clone() {\n        let bbox = BoundingBox {\n            min: [0.0, 0.0, 0.0],\n            max: [1.0, 1.0, 1.0],\n        };\n\n        let debug_str = format!(\"{:?}\", bbox);\n        assert!(debug_str.contains(\"BoundingBox\"));\n\n        let cloned = bbox.clone();\n        assert_eq!(cloned.min, [0.0, 0.0, 0.0]);\n    }\n\n    #[test]\n    fn test_scene3ds_bounding_box() {\n        let mut scene = Scene3DS::default();\n        scene.meshes.push(Mesh {\n            name: \"mesh1\".to_string(),\n            vertices: vec![\n                Vertex::new(0.0, 0.0, 0.0),\n                Vertex::new(5.0, 10.0, 15.0),\n            ],\n            ..Default::default()\n        });\n\n        let bbox = scene.bounding_box();\n        assert!(bbox.is_valid());\n        assert_eq!(bbox.min, [0.0, 0.0, 0.0]);\n        assert_eq!(bbox.max, [5.0, 10.0, 15.0]);\n    }\n\n    #[test]\n    fn test_face_color_debug_clone() {\n        let fc = FaceColor {\n            face_index: 5,\n            r: 255,\n            g: 128,\n            b: 64,\n        };\n\n        let debug_str = format!(\"{:?}\", fc);\n        assert!(debug_str.contains(\"FaceColor\"));\n\n        let cloned = fc.clone();\n        assert_eq!(cloned.face_index, 5);\n        assert_eq!(cloned.r, 255);\n    }\n\n    #[test]\n    fn test_embedded_texture_debug_clone() {\n        let tex = EmbeddedTexture {\n            name: \"texture.png\".to_string(),\n            data: vec![0x89, 0x50, 0x4E, 0x47],\n            width: 64,\n            height: 64,\n        };\n\n        let debug_str = format!(\"{:?}\", tex);\n        assert!(debug_str.contains(\"texture.png\"));\n\n        let cloned = tex.clone();\n        assert_eq!(cloned.name, \"texture.png\");\n        assert_eq!(cloned.width, 64);\n        assert_eq!(cloned.height, 64);\n    }\n\n    #[test]\n    fn test_geometry_format_debug_partialeq() {\n        let fmt1 = GeometryFormat::ThreeDS;\n        let fmt2 = GeometryFormat::ThreeDS;\n        let fmt3 = GeometryFormat::Obj;\n\n        assert_eq!(fmt1, fmt2);\n        assert_ne!(fmt1, fmt3);\n\n        let debug_str = format!(\"{:?}\", fmt1);\n        assert!(debug_str.contains(\"ThreeDS\"));\n    }\n\n    #[test]\n    fn test_geometry_error_display() {\n        let err = GeometryError::Invalid3DS(\"bad magic\".to_string());\n        let display_str = format!(\"{}\", err);\n        assert!(display_str.contains(\"bad magic\") || display_str.contains(\"Invalid 3DS\"));\n\n        let err = GeometryError::InvalidOBJ(\"bad vertex\".to_string());\n        let display_str = format!(\"{}\", err);\n        assert!(display_str.contains(\"bad vertex\") || display_str.contains(\"Invalid OBJ\"));\n\n        let err = GeometryError::InvalidGeo(\"bad format\".to_string());\n        let display_str = format!(\"{}\", err);\n        assert!(display_str.contains(\"bad format\") || display_str.contains(\"Invalid GEO\"));\n    }\n\n    #[test]\n    fn test_geometry_error_debug() {\n        let err = GeometryError::Invalid3DS(\"test\".to_string());\n        let debug_str = format!(\"{:?}\", err);\n        assert!(debug_str.contains(\"Invalid3DS\"));\n    }\n\n    #[test]\n    fn test_geometry_error_io() {\n        let io_err = io::Error::new(io::ErrorKind::NotFound, \"file not found\");\n        let err = GeometryError::Io(io_err);\n        let display_str = format!(\"{}\", err);\n        assert!(display_str.contains(\"IO error\") || display_str.contains(\"file not found\"));\n    }\n\n    #[test]\n    fn test_mesh_center() {\n        let mut mesh = Mesh {\n            name: \"test\".to_string(),\n            vertices: vec![\n                Vertex::new(2.0, 4.0, 6.0),\n                Vertex::new(4.0, 6.0, 8.0),\n            ],\n            ..Default::default()\n        };\n\n        mesh.center();\n        // Center should be at (3, 5, 7) so vertices become (-1,-1,-1) and (1,1,1)\n        assert!((mesh.vertices[0].x - (-1.0)).abs() < 0.001);\n        assert!((mesh.vertices[1].x - 1.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_mesh_ground() {\n        let mut mesh = Mesh {\n            name: \"test\".to_string(),\n            vertices: vec![\n                Vertex::new(0.0, 5.0, 0.0),\n                Vertex::new(0.0, 10.0, 0.0),\n            ],\n            ..Default::default()\n        };\n\n        mesh.ground();\n        // Should move mesh so that min Y is 0\n        assert!((mesh.vertices[0].y - 0.0).abs() < 0.001);\n        assert!((mesh.vertices[1].y - 5.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_mesh_normalize() {\n        let mut mesh = Mesh {\n            name: \"test\".to_string(),\n            vertices: vec![\n                Vertex::new(10.0, 5.0, 20.0),\n                Vertex::new(20.0, 15.0, 30.0),\n            ],\n            ..Default::default()\n        };\n\n        mesh.normalize();\n        // normalize() centers X/Z and grounds Y (min Y = 0)\n        let bbox = mesh.bounding_box();\n        // Center of X should be 0 (was 15, range 10-20)\n        let center_x = (bbox.min[0] + bbox.max[0]) / 2.0;\n        assert!((center_x - 0.0).abs() < 0.001);\n        // Min Y should be 0 (was 5)\n        assert!((bbox.min[1] - 0.0).abs() < 0.001);\n        // Center of Z should be 0 (was 25, range 20-30)\n        let center_z = (bbox.min[2] + bbox.max[2]) / 2.0;\n        assert!((center_z - 0.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_mesh_convert_to_yup() {\n        let mut mesh = Mesh {\n            name: \"test\".to_string(),\n            vertices: vec![Vertex::new(1.0, 2.0, 3.0)],\n            coord_system: CoordSystem::Zup3DS,\n            ..Default::default()\n        };\n\n        mesh.convert_to_yup();\n        // 3DS Z-up to Y-up: (x,y,z) -> (x,z,-y)\n        assert_eq!(mesh.coord_system, CoordSystem::YupGltf);\n    }\n\n    #[test]\n    fn test_mesh_convert_to_yup_coordinate_transform() {\n        let mut mesh = Mesh {\n            name: \"test\".to_string(),\n            vertices: vec![Vertex::new(1.0, 2.0, 3.0)],\n            coord_system: CoordSystem::Zup3DS,\n            ..Default::default()\n        };\n\n        mesh.convert_to_yup();\n        // 3DS (x,y,z) -> GLTF (x,z,-y)\n        // (1,2,3) -> (1,3,-2)\n        assert_eq!(mesh.vertices[0].x, 1.0);\n        assert_eq!(mesh.vertices[0].y, 3.0);\n        assert_eq!(mesh.vertices[0].z, -2.0);\n    }\n\n    #[test]\n    fn test_coord_system_default() {\n        let cs = CoordSystem::default();\n        assert_eq!(cs, CoordSystem::Zup3DS);\n    }\n\n    #[test]\n    fn test_coord_system_debug_partialeq() {\n        let cs1 = CoordSystem::Zup3DS;\n        let cs2 = CoordSystem::YupGltf;\n        assert_ne!(cs1, cs2);\n\n        let debug_str = format!(\"{:?}\", cs1);\n        assert!(debug_str.contains(\"Zup3DS\"));\n    }\n\n    #[test]\n    fn test_assembly_new() {\n        let assembly = Assembly::new(\"test_assembly\");\n        assert_eq!(assembly.name, \"test_assembly\");\n        assert!(assembly.parts.is_empty());\n    }\n\n    #[test]\n    fn test_assembly_add_part() {\n        let mut assembly = Assembly::new(\"test\");\n        let mesh = Mesh {\n            name: \"part1\".to_string(),\n            vertices: vec![Vertex::new(1.0, 2.0, 3.0)],\n            ..Default::default()\n        };\n\n        assembly.add_part(mesh, Some(\"material1\".to_string()));\n        assert_eq!(assembly.parts.len(), 1);\n        assert_eq!(assembly.parts[0].material, Some(\"material1\".to_string()));\n    }\n\n    #[test]\n    fn test_assembly_to_scene() {\n        let mut assembly = Assembly::new(\"test\");\n        let mesh1 = Mesh {\n            name: \"part1\".to_string(),\n            vertices: vec![Vertex::new(0.0, 0.0, 0.0)],\n            ..Default::default()\n        };\n        let mesh2 = Mesh {\n            name: \"\".to_string(), // Empty name\n            vertices: vec![Vertex::new(1.0, 1.0, 1.0)],\n            ..Default::default()\n        };\n\n        assembly.add_part(mesh1, Some(\"mat1\".to_string()));\n        assembly.add_part(mesh2, None);\n\n        let scene = assembly.to_scene();\n        assert_eq!(scene.meshes.len(), 2);\n        assert_eq!(scene.meshes[0].name, \"part1\");\n        assert!(scene.meshes[1].name.starts_with(\"part_\")); // Auto-named\n        assert_eq!(scene.meshes[0].material_name, Some(\"mat1\".to_string()));\n    }\n\n    #[test]\n    fn test_assembly_default() {\n        let assembly = Assembly::default();\n        assert!(assembly.name.is_empty() || assembly.name == \"\");\n        assert!(assembly.parts.is_empty());\n    }\n\n    #[test]\n    fn test_assembly_part_debug_clone() {\n        let part = AssemblyPart {\n            mesh: Mesh {\n                name: \"test\".to_string(),\n                ..Default::default()\n            },\n            material: Some(\"mat\".to_string()),\n        };\n\n        let debug_str = format!(\"{:?}\", part);\n        assert!(debug_str.contains(\"AssemblyPart\"));\n\n        let cloned = part.clone();\n        assert_eq!(cloned.mesh.name, \"test\");\n    }\n\n    #[test]\n    fn test_bounding_box_dimensions_match() {\n        // dimensions_match converts to mm: dims * 1000 - expected <= tolerance\n        // So bbox with dims [0.1, 0.05, 0.025] (in meters) becomes [100, 50, 25] in mm\n        let bbox = BoundingBox {\n            min: [0.0, 0.0, 0.0],\n            max: [0.1, 0.05, 0.025], // 100mm, 50mm, 25mm\n        };\n\n        assert!(bbox.dimensions_match([100.0, 50.0, 25.0], 0.01));\n        assert!(bbox.dimensions_match([100.5, 50.5, 25.5], 1.0));\n        assert!(!bbox.dimensions_match([200.0, 50.0, 25.0], 0.01));\n    }\n\n    #[test]\n    fn test_bounding_box_empty_dimensions() {\n        let bbox = BoundingBox::empty();\n        let dims = bbox.dimensions();\n        // Empty box should return zero dimensions\n        assert_eq!(dims, [0.0, 0.0, 0.0]);\n    }\n\n    #[test]\n    fn test_mesh_bounds() {\n        let mesh = Mesh {\n            name: \"test\".to_string(),\n            vertices: vec![\n                Vertex::new(-5.0, 0.0, 10.0),\n                Vertex::new(5.0, 10.0, 20.0),\n            ],\n            ..Default::default()\n        };\n\n        let (min, max) = mesh.bounds();\n        assert_eq!(min, [-5.0, 0.0, 10.0]);\n        assert_eq!(max, [5.0, 10.0, 20.0]);\n    }\n\n    #[test]\n    fn test_parse_3ds_invalid_magic() {\n        let data = [0x00, 0x00, 0x00, 0x00]; // Invalid magic\n        let result = parse_3ds(&data);\n        assert!(result.is_err());\n        match result {\n            Err(GeometryError::Invalid3DS(msg)) => {\n                assert!(msg.contains(\"Invalid main chunk\") || msg.contains(\"0000\"));\n            }\n            _ => panic!(\"Expected Invalid3DS error\"),\n        }\n    }\n\n    #[test]\n    fn test_parse_3ds_too_short() {\n        let data: &[u8] = &[0x4D]; // Too short for a 3DS file\n        let result = parse_3ds(data);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_parse_3ds_empty() {\n        let data: &[u8] = &[];\n        let result = parse_3ds(data);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_parse_geo_empty() {\n        let data: &[u8] = &[];\n        let result = parse_geo(data);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_parse_obj_comments_only() {\n        // OBJ with only comments - returns error since it requires at least one face\n        let data = b\"# This is a comment\\n# Another comment\\n\";\n        let result = parse_obj(data);\n        // The parser may return an error for empty/invalid OBJ data\n        // Or return an empty mesh - either is acceptable behavior\n        match result {\n            Ok(scene) => {\n                assert_eq!(scene.meshes.len(), 1);\n                assert!(scene.meshes[0].vertices.is_empty());\n            }\n            Err(_) => {\n                // Also acceptable - empty OBJ is invalid\n            }\n        }\n    }\n\n    #[test]\n    fn test_parse_geometry_auto_3ds() {\n        // 3DS magic bytes\n        let data = [0x4D, 0x4D, 0x00, 0x00, 0x00, 0x00];\n        // Should detect as 3DS and try to parse (will fail due to incomplete data)\n        let result = parse_geometry_auto(\"test.3ds\", &data);\n        // The parse may fail due to incomplete data, but format detection works\n        assert!(result.is_ok() || result.is_err());\n    }\n\n    #[test]\n    fn test_parse_geometry_auto_obj() {\n        let data = b\"v 0.0 0.0 0.0\\nv 1.0 0.0 0.0\\nv 1.0 1.0 0.0\\nf 1 2 3\\n\";\n        let result = parse_geometry_auto(\"test.obj\", data);\n        assert!(result.is_ok());\n        let scene = result.unwrap();\n        assert!(!scene.meshes.is_empty());\n    }\n\n    #[test]\n    fn test_parse_geometry_auto_unknown() {\n        let data = b\"unknown format data that doesn't match any parser\";\n        let result = parse_geometry_auto(\"test.xyz\", data);\n        // Will try all parsers and fail\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_parse_obj_simple() {\n        let data = b\"v 0.0 0.0 0.0\\nv 1.0 0.0 0.0\\nv 1.0 1.0 0.0\\nf 1 2 3\\n\";\n        let result = parse_obj(data);\n        assert!(result.is_ok());\n        let scene = result.unwrap();\n        assert!(!scene.meshes.is_empty());\n        assert_eq!(scene.meshes[0].vertices.len(), 3);\n        assert_eq!(scene.meshes[0].faces.len(), 1);\n    }\n\n    #[test]\n    fn test_parse_obj_with_normals() {\n        let data = b\"v 0.0 0.0 0.0\\nv 1.0 0.0 0.0\\nv 1.0 1.0 0.0\\nvn 0.0 0.0 1.0\\nf 1//1 2//1 3//1\\n\";\n        let result = parse_obj(data);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_parse_obj_with_texcoords() {\n        let data = b\"v 0.0 0.0 0.0\\nv 1.0 0.0 0.0\\nv 1.0 1.0 0.0\\nvt 0.0 0.0\\nvt 1.0 0.0\\nvt 1.0 1.0\\nf 1/1 2/2 3/3\\n\";\n        let result = parse_obj(data);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_parse_obj_with_object() {\n        let data = b\"o Cube\\nv 0.0 0.0 0.0\\nv 1.0 0.0 0.0\\nv 1.0 1.0 0.0\\nf 1 2 3\\n\";\n        let result = parse_obj(data);\n        assert!(result.is_ok());\n        let scene = result.unwrap();\n        assert!(!scene.meshes.is_empty());\n    }\n\n    #[test]\n    fn test_parse_obj_with_group() {\n        let data = b\"g MyGroup\\nv 0.0 0.0 0.0\\nv 1.0 0.0 0.0\\nv 1.0 1.0 0.0\\nf 1 2 3\\n\";\n        let result = parse_obj(data);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_parse_geo_off_format_error() {\n        // OFF format has different header parsing requirements\n        let data = b\"OFF\\n4 2 0\\n0.0 0.0 0.0\\n1.0 0.0 0.0\\n1.0 1.0 0.0\\n0.0 1.0 0.0\\n3 0 1 2\\n3 0 2 3\\n\";\n        let result = parse_geo(data);\n        // OFF format is not fully supported in parse_geo (expects simple vertex/face counts as first line)\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_parse_geo_simple() {\n        // GEO format: first line is \"vertex_count face_count\"\n        let data = b\"3 1\\n0.0 0.0 0.0\\n1.0 0.0 0.0\\n1.0 1.0 0.0\\n3 0 1 2\\n\";\n        let result = parse_geo(data);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_scene3ds_debug_clone() {\n        let mut scene = Scene3DS::default();\n        scene.meshes.push(Mesh {\n            name: \"mesh1\".to_string(),\n            ..Default::default()\n        });\n\n        let debug_str = format!(\"{:?}\", scene);\n        assert!(debug_str.contains(\"Scene3DS\"));\n\n        let cloned = scene.clone();\n        assert_eq!(cloned.meshes.len(), 1);\n    }\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":11002}},{"line":43,"address":[],"length":0,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":8}},{"line":46,"address":[],"length":0,"stats":{"Line":4}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":135,"address":[],"length":0,"stats":{"Line":21}},{"line":137,"address":[],"length":0,"stats":{"Line":21}},{"line":138,"address":[],"length":0,"stats":{"Line":21}},{"line":143,"address":[],"length":0,"stats":{"Line":28}},{"line":144,"address":[],"length":0,"stats":{"Line":76}},{"line":148,"address":[],"length":0,"stats":{"Line":11}},{"line":149,"address":[],"length":0,"stats":{"Line":11}},{"line":150,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":18}},{"line":154,"address":[],"length":0,"stats":{"Line":18}},{"line":155,"address":[],"length":0,"stats":{"Line":9}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":38}},{"line":173,"address":[],"length":0,"stats":{"Line":114}},{"line":174,"address":[],"length":0,"stats":{"Line":114}},{"line":175,"address":[],"length":0,"stats":{"Line":114}},{"line":176,"address":[],"length":0,"stats":{"Line":114}},{"line":177,"address":[],"length":0,"stats":{"Line":114}},{"line":178,"address":[],"length":0,"stats":{"Line":114}},{"line":182,"address":[],"length":0,"stats":{"Line":7}},{"line":183,"address":[],"length":0,"stats":{"Line":7}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":21}},{"line":187,"address":[],"length":0,"stats":{"Line":21}},{"line":191,"address":[],"length":0,"stats":{"Line":3}},{"line":192,"address":[],"length":0,"stats":{"Line":9}},{"line":193,"address":[],"length":0,"stats":{"Line":6}},{"line":194,"address":[],"length":0,"stats":{"Line":6}},{"line":195,"address":[],"length":0,"stats":{"Line":4}},{"line":196,"address":[],"length":0,"stats":{"Line":4}},{"line":202,"address":[],"length":0,"stats":{"Line":7}},{"line":203,"address":[],"length":0,"stats":{"Line":14}},{"line":204,"address":[],"length":0,"stats":{"Line":58}},{"line":205,"address":[],"length":0,"stats":{"Line":68}},{"line":207,"address":[],"length":0,"stats":{"Line":7}},{"line":213,"address":[],"length":0,"stats":{"Line":7}},{"line":214,"address":[],"length":0,"stats":{"Line":14}},{"line":215,"address":[],"length":0,"stats":{"Line":25}},{"line":216,"address":[],"length":0,"stats":{"Line":18}},{"line":218,"address":[],"length":0,"stats":{"Line":7}},{"line":222,"address":[],"length":0,"stats":{"Line":7}},{"line":223,"address":[],"length":0,"stats":{"Line":35}},{"line":227,"address":[],"length":0,"stats":{"Line":7}},{"line":228,"address":[],"length":0,"stats":{"Line":33}},{"line":262,"address":[],"length":0,"stats":{"Line":13}},{"line":263,"address":[],"length":0,"stats":{"Line":39}},{"line":264,"address":[],"length":0,"stats":{"Line":13}},{"line":265,"address":[],"length":0,"stats":{"Line":3}},{"line":266,"address":[],"length":0,"stats":{"Line":10}},{"line":267,"address":[],"length":0,"stats":{"Line":4}},{"line":268,"address":[],"length":0,"stats":{"Line":11}},{"line":269,"address":[],"length":0,"stats":{"Line":2}},{"line":271,"address":[],"length":0,"stats":{"Line":4}},{"line":276,"address":[],"length":0,"stats":{"Line":10}},{"line":277,"address":[],"length":0,"stats":{"Line":10}},{"line":278,"address":[],"length":0,"stats":{"Line":1}},{"line":282,"address":[],"length":0,"stats":{"Line":20}},{"line":283,"address":[],"length":0,"stats":{"Line":2}},{"line":287,"address":[],"length":0,"stats":{"Line":35}},{"line":288,"address":[],"length":0,"stats":{"Line":21}},{"line":290,"address":[],"length":0,"stats":{"Line":14}},{"line":291,"address":[],"length":0,"stats":{"Line":12}},{"line":292,"address":[],"length":0,"stats":{"Line":10}},{"line":293,"address":[],"length":0,"stats":{"Line":10}},{"line":294,"address":[],"length":0,"stats":{"Line":8}},{"line":295,"address":[],"length":0,"stats":{"Line":8}},{"line":296,"address":[],"length":0,"stats":{"Line":8}},{"line":298,"address":[],"length":0,"stats":{"Line":3}},{"line":302,"address":[],"length":0,"stats":{"Line":8}},{"line":303,"address":[],"length":0,"stats":{"Line":1}},{"line":307,"address":[],"length":0,"stats":{"Line":15}},{"line":308,"address":[],"length":0,"stats":{"Line":15}},{"line":309,"address":[],"length":0,"stats":{"Line":3}},{"line":310,"address":[],"length":0,"stats":{"Line":4}},{"line":311,"address":[],"length":0,"stats":{"Line":2}},{"line":313,"address":[],"length":0,"stats":{"Line":1}},{"line":317,"address":[],"length":0,"stats":{"Line":2}},{"line":321,"address":[],"length":0,"stats":{"Line":5}},{"line":323,"address":[],"length":0,"stats":{"Line":15}},{"line":324,"address":[],"length":0,"stats":{"Line":5}},{"line":325,"address":[],"length":0,"stats":{"Line":3}},{"line":329,"address":[],"length":0,"stats":{"Line":4}},{"line":334,"address":[],"length":0,"stats":{"Line":3}},{"line":335,"address":[],"length":0,"stats":{"Line":12}},{"line":337,"address":[],"length":0,"stats":{"Line":3}},{"line":338,"address":[],"length":0,"stats":{"Line":2}},{"line":339,"address":[],"length":0,"stats":{"Line":2}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":1}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":1}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":1}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":1}},{"line":353,"address":[],"length":0,"stats":{"Line":1}},{"line":360,"address":[],"length":0,"stats":{"Line":88}},{"line":361,"address":[],"length":0,"stats":{"Line":264}},{"line":362,"address":[],"length":0,"stats":{"Line":176}},{"line":365,"address":[],"length":0,"stats":{"Line":264}},{"line":366,"address":[],"length":0,"stats":{"Line":86}},{"line":367,"address":[],"length":0,"stats":{"Line":2}},{"line":368,"address":[],"length":0,"stats":{"Line":2}},{"line":369,"address":[],"length":0,"stats":{"Line":2}},{"line":372,"address":[],"length":0,"stats":{"Line":252}},{"line":375,"address":[],"length":0,"stats":{"Line":336}},{"line":377,"address":[],"length":0,"stats":{"Line":84}},{"line":380,"address":[],"length":0,"stats":{"Line":167}},{"line":385,"address":[],"length":0,"stats":{"Line":1317}},{"line":386,"address":[],"length":0,"stats":{"Line":1314}},{"line":387,"address":[],"length":0,"stats":{"Line":1314}},{"line":388,"address":[],"length":0,"stats":{"Line":1752}},{"line":390,"address":[],"length":0,"stats":{"Line":438}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":332}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":332}},{"line":396,"address":[],"length":0,"stats":{"Line":249}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":4}},{"line":400,"address":[],"length":0,"stats":{"Line":5}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":813}},{"line":408,"address":[],"length":0,"stats":{"Line":1314}},{"line":409,"address":[],"length":0,"stats":{"Line":166}},{"line":412,"address":[],"length":0,"stats":{"Line":167}},{"line":415,"address":[],"length":0,"stats":{"Line":83}},{"line":416,"address":[],"length":0,"stats":{"Line":166}},{"line":419,"address":[],"length":0,"stats":{"Line":166}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":2697}},{"line":422,"address":[],"length":0,"stats":{"Line":899}},{"line":423,"address":[],"length":0,"stats":{"Line":83}},{"line":425,"address":[],"length":0,"stats":{"Line":2448}},{"line":427,"address":[],"length":0,"stats":{"Line":249}},{"line":430,"address":[],"length":0,"stats":{"Line":498}},{"line":431,"address":[],"length":0,"stats":{"Line":249}},{"line":432,"address":[],"length":0,"stats":{"Line":249}},{"line":433,"address":[],"length":0,"stats":{"Line":332}},{"line":435,"address":[],"length":0,"stats":{"Line":83}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":332}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":83}},{"line":448,"address":[],"length":0,"stats":{"Line":83}},{"line":453,"address":[],"length":0,"stats":{"Line":1125}},{"line":454,"address":[],"length":0,"stats":{"Line":876}},{"line":455,"address":[],"length":0,"stats":{"Line":876}},{"line":456,"address":[],"length":0,"stats":{"Line":1168}},{"line":458,"address":[],"length":0,"stats":{"Line":292}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":249}},{"line":461,"address":[],"length":0,"stats":{"Line":249}},{"line":462,"address":[],"length":0,"stats":{"Line":83}},{"line":463,"address":[],"length":0,"stats":{"Line":32850}},{"line":464,"address":[],"length":0,"stats":{"Line":32850}},{"line":465,"address":[],"length":0,"stats":{"Line":32850}},{"line":466,"address":[],"length":0,"stats":{"Line":65700}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":249}},{"line":471,"address":[],"length":0,"stats":{"Line":249}},{"line":472,"address":[],"length":0,"stats":{"Line":83}},{"line":473,"address":[],"length":0,"stats":{"Line":62328}},{"line":474,"address":[],"length":0,"stats":{"Line":62328}},{"line":475,"address":[],"length":0,"stats":{"Line":62328}},{"line":476,"address":[],"length":0,"stats":{"Line":62328}},{"line":477,"address":[],"length":0,"stats":{"Line":103880}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":54}},{"line":482,"address":[],"length":0,"stats":{"Line":54}},{"line":483,"address":[],"length":0,"stats":{"Line":18}},{"line":484,"address":[],"length":0,"stats":{"Line":12570}},{"line":485,"address":[],"length":0,"stats":{"Line":12570}},{"line":486,"address":[],"length":0,"stats":{"Line":12570}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":625}},{"line":491,"address":[],"length":0,"stats":{"Line":900}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":2}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":12}},{"line":499,"address":[],"length":0,"stats":{"Line":4}},{"line":500,"address":[],"length":0,"stats":{"Line":1}},{"line":502,"address":[],"length":0,"stats":{"Line":9}},{"line":504,"address":[],"length":0,"stats":{"Line":2}},{"line":506,"address":[],"length":0,"stats":{"Line":3}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":246}},{"line":514,"address":[],"length":0,"stats":{"Line":83}},{"line":517,"address":[],"length":0,"stats":{"Line":1}},{"line":521,"address":[],"length":0,"stats":{"Line":2}},{"line":523,"address":[],"length":0,"stats":{"Line":21}},{"line":524,"address":[],"length":0,"stats":{"Line":18}},{"line":525,"address":[],"length":0,"stats":{"Line":18}},{"line":526,"address":[],"length":0,"stats":{"Line":24}},{"line":528,"address":[],"length":0,"stats":{"Line":6}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":2}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":12}},{"line":533,"address":[],"length":0,"stats":{"Line":4}},{"line":534,"address":[],"length":0,"stats":{"Line":1}},{"line":536,"address":[],"length":0,"stats":{"Line":9}},{"line":538,"address":[],"length":0,"stats":{"Line":3}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":3}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":3}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":9}},{"line":555,"address":[],"length":0,"stats":{"Line":1}},{"line":558,"address":[],"length":0,"stats":{"Line":2}},{"line":559,"address":[],"length":0,"stats":{"Line":4}},{"line":561,"address":[],"length":0,"stats":{"Line":12}},{"line":562,"address":[],"length":0,"stats":{"Line":6}},{"line":563,"address":[],"length":0,"stats":{"Line":6}},{"line":564,"address":[],"length":0,"stats":{"Line":8}},{"line":566,"address":[],"length":0,"stats":{"Line":2}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":6}},{"line":575,"address":[],"length":0,"stats":{"Line":6}},{"line":576,"address":[],"length":0,"stats":{"Line":6}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":2}},{"line":593,"address":[],"length":0,"stats":{"Line":8}},{"line":594,"address":[],"length":0,"stats":{"Line":32}},{"line":596,"address":[],"length":0,"stats":{"Line":24}},{"line":597,"address":[],"length":0,"stats":{"Line":24}},{"line":598,"address":[],"length":0,"stats":{"Line":24}},{"line":599,"address":[],"length":0,"stats":{"Line":24}},{"line":600,"address":[],"length":0,"stats":{"Line":16}},{"line":601,"address":[],"length":0,"stats":{"Line":24}},{"line":603,"address":[],"length":0,"stats":{"Line":49}},{"line":604,"address":[],"length":0,"stats":{"Line":99}},{"line":605,"address":[],"length":0,"stats":{"Line":66}},{"line":608,"address":[],"length":0,"stats":{"Line":132}},{"line":609,"address":[],"length":0,"stats":{"Line":2}},{"line":612,"address":[],"length":0,"stats":{"Line":155}},{"line":613,"address":[],"length":0,"stats":{"Line":62}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":31}},{"line":618,"address":[],"length":0,"stats":{"Line":103}},{"line":620,"address":[],"length":0,"stats":{"Line":108}},{"line":621,"address":[],"length":0,"stats":{"Line":108}},{"line":622,"address":[],"length":0,"stats":{"Line":108}},{"line":623,"address":[],"length":0,"stats":{"Line":90}},{"line":625,"address":[],"length":0,"stats":{"Line":25}},{"line":627,"address":[],"length":0,"stats":{"Line":18}},{"line":628,"address":[],"length":0,"stats":{"Line":18}},{"line":629,"address":[],"length":0,"stats":{"Line":9}},{"line":631,"address":[],"length":0,"stats":{"Line":14}},{"line":633,"address":[],"length":0,"stats":{"Line":6}},{"line":634,"address":[],"length":0,"stats":{"Line":6}},{"line":635,"address":[],"length":0,"stats":{"Line":6}},{"line":636,"address":[],"length":0,"stats":{"Line":5}},{"line":638,"address":[],"length":0,"stats":{"Line":27}},{"line":641,"address":[],"length":0,"stats":{"Line":18}},{"line":642,"address":[],"length":0,"stats":{"Line":24}},{"line":643,"address":[],"length":0,"stats":{"Line":90}},{"line":644,"address":[],"length":0,"stats":{"Line":36}},{"line":646,"address":[],"length":0,"stats":{"Line":36}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":18}},{"line":651,"address":[],"length":0,"stats":{"Line":54}},{"line":656,"address":[],"length":0,"stats":{"Line":6}},{"line":657,"address":[],"length":0,"stats":{"Line":18}},{"line":658,"address":[],"length":0,"stats":{"Line":18}},{"line":659,"address":[],"length":0,"stats":{"Line":12}},{"line":660,"address":[],"length":0,"stats":{"Line":12}},{"line":661,"address":[],"length":0,"stats":{"Line":6}},{"line":662,"address":[],"length":0,"stats":{"Line":6}},{"line":667,"address":[],"length":0,"stats":{"Line":10}},{"line":669,"address":[],"length":0,"stats":{"Line":6}},{"line":671,"address":[],"length":0,"stats":{"Line":1}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":1}},{"line":678,"address":[],"length":0,"stats":{"Line":16}},{"line":679,"address":[],"length":0,"stats":{"Line":2}},{"line":683,"address":[],"length":0,"stats":{"Line":12}},{"line":693,"address":[],"length":0,"stats":{"Line":6}},{"line":697,"address":[],"length":0,"stats":{"Line":6}},{"line":698,"address":[],"length":0,"stats":{"Line":18}},{"line":699,"address":[],"length":0,"stats":{"Line":6}},{"line":700,"address":[],"length":0,"stats":{"Line":6}},{"line":714,"address":[],"length":0,"stats":{"Line":4}},{"line":715,"address":[],"length":0,"stats":{"Line":16}},{"line":716,"address":[],"length":0,"stats":{"Line":12}},{"line":719,"address":[],"length":0,"stats":{"Line":7}},{"line":721,"address":[],"length":0,"stats":{"Line":7}},{"line":722,"address":[],"length":0,"stats":{"Line":3}},{"line":724,"address":[],"length":0,"stats":{"Line":12}},{"line":725,"address":[],"length":0,"stats":{"Line":3}},{"line":726,"address":[],"length":0,"stats":{"Line":1}},{"line":729,"address":[],"length":0,"stats":{"Line":4}},{"line":731,"address":[],"length":0,"stats":{"Line":5}},{"line":732,"address":[],"length":0,"stats":{"Line":3}},{"line":734,"address":[],"length":0,"stats":{"Line":1}},{"line":737,"address":[],"length":0,"stats":{"Line":3}},{"line":738,"address":[],"length":0,"stats":{"Line":1}},{"line":739,"address":[],"length":0,"stats":{"Line":6}},{"line":741,"address":[],"length":0,"stats":{"Line":3}},{"line":742,"address":[],"length":0,"stats":{"Line":3}},{"line":744,"address":[],"length":0,"stats":{"Line":12}},{"line":745,"address":[],"length":0,"stats":{"Line":3}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":15}},{"line":750,"address":[],"length":0,"stats":{"Line":15}},{"line":751,"address":[],"length":0,"stats":{"Line":15}},{"line":754,"address":[],"length":0,"stats":{"Line":18}},{"line":758,"address":[],"length":0,"stats":{"Line":3}},{"line":759,"address":[],"length":0,"stats":{"Line":3}},{"line":760,"address":[],"length":0,"stats":{"Line":3}},{"line":761,"address":[],"length":0,"stats":{"Line":4}},{"line":763,"address":[],"length":0,"stats":{"Line":2}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":6}},{"line":769,"address":[],"length":0,"stats":{"Line":6}},{"line":770,"address":[],"length":0,"stats":{"Line":6}},{"line":772,"address":[],"length":0,"stats":{"Line":3}},{"line":773,"address":[],"length":0,"stats":{"Line":2}},{"line":774,"address":[],"length":0,"stats":{"Line":1}},{"line":775,"address":[],"length":0,"stats":{"Line":1}},{"line":776,"address":[],"length":0,"stats":{"Line":1}},{"line":781,"address":[],"length":0,"stats":{"Line":3}},{"line":783,"address":[],"length":0,"stats":{"Line":2}},{"line":785,"address":[],"length":0,"stats":{"Line":2}},{"line":787,"address":[],"length":0,"stats":{"Line":1}},{"line":791,"address":[],"length":0,"stats":{"Line":1}},{"line":792,"address":[],"length":0,"stats":{"Line":3}},{"line":793,"address":[],"length":0,"stats":{"Line":1}},{"line":794,"address":[],"length":0,"stats":{"Line":1}},{"line":799,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":801,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":806,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":819,"address":[],"length":0,"stats":{"Line":0}},{"line":820,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[],"length":0,"stats":{"Line":0}},{"line":822,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":824,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[],"length":0,"stats":{"Line":0}},{"line":827,"address":[],"length":0,"stats":{"Line":0}},{"line":828,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":832,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":836,"address":[],"length":0,"stats":{"Line":0}},{"line":837,"address":[],"length":0,"stats":{"Line":0}},{"line":838,"address":[],"length":0,"stats":{"Line":0}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":843,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":0}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":851,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":874,"address":[],"length":0,"stats":{"Line":0}},{"line":879,"address":[],"length":0,"stats":{"Line":0}},{"line":880,"address":[],"length":0,"stats":{"Line":0}},{"line":881,"address":[],"length":0,"stats":{"Line":0}},{"line":885,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":890,"address":[],"length":0,"stats":{"Line":0}},{"line":891,"address":[],"length":0,"stats":{"Line":0}},{"line":893,"address":[],"length":0,"stats":{"Line":0}},{"line":894,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":902,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":0}},{"line":907,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":920,"address":[],"length":0,"stats":{"Line":0}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":927,"address":[],"length":0,"stats":{"Line":0}},{"line":932,"address":[],"length":0,"stats":{"Line":0}},{"line":933,"address":[],"length":0,"stats":{"Line":0}},{"line":937,"address":[],"length":0,"stats":{"Line":0}},{"line":944,"address":[],"length":0,"stats":{"Line":0}},{"line":949,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":952,"address":[],"length":0,"stats":{"Line":0}},{"line":956,"address":[],"length":0,"stats":{"Line":0}},{"line":957,"address":[],"length":0,"stats":{"Line":0}},{"line":958,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":963,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":966,"address":[],"length":0,"stats":{"Line":0}},{"line":967,"address":[],"length":0,"stats":{"Line":0}},{"line":968,"address":[],"length":0,"stats":{"Line":0}},{"line":969,"address":[],"length":0,"stats":{"Line":0}},{"line":970,"address":[],"length":0,"stats":{"Line":0}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":972,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":977,"address":[],"length":0,"stats":{"Line":0}},{"line":978,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":1154,"address":[],"length":0,"stats":{"Line":0}},{"line":1157,"address":[],"length":0,"stats":{"Line":0}},{"line":1158,"address":[],"length":0,"stats":{"Line":0}},{"line":1159,"address":[],"length":0,"stats":{"Line":0}},{"line":1160,"address":[],"length":0,"stats":{"Line":0}},{"line":1161,"address":[],"length":0,"stats":{"Line":0}},{"line":1162,"address":[],"length":0,"stats":{"Line":0}},{"line":1163,"address":[],"length":0,"stats":{"Line":0}},{"line":1166,"address":[],"length":0,"stats":{"Line":0}},{"line":1167,"address":[],"length":0,"stats":{"Line":0}},{"line":1168,"address":[],"length":0,"stats":{"Line":0}},{"line":1169,"address":[],"length":0,"stats":{"Line":0}},{"line":1170,"address":[],"length":0,"stats":{"Line":0}},{"line":1171,"address":[],"length":0,"stats":{"Line":0}},{"line":1172,"address":[],"length":0,"stats":{"Line":0}},{"line":1173,"address":[],"length":0,"stats":{"Line":0}},{"line":1174,"address":[],"length":0,"stats":{"Line":0}},{"line":1175,"address":[],"length":0,"stats":{"Line":0}},{"line":1180,"address":[],"length":0,"stats":{"Line":0}},{"line":1181,"address":[],"length":0,"stats":{"Line":0}},{"line":1182,"address":[],"length":0,"stats":{"Line":0}},{"line":1186,"address":[],"length":0,"stats":{"Line":0}},{"line":1187,"address":[],"length":0,"stats":{"Line":0}},{"line":1189,"address":[],"length":0,"stats":{"Line":0}},{"line":1193,"address":[],"length":0,"stats":{"Line":0}},{"line":1194,"address":[],"length":0,"stats":{"Line":0}},{"line":1195,"address":[],"length":0,"stats":{"Line":0}},{"line":1196,"address":[],"length":0,"stats":{"Line":0}},{"line":1197,"address":[],"length":0,"stats":{"Line":0}},{"line":1198,"address":[],"length":0,"stats":{"Line":0}},{"line":1199,"address":[],"length":0,"stats":{"Line":0}},{"line":1200,"address":[],"length":0,"stats":{"Line":0}},{"line":1201,"address":[],"length":0,"stats":{"Line":0}},{"line":1205,"address":[],"length":0,"stats":{"Line":0}},{"line":1206,"address":[],"length":0,"stats":{"Line":0}},{"line":1207,"address":[],"length":0,"stats":{"Line":0}},{"line":1208,"address":[],"length":0,"stats":{"Line":0}},{"line":1209,"address":[],"length":0,"stats":{"Line":0}},{"line":1211,"address":[],"length":0,"stats":{"Line":0}},{"line":1213,"address":[],"length":0,"stats":{"Line":0}},{"line":1214,"address":[],"length":0,"stats":{"Line":0}},{"line":1215,"address":[],"length":0,"stats":{"Line":0}},{"line":1216,"address":[],"length":0,"stats":{"Line":0}},{"line":1217,"address":[],"length":0,"stats":{"Line":0}},{"line":1220,"address":[],"length":0,"stats":{"Line":0}},{"line":1221,"address":[],"length":0,"stats":{"Line":0}},{"line":1222,"address":[],"length":0,"stats":{"Line":0}},{"line":1223,"address":[],"length":0,"stats":{"Line":0}},{"line":1224,"address":[],"length":0,"stats":{"Line":0}},{"line":1225,"address":[],"length":0,"stats":{"Line":0}},{"line":1226,"address":[],"length":0,"stats":{"Line":0}},{"line":1227,"address":[],"length":0,"stats":{"Line":0}},{"line":1231,"address":[],"length":0,"stats":{"Line":0}},{"line":1232,"address":[],"length":0,"stats":{"Line":0}},{"line":1234,"address":[],"length":0,"stats":{"Line":0}},{"line":1235,"address":[],"length":0,"stats":{"Line":0}},{"line":1237,"address":[],"length":0,"stats":{"Line":0}},{"line":1240,"address":[],"length":0,"stats":{"Line":0}},{"line":1241,"address":[],"length":0,"stats":{"Line":0}},{"line":1242,"address":[],"length":0,"stats":{"Line":0}},{"line":1243,"address":[],"length":0,"stats":{"Line":0}},{"line":1244,"address":[],"length":0,"stats":{"Line":0}},{"line":1246,"address":[],"length":0,"stats":{"Line":0}},{"line":1248,"address":[],"length":0,"stats":{"Line":0}},{"line":1249,"address":[],"length":0,"stats":{"Line":0}},{"line":1250,"address":[],"length":0,"stats":{"Line":0}},{"line":1251,"address":[],"length":0,"stats":{"Line":0}},{"line":1252,"address":[],"length":0,"stats":{"Line":0}},{"line":1255,"address":[],"length":0,"stats":{"Line":0}},{"line":1256,"address":[],"length":0,"stats":{"Line":0}},{"line":1257,"address":[],"length":0,"stats":{"Line":0}},{"line":1258,"address":[],"length":0,"stats":{"Line":0}},{"line":1259,"address":[],"length":0,"stats":{"Line":0}},{"line":1260,"address":[],"length":0,"stats":{"Line":0}},{"line":1261,"address":[],"length":0,"stats":{"Line":0}},{"line":1262,"address":[],"length":0,"stats":{"Line":0}},{"line":1264,"address":[],"length":0,"stats":{"Line":0}},{"line":1266,"address":[],"length":0,"stats":{"Line":0}},{"line":1271,"address":[],"length":0,"stats":{"Line":0}},{"line":1272,"address":[],"length":0,"stats":{"Line":0}},{"line":1274,"address":[],"length":0,"stats":{"Line":0}},{"line":1275,"address":[],"length":0,"stats":{"Line":0}},{"line":1276,"address":[],"length":0,"stats":{"Line":0}},{"line":1277,"address":[],"length":0,"stats":{"Line":0}},{"line":1278,"address":[],"length":0,"stats":{"Line":0}},{"line":1279,"address":[],"length":0,"stats":{"Line":0}},{"line":1280,"address":[],"length":0,"stats":{"Line":0}},{"line":1282,"address":[],"length":0,"stats":{"Line":0}},{"line":1283,"address":[],"length":0,"stats":{"Line":0}},{"line":1284,"address":[],"length":0,"stats":{"Line":0}},{"line":1287,"address":[],"length":0,"stats":{"Line":0}},{"line":1289,"address":[],"length":0,"stats":{"Line":0}},{"line":1290,"address":[],"length":0,"stats":{"Line":0}},{"line":1291,"address":[],"length":0,"stats":{"Line":0}},{"line":1292,"address":[],"length":0,"stats":{"Line":0}},{"line":1293,"address":[],"length":0,"stats":{"Line":0}},{"line":1296,"address":[],"length":0,"stats":{"Line":0}},{"line":1297,"address":[],"length":0,"stats":{"Line":0}},{"line":1298,"address":[],"length":0,"stats":{"Line":0}},{"line":1299,"address":[],"length":0,"stats":{"Line":0}},{"line":1300,"address":[],"length":0,"stats":{"Line":0}},{"line":1301,"address":[],"length":0,"stats":{"Line":0}},{"line":1302,"address":[],"length":0,"stats":{"Line":0}},{"line":1303,"address":[],"length":0,"stats":{"Line":0}},{"line":1307,"address":[],"length":0,"stats":{"Line":0}},{"line":1308,"address":[],"length":0,"stats":{"Line":0}},{"line":1310,"address":[],"length":0,"stats":{"Line":0}},{"line":1313,"address":[],"length":0,"stats":{"Line":0}},{"line":1314,"address":[],"length":0,"stats":{"Line":0}},{"line":1315,"address":[],"length":0,"stats":{"Line":0}},{"line":1316,"address":[],"length":0,"stats":{"Line":0}},{"line":1317,"address":[],"length":0,"stats":{"Line":0}},{"line":1319,"address":[],"length":0,"stats":{"Line":0}},{"line":1320,"address":[],"length":0,"stats":{"Line":0}},{"line":1322,"address":[],"length":0,"stats":{"Line":0}},{"line":1325,"address":[],"length":0,"stats":{"Line":0}},{"line":1326,"address":[],"length":0,"stats":{"Line":0}},{"line":1327,"address":[],"length":0,"stats":{"Line":0}},{"line":1328,"address":[],"length":0,"stats":{"Line":0}},{"line":1333,"address":[],"length":0,"stats":{"Line":0}},{"line":1335,"address":[],"length":0,"stats":{"Line":0}},{"line":1339,"address":[],"length":0,"stats":{"Line":0}},{"line":1343,"address":[],"length":0,"stats":{"Line":0}},{"line":1350,"address":[],"length":0,"stats":{"Line":0}},{"line":1357,"address":[],"length":0,"stats":{"Line":0}},{"line":1358,"address":[],"length":0,"stats":{"Line":0}},{"line":1360,"address":[],"length":0,"stats":{"Line":0}},{"line":1364,"address":[],"length":0,"stats":{"Line":1}},{"line":1365,"address":[],"length":0,"stats":{"Line":2}},{"line":1366,"address":[],"length":0,"stats":{"Line":2}},{"line":1367,"address":[],"length":0,"stats":{"Line":2}},{"line":1368,"address":[],"length":0,"stats":{"Line":2}},{"line":1369,"address":[],"length":0,"stats":{"Line":2}},{"line":1370,"address":[],"length":0,"stats":{"Line":2}},{"line":1371,"address":[],"length":0,"stats":{"Line":2}},{"line":1372,"address":[],"length":0,"stats":{"Line":3}},{"line":1373,"address":[],"length":0,"stats":{"Line":3}},{"line":1374,"address":[],"length":0,"stats":{"Line":3}},{"line":1377,"address":[],"length":0,"stats":{"Line":3}},{"line":1378,"address":[],"length":0,"stats":{"Line":1}},{"line":1380,"address":[],"length":0,"stats":{"Line":0}},{"line":1381,"address":[],"length":0,"stats":{"Line":0}},{"line":1382,"address":[],"length":0,"stats":{"Line":0}},{"line":1383,"address":[],"length":0,"stats":{"Line":0}},{"line":1384,"address":[],"length":0,"stats":{"Line":0}},{"line":1387,"address":[],"length":0,"stats":{"Line":0}},{"line":1389,"address":[],"length":0,"stats":{"Line":0}},{"line":1390,"address":[],"length":0,"stats":{"Line":0}},{"line":1393,"address":[],"length":0,"stats":{"Line":0}},{"line":1394,"address":[],"length":0,"stats":{"Line":0}},{"line":1395,"address":[],"length":0,"stats":{"Line":0}},{"line":1398,"address":[],"length":0,"stats":{"Line":0}},{"line":1399,"address":[],"length":0,"stats":{"Line":0}},{"line":1400,"address":[],"length":0,"stats":{"Line":0}},{"line":1401,"address":[],"length":0,"stats":{"Line":0}},{"line":1402,"address":[],"length":0,"stats":{"Line":0}},{"line":1403,"address":[],"length":0,"stats":{"Line":0}},{"line":1407,"address":[],"length":0,"stats":{"Line":0}},{"line":1408,"address":[],"length":0,"stats":{"Line":0}},{"line":1409,"address":[],"length":0,"stats":{"Line":0}},{"line":1410,"address":[],"length":0,"stats":{"Line":0}},{"line":1414,"address":[],"length":0,"stats":{"Line":0}},{"line":1415,"address":[],"length":0,"stats":{"Line":0}},{"line":1416,"address":[],"length":0,"stats":{"Line":0}},{"line":1417,"address":[],"length":0,"stats":{"Line":0}},{"line":1420,"address":[],"length":0,"stats":{"Line":0}},{"line":1425,"address":[],"length":0,"stats":{"Line":3}},{"line":1426,"address":[],"length":0,"stats":{"Line":1}},{"line":1427,"address":[],"length":0,"stats":{"Line":0}},{"line":1430,"address":[],"length":0,"stats":{"Line":0}},{"line":1431,"address":[],"length":0,"stats":{"Line":0}},{"line":1433,"address":[],"length":0,"stats":{"Line":0}},{"line":1434,"address":[],"length":0,"stats":{"Line":0}},{"line":1436,"address":[],"length":0,"stats":{"Line":0}},{"line":1437,"address":[],"length":0,"stats":{"Line":0}},{"line":1438,"address":[],"length":0,"stats":{"Line":0}},{"line":1439,"address":[],"length":0,"stats":{"Line":0}},{"line":1440,"address":[],"length":0,"stats":{"Line":0}},{"line":1441,"address":[],"length":0,"stats":{"Line":0}},{"line":1442,"address":[],"length":0,"stats":{"Line":0}},{"line":1447,"address":[],"length":0,"stats":{"Line":3}},{"line":1448,"address":[],"length":0,"stats":{"Line":4}},{"line":1449,"address":[],"length":0,"stats":{"Line":0}},{"line":1453,"address":[],"length":0,"stats":{"Line":3}},{"line":1454,"address":[],"length":0,"stats":{"Line":9}},{"line":1456,"address":[],"length":0,"stats":{"Line":0}},{"line":1460,"address":[],"length":0,"stats":{"Line":2}},{"line":1461,"address":[],"length":0,"stats":{"Line":2}},{"line":1462,"address":[],"length":0,"stats":{"Line":10}},{"line":1463,"address":[],"length":0,"stats":{"Line":12}},{"line":1464,"address":[],"length":0,"stats":{"Line":12}},{"line":1465,"address":[],"length":0,"stats":{"Line":12}},{"line":1466,"address":[],"length":0,"stats":{"Line":12}},{"line":1467,"address":[],"length":0,"stats":{"Line":12}},{"line":1468,"address":[],"length":0,"stats":{"Line":9}},{"line":1472,"address":[],"length":0,"stats":{"Line":3}},{"line":1473,"address":[],"length":0,"stats":{"Line":10}},{"line":1474,"address":[],"length":0,"stats":{"Line":12}},{"line":1475,"address":[],"length":0,"stats":{"Line":12}},{"line":1476,"address":[],"length":0,"stats":{"Line":9}},{"line":1478,"address":[],"length":0,"stats":{"Line":3}},{"line":1480,"address":[],"length":0,"stats":{"Line":3}},{"line":1481,"address":[],"length":0,"stats":{"Line":1}},{"line":1482,"address":[],"length":0,"stats":{"Line":2}},{"line":1483,"address":[],"length":0,"stats":{"Line":1}},{"line":1484,"address":[],"length":0,"stats":{"Line":1}},{"line":1487,"address":[],"length":0,"stats":{"Line":3}},{"line":1488,"address":[],"length":0,"stats":{"Line":3}},{"line":1489,"address":[],"length":0,"stats":{"Line":2}},{"line":1490,"address":[],"length":0,"stats":{"Line":1}},{"line":1491,"address":[],"length":0,"stats":{"Line":3}},{"line":1492,"address":[],"length":0,"stats":{"Line":3}},{"line":1493,"address":[],"length":0,"stats":{"Line":2}},{"line":1494,"address":[],"length":0,"stats":{"Line":1}},{"line":1498,"address":[],"length":0,"stats":{"Line":1}},{"line":1499,"address":[],"length":0,"stats":{"Line":1}},{"line":1500,"address":[],"length":0,"stats":{"Line":0}},{"line":1501,"address":[],"length":0,"stats":{"Line":0}},{"line":1503,"address":[],"length":0,"stats":{"Line":0}},{"line":1506,"address":[],"length":0,"stats":{"Line":0}},{"line":1507,"address":[],"length":0,"stats":{"Line":0}},{"line":1508,"address":[],"length":0,"stats":{"Line":0}},{"line":1509,"address":[],"length":0,"stats":{"Line":0}},{"line":1510,"address":[],"length":0,"stats":{"Line":0}},{"line":1512,"address":[],"length":0,"stats":{"Line":0}},{"line":1514,"address":[],"length":0,"stats":{"Line":0}},{"line":1515,"address":[],"length":0,"stats":{"Line":0}},{"line":1516,"address":[],"length":0,"stats":{"Line":0}},{"line":1517,"address":[],"length":0,"stats":{"Line":0}},{"line":1518,"address":[],"length":0,"stats":{"Line":0}},{"line":1521,"address":[],"length":0,"stats":{"Line":0}},{"line":1522,"address":[],"length":0,"stats":{"Line":0}},{"line":1523,"address":[],"length":0,"stats":{"Line":0}},{"line":1524,"address":[],"length":0,"stats":{"Line":0}},{"line":1525,"address":[],"length":0,"stats":{"Line":0}},{"line":1526,"address":[],"length":0,"stats":{"Line":0}},{"line":1527,"address":[],"length":0,"stats":{"Line":0}},{"line":1528,"address":[],"length":0,"stats":{"Line":0}},{"line":1530,"address":[],"length":0,"stats":{"Line":0}},{"line":1532,"address":[],"length":0,"stats":{"Line":1}},{"line":1536,"address":[],"length":0,"stats":{"Line":1}},{"line":1537,"address":[],"length":0,"stats":{"Line":0}},{"line":1539,"address":[],"length":0,"stats":{"Line":3}},{"line":1540,"address":[],"length":0,"stats":{"Line":2}},{"line":1541,"address":[],"length":0,"stats":{"Line":3}},{"line":1542,"address":[],"length":0,"stats":{"Line":1}},{"line":1543,"address":[],"length":0,"stats":{"Line":0}},{"line":1544,"address":[],"length":0,"stats":{"Line":0}},{"line":1545,"address":[],"length":0,"stats":{"Line":0}},{"line":1547,"address":[],"length":0,"stats":{"Line":4}},{"line":1548,"address":[],"length":0,"stats":{"Line":4}},{"line":1549,"address":[],"length":0,"stats":{"Line":3}},{"line":1552,"address":[],"length":0,"stats":{"Line":3}},{"line":1554,"address":[],"length":0,"stats":{"Line":3}},{"line":1555,"address":[],"length":0,"stats":{"Line":1}},{"line":1556,"address":[],"length":0,"stats":{"Line":2}},{"line":1557,"address":[],"length":0,"stats":{"Line":1}},{"line":1558,"address":[],"length":0,"stats":{"Line":1}},{"line":1561,"address":[],"length":0,"stats":{"Line":3}},{"line":1562,"address":[],"length":0,"stats":{"Line":2}},{"line":1563,"address":[],"length":0,"stats":{"Line":1}},{"line":1564,"address":[],"length":0,"stats":{"Line":2}},{"line":1565,"address":[],"length":0,"stats":{"Line":1}},{"line":1566,"address":[],"length":0,"stats":{"Line":2}},{"line":1567,"address":[],"length":0,"stats":{"Line":1}},{"line":1568,"address":[],"length":0,"stats":{"Line":1}},{"line":1571,"address":[],"length":0,"stats":{"Line":2}},{"line":1572,"address":[],"length":0,"stats":{"Line":1}},{"line":1574,"address":[],"length":0,"stats":{"Line":1}},{"line":1577,"address":[],"length":0,"stats":{"Line":3}},{"line":1578,"address":[],"length":0,"stats":{"Line":3}},{"line":1579,"address":[],"length":0,"stats":{"Line":3}},{"line":1580,"address":[],"length":0,"stats":{"Line":3}},{"line":1581,"address":[],"length":0,"stats":{"Line":3}},{"line":1583,"address":[],"length":0,"stats":{"Line":2}},{"line":1584,"address":[],"length":0,"stats":{"Line":2}},{"line":1586,"address":[],"length":0,"stats":{"Line":1}},{"line":1589,"address":[],"length":0,"stats":{"Line":4}},{"line":1590,"address":[],"length":0,"stats":{"Line":3}},{"line":1591,"address":[],"length":0,"stats":{"Line":2}},{"line":1592,"address":[],"length":0,"stats":{"Line":1}},{"line":1624,"address":[],"length":0,"stats":{"Line":2}},{"line":1628,"address":[],"length":0,"stats":{"Line":3}},{"line":1635,"address":[],"length":0,"stats":{"Line":3}},{"line":1644,"address":[],"length":0,"stats":{"Line":1}},{"line":1645,"address":[],"length":0,"stats":{"Line":3}},{"line":1646,"address":[],"length":0,"stats":{"Line":3}},{"line":1649,"address":[],"length":0,"stats":{"Line":2}},{"line":1650,"address":[],"length":0,"stats":{"Line":3}},{"line":1653,"address":[],"length":0,"stats":{"Line":2}},{"line":1654,"address":[],"length":0,"stats":{"Line":3}},{"line":1657,"address":[],"length":0,"stats":{"Line":2}},{"line":1659,"address":[],"length":0,"stats":{"Line":3}},{"line":1662,"address":[],"length":0,"stats":{"Line":3}},{"line":1663,"address":[],"length":0,"stats":{"Line":3}},{"line":1664,"address":[],"length":0,"stats":{"Line":3}},{"line":1667,"address":[],"length":0,"stats":{"Line":3}},{"line":1668,"address":[],"length":0,"stats":{"Line":3}},{"line":1669,"address":[],"length":0,"stats":{"Line":3}},{"line":1670,"address":[],"length":0,"stats":{"Line":4}},{"line":1673,"address":[],"length":0,"stats":{"Line":3}},{"line":1674,"address":[],"length":0,"stats":{"Line":3}},{"line":1675,"address":[],"length":0,"stats":{"Line":3}},{"line":1676,"address":[],"length":0,"stats":{"Line":4}},{"line":1678,"address":[],"length":0,"stats":{"Line":1}},{"line":1682,"address":[],"length":0,"stats":{"Line":0}},{"line":1683,"address":[],"length":0,"stats":{"Line":0}},{"line":1684,"address":[],"length":0,"stats":{"Line":0}},{"line":1685,"address":[],"length":0,"stats":{"Line":0}},{"line":1687,"address":[],"length":0,"stats":{"Line":0}},{"line":1689,"address":[],"length":0,"stats":{"Line":0}},{"line":1690,"address":[],"length":0,"stats":{"Line":0}},{"line":1691,"address":[],"length":0,"stats":{"Line":0}},{"line":1694,"address":[],"length":0,"stats":{"Line":0}},{"line":1695,"address":[],"length":0,"stats":{"Line":0}},{"line":1696,"address":[],"length":0,"stats":{"Line":0}},{"line":1697,"address":[],"length":0,"stats":{"Line":0}},{"line":1698,"address":[],"length":0,"stats":{"Line":0}},{"line":1702,"address":[],"length":0,"stats":{"Line":0}},{"line":1703,"address":[],"length":0,"stats":{"Line":0}},{"line":1704,"address":[],"length":0,"stats":{"Line":0}},{"line":1710,"address":[],"length":0,"stats":{"Line":0}},{"line":1714,"address":[],"length":0,"stats":{"Line":0}},{"line":1715,"address":[],"length":0,"stats":{"Line":0}},{"line":1716,"address":[],"length":0,"stats":{"Line":0}},{"line":1717,"address":[],"length":0,"stats":{"Line":0}},{"line":1719,"address":[],"length":0,"stats":{"Line":0}},{"line":1724,"address":[],"length":0,"stats":{"Line":0}},{"line":1728,"address":[],"length":0,"stats":{"Line":0}},{"line":1729,"address":[],"length":0,"stats":{"Line":0}},{"line":1730,"address":[],"length":0,"stats":{"Line":0}},{"line":1733,"address":[],"length":0,"stats":{"Line":0}},{"line":1742,"address":[],"length":0,"stats":{"Line":7}},{"line":1743,"address":[],"length":0,"stats":{"Line":37}},{"line":1744,"address":[],"length":0,"stats":{"Line":20}},{"line":1745,"address":[],"length":0,"stats":{"Line":10}},{"line":1746,"address":[],"length":0,"stats":{"Line":10}},{"line":1751,"address":[],"length":0,"stats":{"Line":1}},{"line":1752,"address":[],"length":0,"stats":{"Line":3}},{"line":1753,"address":[],"length":0,"stats":{"Line":3}},{"line":1754,"address":[],"length":0,"stats":{"Line":4}},{"line":1755,"address":[],"length":0,"stats":{"Line":3}},{"line":1756,"address":[],"length":0,"stats":{"Line":3}},{"line":1757,"address":[],"length":0,"stats":{"Line":3}},{"line":1758,"address":[],"length":0,"stats":{"Line":2}},{"line":1763,"address":[],"length":0,"stats":{"Line":1}},{"line":1764,"address":[],"length":0,"stats":{"Line":3}},{"line":1765,"address":[],"length":0,"stats":{"Line":3}},{"line":1766,"address":[],"length":0,"stats":{"Line":4}},{"line":1767,"address":[],"length":0,"stats":{"Line":3}},{"line":1768,"address":[],"length":0,"stats":{"Line":3}},{"line":1769,"address":[],"length":0,"stats":{"Line":3}},{"line":1770,"address":[],"length":0,"stats":{"Line":2}},{"line":1775,"address":[],"length":0,"stats":{"Line":1}},{"line":1776,"address":[],"length":0,"stats":{"Line":3}},{"line":1777,"address":[],"length":0,"stats":{"Line":3}},{"line":1778,"address":[],"length":0,"stats":{"Line":4}},{"line":1779,"address":[],"length":0,"stats":{"Line":3}},{"line":1780,"address":[],"length":0,"stats":{"Line":3}},{"line":1781,"address":[],"length":0,"stats":{"Line":3}},{"line":1782,"address":[],"length":0,"stats":{"Line":2}},{"line":1787,"address":[],"length":0,"stats":{"Line":1}},{"line":1788,"address":[],"length":0,"stats":{"Line":4}},{"line":1789,"address":[],"length":0,"stats":{"Line":2}},{"line":1790,"address":[],"length":0,"stats":{"Line":1}},{"line":1791,"address":[],"length":0,"stats":{"Line":1}},{"line":1796,"address":[],"length":0,"stats":{"Line":7}},{"line":1797,"address":[],"length":0,"stats":{"Line":14}},{"line":1798,"address":[],"length":0,"stats":{"Line":14}},{"line":1799,"address":[],"length":0,"stats":{"Line":40}},{"line":1800,"address":[],"length":0,"stats":{"Line":44}},{"line":1801,"address":[],"length":0,"stats":{"Line":44}},{"line":1802,"address":[],"length":0,"stats":{"Line":44}},{"line":1803,"address":[],"length":0,"stats":{"Line":44}},{"line":1804,"address":[],"length":0,"stats":{"Line":44}},{"line":1805,"address":[],"length":0,"stats":{"Line":33}},{"line":1807,"address":[],"length":0,"stats":{"Line":7}},{"line":1811,"address":[],"length":0,"stats":{"Line":4}},{"line":1812,"address":[],"length":0,"stats":{"Line":12}},{"line":1813,"address":[],"length":0,"stats":{"Line":8}},{"line":1814,"address":[],"length":0,"stats":{"Line":8}},{"line":1815,"address":[],"length":0,"stats":{"Line":8}},{"line":1816,"address":[],"length":0,"stats":{"Line":4}},{"line":1818,"address":[],"length":0,"stats":{"Line":16}},{"line":1822,"address":[],"length":0,"stats":{"Line":1}},{"line":1823,"address":[],"length":0,"stats":{"Line":2}},{"line":1824,"address":[],"length":0,"stats":{"Line":3}},{"line":1829,"address":[],"length":0,"stats":{"Line":1}},{"line":1830,"address":[],"length":0,"stats":{"Line":3}},{"line":1832,"address":[],"length":0,"stats":{"Line":2}},{"line":1833,"address":[],"length":0,"stats":{"Line":2}},{"line":1835,"address":[],"length":0,"stats":{"Line":4}},{"line":1840,"address":[],"length":0,"stats":{"Line":2}},{"line":1841,"address":[],"length":0,"stats":{"Line":8}},{"line":1842,"address":[],"length":0,"stats":{"Line":6}},{"line":1843,"address":[],"length":0,"stats":{"Line":6}},{"line":1844,"address":[],"length":0,"stats":{"Line":2}},{"line":1845,"address":[],"length":0,"stats":{"Line":2}},{"line":1847,"address":[],"length":0,"stats":{"Line":2}},{"line":1864,"address":[],"length":0,"stats":{"Line":2}},{"line":1868,"address":[],"length":0,"stats":{"Line":2}},{"line":1869,"address":[],"length":0,"stats":{"Line":1}},{"line":1872,"address":[],"length":0,"stats":{"Line":2}},{"line":1873,"address":[],"length":0,"stats":{"Line":3}},{"line":1875,"address":[],"length":0,"stats":{"Line":3}},{"line":1876,"address":[],"length":0,"stats":{"Line":4}},{"line":1877,"address":[],"length":0,"stats":{"Line":4}},{"line":1878,"address":[],"length":0,"stats":{"Line":0}},{"line":1881,"address":[],"length":0,"stats":{"Line":6}},{"line":1882,"address":[],"length":0,"stats":{"Line":4}},{"line":1883,"address":[],"length":0,"stats":{"Line":4}},{"line":1884,"address":[],"length":0,"stats":{"Line":2}},{"line":1885,"address":[],"length":0,"stats":{"Line":2}},{"line":1887,"address":[],"length":0,"stats":{"Line":6}},{"line":1888,"address":[],"length":0,"stats":{"Line":4}},{"line":1889,"address":[],"length":0,"stats":{"Line":4}},{"line":1890,"address":[],"length":0,"stats":{"Line":2}},{"line":1891,"address":[],"length":0,"stats":{"Line":2}},{"line":1893,"address":[],"length":0,"stats":{"Line":6}},{"line":1894,"address":[],"length":0,"stats":{"Line":4}},{"line":1895,"address":[],"length":0,"stats":{"Line":4}},{"line":1896,"address":[],"length":0,"stats":{"Line":2}},{"line":1897,"address":[],"length":0,"stats":{"Line":2}},{"line":1900,"address":[],"length":0,"stats":{"Line":12}},{"line":1904,"address":[],"length":0,"stats":{"Line":6}},{"line":1905,"address":[],"length":0,"stats":{"Line":6}},{"line":1907,"address":[],"length":0,"stats":{"Line":1}},{"line":1932,"address":[],"length":0,"stats":{"Line":2}},{"line":1935,"address":[],"length":0,"stats":{"Line":2}},{"line":1936,"address":[],"length":0,"stats":{"Line":1}},{"line":1939,"address":[],"length":0,"stats":{"Line":2}},{"line":1940,"address":[],"length":0,"stats":{"Line":3}},{"line":1942,"address":[],"length":0,"stats":{"Line":3}},{"line":1943,"address":[],"length":0,"stats":{"Line":4}},{"line":1944,"address":[],"length":0,"stats":{"Line":4}},{"line":1945,"address":[],"length":0,"stats":{"Line":0}},{"line":1948,"address":[],"length":0,"stats":{"Line":6}},{"line":1949,"address":[],"length":0,"stats":{"Line":4}},{"line":1950,"address":[],"length":0,"stats":{"Line":4}},{"line":1951,"address":[],"length":0,"stats":{"Line":2}},{"line":1952,"address":[],"length":0,"stats":{"Line":2}},{"line":1954,"address":[],"length":0,"stats":{"Line":4}},{"line":1955,"address":[],"length":0,"stats":{"Line":4}},{"line":1956,"address":[],"length":0,"stats":{"Line":4}},{"line":1958,"address":[],"length":0,"stats":{"Line":6}},{"line":1959,"address":[],"length":0,"stats":{"Line":4}},{"line":1960,"address":[],"length":0,"stats":{"Line":4}},{"line":1961,"address":[],"length":0,"stats":{"Line":2}},{"line":1962,"address":[],"length":0,"stats":{"Line":2}},{"line":1966,"address":[],"length":0,"stats":{"Line":1}},{"line":1973,"address":[],"length":0,"stats":{"Line":1}},{"line":1974,"address":[],"length":0,"stats":{"Line":5}},{"line":1975,"address":[],"length":0,"stats":{"Line":4}},{"line":1976,"address":[],"length":0,"stats":{"Line":6}},{"line":1979,"address":[],"length":0,"stats":{"Line":6}},{"line":1980,"address":[],"length":0,"stats":{"Line":2}},{"line":2000,"address":[],"length":0,"stats":{"Line":3}},{"line":2002,"address":[],"length":0,"stats":{"Line":6}},{"line":2003,"address":[],"length":0,"stats":{"Line":3}},{"line":2007,"address":[],"length":0,"stats":{"Line":3}},{"line":2008,"address":[],"length":0,"stats":{"Line":6}},{"line":2009,"address":[],"length":0,"stats":{"Line":9}},{"line":2013,"address":[],"length":0,"stats":{"Line":1}},{"line":2014,"address":[],"length":0,"stats":{"Line":2}},{"line":2015,"address":[],"length":0,"stats":{"Line":6}},{"line":2016,"address":[],"length":0,"stats":{"Line":6}},{"line":2017,"address":[],"length":0,"stats":{"Line":5}},{"line":2018,"address":[],"length":0,"stats":{"Line":2}},{"line":2020,"address":[],"length":0,"stats":{"Line":6}},{"line":2021,"address":[],"length":0,"stats":{"Line":6}},{"line":2023,"address":[],"length":0,"stats":{"Line":1}}],"covered":557,"coverable":916},{"path":["/","workspace","crates","ofml-lib","src","geometry2d.rs"],"content":"//! 2D Representation System - Floor plan generation.\n//!\n//! This module implements 2D geometry primitives and SVG export\n//! for floor plan views.\n\nuse std::f64::consts::PI;\n\n/// 2D point.\n#[derive(Debug, Clone, Copy, PartialEq)]\npub struct Point2D {\n    pub x: f64,\n    pub y: f64,\n}\n\nimpl Point2D {\n    /// Create a new point.\n    pub fn new(x: f64, y: f64) -> Self {\n        Self { x, y }\n    }\n\n    /// Origin point (0, 0).\n    pub fn origin() -> Self {\n        Self { x: 0.0, y: 0.0 }\n    }\n\n    /// Distance to another point.\n    pub fn distance(&self, other: &Point2D) -> f64 {\n        let dx = self.x - other.x;\n        let dy = self.y - other.y;\n        (dx * dx + dy * dy).sqrt()\n    }\n\n    /// Apply a transform.\n    pub fn transform(&self, t: &Transform2D) -> Point2D {\n        // Apply scale\n        let x = self.x * t.scale[0];\n        let y = self.y * t.scale[1];\n\n        // Apply rotation\n        let cos_r = t.rotation.cos();\n        let sin_r = t.rotation.sin();\n        let rx = x * cos_r - y * sin_r;\n        let ry = x * sin_r + y * cos_r;\n\n        // Apply translation\n        Point2D {\n            x: rx + t.translation[0],\n            y: ry + t.translation[1],\n        }\n    }\n}\n\n/// 2D line segment.\n#[derive(Debug, Clone)]\npub struct Line2D {\n    pub start: Point2D,\n    pub end: Point2D,\n}\n\nimpl Line2D {\n    /// Create a new line.\n    pub fn new(start: Point2D, end: Point2D) -> Self {\n        Self { start, end }\n    }\n\n    /// Create from coordinates.\n    pub fn from_coords(x1: f64, y1: f64, x2: f64, y2: f64) -> Self {\n        Self {\n            start: Point2D::new(x1, y1),\n            end: Point2D::new(x2, y2),\n        }\n    }\n\n    /// Get the length.\n    pub fn length(&self) -> f64 {\n        self.start.distance(&self.end)\n    }\n}\n\n/// 2D rectangle.\n#[derive(Debug, Clone)]\npub struct Rect2D {\n    pub x: f64,\n    pub y: f64,\n    pub width: f64,\n    pub height: f64,\n}\n\nimpl Rect2D {\n    /// Create a new rectangle.\n    pub fn new(x: f64, y: f64, width: f64, height: f64) -> Self {\n        Self {\n            x,\n            y,\n            width,\n            height,\n        }\n    }\n\n    /// Get the center point.\n    pub fn center(&self) -> Point2D {\n        Point2D::new(self.x + self.width / 2.0, self.y + self.height / 2.0)\n    }\n\n    /// Get the corner points.\n    pub fn corners(&self) -> [Point2D; 4] {\n        [\n            Point2D::new(self.x, self.y),\n            Point2D::new(self.x + self.width, self.y),\n            Point2D::new(self.x + self.width, self.y + self.height),\n            Point2D::new(self.x, self.y + self.height),\n        ]\n    }\n}\n\n/// 2D circle.\n#[derive(Debug, Clone)]\npub struct Circle2D {\n    pub center: Point2D,\n    pub radius: f64,\n}\n\nimpl Circle2D {\n    /// Create a new circle.\n    pub fn new(center: Point2D, radius: f64) -> Self {\n        Self { center, radius }\n    }\n\n    /// Create from center coordinates.\n    pub fn from_coords(cx: f64, cy: f64, radius: f64) -> Self {\n        Self {\n            center: Point2D::new(cx, cy),\n            radius,\n        }\n    }\n}\n\n/// 2D ellipse.\n#[derive(Debug, Clone)]\npub struct Ellipse2D {\n    pub center: Point2D,\n    pub rx: f64,\n    pub ry: f64,\n}\n\nimpl Ellipse2D {\n    /// Create a new ellipse.\n    pub fn new(center: Point2D, rx: f64, ry: f64) -> Self {\n        Self { center, rx, ry }\n    }\n}\n\n/// 2D arc.\n#[derive(Debug, Clone)]\npub struct Arc2D {\n    pub center: Point2D,\n    pub radius: f64,\n    /// Start angle in radians\n    pub start_angle: f64,\n    /// End angle in radians\n    pub end_angle: f64,\n}\n\nimpl Arc2D {\n    /// Create a new arc.\n    pub fn new(center: Point2D, radius: f64, start_angle: f64, end_angle: f64) -> Self {\n        Self {\n            center,\n            radius,\n            start_angle,\n            end_angle,\n        }\n    }\n\n    /// Get the start point.\n    pub fn start_point(&self) -> Point2D {\n        Point2D::new(\n            self.center.x + self.radius * self.start_angle.cos(),\n            self.center.y + self.radius * self.start_angle.sin(),\n        )\n    }\n\n    /// Get the end point.\n    pub fn end_point(&self) -> Point2D {\n        Point2D::new(\n            self.center.x + self.radius * self.end_angle.cos(),\n            self.center.y + self.radius * self.end_angle.sin(),\n        )\n    }\n}\n\n/// Text anchor position.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]\npub enum TextAnchor {\n    #[default]\n    Start,\n    Middle,\n    End,\n}\n\n/// 2D text label.\n#[derive(Debug, Clone)]\npub struct Text2D {\n    pub position: Point2D,\n    pub text: String,\n    pub font_size: f64,\n    pub anchor: TextAnchor,\n}\n\nimpl Text2D {\n    /// Create a new text label.\n    pub fn new(position: Point2D, text: impl Into<String>, font_size: f64) -> Self {\n        Self {\n            position,\n            text: text.into(),\n            font_size,\n            anchor: TextAnchor::default(),\n        }\n    }\n\n    /// Set the anchor.\n    pub fn with_anchor(mut self, anchor: TextAnchor) -> Self {\n        self.anchor = anchor;\n        self\n    }\n}\n\n/// 2D primitive types for floor plan generation.\n#[derive(Debug, Clone)]\npub enum G2DPrimitive {\n    /// Point set\n    Points(Vec<Point2D>),\n    /// Individual line segments\n    Lines(Vec<Line2D>),\n    /// Connected line strip\n    LineStrip(Vec<Point2D>),\n    /// Closed line loop\n    LineLoop(Vec<Point2D>),\n    /// Convex polygon (filled)\n    Polygon(Vec<Point2D>),\n    /// Rectangle\n    Rectangle(Rect2D),\n    /// Circle\n    Circle(Circle2D),\n    /// Ellipse\n    Ellipse(Ellipse2D),\n    /// Arc\n    Arc(Arc2D),\n    /// Text label\n    Text(Text2D),\n}\n\n/// Line style.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]\npub enum LineStyle {\n    #[default]\n    Solid,\n    Dashed,\n    Dotted,\n    DashDot,\n}\n\nimpl LineStyle {\n    /// Get SVG dash array.\n    pub fn to_svg_dasharray(&self) -> Option<&'static str> {\n        match self {\n            LineStyle::Solid => None,\n            LineStyle::Dashed => Some(\"10,5\"),\n            LineStyle::Dotted => Some(\"2,2\"),\n            LineStyle::DashDot => Some(\"10,2,2,2\"),\n        }\n    }\n}\n\n/// Fill style.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]\npub enum FillStyle {\n    #[default]\n    None,\n    Solid,\n    Hatched,\n}\n\n/// Visual attributes for 2D rendering.\n#[derive(Debug, Clone)]\npub struct G2DAttributes {\n    /// Stroke/line color [R, G, B, A]\n    pub color: [f32; 4],\n    /// Fill color (None = no fill)\n    pub fill_color: Option<[f32; 4]>,\n    /// Line width in mm\n    pub line_width: f32,\n    /// Line style\n    pub line_style: LineStyle,\n    /// Fill style\n    pub fill_style: FillStyle,\n    /// Layer name for visibility control\n    pub layer: String,\n}\n\nimpl G2DAttributes {\n    /// Create new attributes with default values.\n    pub fn new() -> Self {\n        Self {\n            color: [0.0, 0.0, 0.0, 1.0],\n            fill_color: None,\n            line_width: 1.0,\n            line_style: LineStyle::Solid,\n            fill_style: FillStyle::None,\n            layer: \"default\".to_string(),\n        }\n    }\n\n    /// Set stroke color.\n    pub fn with_color(mut self, r: f32, g: f32, b: f32, a: f32) -> Self {\n        self.color = [r, g, b, a];\n        self\n    }\n\n    /// Set fill color.\n    pub fn with_fill(mut self, r: f32, g: f32, b: f32, a: f32) -> Self {\n        self.fill_color = Some([r, g, b, a]);\n        self.fill_style = FillStyle::Solid;\n        self\n    }\n\n    /// Set line width.\n    pub fn with_line_width(mut self, width: f32) -> Self {\n        self.line_width = width;\n        self\n    }\n\n    /// Set line style.\n    pub fn with_line_style(mut self, style: LineStyle) -> Self {\n        self.line_style = style;\n        self\n    }\n\n    /// Set layer.\n    pub fn with_layer(mut self, layer: impl Into<String>) -> Self {\n        self.layer = layer.into();\n        self\n    }\n\n    /// Get SVG stroke color string.\n    pub fn svg_stroke(&self) -> String {\n        format!(\n            \"rgb({},{},{})\",\n            (self.color[0] * 255.0) as u8,\n            (self.color[1] * 255.0) as u8,\n            (self.color[2] * 255.0) as u8\n        )\n    }\n\n    /// Get SVG fill color string.\n    pub fn svg_fill(&self) -> String {\n        match self.fill_color {\n            Some(c) => format!(\n                \"rgb({},{},{})\",\n                (c[0] * 255.0) as u8,\n                (c[1] * 255.0) as u8,\n                (c[2] * 255.0) as u8\n            ),\n            None => \"none\".to_string(),\n        }\n    }\n}\n\nimpl Default for G2DAttributes {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// 2D affine transform.\n#[derive(Debug, Clone)]\npub struct Transform2D {\n    /// Translation [tx, ty]\n    pub translation: [f64; 2],\n    /// Rotation angle in radians\n    pub rotation: f64,\n    /// Scale factors [sx, sy]\n    pub scale: [f64; 2],\n}\n\nimpl Transform2D {\n    /// Create an identity transform.\n    pub fn identity() -> Self {\n        Self::default()\n    }\n\n    /// Create a translation transform.\n    pub fn translate(x: f64, y: f64) -> Self {\n        Self {\n            translation: [x, y],\n            rotation: 0.0,\n            scale: [1.0, 1.0],\n        }\n    }\n\n    /// Create a rotation transform.\n    pub fn rotate(angle: f64) -> Self {\n        Self {\n            translation: [0.0, 0.0],\n            rotation: angle,\n            scale: [1.0, 1.0],\n        }\n    }\n\n    /// Create a scale transform.\n    pub fn scale(sx: f64, sy: f64) -> Self {\n        Self {\n            translation: [0.0, 0.0],\n            rotation: 0.0,\n            scale: [sx, sy],\n        }\n    }\n\n    /// Compose with another transform.\n    pub fn then(&self, other: &Transform2D) -> Transform2D {\n        // Simplified composition: apply self, then other\n        Transform2D {\n            translation: [\n                self.translation[0] + other.translation[0],\n                self.translation[1] + other.translation[1],\n            ],\n            rotation: self.rotation + other.rotation,\n            scale: [\n                self.scale[0] * other.scale[0],\n                self.scale[1] * other.scale[1],\n            ],\n        }\n    }\n\n    /// Get SVG transform string.\n    pub fn to_svg(&self) -> String {\n        let mut parts = Vec::new();\n\n        if self.translation[0] != 0.0 || self.translation[1] != 0.0 {\n            parts.push(format!(\n                \"translate({:.3},{:.3})\",\n                self.translation[0], self.translation[1]\n            ));\n        }\n\n        if self.rotation != 0.0 {\n            parts.push(format!(\"rotate({:.3})\", self.rotation * 180.0 / PI));\n        }\n\n        if self.scale[0] != 1.0 || self.scale[1] != 1.0 {\n            parts.push(format!(\"scale({:.3},{:.3})\", self.scale[0], self.scale[1]));\n        }\n\n        parts.join(\" \")\n    }\n}\n\nimpl Default for Transform2D {\n    fn default() -> Self {\n        Self {\n            translation: [0.0, 0.0],\n            rotation: 0.0,\n            scale: [1.0, 1.0],\n        }\n    }\n}\n\n/// Compound 2D object containing multiple primitives.\n#[derive(Debug, Clone)]\npub struct G2DCompound {\n    /// Child primitives\n    pub primitives: Vec<G2DPrimitive>,\n    /// Child compounds (nested groups)\n    pub children: Vec<G2DCompound>,\n    /// Local transform\n    pub transform: Transform2D,\n    /// Visual attributes (inherited by children unless overridden)\n    pub attributes: G2DAttributes,\n}\n\nimpl G2DCompound {\n    /// Create a new empty compound.\n    pub fn new() -> Self {\n        Self {\n            primitives: Vec::new(),\n            children: Vec::new(),\n            transform: Transform2D::default(),\n            attributes: G2DAttributes::default(),\n        }\n    }\n\n    /// Add a primitive.\n    pub fn add_primitive(&mut self, primitive: G2DPrimitive) {\n        self.primitives.push(primitive);\n    }\n\n    /// Add a child compound.\n    pub fn add_child(&mut self, child: G2DCompound) {\n        self.children.push(child);\n    }\n\n    /// Set the transform.\n    pub fn with_transform(mut self, transform: Transform2D) -> Self {\n        self.transform = transform;\n        self\n    }\n\n    /// Set the attributes.\n    pub fn with_attributes(mut self, attributes: G2DAttributes) -> Self {\n        self.attributes = attributes;\n        self\n    }\n\n    /// Export to SVG string.\n    pub fn to_svg(&self) -> String {\n        let mut svg = String::new();\n        svg.push_str(r#\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\"#);\n        svg.push('\\n');\n        svg.push_str(r#\"<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\"#);\n        svg.push('\\n');\n\n        self.write_svg_content(&mut svg, &Transform2D::default());\n\n        svg.push_str(\"</svg>\\n\");\n        svg\n    }\n\n    /// Write SVG content recursively.\n    fn write_svg_content(&self, svg: &mut String, parent_transform: &Transform2D) {\n        let combined = parent_transform.then(&self.transform);\n        let transform_attr = combined.to_svg();\n        let group_start = if transform_attr.is_empty() {\n            \"<g>\".to_string()\n        } else {\n            format!(r#\"<g transform=\"{}\">\"#, transform_attr)\n        };\n\n        svg.push_str(&group_start);\n        svg.push('\\n');\n\n        // Write primitives\n        for primitive in &self.primitives {\n            self.write_primitive_svg(svg, primitive);\n        }\n\n        // Write children\n        for child in &self.children {\n            child.write_svg_content(svg, &combined);\n        }\n\n        svg.push_str(\"</g>\\n\");\n    }\n\n    /// Write a single primitive to SVG.\n    fn write_primitive_svg(&self, svg: &mut String, primitive: &G2DPrimitive) {\n        let stroke = self.attributes.svg_stroke();\n        let fill = self.attributes.svg_fill();\n        let width = self.attributes.line_width;\n        let dash = self.attributes.line_style.to_svg_dasharray();\n        let dash_attr = dash\n            .map(|d| format!(r#\" stroke-dasharray=\"{}\"\"#, d))\n            .unwrap_or_default();\n\n        match primitive {\n            G2DPrimitive::Points(points) => {\n                for p in points {\n                    svg.push_str(&format!(\n                        r#\"  <circle cx=\"{:.3}\" cy=\"{:.3}\" r=\"1\" fill=\"{}\" />\"#,\n                        p.x, p.y, stroke\n                    ));\n                    svg.push('\\n');\n                }\n            }\n            G2DPrimitive::Lines(lines) => {\n                for line in lines {\n                    svg.push_str(&format!(\n                        r#\"  <line x1=\"{:.3}\" y1=\"{:.3}\" x2=\"{:.3}\" y2=\"{:.3}\" stroke=\"{}\" stroke-width=\"{:.2}\"{} />\"#,\n                        line.start.x, line.start.y, line.end.x, line.end.y, stroke, width, dash_attr\n                    ));\n                    svg.push('\\n');\n                }\n            }\n            G2DPrimitive::LineStrip(points) => {\n                if points.len() >= 2 {\n                    let path_data: String = points\n                        .iter()\n                        .enumerate()\n                        .map(|(i, p)| {\n                            if i == 0 {\n                                format!(\"M{:.3},{:.3}\", p.x, p.y)\n                            } else {\n                                format!(\"L{:.3},{:.3}\", p.x, p.y)\n                            }\n                        })\n                        .collect();\n                    svg.push_str(&format!(\n                        r#\"  <path d=\"{}\" fill=\"none\" stroke=\"{}\" stroke-width=\"{:.2}\"{} />\"#,\n                        path_data, stroke, width, dash_attr\n                    ));\n                    svg.push('\\n');\n                }\n            }\n            G2DPrimitive::LineLoop(points) => {\n                if points.len() >= 3 {\n                    let path_data: String = points\n                        .iter()\n                        .enumerate()\n                        .map(|(i, p)| {\n                            if i == 0 {\n                                format!(\"M{:.3},{:.3}\", p.x, p.y)\n                            } else {\n                                format!(\"L{:.3},{:.3}\", p.x, p.y)\n                            }\n                        })\n                        .collect::<String>()\n                        + \"Z\";\n                    svg.push_str(&format!(\n                        r#\"  <path d=\"{}\" fill=\"none\" stroke=\"{}\" stroke-width=\"{:.2}\"{} />\"#,\n                        path_data, stroke, width, dash_attr\n                    ));\n                    svg.push('\\n');\n                }\n            }\n            G2DPrimitive::Polygon(points) => {\n                if points.len() >= 3 {\n                    let points_str: String = points\n                        .iter()\n                        .map(|p| format!(\"{:.3},{:.3}\", p.x, p.y))\n                        .collect::<Vec<_>>()\n                        .join(\" \");\n                    svg.push_str(&format!(\n                        r#\"  <polygon points=\"{}\" fill=\"{}\" stroke=\"{}\" stroke-width=\"{:.2}\" />\"#,\n                        points_str, fill, stroke, width\n                    ));\n                    svg.push('\\n');\n                }\n            }\n            G2DPrimitive::Rectangle(rect) => {\n                svg.push_str(&format!(\n                    r#\"  <rect x=\"{:.3}\" y=\"{:.3}\" width=\"{:.3}\" height=\"{:.3}\" fill=\"{}\" stroke=\"{}\" stroke-width=\"{:.2}\"{} />\"#,\n                    rect.x, rect.y, rect.width, rect.height, fill, stroke, width, dash_attr\n                ));\n                svg.push('\\n');\n            }\n            G2DPrimitive::Circle(circle) => {\n                svg.push_str(&format!(\n                    r#\"  <circle cx=\"{:.3}\" cy=\"{:.3}\" r=\"{:.3}\" fill=\"{}\" stroke=\"{}\" stroke-width=\"{:.2}\" />\"#,\n                    circle.center.x, circle.center.y, circle.radius, fill, stroke, width\n                ));\n                svg.push('\\n');\n            }\n            G2DPrimitive::Ellipse(ellipse) => {\n                svg.push_str(&format!(\n                    r#\"  <ellipse cx=\"{:.3}\" cy=\"{:.3}\" rx=\"{:.3}\" ry=\"{:.3}\" fill=\"{}\" stroke=\"{}\" stroke-width=\"{:.2}\" />\"#,\n                    ellipse.center.x, ellipse.center.y, ellipse.rx, ellipse.ry, fill, stroke, width\n                ));\n                svg.push('\\n');\n            }\n            G2DPrimitive::Arc(arc) => {\n                let start = arc.start_point();\n                let end = arc.end_point();\n                let large_arc = if (arc.end_angle - arc.start_angle).abs() > PI {\n                    1\n                } else {\n                    0\n                };\n                let sweep = if arc.end_angle > arc.start_angle {\n                    1\n                } else {\n                    0\n                };\n\n                svg.push_str(&format!(\n                    r#\"  <path d=\"M{:.3},{:.3} A{:.3},{:.3} 0 {} {} {:.3},{:.3}\" fill=\"none\" stroke=\"{}\" stroke-width=\"{:.2}\" />\"#,\n                    start.x, start.y, arc.radius, arc.radius, large_arc, sweep, end.x, end.y, stroke, width\n                ));\n                svg.push('\\n');\n            }\n            G2DPrimitive::Text(text) => {\n                let anchor = match text.anchor {\n                    TextAnchor::Start => \"start\",\n                    TextAnchor::Middle => \"middle\",\n                    TextAnchor::End => \"end\",\n                };\n                svg.push_str(&format!(\n                    r#\"  <text x=\"{:.3}\" y=\"{:.3}\" font-size=\"{:.1}\" text-anchor=\"{}\" fill=\"{}\">{}</text>\"#,\n                    text.position.x, text.position.y, text.font_size, anchor, stroke, text.text\n                ));\n                svg.push('\\n');\n            }\n        }\n    }\n\n    /// Calculate bounding box.\n    pub fn bounding_box(&self) -> Option<(Point2D, Point2D)> {\n        let mut min_x = f64::MAX;\n        let mut min_y = f64::MAX;\n        let mut max_x = f64::MIN;\n        let mut max_y = f64::MIN;\n        let mut has_points = false;\n\n        fn update_bounds(\n            x: f64,\n            y: f64,\n            min_x: &mut f64,\n            min_y: &mut f64,\n            max_x: &mut f64,\n            max_y: &mut f64,\n            has_points: &mut bool,\n        ) {\n            *min_x = min_x.min(x);\n            *min_y = min_y.min(y);\n            *max_x = max_x.max(x);\n            *max_y = max_y.max(y);\n            *has_points = true;\n        }\n\n        for primitive in &self.primitives {\n            match primitive {\n                G2DPrimitive::Points(points)\n                | G2DPrimitive::LineStrip(points)\n                | G2DPrimitive::LineLoop(points)\n                | G2DPrimitive::Polygon(points) => {\n                    for p in points {\n                        update_bounds(\n                            p.x,\n                            p.y,\n                            &mut min_x,\n                            &mut min_y,\n                            &mut max_x,\n                            &mut max_y,\n                            &mut has_points,\n                        );\n                    }\n                }\n                G2DPrimitive::Lines(lines) => {\n                    for line in lines {\n                        update_bounds(\n                            line.start.x,\n                            line.start.y,\n                            &mut min_x,\n                            &mut min_y,\n                            &mut max_x,\n                            &mut max_y,\n                            &mut has_points,\n                        );\n                        update_bounds(\n                            line.end.x,\n                            line.end.y,\n                            &mut min_x,\n                            &mut min_y,\n                            &mut max_x,\n                            &mut max_y,\n                            &mut has_points,\n                        );\n                    }\n                }\n                G2DPrimitive::Rectangle(rect) => {\n                    update_bounds(\n                        rect.x,\n                        rect.y,\n                        &mut min_x,\n                        &mut min_y,\n                        &mut max_x,\n                        &mut max_y,\n                        &mut has_points,\n                    );\n                    update_bounds(\n                        rect.x + rect.width,\n                        rect.y + rect.height,\n                        &mut min_x,\n                        &mut min_y,\n                        &mut max_x,\n                        &mut max_y,\n                        &mut has_points,\n                    );\n                }\n                G2DPrimitive::Circle(circle) => {\n                    update_bounds(\n                        circle.center.x - circle.radius,\n                        circle.center.y - circle.radius,\n                        &mut min_x,\n                        &mut min_y,\n                        &mut max_x,\n                        &mut max_y,\n                        &mut has_points,\n                    );\n                    update_bounds(\n                        circle.center.x + circle.radius,\n                        circle.center.y + circle.radius,\n                        &mut min_x,\n                        &mut min_y,\n                        &mut max_x,\n                        &mut max_y,\n                        &mut has_points,\n                    );\n                }\n                G2DPrimitive::Ellipse(ellipse) => {\n                    update_bounds(\n                        ellipse.center.x - ellipse.rx,\n                        ellipse.center.y - ellipse.ry,\n                        &mut min_x,\n                        &mut min_y,\n                        &mut max_x,\n                        &mut max_y,\n                        &mut has_points,\n                    );\n                    update_bounds(\n                        ellipse.center.x + ellipse.rx,\n                        ellipse.center.y + ellipse.ry,\n                        &mut min_x,\n                        &mut min_y,\n                        &mut max_x,\n                        &mut max_y,\n                        &mut has_points,\n                    );\n                }\n                G2DPrimitive::Arc(arc) => {\n                    update_bounds(\n                        arc.center.x - arc.radius,\n                        arc.center.y - arc.radius,\n                        &mut min_x,\n                        &mut min_y,\n                        &mut max_x,\n                        &mut max_y,\n                        &mut has_points,\n                    );\n                    update_bounds(\n                        arc.center.x + arc.radius,\n                        arc.center.y + arc.radius,\n                        &mut min_x,\n                        &mut min_y,\n                        &mut max_x,\n                        &mut max_y,\n                        &mut has_points,\n                    );\n                }\n                G2DPrimitive::Text(text) => {\n                    update_bounds(\n                        text.position.x,\n                        text.position.y,\n                        &mut min_x,\n                        &mut min_y,\n                        &mut max_x,\n                        &mut max_y,\n                        &mut has_points,\n                    );\n                }\n            }\n        }\n\n        if has_points {\n            Some((Point2D::new(min_x, min_y), Point2D::new(max_x, max_y)))\n        } else {\n            None\n        }\n    }\n}\n\nimpl Default for G2DCompound {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Convert an Odb2dRecord to a G2DPrimitive.\n///\n/// This handles the conversion of EBASE odb2d records into 2D geometry primitives\n/// for floor plan rendering and SVG export.\npub fn odb2d_to_primitive(record: &crate::ebase::Odb2dRecord) -> Option<G2DPrimitive> {\n    let prim_type = record.prim_type.to_lowercase();\n    let x = record.parse_x_coords();\n    let y = record.parse_y_coords();\n\n    match prim_type.as_str() {\n        \"point\" | \"points\" => {\n            let points: Vec<Point2D> = x\n                .iter()\n                .zip(y.iter())\n                .map(|(&x, &y)| Point2D::new(x, y))\n                .collect();\n            if points.is_empty() {\n                None\n            } else {\n                Some(G2DPrimitive::Points(points))\n            }\n        }\n        \"line\" | \"lines\" => {\n            // Lines come in pairs of points\n            if x.len() < 2 || y.len() < 2 {\n                return None;\n            }\n            let mut lines = Vec::new();\n            for i in (0..x.len().min(y.len())).step_by(2) {\n                if i + 1 < x.len() && i + 1 < y.len() {\n                    lines.push(Line2D::from_coords(x[i], y[i], x[i + 1], y[i + 1]));\n                }\n            }\n            if lines.is_empty() {\n                None\n            } else {\n                Some(G2DPrimitive::Lines(lines))\n            }\n        }\n        \"linestrip\" | \"line_strip\" | \"polyline\" => {\n            let points: Vec<Point2D> = x\n                .iter()\n                .zip(y.iter())\n                .map(|(&x, &y)| Point2D::new(x, y))\n                .collect();\n            if points.len() < 2 {\n                None\n            } else {\n                Some(G2DPrimitive::LineStrip(points))\n            }\n        }\n        \"lineloop\" | \"line_loop\" | \"closed_polyline\" => {\n            let points: Vec<Point2D> = x\n                .iter()\n                .zip(y.iter())\n                .map(|(&x, &y)| Point2D::new(x, y))\n                .collect();\n            if points.len() < 3 {\n                None\n            } else {\n                Some(G2DPrimitive::LineLoop(points))\n            }\n        }\n        \"polygon\" | \"poly\" | \"filled_polygon\" => {\n            let points: Vec<Point2D> = x\n                .iter()\n                .zip(y.iter())\n                .map(|(&x, &y)| Point2D::new(x, y))\n                .collect();\n            if points.len() < 3 {\n                None\n            } else {\n                Some(G2DPrimitive::Polygon(points))\n            }\n        }\n        \"rect\" | \"rectangle\" => {\n            let px = x.first().copied().unwrap_or(0.0);\n            let py = y.first().copied().unwrap_or(0.0);\n            let width = record.parse_width();\n            let height = record.parse_height();\n            Some(G2DPrimitive::Rectangle(Rect2D::new(px, py, width, height)))\n        }\n        \"circle\" => {\n            let cx = x.first().copied().unwrap_or(0.0);\n            let cy = y.first().copied().unwrap_or(0.0);\n            let radius = record.parse_radius();\n            Some(G2DPrimitive::Circle(Circle2D::from_coords(cx, cy, radius)))\n        }\n        \"ellipse\" => {\n            let cx = x.first().copied().unwrap_or(0.0);\n            let cy = y.first().copied().unwrap_or(0.0);\n            let rx = record.parse_width() / 2.0;\n            let ry = record.parse_height() / 2.0;\n            Some(G2DPrimitive::Ellipse(Ellipse2D::new(\n                Point2D::new(cx, cy),\n                rx,\n                ry,\n            )))\n        }\n        \"arc\" => {\n            let cx = x.first().copied().unwrap_or(0.0);\n            let cy = y.first().copied().unwrap_or(0.0);\n            let radius = record.parse_radius();\n            let start_angle = record.parse_start_angle().to_radians();\n            let end_angle = record.parse_end_angle().to_radians();\n            Some(G2DPrimitive::Arc(Arc2D::new(\n                Point2D::new(cx, cy),\n                radius,\n                start_angle,\n                end_angle,\n            )))\n        }\n        \"text\" | \"label\" => {\n            let px = x.first().copied().unwrap_or(0.0);\n            let py = y.first().copied().unwrap_or(0.0);\n            let text = &record.text;\n            let font_size = record.parse_font_size();\n            Some(G2DPrimitive::Text(Text2D::new(\n                Point2D::new(px, py),\n                text.clone(),\n                font_size,\n            )))\n        }\n        _ => None,\n    }\n}\n\n/// Get G2DAttributes from an Odb2dRecord.\npub fn odb2d_to_attributes(record: &crate::ebase::Odb2dRecord) -> G2DAttributes {\n    let color = record.parse_color();\n    let fill_color = record.parse_fill_color();\n    let line_width = record.parse_line_width();\n    let line_style = match record.get_line_style() {\n        \"dashed\" => LineStyle::Dashed,\n        \"dotted\" => LineStyle::Dotted,\n        \"dashdot\" => LineStyle::DashDot,\n        _ => LineStyle::Solid,\n    };\n\n    let mut attrs = G2DAttributes::new()\n        .with_color(color[0], color[1], color[2], color[3])\n        .with_line_width(line_width)\n        .with_line_style(line_style)\n        .with_layer(&record.layer);\n\n    if let Some(fill) = fill_color {\n        attrs = attrs.with_fill(fill[0], fill[1], fill[2], fill[3]);\n    }\n\n    attrs\n}\n\n/// Process multiple Odb2dRecords into a G2DCompound.\n///\n/// Groups primitives by layer and applies attributes.\npub fn process_odb2d_records(records: &[crate::ebase::Odb2dRecord]) -> G2DCompound {\n    let mut compound = G2DCompound::new();\n\n    for record in records {\n        if let Some(primitive) = odb2d_to_primitive(record) {\n            // Create a sub-compound for each primitive with its attributes\n            let attrs = odb2d_to_attributes(record);\n            let mut prim_compound = G2DCompound::new().with_attributes(attrs);\n            prim_compound.add_primitive(primitive);\n            compound.add_child(prim_compound);\n        }\n    }\n\n    compound\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_point2d() {\n        let p1 = Point2D::new(0.0, 0.0);\n        let p2 = Point2D::new(3.0, 4.0);\n        assert!((p1.distance(&p2) - 5.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_point_transform() {\n        let p = Point2D::new(1.0, 0.0);\n        let t = Transform2D::rotate(std::f64::consts::FRAC_PI_2);\n        let tp = p.transform(&t);\n        assert!(tp.x.abs() < 0.001);\n        assert!((tp.y - 1.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_rect2d() {\n        let rect = Rect2D::new(0.0, 0.0, 100.0, 50.0);\n        let center = rect.center();\n        assert_eq!(center.x, 50.0);\n        assert_eq!(center.y, 25.0);\n\n        let corners = rect.corners();\n        assert_eq!(corners.len(), 4);\n    }\n\n    #[test]\n    fn test_transform2d() {\n        let t = Transform2D::translate(10.0, 20.0);\n        assert_eq!(t.translation, [10.0, 20.0]);\n\n        let svg = t.to_svg();\n        assert!(svg.contains(\"translate\"));\n    }\n\n    #[test]\n    fn test_g2d_compound() {\n        let mut compound = G2DCompound::new();\n\n        compound.add_primitive(G2DPrimitive::Rectangle(Rect2D::new(0.0, 0.0, 100.0, 50.0)));\n        compound.add_primitive(G2DPrimitive::Circle(Circle2D::from_coords(\n            50.0, 25.0, 10.0,\n        )));\n\n        let svg = compound.to_svg();\n        assert!(svg.contains(\"<rect\"));\n        assert!(svg.contains(\"<circle\"));\n    }\n\n    #[test]\n    fn test_g2d_bounding_box() {\n        let mut compound = G2DCompound::new();\n        compound.add_primitive(G2DPrimitive::Rectangle(Rect2D::new(\n            10.0, 20.0, 100.0, 50.0,\n        )));\n\n        let bbox = compound.bounding_box().unwrap();\n        assert_eq!(bbox.0.x, 10.0);\n        assert_eq!(bbox.0.y, 20.0);\n        assert_eq!(bbox.1.x, 110.0);\n        assert_eq!(bbox.1.y, 70.0);\n    }\n\n    #[test]\n    fn test_g2d_attributes() {\n        let attrs = G2DAttributes::new()\n            .with_color(1.0, 0.0, 0.0, 1.0)\n            .with_fill(0.0, 1.0, 0.0, 1.0)\n            .with_line_width(2.0)\n            .with_line_style(LineStyle::Dashed);\n\n        assert_eq!(attrs.svg_stroke(), \"rgb(255,0,0)\");\n        assert_eq!(attrs.svg_fill(), \"rgb(0,255,0)\");\n        assert_eq!(attrs.line_style.to_svg_dasharray(), Some(\"10,5\"));\n    }\n\n    #[test]\n    fn test_line_style() {\n        assert_eq!(LineStyle::Solid.to_svg_dasharray(), None);\n        assert_eq!(LineStyle::Dashed.to_svg_dasharray(), Some(\"10,5\"));\n        assert_eq!(LineStyle::Dotted.to_svg_dasharray(), Some(\"2,2\"));\n    }\n\n    #[test]\n    fn test_odb2d_to_polygon() {\n        use crate::ebase::{Odb2dRecord, Record, Value};\n\n        let mut record_map = Record::new();\n        record_map.insert(\n            \"prim_type\".to_string(),\n            Value::String(\"polygon\".to_string()),\n        );\n        record_map.insert(\n            \"x_coords\".to_string(),\n            Value::String(\"0,100,100,0\".to_string()),\n        );\n        record_map.insert(\n            \"y_coords\".to_string(),\n            Value::String(\"0,0,50,50\".to_string()),\n        );\n\n        let odb_record = Odb2dRecord::from_record(&record_map).unwrap();\n        let primitive = odb2d_to_primitive(&odb_record).unwrap();\n\n        if let G2DPrimitive::Polygon(points) = primitive {\n            assert_eq!(points.len(), 4);\n            assert_eq!(points[0].x, 0.0);\n            assert_eq!(points[1].x, 100.0);\n            assert_eq!(points[2].y, 50.0);\n        } else {\n            panic!(\"Expected Polygon primitive\");\n        }\n    }\n\n    #[test]\n    fn test_odb2d_to_rect() {\n        use crate::ebase::{Odb2dRecord, Record, Value};\n\n        let mut record_map = Record::new();\n        record_map.insert(\"prim_type\".to_string(), Value::String(\"rect\".to_string()));\n        record_map.insert(\"x\".to_string(), Value::String(\"10\".to_string()));\n        record_map.insert(\"y\".to_string(), Value::String(\"20\".to_string()));\n        record_map.insert(\"width\".to_string(), Value::String(\"100\".to_string()));\n        record_map.insert(\"height\".to_string(), Value::String(\"50\".to_string()));\n\n        let odb_record = Odb2dRecord::from_record(&record_map).unwrap();\n        let primitive = odb2d_to_primitive(&odb_record).unwrap();\n\n        if let G2DPrimitive::Rectangle(rect) = primitive {\n            assert_eq!(rect.x, 10.0);\n            assert_eq!(rect.y, 20.0);\n            assert_eq!(rect.width, 100.0);\n            assert_eq!(rect.height, 50.0);\n        } else {\n            panic!(\"Expected Rectangle primitive\");\n        }\n    }\n\n    #[test]\n    fn test_odb2d_to_circle() {\n        use crate::ebase::{Odb2dRecord, Record, Value};\n\n        let mut record_map = Record::new();\n        record_map.insert(\"prim_type\".to_string(), Value::String(\"circle\".to_string()));\n        record_map.insert(\"x\".to_string(), Value::String(\"50\".to_string()));\n        record_map.insert(\"y\".to_string(), Value::String(\"50\".to_string()));\n        record_map.insert(\"r\".to_string(), Value::String(\"25\".to_string()));\n\n        let odb_record = Odb2dRecord::from_record(&record_map).unwrap();\n        let primitive = odb2d_to_primitive(&odb_record).unwrap();\n\n        if let G2DPrimitive::Circle(circle) = primitive {\n            assert_eq!(circle.center.x, 50.0);\n            assert_eq!(circle.center.y, 50.0);\n            assert_eq!(circle.radius, 25.0);\n        } else {\n            panic!(\"Expected Circle primitive\");\n        }\n    }\n\n    #[test]\n    fn test_odb2d_to_text() {\n        use crate::ebase::{Odb2dRecord, Record, Value};\n\n        let mut record_map = Record::new();\n        record_map.insert(\"prim_type\".to_string(), Value::String(\"text\".to_string()));\n        record_map.insert(\"x\".to_string(), Value::String(\"10\".to_string()));\n        record_map.insert(\"y\".to_string(), Value::String(\"20\".to_string()));\n        record_map.insert(\"text\".to_string(), Value::String(\"Hello\".to_string()));\n        record_map.insert(\"font_size\".to_string(), Value::String(\"12\".to_string()));\n\n        let odb_record = Odb2dRecord::from_record(&record_map).unwrap();\n        let primitive = odb2d_to_primitive(&odb_record).unwrap();\n\n        if let G2DPrimitive::Text(text) = primitive {\n            assert_eq!(text.position.x, 10.0);\n            assert_eq!(text.text, \"Hello\");\n            assert_eq!(text.font_size, 12.0);\n        } else {\n            panic!(\"Expected Text primitive\");\n        }\n    }\n\n    #[test]\n    fn test_odb2d_to_lines() {\n        use crate::ebase::{Odb2dRecord, Record, Value};\n\n        let mut record_map = Record::new();\n        record_map.insert(\"prim_type\".to_string(), Value::String(\"lines\".to_string()));\n        record_map.insert(\n            \"x_coords\".to_string(),\n            Value::String(\"0,100,50,150\".to_string()),\n        );\n        record_map.insert(\n            \"y_coords\".to_string(),\n            Value::String(\"0,0,50,50\".to_string()),\n        );\n\n        let odb_record = Odb2dRecord::from_record(&record_map).unwrap();\n        let primitive = odb2d_to_primitive(&odb_record).unwrap();\n\n        if let G2DPrimitive::Lines(lines) = primitive {\n            assert_eq!(lines.len(), 2);\n            assert_eq!(lines[0].start.x, 0.0);\n            assert_eq!(lines[0].end.x, 100.0);\n            assert_eq!(lines[1].start.x, 50.0);\n            assert_eq!(lines[1].end.x, 150.0);\n        } else {\n            panic!(\"Expected Lines primitive\");\n        }\n    }\n\n    #[test]\n    fn test_odb2d_to_attributes() {\n        use crate::ebase::{Odb2dRecord, Record, Value};\n\n        let mut record_map = Record::new();\n        record_map.insert(\"prim_type\".to_string(), Value::String(\"rect\".to_string()));\n        record_map.insert(\n            \"color\".to_string(),\n            Value::String(\"0.8 0.4 0.2\".to_string()),\n        );\n        record_map.insert(\n            \"fill_color\".to_string(),\n            Value::String(\"0.1 0.9 0.1\".to_string()),\n        );\n        record_map.insert(\"line_width\".to_string(), Value::String(\"2.5\".to_string()));\n        record_map.insert(\n            \"line_style\".to_string(),\n            Value::String(\"dashed\".to_string()),\n        );\n        record_map.insert(\"layer\".to_string(), Value::String(\"floor\".to_string()));\n\n        let odb_record = Odb2dRecord::from_record(&record_map).unwrap();\n        let attrs = odb2d_to_attributes(&odb_record);\n\n        assert!((attrs.color[0] - 0.8).abs() < 0.001);\n        assert!((attrs.color[1] - 0.4).abs() < 0.001);\n        assert!(attrs.fill_color.is_some());\n        let fill = attrs.fill_color.unwrap();\n        assert!((fill[1] - 0.9).abs() < 0.001);\n        assert!((attrs.line_width - 2.5).abs() < 0.001);\n        assert_eq!(attrs.line_style, LineStyle::Dashed);\n        assert_eq!(attrs.layer, \"floor\");\n    }\n\n    #[test]\n    fn test_process_odb2d_records() {\n        use crate::ebase::{Odb2dRecord, Record, Value};\n\n        let mut records = Vec::new();\n\n        // Add a rectangle\n        let mut r1 = Record::new();\n        r1.insert(\"prim_type\".to_string(), Value::String(\"rect\".to_string()));\n        r1.insert(\"x\".to_string(), Value::String(\"0\".to_string()));\n        r1.insert(\"y\".to_string(), Value::String(\"0\".to_string()));\n        r1.insert(\"width\".to_string(), Value::String(\"100\".to_string()));\n        r1.insert(\"height\".to_string(), Value::String(\"50\".to_string()));\n        records.push(Odb2dRecord::from_record(&r1).unwrap());\n\n        // Add a circle\n        let mut r2 = Record::new();\n        r2.insert(\"prim_type\".to_string(), Value::String(\"circle\".to_string()));\n        r2.insert(\"x\".to_string(), Value::String(\"50\".to_string()));\n        r2.insert(\"y\".to_string(), Value::String(\"25\".to_string()));\n        r2.insert(\"r\".to_string(), Value::String(\"10\".to_string()));\n        records.push(Odb2dRecord::from_record(&r2).unwrap());\n\n        let compound = process_odb2d_records(&records);\n        assert_eq!(compound.children.len(), 2);\n\n        // Verify SVG export works\n        let svg = compound.to_svg();\n        assert!(svg.contains(\"<rect\"));\n        assert!(svg.contains(\"<circle\"));\n    }\n\n    // ========== Additional Coverage Tests ==========\n\n    #[test]\n    fn test_point2d_origin() {\n        let origin = Point2D::origin();\n        assert_eq!(origin.x, 0.0);\n        assert_eq!(origin.y, 0.0);\n    }\n\n    #[test]\n    fn test_point2d_debug_clone() {\n        let p = Point2D::new(1.0, 2.0);\n        let debug_str = format!(\"{:?}\", p);\n        assert!(debug_str.contains(\"Point2D\"));\n\n        let cloned = p.clone();\n        assert_eq!(cloned.x, 1.0);\n        assert_eq!(cloned.y, 2.0);\n    }\n\n    #[test]\n    fn test_point2d_partial_eq() {\n        let p1 = Point2D::new(1.0, 2.0);\n        let p2 = Point2D::new(1.0, 2.0);\n        let p3 = Point2D::new(3.0, 4.0);\n        assert_eq!(p1, p2);\n        assert_ne!(p1, p3);\n    }\n\n    #[test]\n    fn test_line2d_new() {\n        let start = Point2D::new(0.0, 0.0);\n        let end = Point2D::new(10.0, 10.0);\n        let line = Line2D::new(start, end);\n        assert_eq!(line.start.x, 0.0);\n        assert_eq!(line.end.x, 10.0);\n    }\n\n    #[test]\n    fn test_line2d_from_coords() {\n        let line = Line2D::from_coords(1.0, 2.0, 3.0, 4.0);\n        assert_eq!(line.start.x, 1.0);\n        assert_eq!(line.start.y, 2.0);\n        assert_eq!(line.end.x, 3.0);\n        assert_eq!(line.end.y, 4.0);\n    }\n\n    #[test]\n    fn test_line2d_length() {\n        let line = Line2D::from_coords(0.0, 0.0, 3.0, 4.0);\n        assert!((line.length() - 5.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_line2d_debug_clone() {\n        let line = Line2D::from_coords(0.0, 0.0, 1.0, 1.0);\n        let debug_str = format!(\"{:?}\", line);\n        assert!(debug_str.contains(\"Line2D\"));\n\n        let cloned = line.clone();\n        assert_eq!(cloned.start.x, 0.0);\n    }\n\n    #[test]\n    fn test_rect2d_new() {\n        let rect = Rect2D::new(10.0, 20.0, 100.0, 50.0);\n        assert_eq!(rect.x, 10.0);\n        assert_eq!(rect.y, 20.0);\n        assert_eq!(rect.width, 100.0);\n        assert_eq!(rect.height, 50.0);\n    }\n\n    #[test]\n    fn test_rect2d_corners() {\n        let rect = Rect2D::new(10.0, 20.0, 100.0, 50.0);\n        let corners = rect.corners();\n        assert_eq!(corners[0].x, 10.0);\n        assert_eq!(corners[0].y, 20.0);\n        assert_eq!(corners[2].x, 110.0);\n        assert_eq!(corners[2].y, 70.0);\n    }\n\n    #[test]\n    fn test_rect2d_debug_clone() {\n        let rect = Rect2D::new(0.0, 0.0, 10.0, 10.0);\n        let debug_str = format!(\"{:?}\", rect);\n        assert!(debug_str.contains(\"Rect2D\"));\n\n        let cloned = rect.clone();\n        assert_eq!(cloned.width, 10.0);\n    }\n\n    #[test]\n    fn test_circle2d_new() {\n        let circle = Circle2D::new(Point2D::new(50.0, 50.0), 25.0);\n        assert_eq!(circle.center.x, 50.0);\n        assert_eq!(circle.radius, 25.0);\n    }\n\n    #[test]\n    fn test_circle2d_from_coords() {\n        let circle = Circle2D::from_coords(100.0, 200.0, 30.0);\n        assert_eq!(circle.center.x, 100.0);\n        assert_eq!(circle.center.y, 200.0);\n        assert_eq!(circle.radius, 30.0);\n    }\n\n    #[test]\n    fn test_circle2d_debug_clone() {\n        let circle = Circle2D::from_coords(0.0, 0.0, 10.0);\n        let debug_str = format!(\"{:?}\", circle);\n        assert!(debug_str.contains(\"Circle2D\"));\n\n        let cloned = circle.clone();\n        assert_eq!(cloned.radius, 10.0);\n    }\n\n    #[test]\n    fn test_arc2d_new() {\n        let arc = Arc2D::new(Point2D::new(50.0, 50.0), 25.0, 0.0, PI / 2.0);\n        assert_eq!(arc.center.x, 50.0);\n        assert_eq!(arc.radius, 25.0);\n        assert_eq!(arc.start_angle, 0.0);\n        assert!((arc.end_angle - PI / 2.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_arc2d_debug_clone() {\n        let arc = Arc2D::new(Point2D::origin(), 10.0, 0.0, PI);\n        let debug_str = format!(\"{:?}\", arc);\n        assert!(debug_str.contains(\"Arc2D\"));\n\n        let cloned = arc.clone();\n        assert_eq!(cloned.radius, 10.0);\n    }\n\n    #[test]\n    fn test_text2d_new() {\n        let text = Text2D::new(Point2D::new(10.0, 20.0), \"Hello\", 12.0);\n        assert_eq!(text.text, \"Hello\");\n        assert_eq!(text.position.x, 10.0);\n        assert_eq!(text.font_size, 12.0);\n    }\n\n    #[test]\n    fn test_text2d_debug_clone() {\n        let text = Text2D::new(Point2D::origin(), \"Test\", 14.0);\n        let debug_str = format!(\"{:?}\", text);\n        assert!(debug_str.contains(\"Text2D\"));\n\n        let cloned = text.clone();\n        assert_eq!(cloned.text, \"Test\");\n    }\n\n    #[test]\n    fn test_transform2d_identity() {\n        let t = Transform2D::identity();\n        assert_eq!(t.translation, [0.0, 0.0]);\n        assert_eq!(t.rotation, 0.0);\n        assert_eq!(t.scale, [1.0, 1.0]);\n    }\n\n    #[test]\n    fn test_transform2d_translate() {\n        let t = Transform2D::translate(10.0, 20.0);\n        assert_eq!(t.translation, [10.0, 20.0]);\n        assert_eq!(t.rotation, 0.0);\n    }\n\n    #[test]\n    fn test_transform2d_rotate() {\n        let t = Transform2D::rotate(PI / 2.0);\n        assert!((t.rotation - PI / 2.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_transform2d_scale() {\n        let t = Transform2D::scale(2.0, 3.0);\n        assert_eq!(t.scale, [2.0, 3.0]);\n    }\n\n    #[test]\n    fn test_transform2d_then() {\n        let t1 = Transform2D::translate(10.0, 0.0);\n        let t2 = Transform2D::translate(0.0, 20.0);\n        let combined = t1.then(&t2);\n        assert_eq!(combined.translation, [10.0, 20.0]);\n    }\n\n    #[test]\n    fn test_transform2d_debug_clone() {\n        let t = Transform2D::translate(5.0, 5.0);\n        let debug_str = format!(\"{:?}\", t);\n        assert!(debug_str.contains(\"Transform2D\"));\n\n        let cloned = t.clone();\n        assert_eq!(cloned.translation, [5.0, 5.0]);\n    }\n\n    #[test]\n    fn test_g2d_attributes_default() {\n        let attrs = G2DAttributes::default();\n        assert_eq!(attrs.layer, \"default\");\n    }\n\n    #[test]\n    fn test_g2d_attributes_debug_clone() {\n        let attrs = G2DAttributes::new().with_line_width(3.0);\n        let debug_str = format!(\"{:?}\", attrs);\n        assert!(debug_str.contains(\"G2DAttributes\"));\n\n        let cloned = attrs.clone();\n        assert_eq!(cloned.line_width, 3.0);\n    }\n\n    #[test]\n    fn test_line_style_dotted() {\n        assert_eq!(LineStyle::Dotted.to_svg_dasharray(), Some(\"2,2\"));\n    }\n\n    #[test]\n    fn test_line_style_dash_dot() {\n        assert_eq!(LineStyle::DashDot.to_svg_dasharray(), Some(\"10,2,2,2\"));\n    }\n\n    #[test]\n    fn test_line_style_debug_clone() {\n        let style = LineStyle::Dashed;\n        let debug_str = format!(\"{:?}\", style);\n        assert!(debug_str.contains(\"Dashed\"));\n\n        let cloned = style.clone();\n        assert_eq!(cloned, LineStyle::Dashed);\n    }\n\n    #[test]\n    fn test_g2d_primitive_debug_clone() {\n        let prim = G2DPrimitive::Rectangle(Rect2D::new(0.0, 0.0, 10.0, 10.0));\n        let debug_str = format!(\"{:?}\", prim);\n        assert!(debug_str.contains(\"Rectangle\"));\n\n        let cloned = prim.clone();\n        if let G2DPrimitive::Rectangle(rect) = cloned {\n            assert_eq!(rect.width, 10.0);\n        }\n    }\n\n    #[test]\n    fn test_g2d_compound_empty() {\n        let compound = G2DCompound::new();\n        assert!(compound.children.is_empty());\n        assert!(compound.bounding_box().is_none());\n    }\n\n    #[test]\n    fn test_g2d_compound_with_transform() {\n        let t = Transform2D::translate(10.0, 20.0);\n        let compound = G2DCompound::new().with_transform(t);\n        assert_eq!(compound.transform.translation, [10.0, 20.0]);\n    }\n\n    #[test]\n    fn test_g2d_compound_with_attributes() {\n        let attrs = G2DAttributes::new().with_line_width(5.0);\n        let compound = G2DCompound::new().with_attributes(attrs);\n        assert_eq!(compound.attributes.line_width, 5.0);\n    }\n\n    #[test]\n    fn test_g2d_compound_debug_clone() {\n        let compound = G2DCompound::new();\n        let debug_str = format!(\"{:?}\", compound);\n        assert!(debug_str.contains(\"G2DCompound\"));\n\n        let cloned = compound.clone();\n        assert!(cloned.children.is_empty());\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":43}},{"line":22,"address":[],"length":0,"stats":{"Line":3}},{"line":27,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":4}},{"line":30,"address":[],"length":0,"stats":{"Line":6}},{"line":34,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":3}},{"line":41,"address":[],"length":0,"stats":{"Line":3}},{"line":42,"address":[],"length":0,"stats":{"Line":3}},{"line":43,"address":[],"length":0,"stats":{"Line":3}},{"line":47,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":5}},{"line":69,"address":[],"length":0,"stats":{"Line":20}},{"line":70,"address":[],"length":0,"stats":{"Line":10}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":3}},{"line":91,"address":[],"length":0,"stats":{"Line":9}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":3}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":8}},{"line":109,"address":[],"length":0,"stats":{"Line":8}},{"line":110,"address":[],"length":0,"stats":{"Line":8}},{"line":111,"address":[],"length":0,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":5}},{"line":132,"address":[],"length":0,"stats":{"Line":15}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":3}},{"line":215,"address":[],"length":0,"stats":{"Line":9}},{"line":217,"address":[],"length":0,"stats":{"Line":3}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":10}},{"line":266,"address":[],"length":0,"stats":{"Line":10}},{"line":267,"address":[],"length":0,"stats":{"Line":5}},{"line":268,"address":[],"length":0,"stats":{"Line":2}},{"line":269,"address":[],"length":0,"stats":{"Line":2}},{"line":270,"address":[],"length":0,"stats":{"Line":1}},{"line":303,"address":[],"length":0,"stats":{"Line":16}},{"line":305,"address":[],"length":0,"stats":{"Line":32}},{"line":310,"address":[],"length":0,"stats":{"Line":16}},{"line":315,"address":[],"length":0,"stats":{"Line":4}},{"line":316,"address":[],"length":0,"stats":{"Line":12}},{"line":317,"address":[],"length":0,"stats":{"Line":4}},{"line":321,"address":[],"length":0,"stats":{"Line":2}},{"line":322,"address":[],"length":0,"stats":{"Line":6}},{"line":323,"address":[],"length":0,"stats":{"Line":2}},{"line":324,"address":[],"length":0,"stats":{"Line":2}},{"line":328,"address":[],"length":0,"stats":{"Line":6}},{"line":329,"address":[],"length":0,"stats":{"Line":6}},{"line":330,"address":[],"length":0,"stats":{"Line":6}},{"line":334,"address":[],"length":0,"stats":{"Line":4}},{"line":335,"address":[],"length":0,"stats":{"Line":4}},{"line":336,"address":[],"length":0,"stats":{"Line":4}},{"line":340,"address":[],"length":0,"stats":{"Line":3}},{"line":341,"address":[],"length":0,"stats":{"Line":9}},{"line":342,"address":[],"length":0,"stats":{"Line":3}},{"line":346,"address":[],"length":0,"stats":{"Line":5}},{"line":347,"address":[],"length":0,"stats":{"Line":5}},{"line":349,"address":[],"length":0,"stats":{"Line":5}},{"line":350,"address":[],"length":0,"stats":{"Line":5}},{"line":351,"address":[],"length":0,"stats":{"Line":5}},{"line":356,"address":[],"length":0,"stats":{"Line":5}},{"line":357,"address":[],"length":0,"stats":{"Line":5}},{"line":358,"address":[],"length":0,"stats":{"Line":2}},{"line":360,"address":[],"length":0,"stats":{"Line":1}},{"line":361,"address":[],"length":0,"stats":{"Line":1}},{"line":362,"address":[],"length":0,"stats":{"Line":1}},{"line":364,"address":[],"length":0,"stats":{"Line":8}},{"line":370,"address":[],"length":0,"stats":{"Line":10}},{"line":371,"address":[],"length":0,"stats":{"Line":10}},{"line":388,"address":[],"length":0,"stats":{"Line":1}},{"line":389,"address":[],"length":0,"stats":{"Line":1}},{"line":393,"address":[],"length":0,"stats":{"Line":6}},{"line":395,"address":[],"length":0,"stats":{"Line":6}},{"line":397,"address":[],"length":0,"stats":{"Line":6}},{"line":402,"address":[],"length":0,"stats":{"Line":2}},{"line":404,"address":[],"length":0,"stats":{"Line":4}},{"line":406,"address":[],"length":0,"stats":{"Line":2}},{"line":411,"address":[],"length":0,"stats":{"Line":1}},{"line":413,"address":[],"length":0,"stats":{"Line":2}},{"line":415,"address":[],"length":0,"stats":{"Line":1}},{"line":420,"address":[],"length":0,"stats":{"Line":5}},{"line":423,"address":[],"length":0,"stats":{"Line":10}},{"line":427,"address":[],"length":0,"stats":{"Line":10}},{"line":428,"address":[],"length":0,"stats":{"Line":5}},{"line":436,"address":[],"length":0,"stats":{"Line":5}},{"line":437,"address":[],"length":0,"stats":{"Line":10}},{"line":439,"address":[],"length":0,"stats":{"Line":10}},{"line":440,"address":[],"length":0,"stats":{"Line":4}},{"line":441,"address":[],"length":0,"stats":{"Line":2}},{"line":442,"address":[],"length":0,"stats":{"Line":1}},{"line":446,"address":[],"length":0,"stats":{"Line":5}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":10}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":10}},{"line":459,"address":[],"length":0,"stats":{"Line":12}},{"line":461,"address":[],"length":0,"stats":{"Line":12}},{"line":463,"address":[],"length":0,"stats":{"Line":12}},{"line":483,"address":[],"length":0,"stats":{"Line":9}},{"line":485,"address":[],"length":0,"stats":{"Line":18}},{"line":486,"address":[],"length":0,"stats":{"Line":18}},{"line":487,"address":[],"length":0,"stats":{"Line":9}},{"line":488,"address":[],"length":0,"stats":{"Line":9}},{"line":493,"address":[],"length":0,"stats":{"Line":5}},{"line":494,"address":[],"length":0,"stats":{"Line":15}},{"line":498,"address":[],"length":0,"stats":{"Line":2}},{"line":499,"address":[],"length":0,"stats":{"Line":6}},{"line":503,"address":[],"length":0,"stats":{"Line":1}},{"line":504,"address":[],"length":0,"stats":{"Line":1}},{"line":505,"address":[],"length":0,"stats":{"Line":1}},{"line":509,"address":[],"length":0,"stats":{"Line":3}},{"line":510,"address":[],"length":0,"stats":{"Line":6}},{"line":511,"address":[],"length":0,"stats":{"Line":3}},{"line":515,"address":[],"length":0,"stats":{"Line":2}},{"line":516,"address":[],"length":0,"stats":{"Line":4}},{"line":517,"address":[],"length":0,"stats":{"Line":6}},{"line":518,"address":[],"length":0,"stats":{"Line":4}},{"line":519,"address":[],"length":0,"stats":{"Line":6}},{"line":520,"address":[],"length":0,"stats":{"Line":4}},{"line":522,"address":[],"length":0,"stats":{"Line":8}},{"line":524,"address":[],"length":0,"stats":{"Line":6}},{"line":525,"address":[],"length":0,"stats":{"Line":2}},{"line":529,"address":[],"length":0,"stats":{"Line":4}},{"line":530,"address":[],"length":0,"stats":{"Line":16}},{"line":531,"address":[],"length":0,"stats":{"Line":12}},{"line":532,"address":[],"length":0,"stats":{"Line":12}},{"line":533,"address":[],"length":0,"stats":{"Line":8}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":12}},{"line":539,"address":[],"length":0,"stats":{"Line":8}},{"line":542,"address":[],"length":0,"stats":{"Line":16}},{"line":543,"address":[],"length":0,"stats":{"Line":12}},{"line":547,"address":[],"length":0,"stats":{"Line":10}},{"line":548,"address":[],"length":0,"stats":{"Line":6}},{"line":551,"address":[],"length":0,"stats":{"Line":12}},{"line":555,"address":[],"length":0,"stats":{"Line":4}},{"line":556,"address":[],"length":0,"stats":{"Line":12}},{"line":557,"address":[],"length":0,"stats":{"Line":12}},{"line":558,"address":[],"length":0,"stats":{"Line":8}},{"line":559,"address":[],"length":0,"stats":{"Line":12}},{"line":560,"address":[],"length":0,"stats":{"Line":8}},{"line":561,"address":[],"length":0,"stats":{"Line":4}},{"line":564,"address":[],"length":0,"stats":{"Line":4}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":4}},{"line":639,"address":[],"length":0,"stats":{"Line":8}},{"line":640,"address":[],"length":0,"stats":{"Line":4}},{"line":641,"address":[],"length":0,"stats":{"Line":4}},{"line":643,"address":[],"length":0,"stats":{"Line":2}},{"line":645,"address":[],"length":0,"stats":{"Line":4}},{"line":646,"address":[],"length":0,"stats":{"Line":8}},{"line":647,"address":[],"length":0,"stats":{"Line":4}},{"line":648,"address":[],"length":0,"stats":{"Line":4}},{"line":650,"address":[],"length":0,"stats":{"Line":2}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":2}},{"line":696,"address":[],"length":0,"stats":{"Line":4}},{"line":697,"address":[],"length":0,"stats":{"Line":4}},{"line":698,"address":[],"length":0,"stats":{"Line":4}},{"line":699,"address":[],"length":0,"stats":{"Line":4}},{"line":700,"address":[],"length":0,"stats":{"Line":4}},{"line":702,"address":[],"length":0,"stats":{"Line":2}},{"line":711,"address":[],"length":0,"stats":{"Line":4}},{"line":712,"address":[],"length":0,"stats":{"Line":4}},{"line":713,"address":[],"length":0,"stats":{"Line":4}},{"line":714,"address":[],"length":0,"stats":{"Line":4}},{"line":715,"address":[],"length":0,"stats":{"Line":2}},{"line":718,"address":[],"length":0,"stats":{"Line":4}},{"line":719,"address":[],"length":0,"stats":{"Line":1}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":2}},{"line":760,"address":[],"length":0,"stats":{"Line":2}},{"line":761,"address":[],"length":0,"stats":{"Line":2}},{"line":762,"address":[],"length":0,"stats":{"Line":2}},{"line":763,"address":[],"length":0,"stats":{"Line":2}},{"line":764,"address":[],"length":0,"stats":{"Line":2}},{"line":765,"address":[],"length":0,"stats":{"Line":2}},{"line":766,"address":[],"length":0,"stats":{"Line":2}},{"line":769,"address":[],"length":0,"stats":{"Line":2}},{"line":770,"address":[],"length":0,"stats":{"Line":2}},{"line":771,"address":[],"length":0,"stats":{"Line":2}},{"line":772,"address":[],"length":0,"stats":{"Line":2}},{"line":773,"address":[],"length":0,"stats":{"Line":2}},{"line":774,"address":[],"length":0,"stats":{"Line":1}},{"line":775,"address":[],"length":0,"stats":{"Line":1}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":782,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":801,"address":[],"length":0,"stats":{"Line":0}},{"line":802,"address":[],"length":0,"stats":{"Line":0}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":806,"address":[],"length":0,"stats":{"Line":0}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":815,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":820,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[],"length":0,"stats":{"Line":0}},{"line":822,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":824,"address":[],"length":0,"stats":{"Line":0}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}},{"line":832,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":838,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":842,"address":[],"length":0,"stats":{"Line":0}},{"line":843,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":2}},{"line":853,"address":[],"length":0,"stats":{"Line":5}},{"line":855,"address":[],"length":0,"stats":{"Line":1}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":7}},{"line":871,"address":[],"length":0,"stats":{"Line":14}},{"line":872,"address":[],"length":0,"stats":{"Line":21}},{"line":873,"address":[],"length":0,"stats":{"Line":21}},{"line":875,"address":[],"length":0,"stats":{"Line":7}},{"line":876,"address":[],"length":0,"stats":{"Line":14}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":879,"address":[],"length":0,"stats":{"Line":0}},{"line":880,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[],"length":0,"stats":{"Line":0}},{"line":885,"address":[],"length":0,"stats":{"Line":0}},{"line":888,"address":[],"length":0,"stats":{"Line":14}},{"line":890,"address":[],"length":0,"stats":{"Line":2}},{"line":891,"address":[],"length":0,"stats":{"Line":0}},{"line":893,"address":[],"length":0,"stats":{"Line":2}},{"line":894,"address":[],"length":0,"stats":{"Line":7}},{"line":895,"address":[],"length":0,"stats":{"Line":10}},{"line":896,"address":[],"length":0,"stats":{"Line":14}},{"line":899,"address":[],"length":0,"stats":{"Line":2}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":902,"address":[],"length":0,"stats":{"Line":1}},{"line":905,"address":[],"length":0,"stats":{"Line":18}},{"line":906,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":912,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":18}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":920,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[],"length":0,"stats":{"Line":0}},{"line":923,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":926,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":16}},{"line":930,"address":[],"length":0,"stats":{"Line":3}},{"line":932,"address":[],"length":0,"stats":{"Line":2}},{"line":933,"address":[],"length":0,"stats":{"Line":13}},{"line":935,"address":[],"length":0,"stats":{"Line":1}},{"line":936,"address":[],"length":0,"stats":{"Line":0}},{"line":938,"address":[],"length":0,"stats":{"Line":1}},{"line":941,"address":[],"length":0,"stats":{"Line":8}},{"line":942,"address":[],"length":0,"stats":{"Line":8}},{"line":943,"address":[],"length":0,"stats":{"Line":8}},{"line":944,"address":[],"length":0,"stats":{"Line":6}},{"line":945,"address":[],"length":0,"stats":{"Line":6}},{"line":946,"address":[],"length":0,"stats":{"Line":8}},{"line":948,"address":[],"length":0,"stats":{"Line":3}},{"line":949,"address":[],"length":0,"stats":{"Line":8}},{"line":950,"address":[],"length":0,"stats":{"Line":8}},{"line":951,"address":[],"length":0,"stats":{"Line":6}},{"line":952,"address":[],"length":0,"stats":{"Line":6}},{"line":954,"address":[],"length":0,"stats":{"Line":1}},{"line":955,"address":[],"length":0,"stats":{"Line":0}},{"line":956,"address":[],"length":0,"stats":{"Line":0}},{"line":957,"address":[],"length":0,"stats":{"Line":0}},{"line":958,"address":[],"length":0,"stats":{"Line":0}},{"line":959,"address":[],"length":0,"stats":{"Line":0}},{"line":960,"address":[],"length":0,"stats":{"Line":0}},{"line":961,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":965,"address":[],"length":0,"stats":{"Line":1}},{"line":966,"address":[],"length":0,"stats":{"Line":0}},{"line":967,"address":[],"length":0,"stats":{"Line":0}},{"line":968,"address":[],"length":0,"stats":{"Line":0}},{"line":969,"address":[],"length":0,"stats":{"Line":0}},{"line":970,"address":[],"length":0,"stats":{"Line":0}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":972,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":978,"address":[],"length":0,"stats":{"Line":1}},{"line":979,"address":[],"length":0,"stats":{"Line":4}},{"line":980,"address":[],"length":0,"stats":{"Line":4}},{"line":981,"address":[],"length":0,"stats":{"Line":2}},{"line":982,"address":[],"length":0,"stats":{"Line":3}},{"line":983,"address":[],"length":0,"stats":{"Line":2}},{"line":984,"address":[],"length":0,"stats":{"Line":4}},{"line":985,"address":[],"length":0,"stats":{"Line":2}},{"line":986,"address":[],"length":0,"stats":{"Line":1}},{"line":989,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[],"length":0,"stats":{"Line":3}},{"line":995,"address":[],"length":0,"stats":{"Line":9}},{"line":996,"address":[],"length":0,"stats":{"Line":9}},{"line":997,"address":[],"length":0,"stats":{"Line":9}},{"line":998,"address":[],"length":0,"stats":{"Line":6}},{"line":999,"address":[],"length":0,"stats":{"Line":4}},{"line":1000,"address":[],"length":0,"stats":{"Line":2}},{"line":1001,"address":[],"length":0,"stats":{"Line":2}},{"line":1002,"address":[],"length":0,"stats":{"Line":2}},{"line":1005,"address":[],"length":0,"stats":{"Line":6}},{"line":1006,"address":[],"length":0,"stats":{"Line":15}},{"line":1007,"address":[],"length":0,"stats":{"Line":6}},{"line":1008,"address":[],"length":0,"stats":{"Line":6}},{"line":1009,"address":[],"length":0,"stats":{"Line":6}},{"line":1011,"address":[],"length":0,"stats":{"Line":5}},{"line":1012,"address":[],"length":0,"stats":{"Line":6}},{"line":1015,"address":[],"length":0,"stats":{"Line":3}},{"line":1021,"address":[],"length":0,"stats":{"Line":1}},{"line":1022,"address":[],"length":0,"stats":{"Line":2}},{"line":1024,"address":[],"length":0,"stats":{"Line":5}},{"line":1025,"address":[],"length":0,"stats":{"Line":6}},{"line":1027,"address":[],"length":0,"stats":{"Line":8}},{"line":1028,"address":[],"length":0,"stats":{"Line":10}},{"line":1029,"address":[],"length":0,"stats":{"Line":8}},{"line":1030,"address":[],"length":0,"stats":{"Line":4}},{"line":1034,"address":[],"length":0,"stats":{"Line":1}}],"covered":258,"coverable":467},{"path":["/","workspace","crates","ofml-lib","src","gobject.rs"],"content":"//! GObject Type System - Extended value types with GObject semantics.\n//!\n//! This module implements the GObject type system for OFML compatibility,\n//! providing GStringObj, GSymbolObj, GIntegerObj, GFloatObj, GSequenceObj, and GDictObj.\n\nuse std::collections::HashMap;\n\nuse crate::errors::GObjectError;\nuse crate::value::Value;\n\n/// Extended value type with GObject semantics.\n///\n/// This enum extends the basic Value type to support additional\n/// OFML GObject types like Symbol and Dict.\n#[derive(Debug, Clone)]\npub enum GValue {\n    /// Null value\n    Null,\n    /// Boolean value\n    Bool(bool),\n    /// Integer value (GIntegerObj)\n    Int(i64),\n    /// Floating-point value (GFloatObj)\n    Float(f64),\n    /// String value (GStringObj)\n    String(String),\n    /// Symbol value (@name syntax, GSymbolObj)\n    Symbol(String),\n    /// Sequence/array value (GSequenceObj)\n    Sequence(Vec<GValue>),\n    /// Dictionary value (GDictObj)\n    Dict(HashMap<String, GValue>),\n}\n\nimpl GValue {\n    /// Create a null value.\n    pub fn null() -> Self {\n        GValue::Null\n    }\n\n    /// Create a boolean value.\n    pub fn bool(b: bool) -> Self {\n        GValue::Bool(b)\n    }\n\n    /// Create an integer value.\n    pub fn int(i: i64) -> Self {\n        GValue::Int(i)\n    }\n\n    /// Create a float value.\n    pub fn float(f: f64) -> Self {\n        GValue::Float(f)\n    }\n\n    /// Create a string value.\n    pub fn string(s: impl Into<String>) -> Self {\n        GValue::String(s.into())\n    }\n\n    /// Create a symbol value.\n    pub fn symbol(name: impl Into<String>) -> Self {\n        GValue::Symbol(name.into())\n    }\n\n    /// Create an empty sequence.\n    pub fn sequence() -> Self {\n        GValue::Sequence(Vec::new())\n    }\n\n    /// Create a sequence from values.\n    pub fn sequence_from(values: Vec<GValue>) -> Self {\n        GValue::Sequence(values)\n    }\n\n    /// Create an empty dictionary.\n    pub fn dict() -> Self {\n        GValue::Dict(HashMap::new())\n    }\n\n    /// Create a dictionary from key-value pairs.\n    pub fn dict_from(entries: HashMap<String, GValue>) -> Self {\n        GValue::Dict(entries)\n    }\n\n    /// Check if this value is null.\n    pub fn is_null(&self) -> bool {\n        matches!(self, GValue::Null)\n    }\n\n    /// Get the type name for error messages.\n    pub fn type_name(&self) -> &'static str {\n        match self {\n            GValue::Null => \"null\",\n            GValue::Bool(_) => \"boolean\",\n            GValue::Int(_) => \"integer\",\n            GValue::Float(_) => \"float\",\n            GValue::String(_) => \"string\",\n            GValue::Symbol(_) => \"symbol\",\n            GValue::Sequence(_) => \"sequence\",\n            GValue::Dict(_) => \"dict\",\n        }\n    }\n\n    /// Convert to bool, if possible.\n    pub fn as_bool(&self) -> Option<bool> {\n        match self {\n            GValue::Bool(b) => Some(*b),\n            GValue::Int(i) => Some(*i != 0),\n            _ => None,\n        }\n    }\n\n    /// Convert to i64, if possible.\n    pub fn as_i64(&self) -> Option<i64> {\n        match self {\n            GValue::Int(i) => Some(*i),\n            GValue::Float(f) => Some(*f as i64),\n            _ => None,\n        }\n    }\n\n    /// Convert to f64, if possible.\n    pub fn as_f64(&self) -> Option<f64> {\n        match self {\n            GValue::Float(f) => Some(*f),\n            GValue::Int(i) => Some(*i as f64),\n            _ => None,\n        }\n    }\n\n    /// Get as string reference, if this is a string.\n    pub fn as_str(&self) -> Option<&str> {\n        match self {\n            GValue::String(s) => Some(s),\n            GValue::Symbol(s) => Some(s),\n            _ => None,\n        }\n    }\n\n    /// Get as sequence reference, if this is a sequence.\n    pub fn as_sequence(&self) -> Option<&Vec<GValue>> {\n        match self {\n            GValue::Sequence(v) => Some(v),\n            _ => None,\n        }\n    }\n\n    /// Get as mutable sequence reference, if this is a sequence.\n    pub fn as_sequence_mut(&mut self) -> Option<&mut Vec<GValue>> {\n        match self {\n            GValue::Sequence(v) => Some(v),\n            _ => None,\n        }\n    }\n\n    /// Get as dict reference, if this is a dict.\n    pub fn as_dict(&self) -> Option<&HashMap<String, GValue>> {\n        match self {\n            GValue::Dict(d) => Some(d),\n            _ => None,\n        }\n    }\n\n    /// Get as mutable dict reference, if this is a dict.\n    pub fn as_dict_mut(&mut self) -> Option<&mut HashMap<String, GValue>> {\n        match self {\n            GValue::Dict(d) => Some(d),\n            _ => None,\n        }\n    }\n\n    /// Parse an OFML expression string (implements parseCb).\n    ///\n    /// # Arguments\n    ///\n    /// * `expression` - The expression string to parse\n    ///\n    /// # Returns\n    ///\n    /// The parsed GValue, or an error if parsing failed.\n    pub fn parse(expression: &str) -> Result<GValue, GObjectError> {\n        let trimmed = expression.trim();\n\n        if trimmed.is_empty() || trimmed == \"NULL\" {\n            return Ok(GValue::Null);\n        }\n\n        // Boolean\n        if trimmed == \"true\" || trimmed == \"TRUE\" {\n            return Ok(GValue::Bool(true));\n        }\n        if trimmed == \"false\" || trimmed == \"FALSE\" {\n            return Ok(GValue::Bool(false));\n        }\n\n        // Symbol (@name)\n        if let Some(symbol) = trimmed.strip_prefix('@') {\n            return Ok(GValue::Symbol(symbol.to_string()));\n        }\n\n        // String (quoted)\n        if trimmed.starts_with('\"') && trimmed.ends_with('\"') && trimmed.len() >= 2 {\n            return Ok(GValue::String(trimmed[1..trimmed.len() - 1].to_string()));\n        }\n\n        // Number (integer or float)\n        if let Ok(i) = trimmed.parse::<i64>() {\n            return Ok(GValue::Int(i));\n        }\n        if let Ok(f) = trimmed.parse::<f64>() {\n            return Ok(GValue::Float(f));\n        }\n\n        // Array [a, b, c]\n        if trimmed.starts_with('[') && trimmed.ends_with(']') {\n            let inner = &trimmed[1..trimmed.len() - 1];\n            let elements: Result<Vec<GValue>, GObjectError> =\n                inner.split(',').map(|s| GValue::parse(s.trim())).collect();\n            return elements.map(GValue::Sequence);\n        }\n\n        // Default: treat as string\n        Ok(GValue::String(trimmed.to_string()))\n    }\n\n    /// Get an element from a sequence by index.\n    pub fn get_index(&self, index: usize) -> Result<&GValue, GObjectError> {\n        match self {\n            GValue::Sequence(v) => v.get(index).ok_or(GObjectError::IndexOutOfBounds {\n                index,\n                length: v.len(),\n            }),\n            _ => Err(GObjectError::InvalidOperation {\n                type_name: self.type_name().to_string(),\n                operation: \"index access\".to_string(),\n            }),\n        }\n    }\n\n    /// Get a value from a dict by key.\n    pub fn get_key(&self, key: &str) -> Result<&GValue, GObjectError> {\n        match self {\n            GValue::Dict(d) => d.get(key).ok_or(GObjectError::KeyNotFound(key.to_string())),\n            _ => Err(GObjectError::InvalidOperation {\n                type_name: self.type_name().to_string(),\n                operation: \"key access\".to_string(),\n            }),\n        }\n    }\n\n    /// Set an element in a sequence by index.\n    pub fn set_index(&mut self, index: usize, value: GValue) -> Result<(), GObjectError> {\n        match self {\n            GValue::Sequence(v) => {\n                if index >= v.len() {\n                    return Err(GObjectError::IndexOutOfBounds {\n                        index,\n                        length: v.len(),\n                    });\n                }\n                v[index] = value;\n                Ok(())\n            }\n            _ => Err(GObjectError::InvalidOperation {\n                type_name: self.type_name().to_string(),\n                operation: \"index assignment\".to_string(),\n            }),\n        }\n    }\n\n    /// Set a value in a dict by key.\n    pub fn set_key(&mut self, key: impl Into<String>, value: GValue) -> Result<(), GObjectError> {\n        match self {\n            GValue::Dict(d) => {\n                d.insert(key.into(), value);\n                Ok(())\n            }\n            _ => Err(GObjectError::InvalidOperation {\n                type_name: self.type_name().to_string(),\n                operation: \"key assignment\".to_string(),\n            }),\n        }\n    }\n\n    /// Push a value to a sequence.\n    pub fn push(&mut self, value: GValue) -> Result<(), GObjectError> {\n        match self {\n            GValue::Sequence(v) => {\n                v.push(value);\n                Ok(())\n            }\n            _ => Err(GObjectError::InvalidOperation {\n                type_name: self.type_name().to_string(),\n                operation: \"push\".to_string(),\n            }),\n        }\n    }\n\n    /// Get the length of a sequence or dict.\n    pub fn len(&self) -> Result<usize, GObjectError> {\n        match self {\n            GValue::Sequence(v) => Ok(v.len()),\n            GValue::Dict(d) => Ok(d.len()),\n            GValue::String(s) => Ok(s.len()),\n            _ => Err(GObjectError::InvalidOperation {\n                type_name: self.type_name().to_string(),\n                operation: \"length\".to_string(),\n            }),\n        }\n    }\n\n    /// Check if a sequence or dict is empty.\n    pub fn is_empty(&self) -> Result<bool, GObjectError> {\n        self.len().map(|l| l == 0)\n    }\n}\n\nimpl From<Value> for GValue {\n    fn from(value: Value) -> Self {\n        match value {\n            Value::Null => GValue::Null,\n            Value::Bool(b) => GValue::Bool(b),\n            Value::Int(i) => GValue::Int(i),\n            Value::Float(f) => GValue::Float(f),\n            Value::String(s) => GValue::String((*s).clone()),\n            Value::Symbol(s) => GValue::Symbol((*s).clone()),\n            Value::Array(arr) => {\n                let borrowed = arr.borrow();\n                GValue::Sequence(borrowed.iter().cloned().map(GValue::from).collect())\n            }\n            Value::Object(_) => GValue::Dict(HashMap::new()), // Objects become empty dicts\n            _ => GValue::Null,\n        }\n    }\n}\n\nimpl PartialEq for GValue {\n    fn eq(&self, other: &Self) -> bool {\n        match (self, other) {\n            (GValue::Null, GValue::Null) => true,\n            (GValue::Bool(a), GValue::Bool(b)) => a == b,\n            (GValue::Int(a), GValue::Int(b)) => a == b,\n            (GValue::Float(a), GValue::Float(b)) => (a - b).abs() < 1e-10,\n            (GValue::String(a), GValue::String(b)) => a == b,\n            (GValue::Symbol(a), GValue::Symbol(b)) => a == b,\n            (GValue::Sequence(a), GValue::Sequence(b)) => a == b,\n            (GValue::Dict(a), GValue::Dict(b)) => a == b,\n            // Cross-type numeric comparison\n            (GValue::Int(a), GValue::Float(b)) => (*a as f64 - b).abs() < 1e-10,\n            (GValue::Float(a), GValue::Int(b)) => (a - *b as f64).abs() < 1e-10,\n            _ => false,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_gvalue_creation() {\n        assert!(GValue::null().is_null());\n        assert_eq!(GValue::bool(true).as_bool(), Some(true));\n        assert_eq!(GValue::int(42).as_i64(), Some(42));\n        assert_eq!(GValue::float(3.14).as_f64(), Some(3.14));\n        assert_eq!(GValue::string(\"hello\").as_str(), Some(\"hello\"));\n        assert_eq!(GValue::symbol(\"test\").as_str(), Some(\"test\"));\n    }\n\n    #[test]\n    fn test_gvalue_parse() {\n        assert!(GValue::parse(\"NULL\").unwrap().is_null());\n        assert_eq!(GValue::parse(\"true\").unwrap(), GValue::Bool(true));\n        assert_eq!(GValue::parse(\"42\").unwrap(), GValue::Int(42));\n        assert_eq!(GValue::parse(\"3.14\").unwrap(), GValue::Float(3.14));\n        assert_eq!(\n            GValue::parse(\"@symbol\").unwrap(),\n            GValue::Symbol(\"symbol\".to_string())\n        );\n        assert_eq!(\n            GValue::parse(\"\\\"hello\\\"\").unwrap(),\n            GValue::String(\"hello\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_gvalue_parse_array() {\n        let result = GValue::parse(\"[1, 2, 3]\").unwrap();\n        if let GValue::Sequence(v) = result {\n            assert_eq!(v.len(), 3);\n            assert_eq!(v[0], GValue::Int(1));\n            assert_eq!(v[1], GValue::Int(2));\n            assert_eq!(v[2], GValue::Int(3));\n        } else {\n            panic!(\"Expected Sequence\");\n        }\n    }\n\n    #[test]\n    fn test_gvalue_sequence_operations() {\n        let mut seq = GValue::sequence();\n        seq.push(GValue::int(1)).unwrap();\n        seq.push(GValue::int(2)).unwrap();\n\n        assert_eq!(seq.len().unwrap(), 2);\n        assert_eq!(seq.get_index(0).unwrap(), &GValue::Int(1));\n        assert_eq!(seq.get_index(1).unwrap(), &GValue::Int(2));\n\n        seq.set_index(0, GValue::int(10)).unwrap();\n        assert_eq!(seq.get_index(0).unwrap(), &GValue::Int(10));\n    }\n\n    #[test]\n    fn test_gvalue_dict_operations() {\n        let mut dict = GValue::dict();\n        dict.set_key(\"name\", GValue::string(\"test\")).unwrap();\n        dict.set_key(\"value\", GValue::int(42)).unwrap();\n\n        assert_eq!(dict.len().unwrap(), 2);\n        assert_eq!(\n            dict.get_key(\"name\").unwrap(),\n            &GValue::String(\"test\".to_string())\n        );\n        assert_eq!(dict.get_key(\"value\").unwrap(), &GValue::Int(42));\n    }\n\n    #[test]\n    fn test_gvalue_index_out_of_bounds() {\n        let seq = GValue::sequence_from(vec![GValue::int(1)]);\n        let result = seq.get_index(5);\n        assert!(matches!(\n            result,\n            Err(GObjectError::IndexOutOfBounds {\n                index: 5,\n                length: 1\n            })\n        ));\n    }\n\n    #[test]\n    fn test_gvalue_key_not_found() {\n        let dict = GValue::dict();\n        let result = dict.get_key(\"missing\");\n        assert!(matches!(result, Err(GObjectError::KeyNotFound(_))));\n    }\n\n    #[test]\n    fn test_gvalue_type_name() {\n        assert_eq!(GValue::Null.type_name(), \"null\");\n        assert_eq!(GValue::Bool(true).type_name(), \"boolean\");\n        assert_eq!(GValue::Int(1).type_name(), \"integer\");\n        assert_eq!(GValue::Float(1.0).type_name(), \"float\");\n        assert_eq!(GValue::String(\"\".to_string()).type_name(), \"string\");\n        assert_eq!(GValue::Symbol(\"\".to_string()).type_name(), \"symbol\");\n        assert_eq!(GValue::Sequence(vec![]).type_name(), \"sequence\");\n        assert_eq!(GValue::Dict(HashMap::new()).type_name(), \"dict\");\n    }\n\n    #[test]\n    fn test_gvalue_equality() {\n        assert_eq!(GValue::Null, GValue::Null);\n        assert_eq!(GValue::Bool(true), GValue::Bool(true));\n        assert_eq!(GValue::Int(42), GValue::Int(42));\n        assert_eq!(GValue::Float(3.14), GValue::Float(3.14));\n\n        // Cross-type numeric equality\n        assert_eq!(GValue::Int(42), GValue::Float(42.0));\n        assert_eq!(GValue::Float(42.0), GValue::Int(42));\n    }\n\n    #[test]\n    fn test_gvalue_debug() {\n        let val = GValue::Int(42);\n        let debug_str = format!(\"{:?}\", val);\n        assert!(debug_str.contains(\"Int\"));\n        assert!(debug_str.contains(\"42\"));\n    }\n\n    #[test]\n    fn test_gvalue_clone() {\n        let original = GValue::String(\"test\".to_string());\n        let cloned = original.clone();\n        assert_eq!(original, cloned);\n    }\n\n    #[test]\n    fn test_gvalue_as_bool_from_int() {\n        assert_eq!(GValue::Int(1).as_bool(), Some(true));\n        assert_eq!(GValue::Int(0).as_bool(), Some(false));\n        assert_eq!(GValue::Int(-1).as_bool(), Some(true));\n    }\n\n    #[test]\n    fn test_gvalue_as_bool_from_float() {\n        assert_eq!(GValue::Float(1.0).as_bool(), None);\n        assert_eq!(GValue::String(\"test\".to_string()).as_bool(), None);\n    }\n\n    #[test]\n    fn test_gvalue_as_i64_from_float() {\n        assert_eq!(GValue::Float(42.5).as_i64(), Some(42));\n        assert_eq!(GValue::Float(-10.9).as_i64(), Some(-10));\n    }\n\n    #[test]\n    fn test_gvalue_as_i64_from_other() {\n        assert_eq!(GValue::String(\"42\".to_string()).as_i64(), None);\n        assert_eq!(GValue::Null.as_i64(), None);\n    }\n\n    #[test]\n    fn test_gvalue_as_f64_from_int() {\n        assert_eq!(GValue::Int(42).as_f64(), Some(42.0));\n        assert_eq!(GValue::Int(-10).as_f64(), Some(-10.0));\n    }\n\n    #[test]\n    fn test_gvalue_as_f64_from_other() {\n        assert_eq!(GValue::String(\"3.14\".to_string()).as_f64(), None);\n        assert_eq!(GValue::Null.as_f64(), None);\n    }\n\n    #[test]\n    fn test_gvalue_as_str_from_symbol() {\n        assert_eq!(GValue::Symbol(\"mySymbol\".to_string()).as_str(), Some(\"mySymbol\"));\n    }\n\n    #[test]\n    fn test_gvalue_as_str_from_other() {\n        assert_eq!(GValue::Int(42).as_str(), None);\n        assert_eq!(GValue::Null.as_str(), None);\n    }\n\n    #[test]\n    fn test_gvalue_as_sequence_none() {\n        assert!(GValue::Int(42).as_sequence().is_none());\n        assert!(GValue::String(\"test\".to_string()).as_sequence().is_none());\n    }\n\n    #[test]\n    fn test_gvalue_as_sequence_mut() {\n        let mut seq = GValue::sequence_from(vec![GValue::Int(1), GValue::Int(2)]);\n        if let Some(v) = seq.as_sequence_mut() {\n            v.push(GValue::Int(3));\n        }\n        assert_eq!(seq.len().unwrap(), 3);\n    }\n\n    #[test]\n    fn test_gvalue_as_sequence_mut_none() {\n        let mut val = GValue::Int(42);\n        assert!(val.as_sequence_mut().is_none());\n    }\n\n    #[test]\n    fn test_gvalue_as_dict_none() {\n        assert!(GValue::Int(42).as_dict().is_none());\n        assert!(GValue::Sequence(vec![]).as_dict().is_none());\n    }\n\n    #[test]\n    fn test_gvalue_as_dict_mut() {\n        let mut dict = GValue::dict();\n        if let Some(d) = dict.as_dict_mut() {\n            d.insert(\"key\".to_string(), GValue::Int(42));\n        }\n        assert_eq!(dict.len().unwrap(), 1);\n    }\n\n    #[test]\n    fn test_gvalue_as_dict_mut_none() {\n        let mut val = GValue::Int(42);\n        assert!(val.as_dict_mut().is_none());\n    }\n\n    #[test]\n    fn test_gvalue_parse_empty() {\n        let result = GValue::parse(\"\").unwrap();\n        assert!(result.is_null());\n    }\n\n    #[test]\n    fn test_gvalue_parse_false() {\n        assert_eq!(GValue::parse(\"false\").unwrap(), GValue::Bool(false));\n        assert_eq!(GValue::parse(\"FALSE\").unwrap(), GValue::Bool(false));\n    }\n\n    #[test]\n    fn test_gvalue_parse_true_uppercase() {\n        assert_eq!(GValue::parse(\"TRUE\").unwrap(), GValue::Bool(true));\n    }\n\n    #[test]\n    fn test_gvalue_parse_float() {\n        assert_eq!(GValue::parse(\"3.14\").unwrap(), GValue::Float(3.14));\n        assert_eq!(GValue::parse(\"-2.5\").unwrap(), GValue::Float(-2.5));\n    }\n\n    #[test]\n    fn test_gvalue_parse_negative_int() {\n        assert_eq!(GValue::parse(\"-42\").unwrap(), GValue::Int(-42));\n    }\n\n    #[test]\n    fn test_gvalue_parse_whitespace() {\n        assert_eq!(GValue::parse(\"  42  \").unwrap(), GValue::Int(42));\n        assert_eq!(GValue::parse(\"  true  \").unwrap(), GValue::Bool(true));\n    }\n\n    #[test]\n    fn test_gvalue_parse_unquoted_string() {\n        let result = GValue::parse(\"hello_world\").unwrap();\n        assert_eq!(result, GValue::String(\"hello_world\".to_string()));\n    }\n\n    #[test]\n    fn test_gvalue_get_index_invalid_type() {\n        let val = GValue::Int(42);\n        let result = val.get_index(0);\n        assert!(matches!(result, Err(GObjectError::InvalidOperation { .. })));\n    }\n\n    #[test]\n    fn test_gvalue_get_key_invalid_type() {\n        let val = GValue::Int(42);\n        let result = val.get_key(\"key\");\n        assert!(matches!(result, Err(GObjectError::InvalidOperation { .. })));\n    }\n\n    #[test]\n    fn test_gvalue_set_index_out_of_bounds() {\n        let mut seq = GValue::sequence_from(vec![GValue::Int(1)]);\n        let result = seq.set_index(5, GValue::Int(10));\n        assert!(matches!(result, Err(GObjectError::IndexOutOfBounds { .. })));\n    }\n\n    #[test]\n    fn test_gvalue_set_index_invalid_type() {\n        let mut val = GValue::Int(42);\n        let result = val.set_index(0, GValue::Int(10));\n        assert!(matches!(result, Err(GObjectError::InvalidOperation { .. })));\n    }\n\n    #[test]\n    fn test_gvalue_set_key_invalid_type() {\n        let mut val = GValue::Int(42);\n        let result = val.set_key(\"key\", GValue::Int(10));\n        assert!(matches!(result, Err(GObjectError::InvalidOperation { .. })));\n    }\n\n    #[test]\n    fn test_gvalue_push_invalid_type() {\n        let mut val = GValue::Int(42);\n        let result = val.push(GValue::Int(10));\n        assert!(matches!(result, Err(GObjectError::InvalidOperation { .. })));\n    }\n\n    #[test]\n    fn test_gvalue_len_string() {\n        let val = GValue::String(\"hello\".to_string());\n        assert_eq!(val.len().unwrap(), 5);\n    }\n\n    #[test]\n    fn test_gvalue_len_invalid_type() {\n        let val = GValue::Int(42);\n        let result = val.len();\n        assert!(matches!(result, Err(GObjectError::InvalidOperation { .. })));\n    }\n\n    #[test]\n    fn test_gvalue_is_empty() {\n        let empty_seq = GValue::sequence();\n        assert!(empty_seq.is_empty().unwrap());\n\n        let non_empty_seq = GValue::sequence_from(vec![GValue::Int(1)]);\n        assert!(!non_empty_seq.is_empty().unwrap());\n    }\n\n    #[test]\n    fn test_gvalue_from_value_null() {\n        let value = Value::Null;\n        let gvalue: GValue = value.into();\n        assert!(gvalue.is_null());\n    }\n\n    #[test]\n    fn test_gvalue_from_value_bool() {\n        let value = Value::Bool(true);\n        let gvalue: GValue = value.into();\n        assert_eq!(gvalue, GValue::Bool(true));\n    }\n\n    #[test]\n    fn test_gvalue_from_value_int() {\n        let value = Value::Int(42);\n        let gvalue: GValue = value.into();\n        assert_eq!(gvalue, GValue::Int(42));\n    }\n\n    #[test]\n    fn test_gvalue_from_value_float() {\n        let value = Value::Float(3.14);\n        let gvalue: GValue = value.into();\n        assert_eq!(gvalue, GValue::Float(3.14));\n    }\n\n    #[test]\n    fn test_gvalue_from_value_string() {\n        let value = Value::String(std::rc::Rc::new(\"test\".to_string()));\n        let gvalue: GValue = value.into();\n        assert_eq!(gvalue, GValue::String(\"test\".to_string()));\n    }\n\n    #[test]\n    fn test_gvalue_from_value_symbol() {\n        let value = Value::Symbol(std::rc::Rc::new(\"sym\".to_string()));\n        let gvalue: GValue = value.into();\n        assert_eq!(gvalue, GValue::Symbol(\"sym\".to_string()));\n    }\n\n    #[test]\n    fn test_gvalue_equality_different_types() {\n        assert_ne!(GValue::Int(42), GValue::String(\"42\".to_string()));\n        assert_ne!(GValue::Bool(true), GValue::Int(1));\n        assert_ne!(GValue::Null, GValue::Int(0));\n    }\n\n    #[test]\n    fn test_gvalue_equality_sequences() {\n        let seq1 = GValue::sequence_from(vec![GValue::Int(1), GValue::Int(2)]);\n        let seq2 = GValue::sequence_from(vec![GValue::Int(1), GValue::Int(2)]);\n        let seq3 = GValue::sequence_from(vec![GValue::Int(1), GValue::Int(3)]);\n\n        assert_eq!(seq1, seq2);\n        assert_ne!(seq1, seq3);\n    }\n\n    #[test]\n    fn test_gvalue_equality_dicts() {\n        let mut entries1 = HashMap::new();\n        entries1.insert(\"a\".to_string(), GValue::Int(1));\n\n        let mut entries2 = HashMap::new();\n        entries2.insert(\"a\".to_string(), GValue::Int(1));\n\n        let dict1 = GValue::dict_from(entries1);\n        let dict2 = GValue::dict_from(entries2);\n\n        assert_eq!(dict1, dict2);\n    }\n\n    #[test]\n    fn test_gvalue_equality_string_vs_symbol() {\n        let string = GValue::String(\"test\".to_string());\n        let symbol = GValue::Symbol(\"test\".to_string());\n        assert_ne!(string, symbol);\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":6}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":53,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":7}},{"line":73,"address":[],"length":0,"stats":{"Line":7}},{"line":77,"address":[],"length":0,"stats":{"Line":3}},{"line":78,"address":[],"length":0,"stats":{"Line":3}},{"line":82,"address":[],"length":0,"stats":{"Line":2}},{"line":83,"address":[],"length":0,"stats":{"Line":2}},{"line":87,"address":[],"length":0,"stats":{"Line":4}},{"line":88,"address":[],"length":0,"stats":{"Line":4}},{"line":92,"address":[],"length":0,"stats":{"Line":14}},{"line":93,"address":[],"length":0,"stats":{"Line":14}},{"line":94,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":7}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":6}},{"line":107,"address":[],"length":0,"stats":{"Line":6}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":6}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":5}},{"line":116,"address":[],"length":0,"stats":{"Line":5}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":4}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":124,"address":[],"length":0,"stats":{"Line":5}},{"line":125,"address":[],"length":0,"stats":{"Line":5}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":4}},{"line":128,"address":[],"length":0,"stats":{"Line":2}},{"line":133,"address":[],"length":0,"stats":{"Line":5}},{"line":134,"address":[],"length":0,"stats":{"Line":5}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":4}},{"line":137,"address":[],"length":0,"stats":{"Line":2}},{"line":142,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":2}},{"line":151,"address":[],"length":0,"stats":{"Line":2}},{"line":152,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[],"length":0,"stats":{"Line":2}},{"line":159,"address":[],"length":0,"stats":{"Line":2}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":2}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":20}},{"line":183,"address":[],"length":0,"stats":{"Line":60}},{"line":185,"address":[],"length":0,"stats":{"Line":59}},{"line":186,"address":[],"length":0,"stats":{"Line":2}},{"line":190,"address":[],"length":0,"stats":{"Line":34}},{"line":191,"address":[],"length":0,"stats":{"Line":3}},{"line":193,"address":[],"length":0,"stats":{"Line":29}},{"line":194,"address":[],"length":0,"stats":{"Line":2}},{"line":198,"address":[],"length":0,"stats":{"Line":14}},{"line":199,"address":[],"length":0,"stats":{"Line":1}},{"line":203,"address":[],"length":0,"stats":{"Line":27}},{"line":204,"address":[],"length":0,"stats":{"Line":2}},{"line":208,"address":[],"length":0,"stats":{"Line":17}},{"line":209,"address":[],"length":0,"stats":{"Line":6}},{"line":211,"address":[],"length":0,"stats":{"Line":8}},{"line":212,"address":[],"length":0,"stats":{"Line":3}},{"line":216,"address":[],"length":0,"stats":{"Line":6}},{"line":217,"address":[],"length":0,"stats":{"Line":3}},{"line":218,"address":[],"length":0,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":10}},{"line":220,"address":[],"length":0,"stats":{"Line":2}},{"line":224,"address":[],"length":0,"stats":{"Line":1}},{"line":228,"address":[],"length":0,"stats":{"Line":5}},{"line":229,"address":[],"length":0,"stats":{"Line":5}},{"line":230,"address":[],"length":0,"stats":{"Line":20}},{"line":231,"address":[],"length":0,"stats":{"Line":8}},{"line":232,"address":[],"length":0,"stats":{"Line":4}},{"line":234,"address":[],"length":0,"stats":{"Line":1}},{"line":235,"address":[],"length":0,"stats":{"Line":3}},{"line":236,"address":[],"length":0,"stats":{"Line":1}},{"line":242,"address":[],"length":0,"stats":{"Line":4}},{"line":243,"address":[],"length":0,"stats":{"Line":4}},{"line":244,"address":[],"length":0,"stats":{"Line":18}},{"line":245,"address":[],"length":0,"stats":{"Line":1}},{"line":246,"address":[],"length":0,"stats":{"Line":3}},{"line":247,"address":[],"length":0,"stats":{"Line":1}},{"line":253,"address":[],"length":0,"stats":{"Line":3}},{"line":254,"address":[],"length":0,"stats":{"Line":3}},{"line":255,"address":[],"length":0,"stats":{"Line":2}},{"line":256,"address":[],"length":0,"stats":{"Line":4}},{"line":257,"address":[],"length":0,"stats":{"Line":1}},{"line":258,"address":[],"length":0,"stats":{"Line":2}},{"line":259,"address":[],"length":0,"stats":{"Line":1}},{"line":262,"address":[],"length":0,"stats":{"Line":2}},{"line":263,"address":[],"length":0,"stats":{"Line":1}},{"line":265,"address":[],"length":0,"stats":{"Line":1}},{"line":266,"address":[],"length":0,"stats":{"Line":3}},{"line":267,"address":[],"length":0,"stats":{"Line":1}},{"line":273,"address":[],"length":0,"stats":{"Line":3}},{"line":274,"address":[],"length":0,"stats":{"Line":3}},{"line":275,"address":[],"length":0,"stats":{"Line":2}},{"line":276,"address":[],"length":0,"stats":{"Line":10}},{"line":277,"address":[],"length":0,"stats":{"Line":2}},{"line":279,"address":[],"length":0,"stats":{"Line":1}},{"line":280,"address":[],"length":0,"stats":{"Line":3}},{"line":281,"address":[],"length":0,"stats":{"Line":1}},{"line":287,"address":[],"length":0,"stats":{"Line":3}},{"line":288,"address":[],"length":0,"stats":{"Line":3}},{"line":289,"address":[],"length":0,"stats":{"Line":2}},{"line":290,"address":[],"length":0,"stats":{"Line":6}},{"line":291,"address":[],"length":0,"stats":{"Line":2}},{"line":293,"address":[],"length":0,"stats":{"Line":1}},{"line":294,"address":[],"length":0,"stats":{"Line":3}},{"line":295,"address":[],"length":0,"stats":{"Line":1}},{"line":301,"address":[],"length":0,"stats":{"Line":8}},{"line":302,"address":[],"length":0,"stats":{"Line":8}},{"line":303,"address":[],"length":0,"stats":{"Line":8}},{"line":304,"address":[],"length":0,"stats":{"Line":4}},{"line":305,"address":[],"length":0,"stats":{"Line":2}},{"line":306,"address":[],"length":0,"stats":{"Line":1}},{"line":307,"address":[],"length":0,"stats":{"Line":3}},{"line":308,"address":[],"length":0,"stats":{"Line":1}},{"line":314,"address":[],"length":0,"stats":{"Line":2}},{"line":315,"address":[],"length":0,"stats":{"Line":8}},{"line":320,"address":[],"length":0,"stats":{"Line":6}},{"line":321,"address":[],"length":0,"stats":{"Line":6}},{"line":322,"address":[],"length":0,"stats":{"Line":1}},{"line":323,"address":[],"length":0,"stats":{"Line":2}},{"line":324,"address":[],"length":0,"stats":{"Line":2}},{"line":325,"address":[],"length":0,"stats":{"Line":2}},{"line":326,"address":[],"length":0,"stats":{"Line":2}},{"line":327,"address":[],"length":0,"stats":{"Line":2}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":46}},{"line":340,"address":[],"length":0,"stats":{"Line":92}},{"line":341,"address":[],"length":0,"stats":{"Line":1}},{"line":342,"address":[],"length":0,"stats":{"Line":21}},{"line":343,"address":[],"length":0,"stats":{"Line":51}},{"line":344,"address":[],"length":0,"stats":{"Line":15}},{"line":345,"address":[],"length":0,"stats":{"Line":15}},{"line":346,"address":[],"length":0,"stats":{"Line":6}},{"line":347,"address":[],"length":0,"stats":{"Line":6}},{"line":348,"address":[],"length":0,"stats":{"Line":3}},{"line":350,"address":[],"length":0,"stats":{"Line":3}},{"line":351,"address":[],"length":0,"stats":{"Line":3}},{"line":352,"address":[],"length":0,"stats":{"Line":4}}],"covered":161,"coverable":168},{"path":["/","workspace","crates","ofml-lib","src","interpreter.rs"],"content":"//! OFML Interpreter - Expression evaluation and statement execution\n\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::path::PathBuf;\nuse std::rc::Rc;\n\nuse crate::ast::*;\nuse crate::env::Environment;\nuse crate::scene::{AlignMode, Axis, SceneGraph, SceneNode};\nuse crate::value::*;\n\n/// Interpreter result\npub type InterpResult<T> = Result<T, InterpError>;\n\n/// Interpreter error\n#[derive(Debug, Clone)]\npub struct InterpError {\n    pub message: String,\n    pub kind: ErrorKind,\n}\n\n#[derive(Debug, Clone)]\npub enum ErrorKind {\n    Runtime,\n    TypeError,\n    NameError,\n    Return(Value),\n    Break,\n    Continue,\n}\n\nimpl InterpError {\n    pub fn runtime(msg: impl Into<String>) -> Self {\n        Self {\n            message: msg.into(),\n            kind: ErrorKind::Runtime,\n        }\n    }\n    pub fn type_error(msg: impl Into<String>) -> Self {\n        Self {\n            message: msg.into(),\n            kind: ErrorKind::TypeError,\n        }\n    }\n    pub fn name_error(msg: impl Into<String>) -> Self {\n        Self {\n            message: msg.into(),\n            kind: ErrorKind::NameError,\n        }\n    }\n}\n\nimpl std::fmt::Display for InterpError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{}\", self.message)\n    }\n}\n\nimpl std::error::Error for InterpError {}\n\nimpl From<String> for InterpError {\n    fn from(s: String) -> Self {\n        Self::runtime(s)\n    }\n}\n\n/// The OFML interpreter\npub struct Interpreter {\n    /// Variable environment\n    pub env: Environment,\n    /// Registered classes by short name (for backwards compatibility)\n    pub classes: HashMap<String, Rc<ClassValue>>,\n    /// Registered classes by fully qualified name (e.g., \"::vitra::basics::VitraOiBTGPlElement3\")\n    pub qualified_classes: HashMap<String, Rc<ClassValue>>,\n    /// Current package context (e.g., \"::vitra::basics\")\n    pub current_package: String,\n    /// Current 'self' object for method calls\n    pub current_self: Option<Rc<RefCell<ObjInstance>>>,\n    /// Output buffer for debugging\n    pub output: Vec<String>,\n    /// Scene graph for 3D objects\n    pub scene: SceneGraph,\n    /// Mapping from object instances to scene nodes\n    pub obj_to_node: HashMap<u64, Rc<RefCell<SceneNode>>>,\n    /// Next object ID\n    next_obj_id: u64,\n    /// Current ALB path (for product database lookups)\n    pub current_alb_path: Option<PathBuf>,\n    /// Call depth counter to prevent stack overflow\n    call_depth: usize,\n    /// Total operation counter to prevent infinite execution\n    operation_count: usize,\n}\n\nimpl Interpreter {\n    /// Create a new interpreter\n    pub fn new() -> Self {\n        let mut interp = Self {\n            env: Environment::new(),\n            classes: HashMap::new(),\n            qualified_classes: HashMap::new(),\n            current_package: String::new(),\n            current_self: None,\n            output: Vec::new(),\n            scene: SceneGraph::new(),\n            obj_to_node: HashMap::new(),\n            next_obj_id: 1,\n            current_alb_path: None,\n            call_depth: 0,\n            operation_count: 0,\n        };\n        interp.register_builtins();\n        interp.register_ofml_classes();\n        interp.register_xoi_classes();\n        interp\n    }\n\n    /// Set the ALB path for geometry loading\n    pub fn set_alb_path(&mut self, path: PathBuf) {\n        self.scene.set_alb_path(&path);\n    }\n\n    /// Get the next object ID\n    #[allow(dead_code)]\n    fn next_obj_id(&mut self) -> u64 {\n        let id = self.next_obj_id;\n        self.next_obj_id += 1;\n        id\n    }\n\n    /// Register native OFML classes\n    fn register_ofml_classes(&mut self) {\n        // Mathematical constants\n        self.env\n            .define_global(\"sPi\", Value::Float(std::f64::consts::PI));\n        self.env\n            .define_global(\"sE\", Value::Float(std::f64::consts::E));\n\n        // Math functions\n        self.env.define_global(\n            \"floor\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let val = args.first().and_then(|v| v.to_float()).unwrap_or(0.0);\n                Ok(Value::Int(val.floor() as i64))\n            })),\n        );\n        self.env.define_global(\n            \"ceil\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let val = args.first().and_then(|v| v.to_float()).unwrap_or(0.0);\n                Ok(Value::Int(val.ceil() as i64))\n            })),\n        );\n        self.env.define_global(\n            \"round\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let val = args.first().and_then(|v| v.to_float()).unwrap_or(0.0);\n                Ok(Value::Int(val.round() as i64))\n            })),\n        );\n        self.env.define_global(\n            \"abs\",\n            Value::NativeFunc(Rc::new(|_interp, args| match args.first() {\n                Some(Value::Int(n)) => Ok(Value::Int(n.abs())),\n                Some(Value::Float(f)) => Ok(Value::Float(f.abs())),\n                _ => Ok(Value::Int(0)),\n            })),\n        );\n        self.env.define_global(\n            \"sqrt\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let val = args.first().and_then(|v| v.to_float()).unwrap_or(0.0);\n                Ok(Value::Float(val.sqrt()))\n            })),\n        );\n        self.env.define_global(\n            \"pow\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let base = args.first().and_then(|v| v.to_float()).unwrap_or(0.0);\n                let exp = args.get(1).and_then(|v| v.to_float()).unwrap_or(0.0);\n                Ok(Value::Float(base.powf(exp)))\n            })),\n        );\n        self.env.define_global(\n            \"sin\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let val = args.first().and_then(|v| v.to_float()).unwrap_or(0.0);\n                Ok(Value::Float(val.sin()))\n            })),\n        );\n        self.env.define_global(\n            \"cos\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let val = args.first().and_then(|v| v.to_float()).unwrap_or(0.0);\n                Ok(Value::Float(val.cos()))\n            })),\n        );\n        self.env.define_global(\n            \"atan2\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let y = args.first().and_then(|v| v.to_float()).unwrap_or(0.0);\n                let x = args.get(1).and_then(|v| v.to_float()).unwrap_or(1.0);\n                Ok(Value::Float(y.atan2(x)))\n            })),\n        );\n\n        // Register OiObject base class\n        let oi_object = self.create_native_class(\"OiObject\", None);\n        self.classes\n            .insert(\"OiObject\".to_string(), oi_object.clone());\n        self.env\n            .define_global(\"OiObject\", Value::Class(oi_object.clone()));\n\n        // Register OiPart class (extends OiObject)\n        let oi_part = self.create_native_class(\"OiPart\", Some(oi_object.clone()));\n        self.classes.insert(\"OiPart\".to_string(), oi_part.clone());\n        self.env\n            .define_global(\"OiPart\", Value::Class(oi_part.clone()));\n\n        // Register OiGeometry class (extends OiObject)\n        let oi_geometry = self.create_native_class(\"OiGeometry\", Some(oi_object.clone()));\n        self.classes\n            .insert(\"OiGeometry\".to_string(), oi_geometry.clone());\n        self.env\n            .define_global(\"OiGeometry\", Value::Class(oi_geometry.clone()));\n\n        // Register OiBlock class (extends OiGeometry)\n        let oi_block = self.create_native_class(\"OiBlock\", Some(oi_geometry.clone()));\n        self.classes.insert(\"OiBlock\".to_string(), oi_block.clone());\n        self.env\n            .define_global(\"OiBlock\", Value::Class(oi_block.clone()));\n\n        // Register xxPart class (base for OiPart)\n        let xx_part = self.create_native_class(\"xxPart\", Some(oi_object.clone()));\n        self.classes.insert(\"xxPart\".to_string(), xx_part.clone());\n        self.env\n            .define_global(\"xxPart\", Value::Class(xx_part.clone()));\n\n        // Register Top class (base for OiGeometry in some hierarchies)\n        let top = self.create_native_class(\"Top\", Some(oi_object.clone()));\n        self.classes.insert(\"Top\".to_string(), top.clone());\n        self.env.define_global(\"Top\", Value::Class(top.clone()));\n\n        // Register OiImport class (extends OiGeometry, loads 3DS/OFF files)\n        let oi_import = self.create_native_class(\"OiImport\", Some(oi_geometry.clone()));\n        self.classes\n            .insert(\"OiImport\".to_string(), oi_import.clone());\n        self.env\n            .define_global(\"OiImport\", Value::Class(oi_import.clone()));\n\n        // Register OiCylinder class (extends OiGeometry)\n        let oi_cylinder = self.create_native_class(\"OiCylinder\", Some(oi_geometry.clone()));\n        self.classes\n            .insert(\"OiCylinder\".to_string(), oi_cylinder.clone());\n        self.env\n            .define_global(\"OiCylinder\", Value::Class(oi_cylinder.clone()));\n\n        // Register OiSphere class (extends OiGeometry)\n        let oi_sphere = self.create_native_class(\"OiSphere\", Some(oi_geometry.clone()));\n        self.classes\n            .insert(\"OiSphere\".to_string(), oi_sphere.clone());\n        self.env\n            .define_global(\"OiSphere\", Value::Class(oi_sphere.clone()));\n\n        // Register OiSurface class (extends OiGeometry) - for surface primitives\n        let oi_surface = self.create_native_class(\"OiSurface\", Some(oi_geometry.clone()));\n        self.classes\n            .insert(\"OiSurface\".to_string(), oi_surface.clone());\n        self.env\n            .define_global(\"OiSurface\", Value::Class(oi_surface.clone()));\n\n        // Register OiEllipsoid class (extends OiGeometry)\n        let oi_ellipsoid = self.create_native_class(\"OiEllipsoid\", Some(oi_geometry.clone()));\n        self.classes\n            .insert(\"OiEllipsoid\".to_string(), oi_ellipsoid.clone());\n        self.env\n            .define_global(\"OiEllipsoid\", Value::Class(oi_ellipsoid.clone()));\n\n        // Register OiPolygon class (extends OiGeometry)\n        let oi_polygon = self.create_native_class(\"OiPolygon\", Some(oi_geometry.clone()));\n        self.classes\n            .insert(\"OiPolygon\".to_string(), oi_polygon.clone());\n        self.env\n            .define_global(\"OiPolygon\", Value::Class(oi_polygon.clone()));\n\n        // Register OiFrame class (extends OiGeometry)\n        let oi_frame = self.create_native_class(\"OiFrame\", Some(oi_geometry.clone()));\n        self.classes.insert(\"OiFrame\".to_string(), oi_frame.clone());\n        self.env\n            .define_global(\"OiFrame\", Value::Class(oi_frame.clone()));\n\n        // Register OiRotation class (extends OiGeometry)\n        let oi_rotation = self.create_native_class(\"OiRotation\", Some(oi_geometry.clone()));\n        self.classes\n            .insert(\"OiRotation\".to_string(), oi_rotation.clone());\n        self.env\n            .define_global(\"OiRotation\", Value::Class(oi_rotation.clone()));\n\n        // Register OiSweep class (extends OiGeometry)\n        let oi_sweep = self.create_native_class(\"OiSweep\", Some(oi_geometry.clone()));\n        self.classes.insert(\"OiSweep\".to_string(), oi_sweep.clone());\n        self.env\n            .define_global(\"OiSweep\", Value::Class(oi_sweep.clone()));\n\n        // Register xOiPlGroup class (extends OiPart)\n        let x_oi_plgroup = self.create_native_class(\"xOiPlGroup\", Some(oi_part.clone()));\n        self.classes\n            .insert(\"xOiPlGroup\".to_string(), x_oi_plgroup.clone());\n        self.env\n            .define_global(\"xOiPlGroup\", Value::Class(x_oi_plgroup.clone()));\n\n        // Register xOiJointPlGroup class (extends xOiPlGroup)\n        let x_oi_joint_plgroup =\n            self.create_native_class(\"xOiJointPlGroup\", Some(x_oi_plgroup.clone()));\n        self.classes\n            .insert(\"xOiJointPlGroup\".to_string(), x_oi_joint_plgroup.clone());\n        self.env\n            .define_global(\"xOiJointPlGroup\", Value::Class(x_oi_joint_plgroup));\n\n        // Register GoMetaType class (extends OiPart) - for configurator products\n        let go_meta_type = self.create_native_class(\"GoMetaType\", Some(oi_part.clone()));\n        self.classes\n            .insert(\"GoMetaType\".to_string(), go_meta_type.clone());\n        self.env\n            .define_global(\"GoMetaType\", Value::Class(go_meta_type));\n\n        // oiExists - check if object exists by name\n        self.env.define_global(\n            \"oiExists\",\n            Value::NativeFunc(Rc::new(|interp, args| {\n                let name = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                Ok(Value::Bool(interp.scene.exists(&name)))\n            })),\n        );\n\n        // remove - remove object\n        self.env.define_global(\n            \"remove\",\n            Value::NativeFunc(Rc::new(|interp, args| {\n                if let Some(Value::Object(obj)) = args.first() {\n                    let obj_id = obj.as_ptr() as u64;\n                    if let Some(node) = interp.obj_to_node.remove(&obj_id) {\n                        let node_id = node.borrow().id;\n                        interp.scene.remove_node(node_id);\n                    }\n                }\n                Ok(Value::Null)\n            })),\n        );\n\n        // getName - get object name\n        self.env.define_global(\n            \"getName\",\n            Value::NativeFunc(Rc::new(|interp, _args| {\n                if let Some(ref instance) = interp.current_self {\n                    Ok(Value::String(Rc::new(instance.borrow().name.clone())))\n                } else {\n                    Ok(Value::Null)\n                }\n            })),\n        );\n\n        // xOiDebugStartFunc / xOiDebugFinishFunc / xOiDebugPrint - debug stubs\n        self.env.define_global(\n            \"xOiDebugStartFunc\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Null))),\n        );\n        self.env.define_global(\n            \"xOiDebugFinishFunc\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Null))),\n        );\n        self.env.define_global(\n            \"xOiDebugPrint\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Null))),\n        );\n        self.env.define_global(\n            \"oiDebugStartFunc\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Null))),\n        );\n        self.env.define_global(\n            \"oiDebugFinishFunc\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Null))),\n        );\n        self.env.define_global(\n            \"oiDebugPrint\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Null))),\n        );\n        self.env.define_global(\n            \"afError\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let msg = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                eprintln!(\"afError: {}\", msg);\n                Ok(Value::Null)\n            })),\n        );\n\n        // oiRegisterPackage - Register a package (stub, always returns 1/success)\n        self.env.define_global(\n            \"oiRegisterPackage\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Int(1)))),\n        );\n\n        // xOiGetPackage - Get package name from object's type\n        self.env.define_global(\n            \"xOiGetPackage\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let obj = args.first().cloned().unwrap_or(Value::Null);\n                match obj {\n                    Value::Object(instance) => {\n                        let class = &instance.borrow().class;\n                        Ok(Value::String(Rc::new(class.package.clone())))\n                    }\n                    Value::Class(class) => Ok(Value::String(Rc::new(class.package.clone()))),\n                    _ => Ok(Value::Null),\n                }\n            })),\n        );\n\n        // isInTP - Check if object is in a planning group (stub, returns NULL for now)\n        self.env.define_global(\n            \"isInTP\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Null))),\n        );\n\n        // xOiPackage2ProgID - Convert package name to program ID (e.g., \"::vitra::basics\" -> @vitra_basics)\n        self.env.define_global(\n            \"xOiPackage2ProgID\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let pkg = match args.first() {\n                    Some(Value::String(s)) => s.to_string(),\n                    _ => return Ok(Value::Null),\n                };\n                // Extract manufacturer and series from package name like \"::vitra::basics\"\n                let parts: Vec<&str> = pkg.trim_start_matches(\"::\").split(\"::\").collect();\n                if parts.len() >= 2 {\n                    let prog_id = format!(\"{}_{}\", parts[0], parts[1]);\n                    Ok(Value::Symbol(Rc::new(prog_id)))\n                } else if parts.len() == 1 && !parts[0].is_empty() {\n                    Ok(Value::Symbol(Rc::new(parts[0].to_string())))\n                } else {\n                    Ok(Value::Null)\n                }\n            })),\n        );\n\n        // xOiProgID2Manufacturer - Extract manufacturer from program ID (e.g., @vitra_basics -> \"vitra\")\n        self.env.define_global(\n            \"xOiProgID2Manufacturer\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let pid = match args.first() {\n                    Some(Value::Symbol(s)) => s.to_string(),\n                    _ => return Ok(Value::String(Rc::new(String::new()))),\n                };\n                // Find underscore and return part before it\n                if let Some(pos) = pid.find('_') {\n                    Ok(Value::String(Rc::new(pid[..pos].to_string())))\n                } else {\n                    Ok(Value::String(Rc::new(pid)))\n                }\n            })),\n        );\n\n        // xOiProgID2Series - Extract series from program ID (e.g., @vitra_basics -> \"basics\")\n        self.env.define_global(\n            \"xOiProgID2Series\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let pid = match args.first() {\n                    Some(Value::Symbol(s)) => s.to_string(),\n                    _ => return Ok(Value::String(Rc::new(String::new()))),\n                };\n                // Find underscore and return part after it\n                if let Some(pos) = pid.find('_') {\n                    Ok(Value::String(Rc::new(pid[pos + 1..].to_string())))\n                } else {\n                    Ok(Value::String(Rc::new(String::new())))\n                }\n            })),\n        );\n\n        // xOiCreateArticle / xOiCreateArticle2 - Create an article (stub, returns NULL)\n        self.env.define_global(\n            \"xOiCreateArticle\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Null))),\n        );\n        self.env.define_global(\n            \"xOiCreateArticle2\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Null))),\n        );\n\n        // article2Class - Map article to class (stub, returns NULL)\n        self.env.define_global(\n            \"article2Class\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Null))),\n        );\n\n        // Block(parent, @name, [width, height, depth]) - creates a block primitive\n        // This is a NATIVE function called by OiBlock::initialize\n        self.env.define_global(\n            \"Block\",\n            Value::NativeFunc(Rc::new(|interp, args| {\n                // Args: parent_object, @name_symbol, [width, height, depth]\n                let parent_obj = match args.first() {\n                    Some(Value::Object(obj)) => Some(obj.clone()),\n                    _ => None,\n                };\n\n                let name = match args.get(1) {\n                    Some(Value::Symbol(s)) => s.to_string(),\n                    Some(v) => v.to_string_val(),\n                    None => \"geo\".to_string(),\n                };\n\n                let dims = match args.get(2) {\n                    Some(Value::Array(arr)) => {\n                        let arr = arr.borrow();\n                        [\n                            arr.first().and_then(|v| v.to_float()).unwrap_or(1.0) as f32,\n                            arr.get(1).and_then(|v| v.to_float()).unwrap_or(1.0) as f32,\n                            arr.get(2).and_then(|v| v.to_float()).unwrap_or(1.0) as f32,\n                        ]\n                    }\n                    _ => [1.0, 1.0, 1.0],\n                };\n\n                // Get parent scene node if parent object exists\n                let parent_node = parent_obj.as_ref().and_then(|p| {\n                    let obj_id = p.as_ptr() as u64;\n                    interp.obj_to_node.get(&obj_id).cloned()\n                });\n\n                // Create scene node with block geometry\n                let node = interp.scene.create_block(name.clone(), dims, parent_node);\n\n                // Create an object instance for the block\n                let block_class = interp\n                    .classes\n                    .get(\"OiBlock\")\n                    .cloned()\n                    .unwrap_or_else(|| interp.create_native_class(\"OiBlock\", None));\n\n                let instance = Rc::new(RefCell::new(ObjInstance {\n                    class: block_class,\n                    name: name.clone(),\n                    ..Default::default()\n                }));\n\n                // Link to parent\n                if let Some(ref parent) = parent_obj {\n                    instance.borrow_mut().parent = Some(parent.clone());\n                    parent.borrow_mut().children.push(instance.clone());\n                    parent\n                        .borrow_mut()\n                        .fields\n                        .insert(name.clone(), Value::Object(instance.clone()));\n                }\n\n                // Map instance to scene node\n                let obj_id = instance.as_ptr() as u64;\n                interp.obj_to_node.insert(obj_id, node);\n\n                Ok(Value::Object(instance))\n            })),\n        );\n\n        // OffPolygon(parent, @name, \"filename\") - loads OFF/3DS geometry from file\n        // This is the core native for loading 3DS geometry from ALB archives\n        self.env.define_global(\n            \"OffPolygon\",\n            Value::NativeFunc(Rc::new(|interp, args| {\n                // Args: parent_object, @name_symbol, \"filename\"\n                let parent_obj = match args.first() {\n                    Some(Value::Object(obj)) => Some(obj.clone()),\n                    _ => None,\n                };\n\n                let name = match args.get(1) {\n                    Some(Value::Symbol(s)) => s.to_string(),\n                    Some(v) => v.to_string_val(),\n                    None => \"geo\".to_string(),\n                };\n\n                let filename = match args.get(2) {\n                    Some(Value::String(s)) => s.to_string(),\n                    Some(v) => v.to_string_val(),\n                    None => return Ok(Value::Null),\n                };\n\n                // Get parent scene node\n                let parent_node = parent_obj.as_ref().and_then(|p| {\n                    let obj_id = p.as_ptr() as u64;\n                    interp.obj_to_node.get(&obj_id).cloned()\n                });\n\n                // Create scene node with 3DS geometry\n                let node = interp.scene.create_part(name.clone(), parent_node);\n\n                // Load geometry from ALB if path is set\n                if let Some(ref alb_path) = interp.scene.alb_path.clone() {\n                    if let Err(e) =\n                        interp\n                            .scene\n                            .load_3ds_from_alb(node.clone(), alb_path, &filename)\n                    {\n                        eprintln!(\"OffPolygon: Failed to load '{}': {}\", filename, e);\n                    }\n                } else {\n                    eprintln!(\"OffPolygon: No ALB path set, cannot load '{}'\", filename);\n                }\n\n                // Create object instance\n                let geo_class = interp\n                    .classes\n                    .get(\"OiGeometry\")\n                    .cloned()\n                    .unwrap_or_else(|| interp.create_native_class(\"OiGeometry\", None));\n\n                let instance = Rc::new(RefCell::new(ObjInstance {\n                    class: geo_class,\n                    name: name.clone(),\n                    ..Default::default()\n                }));\n\n                // Link to parent\n                if let Some(ref parent) = parent_obj {\n                    instance.borrow_mut().parent = Some(parent.clone());\n                    parent.borrow_mut().children.push(instance.clone());\n                    parent\n                        .borrow_mut()\n                        .fields\n                        .insert(name.clone(), Value::Object(instance.clone()));\n                }\n\n                // Map instance to scene node\n                let obj_id = instance.as_ptr() as u64;\n                interp.obj_to_node.insert(obj_id, node);\n\n                Ok(Value::Object(instance))\n            })),\n        );\n\n        // Geo(parent, @name, \"filename.3ds\") - creates geometry from external 3DS file\n        // Alias for OffPolygon for compatibility\n        self.env.define_global(\n            \"Geo\",\n            Value::NativeFunc(Rc::new(|interp, args| {\n                // Args: parent_object, @name_symbol, \"pattern\"\n                let parent_obj = match args.first() {\n                    Some(Value::Object(obj)) => Some(obj.clone()),\n                    _ => None,\n                };\n\n                let name = match args.get(1) {\n                    Some(Value::Symbol(s)) => s.to_string(),\n                    Some(v) => v.to_string_val(),\n                    None => \"geo\".to_string(),\n                };\n\n                let pattern = match args.get(2) {\n                    Some(Value::String(s)) => s.to_string(),\n                    Some(v) => v.to_string_val(),\n                    None => return Ok(Value::Null),\n                };\n\n                // Get parent scene node\n                let parent_node = parent_obj.as_ref().and_then(|p| {\n                    let obj_id = p.as_ptr() as u64;\n                    interp.obj_to_node.get(&obj_id).cloned()\n                });\n\n                // Create scene node (initially without geometry)\n                let node = interp.scene.create_part(name.clone(), parent_node);\n\n                // Try to load geometry from ALB\n                if let Err(e) = interp.scene.load_geometry(node.clone(), &pattern) {\n                    eprintln!(\"Geo: Failed to load '{}': {}\", pattern, e);\n                }\n\n                // Create object instance\n                let geo_class = interp\n                    .classes\n                    .get(\"OiGeometry\")\n                    .cloned()\n                    .unwrap_or_else(|| interp.create_native_class(\"OiGeometry\", None));\n\n                let instance = Rc::new(RefCell::new(ObjInstance {\n                    class: geo_class,\n                    name: name.clone(),\n                    ..Default::default()\n                }));\n\n                // Link to parent\n                if let Some(ref parent) = parent_obj {\n                    instance.borrow_mut().parent = Some(parent.clone());\n                    parent.borrow_mut().children.push(instance.clone());\n                    parent\n                        .borrow_mut()\n                        .fields\n                        .insert(name.clone(), Value::Object(instance.clone()));\n                }\n\n                // Map instance to scene node\n                let obj_id = instance.as_ptr() as u64;\n                interp.obj_to_node.insert(obj_id, node);\n\n                Ok(Value::Object(instance))\n            })),\n        );\n\n        // acos, asin, atan - math functions\n        self.env.define_global(\n            \"acos\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let val = args.first().and_then(|v| v.to_float()).unwrap_or(0.0);\n                Ok(Value::Float(val.acos()))\n            })),\n        );\n        self.env.define_global(\n            \"asin\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let val = args.first().and_then(|v| v.to_float()).unwrap_or(0.0);\n                Ok(Value::Float(val.asin()))\n            })),\n        );\n        self.env.define_global(\n            \"atan\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let val = args.first().and_then(|v| v.to_float()).unwrap_or(0.0);\n                Ok(Value::Float(val.atan()))\n            })),\n        );\n        self.env.define_global(\n            \"cos\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let val = args.first().and_then(|v| v.to_float()).unwrap_or(0.0);\n                Ok(Value::Float(val.cos()))\n            })),\n        );\n        self.env.define_global(\n            \"sin\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let val = args.first().and_then(|v| v.to_float()).unwrap_or(0.0);\n                Ok(Value::Float(val.sin()))\n            })),\n        );\n        self.env.define_global(\n            \"tan\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let val = args.first().and_then(|v| v.to_float()).unwrap_or(0.0);\n                Ok(Value::Float(val.tan()))\n            })),\n        );\n        self.env.define_global(\n            \"sqrt\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let val = args.first().and_then(|v| v.to_float()).unwrap_or(0.0);\n                Ok(Value::Float(val.sqrt()))\n            })),\n        );\n        self.env.define_global(\n            \"abs\",\n            Value::NativeFunc(Rc::new(|_interp, args| match args.first() {\n                Some(Value::Int(n)) => Ok(Value::Int(n.abs())),\n                Some(Value::Float(f)) => Ok(Value::Float(f.abs())),\n                _ => Ok(Value::Float(0.0)),\n            })),\n        );\n\n        // fabs - float absolute value (common in OFML)\n        self.env.define_global(\n            \"fabs\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let val = args.first().and_then(|v| v.to_float()).unwrap_or(0.0);\n                Ok(Value::Float(val.abs()))\n            })),\n        );\n\n        // Mod - modulo function returning [quotient, remainder]\n        self.env.define_global(\n            \"Mod\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let a = args.first().and_then(|v| v.to_float()).unwrap_or(0.0);\n                let b = args.get(1).and_then(|v| v.to_float()).unwrap_or(1.0);\n                let quotient = (a / b).floor();\n                let remainder = a - (quotient * b);\n                Ok(Value::Array(Rc::new(RefCell::new(vec![\n                    Value::Float(quotient),\n                    Value::Float(remainder),\n                ]))))\n            })),\n        );\n\n        // getPDManager - returns a property definition manager object\n        // The PDManager provides access to product databases\n        self.env.define_global(\n            \"getPDManager\",\n            Value::NativeFunc(Rc::new(|interp, _args| {\n                // Create a PDManager object that can be used to access product databases\n                let pdm_class = interp\n                    .classes\n                    .get(\"PDManager\")\n                    .cloned()\n                    .unwrap_or_else(|| interp.create_native_class(\"PDManager\", None));\n\n                let instance = Rc::new(RefCell::new(ObjInstance {\n                    class: pdm_class,\n                    name: \"PDManager\".to_string(),\n                    ..Default::default()\n                }));\n\n                Ok(Value::Object(instance))\n            })),\n        );\n\n        // Symbol - create a symbol from a string\n        self.env.define_global(\n            \"Symbol\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let s = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                Ok(Value::Symbol(Rc::new(s)))\n            })),\n        );\n\n        // setInsertMode - sets the insertion mode for planning groups (xOiPlGroup)\n        // Valid modes: 0 (default/free), 1 (intermediate), 2 (inner element)\n        // Note: This is NOT a native OiObject method, but used by xOiPlGroup/xOiPlanning\n        self.env.define_global(\n            \"setInsertMode\",\n            Value::NativeFunc(Rc::new(|interp, args| {\n                let mode = args.first().and_then(|v| v.to_int()).unwrap_or(0);\n                // Validate mode is 0, 1, or 2 (as per xOiPlGroup::setInsertMode)\n                let valid_mode = if (0..=2).contains(&mode) { mode } else { 0 };\n                if let Some(ref instance) = interp.current_self {\n                    instance\n                        .borrow_mut()\n                        .properties\n                        .insert(\"mXoiInsertMode\".to_string(), Value::Int(valid_mode));\n                }\n                Ok(Value::Null)\n            })),\n        );\n\n        // getInsertMode - gets the insertion mode (defaults to 0 if NULL)\n        self.env.define_global(\n            \"getInsertMode\",\n            Value::NativeFunc(Rc::new(|interp, _args| {\n                if let Some(ref instance) = interp.current_self {\n                    if let Some(mode) = instance.borrow().properties.get(\"mXoiInsertMode\") {\n                        if !matches!(mode, Value::Null) {\n                            return Ok(mode.clone());\n                        }\n                    }\n                }\n                Ok(Value::Int(0)) // Default mode per xOiPlGroup::getInsertMode\n            })),\n        );\n\n        // setResolution - sets object space resolution for parametric primitives (OFML spec 4.2.5)\n        // Float value in range 0.0 (min detail) to 1.0 (max detail), initial: 0.1\n        // Returns self for method chaining\n        self.env.define_global(\n            \"setResolution\",\n            Value::NativeFunc(Rc::new(|interp, args| {\n                let resolution = args.first().and_then(|v| v.to_float()).unwrap_or(0.1);\n                // Clamp to valid range 0.0 to 1.0\n                let clamped = resolution.clamp(0.0, 1.0);\n                if let Some(ref instance) = interp.current_self {\n                    instance\n                        .borrow_mut()\n                        .properties\n                        .insert(\"_resolution\".to_string(), Value::Float(clamped));\n                    // Return self for method chaining (per OFML spec)\n                    return Ok(Value::Object(instance.clone()));\n                }\n                Ok(Value::Null)\n            })),\n        );\n\n        // getResolution - gets the object space resolution (Float)\n        // Returns inherited resolution or 0.1 (initial default per OFML spec)\n        self.env.define_global(\n            \"getResolution\",\n            Value::NativeFunc(Rc::new(|interp, _args| {\n                if let Some(ref instance) = interp.current_self {\n                    if let Some(res) = instance.borrow().properties.get(\"_resolution\") {\n                        return Ok(res.clone());\n                    }\n                }\n                Ok(Value::Float(0.1)) // Initial resolution per OFML spec\n            })),\n        );\n\n        // disableCD - disables collision detection (no-op for interpreter)\n        self.env.define_global(\n            \"disableCD\",\n            Value::NativeFunc(Rc::new(|_interp, _args| {\n                // Collision detection is not implemented\n                Ok(Value::Null)\n            })),\n        );\n\n        // enableCD - enables collision detection (no-op for interpreter)\n        self.env.define_global(\n            \"enableCD\",\n            Value::NativeFunc(Rc::new(|_interp, _args| {\n                // Collision detection is not implemented\n                Ok(Value::Null)\n            })),\n        );\n\n        // xOiObjInList - Check if object is in list (returns 0 or 1)\n        self.env.define_global(\n            \"xOiObjInList\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let obj = args.first().cloned().unwrap_or(Value::Null);\n                let list = args.get(1).cloned().unwrap_or(Value::Null);\n\n                if let Value::Array(arr) = list {\n                    for item in arr.borrow().iter() {\n                        if item.equals(&obj) {\n                            return Ok(Value::Int(1));\n                        }\n                    }\n                }\n                Ok(Value::Int(0))\n            })),\n        );\n\n        // xOiParseString2List - Parse string into array by separator\n        self.env.define_global(\n            \"xOiParseString2List\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let str_val = args.first().cloned().unwrap_or(Value::Null);\n                let sep = args.get(1).cloned().unwrap_or(Value::Null);\n\n                if matches!(str_val, Value::Null) {\n                    return Ok(Value::Null);\n                }\n\n                let s = str_val.to_string_val();\n                let separator = match &sep {\n                    Value::String(sep_str) => sep_str.to_string(),\n                    Value::Int(ch) => char::from_u32(*ch as u32)\n                        .map(|c| c.to_string())\n                        .unwrap_or(\",\".to_string()),\n                    _ => \",\".to_string(),\n                };\n\n                let parts: Vec<Value> = s\n                    .split(&separator)\n                    .map(|p| Value::String(Rc::new(p.to_string())))\n                    .collect();\n\n                Ok(Value::Array(Rc::new(RefCell::new(parts))))\n            })),\n        );\n\n        // xOiList2Hash - Convert list of [key, value] pairs to hash\n        self.env.define_global(\n            \"xOiList2Hash\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let list = args.first().cloned().unwrap_or(Value::Null);\n\n                if matches!(list, Value::Null) {\n                    return Ok(Value::Null);\n                }\n\n                let mut hash = HashMap::new();\n\n                if let Value::Array(arr) = list {\n                    for entry in arr.borrow().iter() {\n                        if let Value::Array(pair) = entry {\n                            let pair = pair.borrow();\n                            if pair.len() >= 2 {\n                                let key = pair[0].to_string_val();\n                                let value = pair[1].clone();\n                                hash.insert(key, value);\n                            }\n                        }\n                    }\n                }\n\n                Ok(Value::Hash(Rc::new(RefCell::new(hash))))\n            })),\n        );\n\n        // isNullOrEmpty - Check if value is null or empty\n        self.env.define_global(\n            \"isNullOrEmpty\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let val = args.first().cloned().unwrap_or(Value::Null);\n                let is_empty = match &val {\n                    Value::Null => true,\n                    Value::String(s) => s.is_empty(),\n                    Value::Array(arr) => arr.borrow().is_empty(),\n                    Value::Hash(h) => h.borrow().is_empty(),\n                    _ => false,\n                };\n                Ok(Value::Bool(is_empty))\n            })),\n        );\n\n        // new2DObj - Create a 2D object (stub - returns null for now)\n        self.env.define_global(\n            \"new2DObj\",\n            Value::NativeFunc(Rc::new(|_interp, _args| {\n                // 2D objects not implemented\n                Ok(Value::Null)\n            })),\n        );\n\n        // getMTChildren - Get metatype children (stub)\n        self.env.define_global(\n            \"getMTChildren\",\n            Value::NativeFunc(Rc::new(|_interp, _args| {\n                // Return empty array\n                Ok(Value::Array(Rc::new(RefCell::new(Vec::new()))))\n            })),\n        );\n\n        // initializeFrame - Initialize frame (stub)\n        self.env.define_global(\n            \"initializeFrame\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Null))),\n        );\n\n        // getPropKeys - Get property keys (alias for getPropertyKeys)\n        self.env.define_global(\n            \"getPropKeys\",\n            Value::NativeFunc(Rc::new(|interp, _args| {\n                if let Some(ref instance) = interp.current_self {\n                    let keys: Vec<Value> = instance\n                        .borrow()\n                        .properties\n                        .keys()\n                        .map(|k| Value::Symbol(Rc::new(k.clone())))\n                        .collect();\n                    return Ok(Value::Array(Rc::new(RefCell::new(keys))));\n                }\n                Ok(Value::Array(Rc::new(RefCell::new(Vec::new()))))\n            })),\n        );\n\n        // oiGetPropKeys - Native function to get property keys\n        self.env.define_global(\n            \"oiGetPropKeys\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                if let Some(Value::Object(instance)) = args.first() {\n                    let keys: Vec<Value> = instance\n                        .borrow()\n                        .properties\n                        .keys()\n                        .map(|k| Value::Symbol(Rc::new(k.clone())))\n                        .collect();\n                    return Ok(Value::Array(Rc::new(RefCell::new(keys))));\n                }\n                Ok(Value::Array(Rc::new(RefCell::new(Vec::new()))))\n            })),\n        );\n\n        // xOiDebugStartFunc / xOiDebugStartFunc2 - Debug logging stubs\n        self.env.define_global(\n            \"xOiDebugStartFunc\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Null))),\n        );\n        self.env.define_global(\n            \"xOiDebugStartFunc2\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Null))),\n        );\n        self.env.define_global(\n            \"xOiDebugFinishFunc\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Null))),\n        );\n\n        // xOiCreateArticle - Create article stub\n        self.env.define_global(\n            \"xOiCreateArticle\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Null))),\n        );\n\n        // oo_createArticle - Create article variant\n        self.env.define_global(\n            \"oo_createArticle\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Null))),\n        );\n\n        // getLanguage - Get current language (returns \"en\")\n        self.env.define_global(\n            \"getLanguage\",\n            Value::NativeFunc(Rc::new(|_interp, _args| {\n                Ok(Value::String(Rc::new(\"en\".to_string())))\n            })),\n        );\n\n        // typeOf - Get type of value as string\n        self.env.define_global(\n            \"typeOf\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let val = args.first().cloned().unwrap_or(Value::Null);\n                let type_name = match val {\n                    Value::Null => \"Null\",\n                    Value::Int(_) => \"Int\",\n                    Value::Float(_) => \"Float\",\n                    Value::Bool(_) => \"Bool\",\n                    Value::String(_) => \"String\",\n                    Value::Symbol(_) => \"Symbol\",\n                    Value::Array(_) => \"Vector\",\n                    Value::Hash(_) => \"Hash\",\n                    Value::Object(_) => \"Object\",\n                    Value::Class(_) => \"Class\",\n                    Value::Func(_) => \"Function\",\n                    Value::NativeFunc(_) => \"Function\",\n                    Value::Vec3(_) => \"Vector\",\n                };\n                Ok(Value::String(Rc::new(type_name.to_string())))\n            })),\n        );\n\n        // lastObj - Return null (used in some contexts to track last created object)\n        self.env.define_global(\n            \"lastObj\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Null))),\n        );\n    }\n\n    /// Create a native OFML class\n    fn create_native_class(&self, name: &str, parent: Option<Rc<ClassValue>>) -> Rc<ClassValue> {\n        Rc::new(ClassValue {\n            name: name.to_string(),\n            package: String::new(), // Native classes have no package\n            parent,\n            methods: HashMap::new(),\n            rules: HashMap::new(),\n            static_vars: HashMap::new(),\n            decl: ClassDecl {\n                modifiers: vec![],\n                name: name.to_string(),\n                parent: None,\n                members: vec![],\n                span: crate::ast::Span::default(),\n            },\n        })\n    }\n\n    /// Register built-in functions and classes\n    fn register_builtins(&mut self) {\n        // Hash constructor\n        self.env.define_global(\n            \"Hash\",\n            Value::NativeFunc(Rc::new(|_interp, _args| {\n                Ok(Value::Hash(Rc::new(RefCell::new(HashMap::new()))))\n            })),\n        );\n\n        // String constructor\n        self.env.define_global(\n            \"String\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let s = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                Ok(Value::String(Rc::new(s)))\n            })),\n        );\n\n        // Float constructor\n        self.env.define_global(\n            \"Float\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let f = args.first().and_then(|v| v.to_float()).unwrap_or(0.0);\n                Ok(Value::Float(f))\n            })),\n        );\n\n        // Int constructor\n        self.env.define_global(\n            \"Int\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let i = args.first().and_then(|v| v.to_int()).unwrap_or(0);\n                Ok(Value::Int(i))\n            })),\n        );\n\n        // print function (for debugging)\n        self.env.define_global(\n            \"print\",\n            Value::NativeFunc(Rc::new(|interp, args| {\n                let msg = args\n                    .iter()\n                    .map(|v| v.to_string_val())\n                    .collect::<Vec<_>>()\n                    .join(\" \");\n                interp.output.push(msg.clone());\n                println!(\"{}\", msg);\n                Ok(Value::Null)\n            })),\n        );\n    }\n\n    /// Execute a translation unit\n    pub fn execute(&mut self, unit: &TranslationUnit) -> InterpResult<Value> {\n        // Set current package context from translation unit\n        let prev_package = std::mem::replace(\n            &mut self.current_package,\n            unit.package\n                .as_ref()\n                .map(|p| p.to_string())\n                .unwrap_or_default(),\n        );\n\n        let mut result = Value::Null;\n\n        for stmt in &unit.statements {\n            result = self.execute_stmt(stmt)?;\n        }\n\n        // Restore previous package context\n        self.current_package = prev_package;\n\n        Ok(result)\n    }\n\n    /// Execute a statement\n    pub fn execute_stmt(&mut self, stmt: &Stmt) -> InterpResult<Value> {\n        match stmt {\n            Stmt::Var(decl) => self.execute_var_decl(decl),\n            Stmt::VarList(decls) => {\n                for decl in decls {\n                    self.execute_var_decl(decl)?;\n                }\n                Ok(Value::Null)\n            }\n            Stmt::Class(decl) => self.execute_class_decl(decl),\n            Stmt::Func(decl) => self.execute_func_decl(decl),\n            Stmt::Expr(expr) => self.evaluate(expr),\n            Stmt::Block(block) => self.execute_block(block),\n            Stmt::If(if_stmt) => self.execute_if(if_stmt),\n            Stmt::While(while_stmt) => self.execute_while(while_stmt),\n            Stmt::DoWhile(do_while) => self.execute_do_while(do_while),\n            Stmt::For(for_stmt) => self.execute_for(for_stmt),\n            Stmt::Foreach(foreach) => self.execute_foreach(foreach),\n            Stmt::Return(expr) => self.execute_return(expr.as_ref()),\n            Stmt::Break(_) => Err(InterpError {\n                message: \"break\".into(),\n                kind: ErrorKind::Break,\n            }),\n            Stmt::Continue(_) => Err(InterpError {\n                message: \"continue\".into(),\n                kind: ErrorKind::Continue,\n            }),\n            Stmt::Throw(expr) => {\n                let val = self.evaluate(expr)?;\n                Err(InterpError::runtime(format!(\"Exception: {}\", val)))\n            }\n            Stmt::Try(try_stmt) => self.execute_try(try_stmt),\n            Stmt::Switch(switch) => self.execute_switch(switch),\n            Stmt::Empty => Ok(Value::Null),\n        }\n    }\n\n    /// Execute variable declaration\n    fn execute_var_decl(&mut self, decl: &VarDecl) -> InterpResult<Value> {\n        let value = if let Some(ref init) = decl.initializer {\n            self.evaluate(init)?\n        } else {\n            Value::Null\n        };\n        self.env.define(&decl.name, value);\n        Ok(Value::Null)\n    }\n\n    /// Execute class declaration\n    fn execute_class_decl(&mut self, decl: &ClassDecl) -> InterpResult<Value> {\n        // Resolve parent class - try qualified name first, then short name\n        let parent = if let Some(ref parent_name) = decl.parent {\n            // Build fully qualified parent name if it has package parts\n            let fq_parent = parent_name.to_string();\n\n            // Try fully qualified lookup first\n            if let Some(p) = self.qualified_classes.get(&fq_parent) {\n                Some(p.clone())\n            } else {\n                // Fall back to short name lookup\n                let name = parent_name.parts.last().unwrap_or(&parent_name.parts[0]);\n                self.classes.get(name).cloned()\n            }\n        } else {\n            None\n        };\n\n        let mut methods = HashMap::new();\n        let mut rules = HashMap::new();\n        let mut static_vars = HashMap::new();\n\n        // Process class members\n        for member in &decl.members {\n            match member {\n                ClassMember::Func(func) => {\n                    let func_val = Rc::new(FuncValue {\n                        name: func.name.clone(),\n                        params: func.params.clone(),\n                        body: func.body.clone(),\n                        class: None, // Will be set later\n                        is_static: func.modifiers.contains(&Modifier::Static),\n                    });\n                    methods.insert(func.name.clone(), func_val);\n                }\n                ClassMember::Rule(rule) => {\n                    let func_val = Rc::new(FuncValue {\n                        name: rule.name.clone(),\n                        params: rule.params.clone(),\n                        body: Some(rule.body.clone()),\n                        class: None,\n                        is_static: false,\n                    });\n                    rules.insert(rule.name.clone(), func_val);\n                }\n                ClassMember::Var(var) => {\n                    if var.modifiers.contains(&Modifier::Static) {\n                        let value = if let Some(ref init) = var.initializer {\n                            self.evaluate(init)?\n                        } else {\n                            Value::Null\n                        };\n                        static_vars.insert(var.name.clone(), value);\n                    }\n                }\n                ClassMember::Expr(_) => {\n                    // Class-level expressions are evaluated when creating instances\n                }\n            }\n        }\n\n        let class = Rc::new(ClassValue {\n            name: decl.name.clone(),\n            package: self.current_package.clone(),\n            parent,\n            methods,\n            rules,\n            static_vars,\n            decl: decl.clone(),\n        });\n\n        // Register by short name (may be overwritten by later classes with same name)\n        self.classes.insert(decl.name.clone(), class.clone());\n\n        // Register by fully qualified name (unique, never overwritten)\n        let qualified_name = class.qualified_name();\n        self.qualified_classes.insert(qualified_name, class.clone());\n\n        self.env.define_global(&decl.name, Value::Class(class));\n\n        Ok(Value::Null)\n    }\n\n    /// Execute function declaration\n    fn execute_func_decl(&mut self, decl: &FuncDecl) -> InterpResult<Value> {\n        let func = Rc::new(FuncValue {\n            name: decl.name.clone(),\n            params: decl.params.clone(),\n            body: decl.body.clone(),\n            class: None,\n            is_static: true,\n        });\n        self.env.define(&decl.name, Value::Func(func));\n        Ok(Value::Null)\n    }\n\n    /// Execute block\n    fn execute_block(&mut self, block: &Block) -> InterpResult<Value> {\n        self.env.push_scope();\n        let mut result = Value::Null;\n\n        for stmt in &block.stmts {\n            match self.execute_stmt(stmt) {\n                Ok(val) => result = val,\n                Err(e) => {\n                    self.env.pop_scope();\n                    return Err(e);\n                }\n            }\n        }\n\n        self.env.pop_scope();\n        Ok(result)\n    }\n\n    /// Execute if statement\n    fn execute_if(&mut self, if_stmt: &IfStmt) -> InterpResult<Value> {\n        let cond = self.evaluate(&if_stmt.condition)?;\n        if cond.is_truthy() {\n            self.execute_stmt(&if_stmt.then_branch)\n        } else if let Some(ref else_branch) = if_stmt.else_branch {\n            self.execute_stmt(else_branch)\n        } else {\n            Ok(Value::Null)\n        }\n    }\n\n    /// Execute while loop\n    fn execute_while(&mut self, while_stmt: &WhileStmt) -> InterpResult<Value> {\n        const MAX_LOOP_ITERATIONS: usize = 100_000;\n        let mut result = Value::Null;\n        let mut iterations = 0;\n        loop {\n            iterations += 1;\n            if iterations > MAX_LOOP_ITERATIONS {\n                // Break out of loop gracefully instead of erroring\n                // This allows constructors to continue even if a loop gets stuck\n                break;\n            }\n            let cond = self.evaluate(&while_stmt.condition)?;\n            if !cond.is_truthy() {\n                break;\n            }\n            match self.execute_stmt(&while_stmt.body) {\n                Ok(val) => result = val,\n                Err(e) if matches!(e.kind, ErrorKind::Break) => break,\n                Err(e) if matches!(e.kind, ErrorKind::Continue) => continue,\n                Err(e) => return Err(e),\n            }\n        }\n        Ok(result)\n    }\n\n    /// Execute do-while loop\n    fn execute_do_while(&mut self, do_while: &DoWhileStmt) -> InterpResult<Value> {\n        const MAX_LOOP_ITERATIONS: usize = 100_000;\n        let mut result = Value::Null;\n        let mut iterations = 0;\n        loop {\n            iterations += 1;\n            if iterations > MAX_LOOP_ITERATIONS {\n                // Break out of loop gracefully instead of erroring\n                break;\n            }\n            match self.execute_stmt(&do_while.body) {\n                Ok(val) => result = val,\n                Err(e) if matches!(e.kind, ErrorKind::Break) => break,\n                Err(e) if matches!(e.kind, ErrorKind::Continue) => {}\n                Err(e) => return Err(e),\n            }\n            let cond = self.evaluate(&do_while.condition)?;\n            if !cond.is_truthy() {\n                break;\n            }\n        }\n        Ok(result)\n    }\n\n    /// Execute for loop\n    fn execute_for(&mut self, for_stmt: &ForStmt) -> InterpResult<Value> {\n        const MAX_LOOP_ITERATIONS: usize = 100_000;\n        self.env.push_scope();\n\n        // Init\n        if let Some(ref init) = for_stmt.init {\n            self.execute_stmt(init)?;\n        }\n\n        let mut result = Value::Null;\n        let mut iterations = 0;\n        loop {\n            iterations += 1;\n            if iterations > MAX_LOOP_ITERATIONS {\n                // Break out of loop gracefully instead of erroring\n                break;\n            }\n\n            // Condition\n            if let Some(ref cond) = for_stmt.condition {\n                let cond_val = self.evaluate(cond)?;\n                if !cond_val.is_truthy() {\n                    break;\n                }\n            }\n\n            // Body\n            match self.execute_stmt(&for_stmt.body) {\n                Ok(val) => result = val,\n                Err(e) if matches!(e.kind, ErrorKind::Break) => break,\n                Err(e) if matches!(e.kind, ErrorKind::Continue) => {}\n                Err(e) => {\n                    self.env.pop_scope();\n                    return Err(e);\n                }\n            }\n\n            // Update\n            if let Some(ref update) = for_stmt.update {\n                self.evaluate(update)?;\n            }\n        }\n\n        self.env.pop_scope();\n        Ok(result)\n    }\n\n    /// Execute foreach loop\n    fn execute_foreach(&mut self, foreach: &ForeachStmt) -> InterpResult<Value> {\n        let iterable = self.evaluate(&foreach.iterable)?;\n        let items = match &iterable {\n            Value::Array(arr) => arr.borrow().clone(),\n            Value::Hash(hash) => hash\n                .borrow()\n                .keys()\n                .map(|k| Value::String(Rc::new(k.clone())))\n                .collect(),\n            Value::Null => Vec::new(), // Iterating over Null is empty iteration\n            Value::String(s) => {\n                // Iterate over characters in string\n                s.chars().map(|c| Value::Int(c as i64)).collect()\n            }\n            _ => return Err(InterpError::type_error(\"Cannot iterate over this type\")),\n        };\n\n        self.env.push_scope();\n        let mut result = Value::Null;\n\n        for item in items {\n            self.env.define(&foreach.var_name, item);\n            match self.execute_stmt(&foreach.body) {\n                Ok(val) => result = val,\n                Err(e) if matches!(e.kind, ErrorKind::Break) => break,\n                Err(e) if matches!(e.kind, ErrorKind::Continue) => continue,\n                Err(e) => {\n                    self.env.pop_scope();\n                    return Err(e);\n                }\n            }\n        }\n\n        self.env.pop_scope();\n        Ok(result)\n    }\n\n    /// Execute return statement\n    fn execute_return(&mut self, expr: Option<&Expr>) -> InterpResult<Value> {\n        let value = if let Some(e) = expr {\n            self.evaluate(e)?\n        } else {\n            Value::Null\n        };\n        Err(InterpError {\n            message: \"return\".into(),\n            kind: ErrorKind::Return(value),\n        })\n    }\n\n    /// Execute try-catch\n    fn execute_try(&mut self, try_stmt: &TryStmt) -> InterpResult<Value> {\n        match self.execute_block(&try_stmt.try_block) {\n            Ok(val) => {\n                if let Some(ref finally) = try_stmt.finally_block {\n                    self.execute_block(finally)?;\n                }\n                Ok(val)\n            }\n            Err(e)\n                if matches!(\n                    e.kind,\n                    ErrorKind::Runtime | ErrorKind::TypeError | ErrorKind::NameError\n                ) =>\n            {\n                if let Some(ref catch_block) = try_stmt.catch_block {\n                    self.env.push_scope();\n                    if let Some(ref var) = try_stmt.catch_var {\n                        self.env\n                            .define(var, Value::String(Rc::new(e.message.clone())));\n                    }\n                    let result = self.execute_block(catch_block);\n                    self.env.pop_scope();\n\n                    if let Some(ref finally) = try_stmt.finally_block {\n                        self.execute_block(finally)?;\n                    }\n                    result\n                } else {\n                    if let Some(ref finally) = try_stmt.finally_block {\n                        self.execute_block(finally)?;\n                    }\n                    Err(e)\n                }\n            }\n            Err(e) => {\n                if let Some(ref finally) = try_stmt.finally_block {\n                    self.execute_block(finally)?;\n                }\n                Err(e)\n            }\n        }\n    }\n\n    /// Execute switch statement\n    fn execute_switch(&mut self, switch: &SwitchStmt) -> InterpResult<Value> {\n        let switch_val = self.evaluate(&switch.expr)?;\n        let mut result = Value::Null;\n        let mut matched = false;\n        let mut default_index = None;\n\n        // Find matching case\n        for (i, case) in switch.cases.iter().enumerate() {\n            if case.value.is_none() {\n                default_index = Some(i);\n                continue;\n            }\n            if let Some(ref case_expr) = case.value {\n                let case_val = self.evaluate(case_expr)?;\n                if switch_val.equals(&case_val) {\n                    matched = true;\n                    // Execute this and all following cases (fall-through)\n                    for case in &switch.cases[i..] {\n                        for stmt in &case.stmts {\n                            match self.execute_stmt(stmt) {\n                                Ok(val) => result = val,\n                                Err(e) if matches!(e.kind, ErrorKind::Break) => return Ok(result),\n                                Err(e) => return Err(e),\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n\n        // Execute default if no match\n        if !matched {\n            if let Some(idx) = default_index {\n                for case in &switch.cases[idx..] {\n                    for stmt in &case.stmts {\n                        match self.execute_stmt(stmt) {\n                            Ok(val) => result = val,\n                            Err(e) if matches!(e.kind, ErrorKind::Break) => return Ok(result),\n                            Err(e) => return Err(e),\n                        }\n                    }\n                }\n            }\n        }\n\n        Ok(result)\n    }\n\n    /// Evaluate an expression\n    pub fn evaluate(&mut self, expr: &Expr) -> InterpResult<Value> {\n        const MAX_OPERATIONS: usize = 1_000_000;\n        self.operation_count += 1;\n        if self.operation_count > MAX_OPERATIONS {\n            return Ok(Value::Null); // Graceful degradation\n        }\n        match expr {\n            Expr::Int(n) => Ok(Value::Int(*n)),\n            Expr::Float(f) => Ok(Value::Float(*f)),\n            Expr::String(s) => Ok(Value::String(Rc::new(s.clone()))),\n            Expr::Symbol(s) => Ok(Value::Symbol(Rc::new(s.clone()))),\n            Expr::Null => Ok(Value::Null),\n            Expr::SelfRef => self.get_self(),\n            Expr::SuperRef => self.get_self(), // Simplified for now\n            Expr::Ident(name) => self.get_variable(name),\n            Expr::QualifiedName(qn) => self.get_qualified_name(qn),\n            Expr::Array(elements) => self.eval_array(elements),\n            Expr::List(elements) => self.eval_array(elements), // Treat same as array\n            Expr::Binary(bin) => self.eval_binary(bin),\n            Expr::Unary(unary) => self.eval_unary(unary),\n            Expr::Conditional(cond) => self.eval_conditional(cond),\n            Expr::Assign(assign) => self.eval_assign(assign),\n            Expr::Call(call) => self.eval_call(call),\n            Expr::Index(idx) => self.eval_index(idx),\n            Expr::Range(range) => self.eval_range(range),\n            Expr::Member(member) => self.eval_member(member),\n            Expr::Instanceof(inst) => self.eval_instanceof(inst),\n            Expr::Paren(inner) => self.evaluate(inner),\n        }\n    }\n\n    fn get_self(&self) -> InterpResult<Value> {\n        self.current_self\n            .clone()\n            .map(Value::Object)\n            .ok_or_else(|| InterpError::runtime(\"'self' used outside of method\"))\n    }\n\n    fn get_variable(&self, name: &str) -> InterpResult<Value> {\n        // First try environment (local vars, globals)\n        if let Some(val) = self.env.get(name) {\n            return Ok(val);\n        }\n\n        // Then try current object's fields (OFML allows accessing fields without self.)\n        if let Some(ref instance) = self.current_self {\n            if let Some(val) = instance.borrow().fields.get(name) {\n                return Ok(val.clone());\n            }\n        }\n\n        Err(InterpError::name_error(format!(\n            \"Undefined variable: {}\",\n            name\n        )))\n    }\n\n    fn get_qualified_name(&self, qn: &QualifiedName) -> InterpResult<Value> {\n        // Try to find the class or value\n        let name = qn.parts.last().unwrap();\n        self.env\n            .get(name)\n            .or_else(|| self.classes.get(name).map(|c| Value::Class(c.clone())))\n            .ok_or_else(|| InterpError::name_error(format!(\"Undefined: {}\", qn)))\n    }\n\n    fn eval_array(&mut self, elements: &[Expr]) -> InterpResult<Value> {\n        let values: Result<Vec<_>, _> = elements.iter().map(|e| self.evaluate(e)).collect();\n        Ok(Value::Array(Rc::new(RefCell::new(values?))))\n    }\n\n    fn eval_binary(&mut self, bin: &BinaryExpr) -> InterpResult<Value> {\n        let left = self.evaluate(&bin.left)?;\n        let right = self.evaluate(&bin.right)?;\n\n        match bin.op {\n            BinaryOp::Add => self.binary_add(&left, &right),\n            BinaryOp::Sub => self.binary_sub(&left, &right),\n            BinaryOp::Mul => self.binary_mul(&left, &right),\n            BinaryOp::Div => self.binary_div(&left, &right),\n            BinaryOp::Mod => self.binary_mod(&left, &right),\n            BinaryOp::Eq => Ok(Value::Bool(left.equals(&right))),\n            BinaryOp::Ne => Ok(Value::Bool(!left.equals(&right))),\n            BinaryOp::Lt => self.binary_cmp(&left, &right, |a, b| a < b),\n            BinaryOp::Le => self.binary_cmp(&left, &right, |a, b| a <= b),\n            BinaryOp::Gt => self.binary_cmp(&left, &right, |a, b| a > b),\n            BinaryOp::Ge => self.binary_cmp(&left, &right, |a, b| a >= b),\n            BinaryOp::And => Ok(Value::Bool(left.is_truthy() && right.is_truthy())),\n            BinaryOp::Or => Ok(Value::Bool(left.is_truthy() || right.is_truthy())),\n            BinaryOp::BitAnd => self.binary_bitop(&left, &right, |a, b| a & b),\n            BinaryOp::BitOr => self.binary_bitop(&left, &right, |a, b| a | b),\n            BinaryOp::BitXor => self.binary_bitop(&left, &right, |a, b| a ^ b),\n            BinaryOp::Shl => self.binary_bitop(&left, &right, |a, b| a << b),\n            BinaryOp::Shr => self.binary_bitop(&left, &right, |a, b| a >> b),\n            BinaryOp::Ushr => self.binary_bitop(&left, &right, |a, b| ((a as u64) >> b) as i64),\n            BinaryOp::Min => self.binary_minmax(&left, &right, true),\n            BinaryOp::Max => self.binary_minmax(&left, &right, false),\n            BinaryOp::PatternMatch => Ok(Value::Bool(false)), // Simplified\n        }\n    }\n\n    fn binary_add(&self, left: &Value, right: &Value) -> InterpResult<Value> {\n        match (left, right) {\n            (Value::Int(a), Value::Int(b)) => Ok(Value::Int(a + b)),\n            (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a + b)),\n            (Value::Int(a), Value::Float(b)) => Ok(Value::Float(*a as f64 + b)),\n            (Value::Float(a), Value::Int(b)) => Ok(Value::Float(a + *b as f64)),\n            // Null treated as 0 in addition\n            (Value::Null, Value::Int(b)) => Ok(Value::Int(*b)),\n            (Value::Null, Value::Float(b)) => Ok(Value::Float(*b)),\n            (Value::Int(a), Value::Null) => Ok(Value::Int(*a)),\n            (Value::Float(a), Value::Null) => Ok(Value::Float(*a)),\n            (Value::Null, Value::Null) => Ok(Value::Int(0)),\n            (Value::String(a), Value::String(b)) => {\n                Ok(Value::String(Rc::new(format!(\"{}{}\", a, b))))\n            }\n            (Value::String(a), b) => Ok(Value::String(Rc::new(format!(\n                \"{}{}\",\n                a,\n                b.to_string_val()\n            )))),\n            (a, Value::String(b)) => Ok(Value::String(Rc::new(format!(\n                \"{}{}\",\n                a.to_string_val(),\n                b\n            )))),\n            _ => Err(InterpError::type_error(format!(\n                \"Cannot add {} and {}\",\n                left.type_name(),\n                right.type_name()\n            ))),\n        }\n    }\n\n    fn binary_sub(&self, left: &Value, right: &Value) -> InterpResult<Value> {\n        match (left, right) {\n            (Value::Int(a), Value::Int(b)) => Ok(Value::Int(a - b)),\n            (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a - b)),\n            (Value::Int(a), Value::Float(b)) => Ok(Value::Float(*a as f64 - b)),\n            (Value::Float(a), Value::Int(b)) => Ok(Value::Float(a - *b as f64)),\n            // Null treated as 0 in subtraction\n            (Value::Null, Value::Int(b)) => Ok(Value::Int(-b)),\n            (Value::Null, Value::Float(b)) => Ok(Value::Float(-b)),\n            (Value::Int(a), Value::Null) => Ok(Value::Int(*a)),\n            (Value::Float(a), Value::Null) => Ok(Value::Float(*a)),\n            (Value::Null, Value::Null) => Ok(Value::Int(0)),\n            _ => Err(InterpError::type_error(\"Cannot subtract these types\")),\n        }\n    }\n\n    fn binary_mul(&self, left: &Value, right: &Value) -> InterpResult<Value> {\n        match (left, right) {\n            (Value::Int(a), Value::Int(b)) => Ok(Value::Int(a * b)),\n            (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a * b)),\n            (Value::Int(a), Value::Float(b)) => Ok(Value::Float(*a as f64 * b)),\n            (Value::Float(a), Value::Int(b)) => Ok(Value::Float(a * *b as f64)),\n            // Null treated as 0 in multiplication (x * 0 = 0)\n            (Value::Null, _) | (_, Value::Null) => Ok(Value::Int(0)),\n            _ => Err(InterpError::type_error(\"Cannot multiply these types\")),\n        }\n    }\n\n    fn binary_div(&self, left: &Value, right: &Value) -> InterpResult<Value> {\n        match (left, right) {\n            (Value::Int(a), Value::Int(b)) => {\n                if *b == 0 {\n                    return Err(InterpError::runtime(\"Division by zero\"));\n                }\n                Ok(Value::Int(a / b))\n            }\n            (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a / b)),\n            (Value::Int(a), Value::Float(b)) => Ok(Value::Float(*a as f64 / b)),\n            (Value::Float(a), Value::Int(b)) => Ok(Value::Float(a / *b as f64)),\n            // Null division - treat Null as 0\n            (Value::Null, _) => Ok(Value::Float(0.0)),\n            (Value::Int(a), Value::Null) => Ok(Value::Float(*a as f64)), // x / 0 treated as x\n            (Value::Float(a), Value::Null) => Ok(Value::Float(*a)),\n            _ => Err(InterpError::type_error(\"Cannot divide these types\")),\n        }\n    }\n\n    fn binary_mod(&self, left: &Value, right: &Value) -> InterpResult<Value> {\n        match (left, right) {\n            (Value::Int(a), Value::Int(b)) => {\n                if *b == 0 {\n                    return Err(InterpError::runtime(\"Modulo by zero\"));\n                }\n                Ok(Value::Int(a % b))\n            }\n            (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a % b)),\n            _ => Err(InterpError::type_error(\"Cannot modulo these types\")),\n        }\n    }\n\n    fn binary_cmp<F>(&self, left: &Value, right: &Value, cmp: F) -> InterpResult<Value>\n    where\n        F: Fn(f64, f64) -> bool,\n    {\n        // Null comparisons: Null compared to anything is false\n        if matches!(left, Value::Null) || matches!(right, Value::Null) {\n            return Ok(Value::Bool(false));\n        }\n        let a = left\n            .to_float()\n            .ok_or_else(|| InterpError::type_error(\"Cannot compare\"))?;\n        let b = right\n            .to_float()\n            .ok_or_else(|| InterpError::type_error(\"Cannot compare\"))?;\n        Ok(Value::Bool(cmp(a, b)))\n    }\n\n    fn binary_bitop<F>(&self, left: &Value, right: &Value, op: F) -> InterpResult<Value>\n    where\n        F: Fn(i64, i64) -> i64,\n    {\n        let a = left\n            .to_int()\n            .ok_or_else(|| InterpError::type_error(\"Bitwise requires integers\"))?;\n        let b = right\n            .to_int()\n            .ok_or_else(|| InterpError::type_error(\"Bitwise requires integers\"))?;\n        Ok(Value::Int(op(a, b)))\n    }\n\n    fn binary_minmax(&self, left: &Value, right: &Value, is_min: bool) -> InterpResult<Value> {\n        // Handle Null in min/max - Null is treated as the identity element\n        let a = match left {\n            Value::Null => return Ok(right.clone()), // min/max with Null returns the other value\n            v => v\n                .to_float()\n                .ok_or_else(|| InterpError::type_error(\"Cannot compare\"))?,\n        };\n        let b = match right {\n            Value::Null => return Ok(left.clone()),\n            v => v\n                .to_float()\n                .ok_or_else(|| InterpError::type_error(\"Cannot compare\"))?,\n        };\n        let result = if is_min { a.min(b) } else { a.max(b) };\n        // Preserve integer type if both are integers\n        if matches!(left, Value::Int(_)) && matches!(right, Value::Int(_)) {\n            Ok(Value::Int(result as i64))\n        } else {\n            Ok(Value::Float(result))\n        }\n    }\n\n    fn eval_unary(&mut self, unary: &UnaryExpr) -> InterpResult<Value> {\n        let val = self.evaluate(&unary.operand)?;\n        match unary.op {\n            UnaryOp::Neg => match val {\n                Value::Int(n) => Ok(Value::Int(-n)),\n                Value::Float(f) => Ok(Value::Float(-f)),\n                Value::Null => Ok(Value::Int(0)), // Negating Null returns 0\n                _ => Err(InterpError::type_error(\"Cannot negate\")),\n            },\n            UnaryOp::Pos => Ok(val),\n            UnaryOp::Not => Ok(Value::Bool(!val.is_truthy())),\n            UnaryOp::BitNot => {\n                let n = val\n                    .to_int()\n                    .ok_or_else(|| InterpError::type_error(\"Bitwise requires integer\"))?;\n                Ok(Value::Int(!n))\n            }\n            UnaryOp::Test => Ok(Value::Bool(val.is_truthy())),\n            UnaryOp::Resolve => {\n                // $ operator resolves symbol to variable\n                match val {\n                    Value::Symbol(s) => self.get_variable(&s),\n                    _ => Err(InterpError::type_error(\"$ requires symbol\")),\n                }\n            }\n            UnaryOp::PreInc | UnaryOp::PostInc => {\n                // Simplified - doesn't handle the pre/post difference correctly\n                let n = val\n                    .to_int()\n                    .ok_or_else(|| InterpError::type_error(\"Cannot increment\"))?;\n                Ok(Value::Int(n + 1))\n            }\n            UnaryOp::PreDec | UnaryOp::PostDec => {\n                let n = val\n                    .to_int()\n                    .ok_or_else(|| InterpError::type_error(\"Cannot decrement\"))?;\n                Ok(Value::Int(n - 1))\n            }\n        }\n    }\n\n    fn eval_conditional(&mut self, cond: &ConditionalExpr) -> InterpResult<Value> {\n        let test = self.evaluate(&cond.condition)?;\n        if test.is_truthy() {\n            self.evaluate(&cond.then_expr)\n        } else {\n            self.evaluate(&cond.else_expr)\n        }\n    }\n\n    fn eval_assign(&mut self, assign: &AssignExpr) -> InterpResult<Value> {\n        let value = self.evaluate(&assign.value)?;\n\n        // Handle compound assignment\n        let final_value = match assign.op {\n            AssignOp::Assign => value,\n            _ => {\n                let current = self.evaluate(&assign.target)?;\n                match assign.op {\n                    AssignOp::AddAssign => self.binary_add(&current, &value)?,\n                    AssignOp::SubAssign => self.binary_sub(&current, &value)?,\n                    AssignOp::MulAssign => self.binary_mul(&current, &value)?,\n                    AssignOp::DivAssign => self.binary_div(&current, &value)?,\n                    AssignOp::ModAssign => self.binary_mod(&current, &value)?,\n                    _ => value,\n                }\n            }\n        };\n\n        // Assign to target\n        match &*assign.target {\n            Expr::Ident(name) => {\n                self.env.set_or_define(name, final_value.clone());\n            }\n            Expr::Member(member) => {\n                let obj = self.evaluate(&member.object)?;\n                self.set_member(&obj, &member.member, final_value.clone())?;\n            }\n            Expr::Index(idx) => {\n                let obj = self.evaluate(&idx.object)?;\n                let index = self.evaluate(&idx.index)?;\n                self.set_index(&obj, &index, final_value.clone())?;\n            }\n            _ => return Err(InterpError::runtime(\"Invalid assignment target\")),\n        }\n\n        Ok(final_value)\n    }\n\n    fn eval_call(&mut self, call: &CallExpr) -> InterpResult<Value> {\n        // Evaluate arguments\n        let args: Result<Vec<_>, _> = call.args.iter().map(|a| self.evaluate(a)).collect();\n        let args = args?;\n\n        // Handle method calls (obj.method())\n        if let Expr::Member(member) = &*call.callee {\n            let obj = self.evaluate(&member.object)?;\n            return self.call_method(&obj, &member.member, args);\n        }\n\n        // Handle qualified name calls (Class::method())\n        if let Expr::QualifiedName(qn) = &*call.callee {\n            if qn.parts.len() >= 2 {\n                let short_class_name = &qn.parts[qn.parts.len() - 2];\n                let method_name = qn.parts.last().unwrap();\n\n                // Build fully qualified class name (everything except the method)\n                let class_parts: Vec<&str> = qn.parts[..qn.parts.len() - 1]\n                    .iter()\n                    .map(|s| s.as_str())\n                    .collect();\n                let fq_class_name = if qn.absolute {\n                    format!(\"::{}\", class_parts.join(\"::\"))\n                } else {\n                    class_parts.join(\"::\")\n                };\n\n                // Try fully qualified lookup first, then fall back to short name\n                let class = self\n                    .qualified_classes\n                    .get(&fq_class_name)\n                    .cloned()\n                    .or_else(|| self.classes.get(short_class_name).cloned());\n\n                if let Some(class) = class {\n                    if let Some(method) = class.methods.get(method_name) {\n                        return self.call_function(method.clone(), args);\n                    }\n                    // Check parent classes for the method using lazy resolution\n                    let mut current = Some(class.clone());\n                    while let Some(c) = current {\n                        if let Some(method) = c.methods.get(method_name) {\n                            return self.call_function(method.clone(), args);\n                        }\n                        // Lazy parent resolution\n                        current = if c.parent.is_some() {\n                            c.parent.clone()\n                        } else if let Some(ref parent_name) = c.decl.parent {\n                            let parent_short =\n                                parent_name.parts.last().unwrap_or(&parent_name.parts[0]);\n                            self.classes.get(parent_short).cloned()\n                        } else {\n                            None\n                        };\n                    }\n                    // If method not found but class exists, return Null gracefully\n                    // This handles Parent::initialize() when parent has no initialize\n                    return Ok(Value::Null);\n                } else {\n                    // Class not found - for Parent::initialize() style calls, return Null\n                    // This handles cases where parent class isn't loaded (missing dependencies)\n                    if method_name == \"initialize\" || method_name.starts_with(\"init\") {\n                        return Ok(Value::Null);\n                    }\n                }\n            }\n        }\n\n        // Check if this is a simple identifier call and we're inside a method\n        // If so, try to call it as a method on self first\n        if let Expr::Ident(name) = &*call.callee {\n            if let Some(ref instance) = self.current_self {\n                // First check if it's a method in the class hierarchy\n                let class = instance.borrow().class.clone();\n                if let Some(method) = class.methods.get(name) {\n                    return self.call_function(method.clone(), args);\n                }\n                // Also check parent classes using lazy resolution\n                let mut current = Some(class.clone());\n                while let Some(c) = current {\n                    if let Some(method) = c.methods.get(name) {\n                        return self.call_function(method.clone(), args);\n                    }\n                    // Lazy parent resolution\n                    current = if c.parent.is_some() {\n                        c.parent.clone()\n                    } else if let Some(ref parent_name) = c.decl.parent {\n                        let parent_short =\n                            parent_name.parts.last().unwrap_or(&parent_name.parts[0]);\n                        self.classes.get(parent_short).cloned()\n                    } else {\n                        None\n                    };\n                }\n                // Then try as a built-in method on self (setPosition, rotate, etc.)\n                let obj = Value::Object(instance.clone());\n                if self.is_builtin_method(name) {\n                    return self.call_method(&obj, name, args);\n                }\n            }\n        }\n\n        // Regular function call\n        let callee = self.evaluate(&call.callee)?;\n        match callee {\n            Value::Func(func) => self.call_function(func, args),\n            Value::NativeFunc(func) => func(self, args).map_err(InterpError::from),\n            Value::Class(class) => self.instantiate_class(class, args),\n            // Graceful degradation: calling Null returns Null\n            Value::Null => Ok(Value::Null),\n            _ => Err(InterpError::type_error(format!(\n                \"Cannot call {}\",\n                callee.type_name()\n            ))),\n        }\n    }\n\n    fn call_function(&mut self, func: Rc<FuncValue>, args: Vec<Value>) -> InterpResult<Value> {\n        const MAX_CALL_DEPTH: usize = 500;\n        const MAX_OPERATIONS: usize = 1_000_000;\n\n        self.call_depth += 1;\n        self.operation_count += 1;\n\n        // Check call depth\n        if self.call_depth > MAX_CALL_DEPTH {\n            self.call_depth -= 1;\n            return Err(InterpError::runtime(format!(\n                \"Maximum call depth ({}) exceeded - possible infinite recursion in function '{}'\",\n                MAX_CALL_DEPTH, func.name\n            )));\n        }\n\n        // Check total operations - gracefully break on limit\n        if self.operation_count > MAX_OPERATIONS {\n            self.call_depth -= 1;\n            // Return Null instead of error for graceful degradation\n            return Ok(Value::Null);\n        }\n\n        let body = func.body.as_ref().ok_or_else(|| {\n            self.call_depth -= 1;\n            InterpError::runtime(\"Cannot call native function\")\n        })?;\n\n        self.env.push_scope();\n\n        // Bind parameters\n        for (i, param) in func.params.iter().enumerate() {\n            let value = args.get(i).cloned().unwrap_or(Value::Null);\n            self.env.define(param, value);\n        }\n\n        // Execute body\n        let result = match self.execute_block(body) {\n            Ok(val) => val,\n            Err(e) if matches!(e.kind, ErrorKind::Return(ref _v)) => {\n                if let ErrorKind::Return(v) = e.kind {\n                    v\n                } else {\n                    Value::Null\n                }\n            }\n            Err(e) => {\n                self.env.pop_scope();\n                self.call_depth -= 1;\n                return Err(e);\n            }\n        };\n\n        self.env.pop_scope();\n        self.call_depth -= 1;\n        Ok(result)\n    }\n\n    pub fn call_method(\n        &mut self,\n        obj: &Value,\n        method: &str,\n        args: Vec<Value>,\n    ) -> InterpResult<Value> {\n        // Handle built-in methods\n        match obj {\n            Value::Array(arr) => return self.call_array_method(arr.clone(), method, args),\n            Value::Hash(hash) => return self.call_hash_method(hash.clone(), method, args),\n            Value::Object(instance) => {\n                // Handle object methods\n                let instance = instance.clone();\n\n                // Check for built-in geometry methods\n                match method {\n                    \"setPosition\" => {\n                        if let Some(pos) = args.first() {\n                            instance\n                                .borrow_mut()\n                                .set_position(pos)\n                                .map_err(InterpError::from)?;\n                            // Also update scene node if exists\n                            let obj_id = instance.as_ptr() as u64;\n                            if let Some(node) = self.obj_to_node.get(&obj_id) {\n                                let pos_arr = match pos {\n                                    Value::Array(arr) => {\n                                        let arr = arr.borrow();\n                                        [\n                                            arr.first().and_then(|v| v.to_float()).unwrap_or(0.0)\n                                                as f32,\n                                            arr.get(1).and_then(|v| v.to_float()).unwrap_or(0.0)\n                                                as f32,\n                                            arr.get(2).and_then(|v| v.to_float()).unwrap_or(0.0)\n                                                as f32,\n                                        ]\n                                    }\n                                    _ => [0.0, 0.0, 0.0],\n                                };\n                                node.borrow_mut().set_position(pos_arr);\n                            }\n                        }\n                        return Ok(Value::Null);\n                    }\n                    \"getPosition\" => {\n                        return Ok(instance.borrow().get_position());\n                    }\n                    \"setAlignment\" => {\n                        // setAlignment([@X, @Y, @Z]) - set alignment based on OFML modes\n                        // @I = min bound (default), @C = center, @A = max bound\n                        if let Some(Value::Array(arr)) = args.first() {\n                            let arr = arr.borrow();\n                            let parse_align = |v: Option<&Value>| -> AlignMode {\n                                match v {\n                                    Some(Value::Symbol(s)) => match s.as_str() {\n                                        \"I\" => AlignMode::Min,\n                                        \"C\" => AlignMode::Center,\n                                        \"A\" => AlignMode::Max,\n                                        _ => AlignMode::Min,\n                                    },\n                                    _ => AlignMode::Min,\n                                }\n                            };\n                            let align_x = parse_align(arr.first());\n                            let align_y = parse_align(arr.get(1));\n                            let align_z = parse_align(arr.get(2));\n\n                            // Update scene node\n                            let obj_id = instance.as_ptr() as u64;\n                            if let Some(node) = self.obj_to_node.get(&obj_id) {\n                                node.borrow_mut().set_alignment(align_x, align_y, align_z);\n                            }\n                        }\n                        return Ok(Value::Null);\n                    }\n                    \"setFootAlignment\" => {\n                        // setFootAlignment() - set alignment based on ground contact point\n                        // Useful for L-shaped or irregular geometry where bounding box center\n                        // doesn't represent the actual anchor/contact point\n                        let obj_id = instance.as_ptr() as u64;\n                        if let Some(node) = self.obj_to_node.get(&obj_id) {\n                            node.borrow_mut().set_foot_alignment();\n                        }\n                        return Ok(Value::Null);\n                    }\n                    \"rotate\" => {\n                        // rotate(@axis, angle) - rotate around axis\n                        if let (Some(Value::Symbol(axis)), Some(angle)) =\n                            (args.first(), args.get(1))\n                        {\n                            let angle_f = angle.to_float().unwrap_or(0.0);\n                            let axis_enum = match axis.as_str() {\n                                \"NX\" => Axis::X,\n                                \"NY\" => Axis::Y,\n                                \"NZ\" => Axis::Z,\n                                _ => Axis::Y,\n                            };\n                            // Update ObjInstance rotation\n                            let mut inst = instance.borrow_mut();\n                            match axis_enum {\n                                Axis::X => inst.rotation[0] += angle_f,\n                                Axis::Y => inst.rotation[1] += angle_f,\n                                Axis::Z => inst.rotation[2] += angle_f,\n                            }\n                            drop(inst);\n                            // Update scene node\n                            let obj_id = instance.as_ptr() as u64;\n                            if let Some(node) = self.obj_to_node.get(&obj_id) {\n                                node.borrow_mut().rotate(axis_enum, angle_f as f32);\n                            }\n                        }\n                        return Ok(Value::Null);\n                    }\n                    \"getRotation\" => {\n                        // getRotation(@axis) - get rotation around axis\n                        if let Some(Value::Symbol(axis)) = args.first() {\n                            let inst = instance.borrow();\n                            let angle = match axis.as_str() {\n                                \"NX\" => inst.rotation[0],\n                                \"NY\" => inst.rotation[1],\n                                \"NZ\" => inst.rotation[2],\n                                _ => 0.0,\n                            };\n                            return Ok(Value::Float(angle));\n                        }\n                        return Ok(Value::Float(0.0));\n                    }\n                    \"getLocalBounds\" => {\n                        // Returns [[minX, minY, minZ], [maxX, maxY, maxZ]]\n                        let obj_id = instance.as_ptr() as u64;\n                        if let Some(node) = self.obj_to_node.get(&obj_id) {\n                            let bounds = node.borrow().get_local_bounds();\n                            let min = Value::Array(Rc::new(RefCell::new(vec![\n                                Value::Float(bounds[0][0] as f64),\n                                Value::Float(bounds[0][1] as f64),\n                                Value::Float(bounds[0][2] as f64),\n                            ])));\n                            let max = Value::Array(Rc::new(RefCell::new(vec![\n                                Value::Float(bounds[1][0] as f64),\n                                Value::Float(bounds[1][1] as f64),\n                                Value::Float(bounds[1][2] as f64),\n                            ])));\n                            return Ok(Value::Array(Rc::new(RefCell::new(vec![min, max]))));\n                        }\n                        // Default empty bounds\n                        let zero = Value::Array(Rc::new(RefCell::new(vec![\n                            Value::Float(0.0),\n                            Value::Float(0.0),\n                            Value::Float(0.0),\n                        ])));\n                        return Ok(Value::Array(Rc::new(RefCell::new(vec![\n                            zero.clone(),\n                            zero,\n                        ]))));\n                    }\n                    \"setMaterial\" => {\n                        // setMaterial(materialName) - set material on scene node\n                        if let Some(mat) = args.first() {\n                            let mat_name = mat.to_string_val();\n                            instance.borrow_mut().properties.insert(\n                                \"material\".to_string(),\n                                Value::String(Rc::new(mat_name.clone())),\n                            );\n                            let obj_id = instance.as_ptr() as u64;\n                            if let Some(node) = self.obj_to_node.get(&obj_id) {\n                                node.borrow_mut().material = mat_name;\n                            }\n                        }\n                        return Ok(Value::Null);\n                    }\n                    \"notSelectable\" => {\n                        let obj_id = instance.as_ptr() as u64;\n                        if let Some(node) = self.obj_to_node.get(&obj_id) {\n                            node.borrow_mut().selectable = false;\n                        }\n                        return Ok(Value::Null);\n                    }\n                    \"setCutable\" => {\n                        // Store as property\n                        if let Some(val) = args.first() {\n                            instance\n                                .borrow_mut()\n                                .properties\n                                .insert(\"cutable\".to_string(), val.clone());\n                        }\n                        return Ok(Value::Null);\n                    }\n                    \"setRtAxis\" | \"setTrAxis\" => {\n                        // Store axis properties\n                        if let Some(val) = args.first() {\n                            instance\n                                .borrow_mut()\n                                .properties\n                                .insert(method.to_string(), val.clone());\n                        }\n                        return Ok(Value::Null);\n                    }\n                    \"set2DName\" => {\n                        if let Some(val) = args.first() {\n                            instance\n                                .borrow_mut()\n                                .properties\n                                .insert(\"2DName\".to_string(), val.clone());\n                        }\n                        return Ok(Value::Null);\n                    }\n                    \"getName\" => {\n                        return Ok(Value::String(Rc::new(instance.borrow().name.clone())));\n                    }\n                    \"getElements\" => {\n                        // Return child objects\n                        let children: Vec<Value> = instance\n                            .borrow()\n                            .children\n                            .iter()\n                            .map(|c| Value::Object(c.clone()))\n                            .collect();\n                        return Ok(Value::Array(Rc::new(RefCell::new(children))));\n                    }\n                    \"getPropValue\" => {\n                        if let Some(Value::Symbol(prop)) = args.first() {\n                            return Ok(instance.borrow().get_prop_value(prop));\n                        }\n                        return Ok(Value::Null);\n                    }\n                    \"setPropValue\" => {\n                        if let (Some(Value::Symbol(prop)), Some(val)) = (args.first(), args.get(1))\n                        {\n                            instance.borrow_mut().set_prop_value(prop, val.clone());\n                        }\n                        return Ok(Value::Null);\n                    }\n                    \"hasProperty\" => {\n                        if let Some(Value::Symbol(prop)) = args.first() {\n                            return Ok(Value::Bool(\n                                instance.borrow().properties.contains_key(prop.as_str()),\n                            ));\n                        }\n                        return Ok(Value::Bool(false));\n                    }\n                    \"hasMember\" => {\n                        // Check if object has a method or field\n                        if let Some(Value::Symbol(name)) = args.first() {\n                            let inst = instance.borrow();\n                            let has_field = inst.fields.contains_key(name.as_str());\n                            let has_method = inst.class.methods.contains_key(name.as_str());\n                            return Ok(Value::Bool(has_field || has_method));\n                        }\n                        return Ok(Value::Bool(false));\n                    }\n                    \"isA\" => {\n                        if let Some(arg) = args.first() {\n                            let class_name = match arg {\n                                Value::String(s) => s.to_string(),\n                                Value::Symbol(s) => s.to_string(),\n                                Value::Class(c) => c.name.clone(),\n                                _ => return Ok(Value::Bool(false)),\n                            };\n                            return Ok(Value::Bool(instance.borrow().is_a(&class_name)));\n                        }\n                        return Ok(Value::Bool(false));\n                    }\n                    \"getFather\" => {\n                        let parent = instance.borrow().parent.clone();\n                        return Ok(parent.map(Value::Object).unwrap_or(Value::Null));\n                    }\n                    \"getChildren\" => {\n                        let children: Vec<Value> = instance\n                            .borrow()\n                            .children\n                            .iter()\n                            .map(|c| Value::Object(c.clone()))\n                            .collect();\n                        return Ok(Value::Array(Rc::new(RefCell::new(children))));\n                    }\n                    \"getClass\" => {\n                        // Return the class name of this object\n                        return Ok(Value::String(Rc::new(instance.borrow().class.name.clone())));\n                    }\n                    \"getProductDB\" => {\n                        // PDManager.getProductDB(@product_name) - returns a ProductDB object\n                        // This is used to access product database for property lookups\n                        if instance.borrow().class.name == \"PDManager\" {\n                            let pdb_class = self\n                                .classes\n                                .get(\"ProductDB\")\n                                .cloned()\n                                .unwrap_or_else(|| self.create_native_class(\"ProductDB\", None));\n\n                            let product_name =\n                                args.first().map(|v| v.to_string_val()).unwrap_or_default();\n\n                            let pdb_instance = Rc::new(RefCell::new(ObjInstance {\n                                class: pdb_class,\n                                name: format!(\"ProductDB:{}\", product_name),\n                                ..Default::default()\n                            }));\n                            // Store the product name as a field\n                            pdb_instance.borrow_mut().fields.insert(\n                                \"product\".to_string(),\n                                Value::String(Rc::new(product_name)),\n                            );\n                            // Store the ALB path if available\n                            if let Some(alb_path) = &self.current_alb_path {\n                                pdb_instance.borrow_mut().fields.insert(\n                                    \"dataRootDir\".to_string(),\n                                    Value::String(Rc::new(alb_path.display().to_string())),\n                                );\n                            }\n\n                            return Ok(Value::Object(pdb_instance));\n                        }\n                        return Ok(Value::Null);\n                    }\n                    \"getDataRootDir\" => {\n                        // ProductDB.getDataRootDir() - returns the data root directory path\n                        if instance.borrow().class.name == \"ProductDB\" {\n                            let dir = instance\n                                .borrow()\n                                .fields\n                                .get(\"dataRootDir\")\n                                .cloned()\n                                .unwrap_or_else(|| Value::String(Rc::new(String::new())));\n                            return Ok(dir);\n                        }\n                        return Ok(Value::String(Rc::new(String::new())));\n                    }\n                    \"setState\" => {\n                        // Set object state flags\n                        if let Some(val) = args.first().and_then(|v| v.to_int()) {\n                            instance\n                                .borrow_mut()\n                                .properties\n                                .insert(\"_state\".to_string(), Value::Int(val));\n                        }\n                        return Ok(Value::Null);\n                    }\n                    \"getState\" => {\n                        // Get object state flags\n                        let state = instance\n                            .borrow()\n                            .properties\n                            .get(\"_state\")\n                            .and_then(|v| v.to_int())\n                            .unwrap_or(0);\n                        return Ok(Value::Int(state));\n                    }\n                    \"setDimensions\" => {\n                        // Set block dimensions - update scene node\n                        if let Some(Value::Array(dims)) = args.first() {\n                            let dims = dims.borrow();\n                            let w = dims.first().and_then(|v| v.to_float()).unwrap_or(1.0) as f32;\n                            let h = dims.get(1).and_then(|v| v.to_float()).unwrap_or(1.0) as f32;\n                            let d = dims.get(2).and_then(|v| v.to_float()).unwrap_or(1.0) as f32;\n                            let obj_id = instance.as_ptr() as u64;\n                            if let Some(node) = self.obj_to_node.get(&obj_id) {\n                                node.borrow_mut().geometry = crate::scene::Geometry::Block {\n                                    width: w,\n                                    height: h,\n                                    depth: d,\n                                };\n                            }\n                        }\n                        return Ok(Value::Null);\n                    }\n                    \"getDimensions\" => {\n                        // Get block dimensions from scene node\n                        let obj_id = instance.as_ptr() as u64;\n                        if let Some(node) = self.obj_to_node.get(&obj_id) {\n                            if let crate::scene::Geometry::Block {\n                                width,\n                                height,\n                                depth,\n                            } = node.borrow().geometry\n                            {\n                                return Ok(Value::Array(Rc::new(RefCell::new(vec![\n                                    Value::Float(width as f64),\n                                    Value::Float(height as f64),\n                                    Value::Float(depth as f64),\n                                ]))));\n                            }\n                        }\n                        return Ok(Value::Array(Rc::new(RefCell::new(vec![\n                            Value::Float(0.0),\n                            Value::Float(0.0),\n                            Value::Float(0.0),\n                        ]))));\n                    }\n                    \"isCat\" => {\n                        // Category check - stub, always returns false for now\n                        return Ok(Value::Bool(false));\n                    }\n                    \"article2Class\" => {\n                        // article2Class(pArticle) - returns the class name that models an article\n                        // Per OFML spec: \"If a global product data manager instance is registered,\n                        // the query to this instance is delegated\"\n                        // For now, return NULL as the reference implementation does\n                        // A real implementation would look up the article in the product database\n                        return Ok(Value::Null);\n                    }\n                    \"setupProperty\" => {\n                        // setupProperty(@propName, [label, min, max, group, choices], sortOrder)\n                        if let (\n                            Some(Value::Symbol(prop_name)),\n                            Some(Value::Array(config)),\n                            sort_order,\n                        ) = (args.first(), args.get(1), args.get(2))\n                        {\n                            let config = config.borrow();\n                            let mut prop_def = PropertyDef {\n                                name: prop_name.to_string(),\n                                ..Default::default()\n                            };\n\n                            // Parse config array: [label, min, max, group, choices]\n                            if let Some(label) = config.first() {\n                                prop_def.description = label.to_string_val();\n                            }\n                            // min and max are often NULL in OFML, skip for now\n                            if let Some(group) = config.get(3) {\n                                prop_def.group = group.to_int().unwrap_or(0) as i32;\n                            }\n                            // choices are stored as a string like \"ch @opt1 @opt2\"\n                            if let Some(choices) = config.get(4) {\n                                let choices_str = choices.to_string_val();\n                                if let Some(rest) = choices_str.strip_prefix(\"ch \") {\n                                    let parts: Vec<Value> = rest\n                                        .split_whitespace()\n                                        .filter_map(|s| s.strip_prefix('@'))\n                                        .map(|s| Value::Symbol(Rc::new(s.to_string())))\n                                        .collect();\n                                    prop_def.choices = parts;\n                                }\n                            }\n                            if let Some(sort) = sort_order {\n                                prop_def.sort_order = sort.to_int().unwrap_or(0) as i32;\n                            }\n                            prop_def.state = 3; // editable by default\n\n                            let mut inst = instance.borrow_mut();\n                            inst.prop_defs.insert(prop_name.to_string(), prop_def);\n                            // Initialize property value to NULL if not set\n                            if !inst.properties.contains_key(prop_name.as_str()) {\n                                inst.properties.insert(prop_name.to_string(), Value::Null);\n                            }\n                        }\n                        return Ok(Value::Null);\n                    }\n                    \"removeProperty\" => {\n                        if let Some(Value::Symbol(prop_name)) = args.first() {\n                            let mut inst = instance.borrow_mut();\n                            inst.properties.remove(prop_name.as_str());\n                            inst.prop_defs.remove(prop_name.as_str());\n                            inst.prop_states.remove(prop_name.as_str());\n                        }\n                        return Ok(Value::Null);\n                    }\n                    \"setPropState\" => {\n                        // setPropState(@propName, state) - 0=hidden, 1=readonly, 3=editable\n                        if let (Some(Value::Symbol(prop_name)), Some(state)) =\n                            (args.first(), args.get(1))\n                        {\n                            let state_val = state.to_int().unwrap_or(3) as i32;\n                            instance\n                                .borrow_mut()\n                                .prop_states\n                                .insert(prop_name.to_string(), state_val);\n                        }\n                        return Ok(Value::Null);\n                    }\n                    \"getPropState\" => {\n                        if let Some(Value::Symbol(prop_name)) = args.first() {\n                            let state = instance\n                                .borrow()\n                                .prop_states\n                                .get(prop_name.as_str())\n                                .copied()\n                                .unwrap_or(3); // default to editable\n                            return Ok(Value::Int(state as i64));\n                        }\n                        return Ok(Value::Int(3));\n                    }\n                    \"setPropState2\" => {\n                        // setPropState2(@propName, state) - same as setPropState\n                        if let (Some(Value::Symbol(prop_name)), Some(state)) =\n                            (args.first(), args.get(1))\n                        {\n                            let state_val = state.to_int().unwrap_or(3) as i32;\n                            instance\n                                .borrow_mut()\n                                .prop_states\n                                .insert(prop_name.to_string(), state_val);\n                        }\n                        return Ok(Value::Null);\n                    }\n                    \"getPropState2\" => {\n                        // getPropState2(@propName) - same as getPropState\n                        if let Some(Value::Symbol(prop_name)) = args.first() {\n                            let state = instance\n                                .borrow()\n                                .prop_states\n                                .get(prop_name.as_str())\n                                .copied()\n                                .unwrap_or(3);\n                            return Ok(Value::Int(state as i64));\n                        }\n                        return Ok(Value::Int(3));\n                    }\n                    \"getPropertyKeys\" => {\n                        let keys: Vec<Value> = instance\n                            .borrow()\n                            .properties\n                            .keys()\n                            .map(|k| Value::Symbol(Rc::new(k.clone())))\n                            .collect();\n                        return Ok(Value::Array(Rc::new(RefCell::new(keys))));\n                    }\n                    \"isCurrentPropsChanged\" => {\n                        // Check if properties have changed since last rule evaluation\n                        // For now, return false (no changes)\n                        return Ok(Value::Bool(false));\n                    }\n                    \"setProgram\" | \"checkPropChanges\" | \"invalidatePicture\" | \"setArticleSpec\"\n                    | \"getScene\" | \"getPlanning\" | \"getInfo\" | \"_beAnElement\"\n                    | \"_unBeAnElement\" | \"beAnElement\" | \"unBeAnElement\" | \"hierSelectable\"\n                    | \"notHierSelectable\" | \"setObjState\" | \"getObjState\" | \"disableCD\"\n                    | \"enableCD\" | \"getWorldRotation\" | \"getWorldPosition\" | \"getLanguage\"\n                    | \"setLanguage\" | \"hide\" | \"show\" | \"isHidden\" | \"getProgram\"\n                    | \"setGeometry\" | \"getGeometry\" => {\n                        // Stub methods that are called but don't need implementation for geometry\n                        return Ok(Value::Null);\n                    }\n                    \"geo\" => {\n                        // Return self as geometry reference\n                        return Ok(Value::Object(instance.clone()));\n                    }\n                    \"setInsertMode\" => {\n                        // xOiPlGroup insert mode: 0 (default), 1 (intermediate), 2 (inner element)\n                        let mode = args.first().and_then(|v| v.to_int()).unwrap_or(0);\n                        // Validate mode is 0, 1, or 2 (as per xOiPlGroup::setInsertMode)\n                        let valid_mode = if (0..=2).contains(&mode) { mode } else { 0 };\n                        instance\n                            .borrow_mut()\n                            .properties\n                            .insert(\"mXoiInsertMode\".to_string(), Value::Int(valid_mode));\n                        return Ok(Value::Null);\n                    }\n                    \"getInsertMode\" => {\n                        // Returns mode or 0 if NULL (per xOiPlGroup::getInsertMode)\n                        if let Some(mode) = instance.borrow().properties.get(\"mXoiInsertMode\") {\n                            if !matches!(mode, Value::Null) {\n                                return Ok(mode.clone());\n                            }\n                        }\n                        return Ok(Value::Int(0));\n                    }\n                    \"setResolution\" => {\n                        // OFML spec 4.2.5: Float 0.0-1.0, returns self for chaining\n                        let res = args.first().and_then(|v| v.to_float()).unwrap_or(0.1);\n                        let clamped = res.clamp(0.0, 1.0);\n                        instance\n                            .borrow_mut()\n                            .properties\n                            .insert(\"_resolution\".to_string(), Value::Float(clamped));\n                        return Ok(Value::Object(instance.clone())); // Return self\n                    }\n                    \"getResolution\" => {\n                        // OFML spec 4.2.5: Returns Float, initial 0.1\n                        if let Some(res) = instance.borrow().properties.get(\"_resolution\") {\n                            return Ok(res.clone());\n                        }\n                        return Ok(Value::Float(0.1));\n                    }\n                    _ => {}\n                }\n\n                // Look up method in class\n                let class = instance.borrow().class.clone();\n                if let Some(func) = class.methods.get(method) {\n                    let old_self = self.current_self.take();\n                    self.current_self = Some(instance.clone());\n                    let result = self.call_function(func.clone(), args);\n                    self.current_self = old_self;\n                    return result;\n                }\n\n                return Err(InterpError::name_error(format!(\n                    \"Unknown method: {}\",\n                    method\n                )));\n            }\n            Value::Null => {\n                // Calling any method on Null returns Null (null-safe pattern)\n                return Ok(Value::Null);\n            }\n            Value::String(s) => {\n                // Handle string methods\n                return self.call_string_method(s.clone(), method, args);\n            }\n            Value::Int(_) | Value::Float(_) | Value::Bool(_) | Value::Symbol(_) => {\n                // Calling method on primitive returns Null (graceful degradation)\n                return Ok(Value::Null);\n            }\n            _ => {}\n        }\n\n        Err(InterpError::type_error(format!(\n            \"Cannot call method on {}\",\n            obj.type_name()\n        )))\n    }\n\n    fn call_array_method(\n        &mut self,\n        arr: Rc<RefCell<Vec<Value>>>,\n        method: &str,\n        args: Vec<Value>,\n    ) -> InterpResult<Value> {\n        match method {\n            \"size\" | \"length\" => Ok(Value::Int(arr.borrow().len() as i64)),\n            \"empty\" => Ok(Value::Bool(arr.borrow().is_empty())),\n            \"pushBack\" | \"push\" => {\n                if let Some(val) = args.first() {\n                    arr.borrow_mut().push(val.clone());\n                }\n                Ok(Value::Null)\n            }\n            \"popBack\" | \"pop\" => Ok(arr.borrow_mut().pop().unwrap_or(Value::Null)),\n            \"popFront\" => {\n                let mut arr = arr.borrow_mut();\n                if arr.is_empty() {\n                    Ok(Value::Null)\n                } else {\n                    Ok(arr.remove(0))\n                }\n            }\n            \"pushFront\" => {\n                if let Some(val) = args.first() {\n                    arr.borrow_mut().insert(0, val.clone());\n                }\n                Ok(Value::Null)\n            }\n            \"clear\" => {\n                arr.borrow_mut().clear();\n                Ok(Value::Null)\n            }\n            \"find\" => {\n                // Find element in array, returns index or -1\n                if let Some(val) = args.first() {\n                    let arr = arr.borrow();\n                    for (i, v) in arr.iter().enumerate() {\n                        if v.equals(val) {\n                            return Ok(Value::Int(i as i64));\n                        }\n                    }\n                }\n                Ok(Value::Int(-1))\n            }\n            \"get\" => {\n                if let Some(idx) = args.first().and_then(|v| v.to_int()) {\n                    Ok(arr\n                        .borrow()\n                        .get(idx as usize)\n                        .cloned()\n                        .unwrap_or(Value::Null))\n                } else {\n                    Ok(Value::Null)\n                }\n            }\n            \"insert\" | \"insertAt\" => {\n                if let (Some(idx), Some(val)) = (args.first().and_then(|v| v.to_int()), args.get(1))\n                {\n                    let mut arr = arr.borrow_mut();\n                    let idx = idx as usize;\n                    if idx <= arr.len() {\n                        arr.insert(idx, val.clone());\n                    }\n                }\n                Ok(Value::Null)\n            }\n            \"removeAt\" | \"erase\" => {\n                if let Some(idx) = args.first().and_then(|v| v.to_int()) {\n                    let mut arr = arr.borrow_mut();\n                    let idx = idx as usize;\n                    if idx < arr.len() {\n                        arr.remove(idx);\n                    }\n                }\n                Ok(Value::Null)\n            }\n            _ => Err(InterpError::name_error(format!(\n                \"Unknown array method: {}\",\n                method\n            ))),\n        }\n    }\n\n    fn call_hash_method(\n        &mut self,\n        hash: Rc<RefCell<HashMap<String, Value>>>,\n        method: &str,\n        args: Vec<Value>,\n    ) -> InterpResult<Value> {\n        match method {\n            \"size\" | \"length\" => Ok(Value::Int(hash.borrow().len() as i64)),\n            \"empty\" => Ok(Value::Bool(hash.borrow().is_empty())),\n            \"hasKey\" | \"contains\" => {\n                if let Some(key) = args.first() {\n                    let key_str = key.to_string_val();\n                    Ok(Value::Bool(hash.borrow().contains_key(&key_str)))\n                } else {\n                    Ok(Value::Bool(false))\n                }\n            }\n            \"keys\" => {\n                let keys: Vec<Value> = hash\n                    .borrow()\n                    .keys()\n                    .map(|k| Value::String(Rc::new(k.clone())))\n                    .collect();\n                Ok(Value::Array(Rc::new(RefCell::new(keys))))\n            }\n            \"clear\" => {\n                hash.borrow_mut().clear();\n                Ok(Value::Null)\n            }\n            _ => Err(InterpError::name_error(format!(\n                \"Unknown hash method: {}\",\n                method\n            ))),\n        }\n    }\n\n    fn call_string_method(\n        &mut self,\n        s: Rc<String>,\n        method: &str,\n        args: Vec<Value>,\n    ) -> InterpResult<Value> {\n        match method {\n            \"size\" | \"length\" => Ok(Value::Int(s.len() as i64)),\n            \"empty\" => Ok(Value::Bool(s.is_empty())),\n            \"find\" => {\n                // find(substring, [startPos]) - returns position or -1 if not found\n                let search = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                let start_pos = args.get(1).and_then(|v| v.to_int()).unwrap_or(0) as usize;\n\n                if start_pos >= s.len() {\n                    return Ok(Value::Int(-1));\n                }\n\n                let haystack = &s[start_pos..];\n                match haystack.find(&search) {\n                    Some(pos) => Ok(Value::Int((pos + start_pos) as i64)),\n                    None => Ok(Value::Int(-1)),\n                }\n            }\n            \"substr\" => {\n                // substr(start, [length]) - extract substring\n                let start = args.first().and_then(|v| v.to_int()).unwrap_or(0) as usize;\n                let len = args.get(1).and_then(|v| v.to_int());\n\n                if start >= s.len() {\n                    return Ok(Value::String(Rc::new(String::new())));\n                }\n\n                let result = match len {\n                    Some(l) if l > 0 => {\n                        let end = (start + l as usize).min(s.len());\n                        s.chars().skip(start).take(end - start).collect()\n                    }\n                    _ => s.chars().skip(start).collect(),\n                };\n                Ok(Value::String(Rc::new(result)))\n            }\n            \"substring\" => {\n                // substring(start, end) - extract substring from start to end\n                let start = args.first().and_then(|v| v.to_int()).unwrap_or(0) as usize;\n                let end = args\n                    .get(1)\n                    .and_then(|v| v.to_int())\n                    .map(|e| e as usize)\n                    .unwrap_or(s.len());\n\n                let start = start.min(s.len());\n                let end = end.min(s.len());\n                let result: String = s\n                    .chars()\n                    .skip(start)\n                    .take(end.saturating_sub(start))\n                    .collect();\n                Ok(Value::String(Rc::new(result)))\n            }\n            \"toUpper\" | \"upper\" => Ok(Value::String(Rc::new(s.to_uppercase()))),\n            \"toLower\" | \"lower\" => Ok(Value::String(Rc::new(s.to_lowercase()))),\n            \"trim\" => Ok(Value::String(Rc::new(s.trim().to_string()))),\n            \"startsWith\" => {\n                let prefix = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                Ok(Value::Bool(s.starts_with(&prefix)))\n            }\n            \"endsWith\" => {\n                let suffix = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                Ok(Value::Bool(s.ends_with(&suffix)))\n            }\n            \"replace\" => {\n                // replace(old, new) - replace first occurrence\n                let old = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                let new = args.get(1).map(|v| v.to_string_val()).unwrap_or_default();\n                Ok(Value::String(Rc::new(s.replacen(&old, &new, 1))))\n            }\n            \"replaceAll\" => {\n                // replaceAll(old, new) - replace all occurrences\n                let old = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                let new = args.get(1).map(|v| v.to_string_val()).unwrap_or_default();\n                Ok(Value::String(Rc::new(s.replace(&old, &new))))\n            }\n            \"split\" => {\n                // split(separator) - split string into array\n                let sep = args\n                    .first()\n                    .map(|v| v.to_string_val())\n                    .unwrap_or_else(|| \" \".to_string());\n                let parts: Vec<Value> = s\n                    .split(&sep)\n                    .map(|part| Value::String(Rc::new(part.to_string())))\n                    .collect();\n                Ok(Value::Array(Rc::new(RefCell::new(parts))))\n            }\n            \"charAt\" => {\n                // charAt(index) - get character at index\n                let idx = args.first().and_then(|v| v.to_int()).unwrap_or(0) as usize;\n                match s.chars().nth(idx) {\n                    Some(c) => Ok(Value::String(Rc::new(c.to_string()))),\n                    None => Ok(Value::String(Rc::new(String::new()))),\n                }\n            }\n            \"contains\" => {\n                let search = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                Ok(Value::Bool(s.contains(&search)))\n            }\n            \"indexOf\" => {\n                // indexOf is alias for find\n                let search = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                let start_pos = args.get(1).and_then(|v| v.to_int()).unwrap_or(0) as usize;\n\n                if start_pos >= s.len() {\n                    return Ok(Value::Int(-1));\n                }\n\n                let haystack = &s[start_pos..];\n                match haystack.find(&search) {\n                    Some(pos) => Ok(Value::Int((pos + start_pos) as i64)),\n                    None => Ok(Value::Int(-1)),\n                }\n            }\n            _ => {\n                // Unknown string method - return Null instead of error for graceful degradation\n                Ok(Value::Null)\n            }\n        }\n    }\n\n    /// Public method to instantiate a class with no arguments\n    pub fn instantiate_class_public(&mut self, class: Rc<ClassValue>) -> InterpResult<Value> {\n        self.instantiate_class(class, vec![])\n    }\n\n    fn instantiate_class(\n        &mut self,\n        class: Rc<ClassValue>,\n        args: Vec<Value>,\n    ) -> InterpResult<Value> {\n        // Check for OFML constructor pattern: ClassName(parent, @name, ...)\n        // This creates a child object on the parent with the given name\n        let (parent_obj, obj_name, remaining_args) =\n            self.parse_ofml_constructor_args(&class.name, &args);\n\n        let instance = Rc::new(RefCell::new(ObjInstance {\n            class: class.clone(),\n            name: obj_name.clone(),\n            ..Default::default()\n        }));\n\n        // Set up parent-child relationship\n        if let Some(ref parent) = parent_obj {\n            instance.borrow_mut().parent = Some(parent.clone());\n            parent.borrow_mut().children.push(instance.clone());\n            // Register child by name on parent's fields\n            parent\n                .borrow_mut()\n                .fields\n                .insert(obj_name.clone(), Value::Object(instance.clone()));\n        }\n\n        // Create scene node for geometry classes\n        let is_geometry_class = self.is_geometry_class(&class.name);\n        if is_geometry_class {\n            let parent_node = parent_obj.as_ref().and_then(|p| {\n                let obj_id = p.as_ptr() as u64;\n                self.obj_to_node.get(&obj_id).cloned()\n            });\n\n            // Special handling for OiBlock: create block geometry with dimensions\n            let node = if class.name == \"OiBlock\"\n                || self.class_inherits_from(&class.name, \"OiBlock\")\n            {\n                // OiBlock(parent, @name, [width, height, depth])\n                let dims = match remaining_args.first() {\n                    Some(Value::Array(arr)) => {\n                        let arr = arr.borrow();\n                        [\n                            arr.first().and_then(|v| v.to_float()).unwrap_or(1.0) as f32,\n                            arr.get(1).and_then(|v| v.to_float()).unwrap_or(1.0) as f32,\n                            arr.get(2).and_then(|v| v.to_float()).unwrap_or(1.0) as f32,\n                        ]\n                    }\n                    _ => [1.0, 1.0, 1.0],\n                };\n                self.scene.create_block(obj_name.clone(), dims, parent_node)\n            } else if class.name == \"OiCylinder\"\n                || self.class_inherits_from(&class.name, \"OiCylinder\")\n            {\n                // OiCylinder(parent, @name, [radius, height])\n                let (radius, height) = match remaining_args.first() {\n                    Some(Value::Array(arr)) => {\n                        let arr = arr.borrow();\n                        (\n                            arr.first().and_then(|v| v.to_float()).unwrap_or(0.5) as f32,\n                            arr.get(1).and_then(|v| v.to_float()).unwrap_or(1.0) as f32,\n                        )\n                    }\n                    _ => (0.5, 1.0),\n                };\n                self.scene\n                    .create_cylinder(obj_name.clone(), radius, height, parent_node)\n            } else if class.name == \"OiSphere\" || self.class_inherits_from(&class.name, \"OiSphere\")\n            {\n                // OiSphere(parent, @name, radius)\n                let radius = remaining_args\n                    .first()\n                    .and_then(|v| v.to_float())\n                    .unwrap_or(0.5) as f32;\n                self.scene\n                    .create_sphere(obj_name.clone(), radius, parent_node)\n            } else {\n                // Default: create a container node\n                self.scene.create_part(obj_name.clone(), parent_node)\n            };\n\n            // Map object instance to scene node\n            let obj_id = instance.as_ptr() as u64;\n            self.obj_to_node.insert(obj_id, node);\n        }\n\n        // Initialize instance variables from class declaration AND parent classes\n        // Collect inheritance chain from root to current (root first)\n        // Use lazy parent resolution - look up parents by name from decl.parent\n        let mut class_chain = Vec::new();\n        let mut current_class = Some(class.clone());\n        while let Some(c) = current_class {\n            class_chain.push(c.clone());\n            // Try to resolve parent from class.parent first, then fall back to decl.parent\n            current_class = if c.parent.is_some() {\n                c.parent.clone()\n            } else if let Some(ref parent_name) = c.decl.parent {\n                // Lazy resolution: look up parent by name\n                let parent_short = parent_name.parts.last().unwrap_or(&parent_name.parts[0]);\n                self.classes.get(parent_short).cloned()\n            } else {\n                None\n            };\n        }\n        class_chain.reverse(); // Now ordered from root to derived\n\n        // Initialize variables from each class in the chain (root first, so derived can override)\n        for cls in &class_chain {\n            for member in &cls.decl.members {\n                match member {\n                    ClassMember::Var(var) => {\n                        // Set self context for evaluating initializers\n                        let old_self = self.current_self.take();\n                        self.current_self = Some(instance.clone());\n                        let value = if let Some(ref init) = var.initializer {\n                            self.evaluate(init)?\n                        } else {\n                            Value::Null\n                        };\n                        self.current_self = old_self;\n                        instance.borrow_mut().fields.insert(var.name.clone(), value);\n                    }\n                    ClassMember::Expr(expr) => {\n                        // Execute class-level expressions with self set\n                        let old_self = self.current_self.take();\n                        self.current_self = Some(instance.clone());\n                        self.evaluate(expr)?;\n                        self.current_self = old_self;\n                    }\n                    _ => {}\n                }\n            }\n        }\n\n        // Call initialize if it exists\n        if class.methods.contains_key(\"initialize\") {\n            let old_self = self.current_self.take();\n            self.current_self = Some(instance.clone());\n            // Pass the full original args to initialize (OFML pattern)\n            self.call_method(&Value::Object(instance.clone()), \"initialize\", args)?;\n            self.current_self = old_self;\n        }\n\n        Ok(Value::Object(instance))\n    }\n\n    /// Parse OFML constructor pattern: ClassName(parent, @name, ...)\n    /// Returns (parent_object, object_name, remaining_args)\n    fn parse_ofml_constructor_args(\n        &self,\n        class_name: &str,\n        args: &[Value],\n    ) -> (Option<Rc<RefCell<ObjInstance>>>, String, Vec<Value>) {\n        // Check if this looks like OFML pattern: first arg is object, second is symbol\n        if args.len() >= 2 {\n            if let (Value::Object(parent), Value::Symbol(name)) = (&args[0], &args[1]) {\n                let remaining = if args.len() > 2 {\n                    args[2..].to_vec()\n                } else {\n                    vec![]\n                };\n                return (Some(parent.clone()), name.to_string(), remaining);\n            }\n        }\n\n        // Not OFML pattern, generate a name\n        let name = format!(\"{}_{}\", class_name.to_lowercase(), self.next_obj_id);\n        (None, name, args.to_vec())\n    }\n\n    /// Check if a class is a geometry class that should create scene nodes\n    fn is_geometry_class(&self, class_name: &str) -> bool {\n        matches!(\n            class_name,\n            \"OiObject\" | \"OiPart\" | \"OiBlock\" | \"OiCylinder\" | \"OiSphere\" |\n            // Also handle user-defined classes that extend these\n            \"aWKPart\" | \"aWKPlate2\" | \"aWKContainer\" | \"xOiPlGroup\"\n        ) || self.class_inherits_from(class_name, \"OiPart\")\n            || self.class_inherits_from(class_name, \"OiObject\")\n    }\n\n    /// Check if a class inherits from a base class\n    fn class_inherits_from(&self, class_name: &str, base_name: &str) -> bool {\n        if let Some(class) = self.classes.get(class_name) {\n            // Use lazy parent resolution\n            let mut current = Some(class.clone());\n            while let Some(c) = current {\n                if c.name == base_name {\n                    return true;\n                }\n                current = if c.parent.is_some() {\n                    c.parent.clone()\n                } else if let Some(ref parent_name) = c.decl.parent {\n                    let parent_short = parent_name.parts.last().unwrap_or(&parent_name.parts[0]);\n                    self.classes.get(parent_short).cloned()\n                } else {\n                    None\n                };\n            }\n        }\n        false\n    }\n\n    /// Check if a method name is a built-in object method\n    fn is_builtin_method(&self, name: &str) -> bool {\n        matches!(\n            name,\n            \"setPosition\"\n                | \"getPosition\"\n                | \"setAlignment\"\n                | \"rotate\"\n                | \"getRotation\"\n                | \"getLocalBounds\"\n                | \"setMaterial\"\n                | \"notSelectable\"\n                | \"setCutable\"\n                | \"setRtAxis\"\n                | \"setTrAxis\"\n                | \"set2DName\"\n                | \"getName\"\n                | \"getElements\"\n                | \"getPropValue\"\n                | \"setPropValue\"\n                | \"hasProperty\"\n                | \"hasMember\"\n                | \"isA\"\n                | \"getFather\"\n                | \"getChildren\"\n                | \"setProgram\"\n                | \"checkPropChanges\"\n                | \"invalidatePicture\"\n                | \"setArticleSpec\"\n                | \"removeProperty\"\n                | \"setPropState\"\n                | \"setPropState2\"\n                | \"getPropState2\"\n                | \"getPropertyKeys\"\n                | \"getScene\"\n                | \"getPlanning\"\n                | \"getInfo\"\n                | \"setupProperty\"\n                | \"getPropState\"\n                | \"isCurrentPropsChanged\"\n                | \"setFootAlignment\"\n                | \"getProductDB\"\n                | \"getDataRootDir\"\n                | \"getClass\"\n                | \"setState\"\n                | \"getState\"\n                | \"setDimensions\"\n                | \"getDimensions\"\n                | \"isCat\"\n                | \"article2Class\"\n        )\n    }\n\n    fn set_member(&mut self, obj: &Value, member: &str, value: Value) -> InterpResult<()> {\n        match obj {\n            Value::Object(instance) => {\n                instance\n                    .borrow_mut()\n                    .fields\n                    .insert(member.to_string(), value);\n                Ok(())\n            }\n            _ => Err(InterpError::type_error(\"Cannot set member on this type\")),\n        }\n    }\n\n    fn set_index(&mut self, obj: &Value, index: &Value, value: Value) -> InterpResult<()> {\n        match obj {\n            Value::Array(arr) => {\n                let idx = index\n                    .to_int()\n                    .ok_or_else(|| InterpError::type_error(\"Array index must be integer\"))?;\n                let idx = idx as usize;\n                let mut arr = arr.borrow_mut();\n                if idx < arr.len() {\n                    arr[idx] = value;\n                } else {\n                    // Extend array if needed\n                    while arr.len() <= idx {\n                        arr.push(Value::Null);\n                    }\n                    arr[idx] = value;\n                }\n                Ok(())\n            }\n            Value::Hash(hash) => {\n                let key = match index {\n                    Value::Symbol(s) => s.to_string(),\n                    Value::String(s) => s.to_string(),\n                    _ => index.to_string_val(),\n                };\n                hash.borrow_mut().insert(key, value);\n                Ok(())\n            }\n            Value::Null => {\n                // Assigning to Null index is a no-op (silently ignore)\n                Ok(())\n            }\n            Value::Object(instance) => {\n                // Object indexing - use property assignment\n                let key = match index {\n                    Value::Symbol(s) => s.to_string(),\n                    Value::String(s) => s.to_string(),\n                    _ => index.to_string_val(),\n                };\n                instance.borrow_mut().properties.insert(key, value);\n                Ok(())\n            }\n            _ => Err(InterpError::type_error(\"Cannot index this type\")),\n        }\n    }\n\n    fn eval_index(&mut self, idx: &IndexExpr) -> InterpResult<Value> {\n        let obj = self.evaluate(&idx.object)?;\n        let index = self.evaluate(&idx.index)?;\n\n        match obj {\n            Value::Array(arr) => {\n                let i = index\n                    .to_int()\n                    .ok_or_else(|| InterpError::type_error(\"Array index must be integer\"))?;\n                Ok(arr.borrow().get(i as usize).cloned().unwrap_or(Value::Null))\n            }\n            Value::Hash(hash) => {\n                let key = match index {\n                    Value::Symbol(s) => s.to_string(),\n                    Value::String(s) => s.to_string(),\n                    _ => index.to_string_val(),\n                };\n                Ok(hash.borrow().get(&key).cloned().unwrap_or(Value::Null))\n            }\n            Value::String(s) => {\n                let i = index\n                    .to_int()\n                    .ok_or_else(|| InterpError::type_error(\"String index must be integer\"))?;\n                // Return single character as a string (OFML behavior)\n                Ok(s.chars()\n                    .nth(i as usize)\n                    .map(|c| Value::String(Rc::new(c.to_string())))\n                    .unwrap_or(Value::Null))\n            }\n            Value::Null => {\n                // Indexing Null returns Null (common pattern in dynamic languages)\n                Ok(Value::Null)\n            }\n            Value::Object(instance) => {\n                // Object indexing - use property access\n                let key = match index {\n                    Value::Symbol(s) => s.to_string(),\n                    Value::String(s) => s.to_string(),\n                    _ => index.to_string_val(),\n                };\n                Ok(instance\n                    .borrow()\n                    .properties\n                    .get(&key)\n                    .cloned()\n                    .unwrap_or(Value::Null))\n            }\n            Value::NativeFunc(_) | Value::Func(_) => {\n                // Indexing a function returns Null (common for undefined variables used as functions)\n                Ok(Value::Null)\n            }\n            Value::Int(_) | Value::Float(_) | Value::Bool(_) | Value::Symbol(_) => {\n                // Indexing a primitive type returns Null (graceful degradation)\n                Ok(Value::Null)\n            }\n            other => Err(InterpError::type_error(format!(\n                \"Cannot index type {:?}\",\n                std::mem::discriminant(&other)\n            ))),\n        }\n    }\n\n    fn eval_range(&mut self, range: &RangeExpr) -> InterpResult<Value> {\n        let obj = self.evaluate(&range.object)?;\n        let start = range.start.as_ref().map(|e| self.evaluate(e)).transpose()?;\n        let end = range.end.as_ref().map(|e| self.evaluate(e)).transpose()?;\n\n        match obj {\n            Value::Array(arr) => {\n                let arr = arr.borrow();\n                let start_idx = start.and_then(|v| v.to_int()).unwrap_or(0) as usize;\n                let end_idx = end.and_then(|v| v.to_int()).unwrap_or(arr.len() as i64) as usize;\n                let slice: Vec<Value> = arr\n                    .get(start_idx..end_idx)\n                    .map(|s| s.to_vec())\n                    .unwrap_or_default();\n                Ok(Value::Array(Rc::new(RefCell::new(slice))))\n            }\n            Value::String(s) => {\n                let start_idx = start.and_then(|v| v.to_int()).unwrap_or(0) as usize;\n                let end_idx = end.and_then(|v| v.to_int()).unwrap_or(s.len() as i64) as usize;\n                let slice: String = s\n                    .chars()\n                    .skip(start_idx)\n                    .take(end_idx - start_idx)\n                    .collect();\n                Ok(Value::String(Rc::new(slice)))\n            }\n            _ => Err(InterpError::type_error(\"Cannot slice this type\")),\n        }\n    }\n\n    fn eval_member(&mut self, member: &MemberExpr) -> InterpResult<Value> {\n        let obj = self.evaluate(&member.object)?;\n\n        match obj {\n            Value::Object(instance) => {\n                // Check fields first\n                if let Some(val) = instance.borrow().fields.get(&member.member) {\n                    return Ok(val.clone());\n                }\n                // Check properties\n                if let Some(val) = instance.borrow().properties.get(&member.member) {\n                    return Ok(val.clone());\n                }\n                // Handle special built-in members\n                match member.member.as_str() {\n                    \"geo\" => {\n                        // Return self as geometry reference\n                        return Ok(Value::Object(instance.clone()));\n                    }\n                    \"parent\" => {\n                        // Return parent object if any\n                        if let Some(ref p) = instance.borrow().parent {\n                            return Ok(Value::Object(p.clone()));\n                        }\n                        return Ok(Value::Null);\n                    }\n                    _ => {}\n                }\n                // Return method reference for later call\n                let class = instance.borrow().class.clone();\n                if let Some(func) = class.methods.get(&member.member) {\n                    return Ok(Value::Func(func.clone()));\n                }\n                // For unknown members, return Null instead of error (lenient)\n                Ok(Value::Null)\n            }\n            Value::Class(class) => {\n                // Static member access\n                if let Some(val) = class.static_vars.get(&member.member) {\n                    return Ok(val.clone());\n                }\n                if let Some(func) = class.methods.get(&member.member) {\n                    return Ok(Value::Func(func.clone()));\n                }\n                Err(InterpError::name_error(format!(\n                    \"Unknown static member: {}\",\n                    member.member\n                )))\n            }\n            Value::Null => {\n                // Accessing member on Null returns Null (null-safe pattern)\n                Ok(Value::Null)\n            }\n            _ => Err(InterpError::type_error(format!(\n                \"Cannot access member on {}\",\n                obj.type_name()\n            ))),\n        }\n    }\n\n    fn eval_instanceof(&mut self, inst: &InstanceofExpr) -> InterpResult<Value> {\n        let obj = self.evaluate(&inst.expr)?;\n        let type_val = self.evaluate(&inst.type_name)?;\n\n        match (&obj, &type_val) {\n            (Value::Object(instance), Value::Class(class)) => {\n                Ok(Value::Bool(instance.borrow().is_a(&class.name)))\n            }\n            _ => Ok(Value::Bool(false)),\n        }\n    }\n}\n\nimpl Default for Interpreter {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::parser::Parser;\n\n    #[test]\n    fn test_class_package_tracking() {\n        let source = r#\"\n            package ::vitra::basics;\n\n            public class VitraOiBTGPlElement3 : xOiBTGPlElement3 {\n                public func initialize(pFa, pNa) {\n                    // Parent call\n                }\n            }\n        \"#;\n\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        // Check class is registered with correct package\n        let class = interp.classes.get(\"VitraOiBTGPlElement3\").unwrap();\n        assert_eq!(class.package, \"::vitra::basics\");\n        assert_eq!(class.name, \"VitraOiBTGPlElement3\");\n    }\n\n    #[test]\n    fn test_class_qualified_name() {\n        let source = r#\"\n            package ::vitra::basics;\n            public class TestClass : xOiBTGPlElement3 {}\n        \"#;\n\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        let class = interp.classes.get(\"TestClass\").unwrap();\n        assert_eq!(class.qualified_name(), \"::vitra::basics::TestClass\");\n    }\n\n    #[test]\n    fn test_qualified_class_lookup() {\n        let source = r#\"\n            package ::vitra::basics;\n            public class UniqueClass : xOiBTGPlElement3 {}\n        \"#;\n\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        // Verify class is registered in qualified_classes map\n        let fq_name = \"::vitra::basics::UniqueClass\";\n        assert!(interp.qualified_classes.contains_key(fq_name));\n\n        let class = interp.qualified_classes.get(fq_name).unwrap();\n        assert_eq!(class.name, \"UniqueClass\");\n        assert_eq!(class.package, \"::vitra::basics\");\n    }\n\n    #[test]\n    fn test_multiple_classes_same_short_name_different_packages() {\n        // First package\n        let source1 = r#\"\n            package ::vitra::basics;\n            public class SharedName : xOiBTGPlElement3 {\n                public func getValue() { return 1; }\n            }\n        \"#;\n\n        // Second package with same class name\n        let source2 = r#\"\n            package ::vitra::workit;\n            public class SharedName : xOiBTGPlElement3 {\n                public func getValue() { return 2; }\n            }\n        \"#;\n\n        let mut parser1 = Parser::new(source1).unwrap();\n        let ast1 = parser1.parse().unwrap();\n\n        let mut parser2 = Parser::new(source2).unwrap();\n        let ast2 = parser2.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast1).unwrap();\n        interp.execute(&ast2).unwrap();\n\n        // Both should exist in qualified_classes with different keys\n        assert!(interp\n            .qualified_classes\n            .contains_key(\"::vitra::basics::SharedName\"));\n        assert!(interp\n            .qualified_classes\n            .contains_key(\"::vitra::workit::SharedName\"));\n\n        // short name lookup returns last registered (workit)\n        let short_class = interp.classes.get(\"SharedName\").unwrap();\n        assert_eq!(short_class.package, \"::vitra::workit\");\n\n        // Qualified lookups return correct classes\n        let basics_class = interp\n            .qualified_classes\n            .get(\"::vitra::basics::SharedName\")\n            .unwrap();\n        assert_eq!(basics_class.package, \"::vitra::basics\");\n\n        let workit_class = interp\n            .qualified_classes\n            .get(\"::vitra::workit::SharedName\")\n            .unwrap();\n        assert_eq!(workit_class.package, \"::vitra::workit\");\n    }\n\n    #[test]\n    fn test_parent_class_inheritance_chain() {\n        let source = r#\"\n            package ::vitra::basics;\n\n            public class VitraOiBTGPlElement3 : xOiBTGPlElement3 {\n                public func initialize(pFa, pNa) {}\n            }\n\n            public class ViOiBTGPlElement3 : VitraOiBTGPlElement3 {\n                public func initialize(pFa, pNa) {\n                    // Would call ::vitra::basics::VitraOiBTGPlElement3::initialize(pFa, pNa);\n                }\n            }\n        \"#;\n\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        // Verify inheritance chain\n        let vi_class = interp.classes.get(\"ViOiBTGPlElement3\").unwrap();\n        assert!(vi_class.parent.is_some());\n\n        let parent = vi_class.parent.as_ref().unwrap();\n        assert_eq!(parent.name, \"VitraOiBTGPlElement3\");\n        assert_eq!(parent.package, \"::vitra::basics\");\n    }\n\n    #[test]\n    fn test_native_classes_have_empty_package() {\n        let interp = Interpreter::new();\n\n        // Native classes should have empty package\n        let oi_object = interp.classes.get(\"OiObject\").unwrap();\n        assert_eq!(oi_object.package, \"\");\n\n        let x_oi_btg = interp.classes.get(\"xOiBTGPlElement3\").unwrap();\n        assert_eq!(x_oi_btg.package, \"\");\n    }\n\n    #[test]\n    fn test_interpreter_new() {\n        let interp = Interpreter::new();\n        // Basic native classes should be registered\n        assert!(interp.classes.contains_key(\"OiObject\"));\n        assert!(interp.classes.contains_key(\"xOiBTGPlElement3\"));\n        // Scene should be initialized\n        assert!(interp.scene.alb_path.is_none());\n    }\n\n    #[test]\n    fn test_interpreter_execute_empty() {\n        let mut interp = Interpreter::new();\n        let unit = TranslationUnit::default();\n        let result = interp.execute(&unit);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_interpreter_execute_simple_declaration() {\n        let source = \"var x = 10;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        let result = interp.execute(&ast);\n        assert!(result.is_ok());\n\n        // Variable should be defined\n        let val = interp.env.get(\"x\");\n        assert!(val.is_some());\n        if let Some(Value::Int(n)) = val {\n            assert_eq!(n, 10);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_execute_arithmetic() {\n        let source = \"var x = 2 + 3 * 4;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 14);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_execute_string_concat() {\n        let source = r#\"var s = \"hello\" + \" \" + \"world\";\"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::String(s)) = interp.env.get(\"s\") {\n            assert_eq!(s.as_str(), \"hello world\");\n        }\n    }\n\n    #[test]\n    fn test_interpreter_execute_if_statement() {\n        let source = r#\"\n            var x = 0;\n            if (1) {\n                x = 1;\n            }\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 1);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_execute_if_else() {\n        let source = r#\"\n            var x = 0;\n            if (0) {\n                x = 1;\n            } else {\n                x = 2;\n            }\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 2);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_execute_while_loop() {\n        let source = r#\"\n            var x = 0;\n            while (x < 5) {\n                x = x + 1;\n            }\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 5);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_execute_for_loop() {\n        let source = r#\"\n            var sum = 0;\n            for (var i = 0; i < 5; i = i + 1) {\n                sum = sum + i;\n            }\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"sum\") {\n            assert_eq!(n, 10); // 0+1+2+3+4 = 10\n        }\n    }\n\n    #[test]\n    fn test_interpreter_execute_function_def_and_call() {\n        let source = r#\"\n            func add(a, b) {\n                return a + b;\n            }\n            var result = add(3, 4);\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"result\") {\n            assert_eq!(n, 7);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_execute_array_literal() {\n        let source = r#\"var arr = [1, 2, 3];\"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Array(arr)) = interp.env.get(\"arr\") {\n            assert_eq!(arr.borrow().len(), 3);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_execute_array_access() {\n        let source = r#\"\n            var arr = [10, 20, 30];\n            var x = arr[1];\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 20);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_error_runtime() {\n        let err = InterpError::runtime(\"test error\");\n        assert_eq!(err.message, \"test error\");\n        assert!(matches!(err.kind, ErrorKind::Runtime));\n    }\n\n    #[test]\n    fn test_interpreter_error_type() {\n        let err = InterpError::type_error(\"type mismatch\");\n        assert_eq!(err.message, \"type mismatch\");\n        assert!(matches!(err.kind, ErrorKind::TypeError));\n    }\n\n    #[test]\n    fn test_interpreter_error_name() {\n        let err = InterpError::name_error(\"undefined variable\");\n        assert_eq!(err.message, \"undefined variable\");\n        assert!(matches!(err.kind, ErrorKind::NameError));\n    }\n\n    #[test]\n    fn test_interpreter_set_alb_path() {\n        let mut interp = Interpreter::new();\n        interp.set_alb_path(\"/test/path\".into());\n        assert_eq!(\n            interp.scene.alb_path,\n            Some(std::path::PathBuf::from(\"/test/path\"))\n        );\n    }\n\n    #[test]\n    fn test_interpreter_comparison_operators() {\n        let test_cases = [\n            (\"var x = 5 > 3;\", \"x\", true),\n            (\"var x = 3 > 5;\", \"x\", false),\n            (\"var x = 5 < 3;\", \"x\", false),\n            (\"var x = 3 < 5;\", \"x\", true),\n            (\"var x = 5 >= 5;\", \"x\", true),\n            (\"var x = 5 <= 5;\", \"x\", true),\n            (\"var x = 5 == 5;\", \"x\", true),\n            (\"var x = 5 != 3;\", \"x\", true),\n        ];\n\n        for (source, var, expected) in test_cases {\n            let mut parser = Parser::new(source).unwrap();\n            let ast = parser.parse().unwrap();\n\n            let mut interp = Interpreter::new();\n            interp.execute(&ast).unwrap();\n\n            if let Some(Value::Bool(val)) = interp.env.get(var) {\n                assert_eq!(val, expected, \"Failed for: {}\", source);\n            }\n        }\n    }\n\n    #[test]\n    fn test_interpreter_logical_operators() {\n        let test_cases = [\n            (\"var x = 1 && 1;\", \"x\", 1),\n            (\"var x = 1 && 0;\", \"x\", 0),\n            (\"var x = 0 || 1;\", \"x\", 1),\n            (\"var x = 0 || 0;\", \"x\", 0),\n            (\"var x = !1;\", \"x\", 0),\n            (\"var x = !0;\", \"x\", 1),\n        ];\n\n        for (source, var, expected) in test_cases {\n            let mut parser = Parser::new(source).unwrap();\n            let ast = parser.parse().unwrap();\n\n            let mut interp = Interpreter::new();\n            interp.execute(&ast).unwrap();\n\n            if let Some(Value::Int(val)) = interp.env.get(var) {\n                assert_eq!(val, expected, \"Failed for: {}\", source);\n            }\n        }\n    }\n\n    #[test]\n    fn test_interpreter_unary_minus() {\n        let source = \"var x = -5;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, -5);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_float_arithmetic() {\n        let source = \"var x = 3.14 * 2.0;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Float(val)) = interp.env.get(\"x\") {\n            assert!((val - 6.28).abs() < 0.01);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_mixed_int_float_arithmetic() {\n        let source = \"var x = 5 + 2.5;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Float(val)) = interp.env.get(\"x\") {\n            assert!((val - 7.5).abs() < 0.01);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_modulo() {\n        let source = \"var x = 10 % 3;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 1);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_division() {\n        let source = \"var x = 10 / 3;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 3); // Integer division\n        }\n    }\n\n    #[test]\n    fn test_interpreter_break_in_while() {\n        let source = r#\"\n            var x = 0;\n            while (1) {\n                x = x + 1;\n                if (x >= 5) {\n                    break;\n                }\n            }\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 5);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_return_in_function() {\n        let source = r#\"\n            func earlyReturn(n) {\n                if (n > 5) {\n                    return 100;\n                }\n                return n;\n            }\n            var x = earlyReturn(10);\n            var y = earlyReturn(3);\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 100);\n        }\n        if let Some(Value::Int(n)) = interp.env.get(\"y\") {\n            assert_eq!(n, 3);\n        }\n    }\n\n    // ========== Additional Coverage Tests ==========\n\n    #[test]\n    fn test_interpreter_error_kind_debug() {\n        let kind = ErrorKind::Runtime;\n        let debug_str = format!(\"{:?}\", kind);\n        assert!(debug_str.contains(\"Runtime\"));\n    }\n\n    #[test]\n    fn test_interp_error_display() {\n        let err = InterpError::runtime(\"test message\");\n        let display_str = format!(\"{}\", err);\n        assert!(display_str.contains(\"test message\"));\n    }\n\n    #[test]\n    fn test_interpreter_conditional_operator() {\n        let source = \"var x = (5 > 3) ? 10 : 20;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 10);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_conditional_operator_else() {\n        let source = \"var x = (3 > 5) ? 10 : 20;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 20);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_compound_assignment_add() {\n        let source = r#\"\n            var x = 10;\n            x += 5;\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 15);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_compound_assignment_sub() {\n        let source = r#\"\n            var x = 10;\n            x -= 3;\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 7);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_compound_assignment_mul() {\n        let source = r#\"\n            var x = 5;\n            x *= 3;\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 15);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_compound_assignment_div() {\n        let source = r#\"\n            var x = 20;\n            x /= 4;\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 5);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_bitwise_and() {\n        let source = \"var x = 0xFF & 0x0F;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 0x0F);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_bitwise_or() {\n        let source = \"var x = 0xF0 | 0x0F;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 0xFF);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_bitwise_xor() {\n        let source = \"var x = 0xFF ^ 0xF0;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 0x0F);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_left_shift() {\n        let source = \"var x = 1 << 4;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 16);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_right_shift() {\n        let source = \"var x = 16 >> 2;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 4);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_nested_function_calls() {\n        let source = r#\"\n            func double(n) { return n * 2; }\n            func triple(n) { return n * 3; }\n            var x = double(triple(5));\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 30); // 5 * 3 * 2\n        }\n    }\n\n    #[test]\n    fn test_interpreter_recursive_function() {\n        let source = r#\"\n            func factorial(n) {\n                if (n <= 1) { return 1; }\n                return n * factorial(n - 1);\n            }\n            var x = factorial(5);\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 120); // 5! = 120\n        }\n    }\n\n    #[test]\n    fn test_interpreter_array_push() {\n        let source = r#\"\n            var arr = [1, 2];\n            arr[2] = 3;\n            var len = 3;\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Array(arr)) = interp.env.get(\"arr\") {\n            assert!(arr.borrow().len() >= 3);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_string_comparison() {\n        let source = r#\"\n            var x = \"hello\" == \"hello\";\n            var y = \"hello\" != \"world\";\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Bool(b)) = interp.env.get(\"x\") {\n            assert!(b);\n        }\n        if let Some(Value::Bool(b)) = interp.env.get(\"y\") {\n            assert!(b);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_symbol_literal() {\n        let source = \"var s = @mySymbol;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Symbol(s)) = interp.env.get(\"s\") {\n            assert_eq!(s.as_str(), \"mySymbol\");\n        }\n    }\n\n    #[test]\n    fn test_interpreter_continue_in_loop() {\n        let source = r#\"\n            var sum = 0;\n            for (var i = 0; i < 10; i = i + 1) {\n                if (i % 2 == 0) {\n                    continue;\n                }\n                sum = sum + i;\n            }\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"sum\") {\n            // Sum of odd numbers 1+3+5+7+9 = 25\n            assert_eq!(n, 25);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_nested_blocks() {\n        let source = r#\"\n            var x = 1;\n            {\n                var y = 2;\n                {\n                    var z = 3;\n                    x = x + y + z;\n                }\n            }\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 6); // 1 + 2 + 3\n        }\n    }\n\n    #[test]\n    fn test_interpreter_unary_not() {\n        let source = \"var x = !0;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        // !0 should be truthy\n        if let Some(val) = interp.env.get(\"x\") {\n            assert!(val.is_truthy());\n        }\n    }\n\n    #[test]\n    fn test_interpreter_float_division() {\n        let source = \"var x = 10.0 / 4.0;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Float(f)) = interp.env.get(\"x\") {\n            assert!((f - 2.5).abs() < 0.001);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_subtraction() {\n        let source = \"var x = 10 - 3;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 7);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_class_def() {\n        let source = r#\"\n            public class SimpleClass : OiObject {\n                var x = 0;\n            }\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        assert!(interp.classes.contains_key(\"SimpleClass\"));\n    }\n\n    #[test]\n    fn test_interpreter_hex_literal() {\n        let source = \"var x = 0xFF;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 255);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_negative_numbers() {\n        let source = \"var x = -10 + 5;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, -5);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_parentheses() {\n        let source = \"var x = (2 + 3) * 4;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 20);\n        }\n    }\n\n    #[test]\n    fn test_interp_error_std_error() {\n        let err = InterpError::runtime(\"test\");\n        // InterpError implements std::error::Error\n        let _: &dyn std::error::Error = &err;\n    }\n\n    #[test]\n    fn test_value_is_truthy_int() {\n        assert!(Value::Int(1).is_truthy());\n        assert!(!Value::Int(0).is_truthy());\n        assert!(Value::Int(-1).is_truthy());\n    }\n\n    #[test]\n    fn test_value_is_truthy_string() {\n        assert!(Value::String(std::rc::Rc::new(\"hello\".to_string())).is_truthy());\n        assert!(!Value::String(std::rc::Rc::new(\"\".to_string())).is_truthy());\n    }\n\n    #[test]\n    fn test_value_is_truthy_bool() {\n        assert!(Value::Bool(true).is_truthy());\n        assert!(!Value::Bool(false).is_truthy());\n    }\n\n    #[test]\n    fn test_value_is_truthy_null() {\n        assert!(!Value::Null.is_truthy());\n    }\n\n    // ========== Extended Coverage Tests ==========\n\n    #[test]\n    fn test_interpreter_do_while_loop() {\n        let source = r#\"\n            var x = 0;\n            do {\n                x = x + 1;\n            } while (x < 5);\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 5);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_do_while_executes_once() {\n        let source = r#\"\n            var x = 10;\n            do {\n                x = x + 1;\n            } while (0);\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        // Should execute once even though condition is false\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 11);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_do_while_break() {\n        let source = r#\"\n            var x = 0;\n            do {\n                x = x + 1;\n                if (x >= 3) {\n                    break;\n                }\n            } while (1);\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 3);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_do_while_continue() {\n        let source = r#\"\n            var sum = 0;\n            var i = 0;\n            do {\n                i = i + 1;\n                if (i % 2 == 0) {\n                    continue;\n                }\n                sum = sum + i;\n            } while (i < 5);\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        // Sum of odd numbers 1+3+5 = 9\n        if let Some(Value::Int(n)) = interp.env.get(\"sum\") {\n            assert_eq!(n, 9);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_foreach_array() {\n        // OFML uses semicolon instead of 'in' keyword\n        let source = r#\"\n            var sum = 0;\n            var arr = [1, 2, 3, 4];\n            foreach (item; arr) {\n                sum = sum + item;\n            }\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"sum\") {\n            assert_eq!(n, 10); // 1+2+3+4\n        }\n    }\n\n    #[test]\n    fn test_interpreter_foreach_with_break() {\n        let source = r#\"\n            var sum = 0;\n            var arr = [1, 2, 3, 4, 5];\n            foreach (item; arr) {\n                if (item > 3) {\n                    break;\n                }\n                sum = sum + item;\n            }\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"sum\") {\n            assert_eq!(n, 6); // 1+2+3\n        }\n    }\n\n    #[test]\n    fn test_interpreter_foreach_with_continue() {\n        let source = r#\"\n            var sum = 0;\n            var arr = [1, 2, 3, 4, 5];\n            foreach (item; arr) {\n                if (item % 2 == 0) {\n                    continue;\n                }\n                sum = sum + item;\n            }\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        // Sum of odd numbers 1+3+5 = 9\n        if let Some(Value::Int(n)) = interp.env.get(\"sum\") {\n            assert_eq!(n, 9);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_switch_basic() {\n        let source = r#\"\n            var result = 0;\n            var x = 2;\n            switch (x) {\n                case 1:\n                    result = 10;\n                    break;\n                case 2:\n                    result = 20;\n                    break;\n                case 3:\n                    result = 30;\n                    break;\n            }\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"result\") {\n            assert_eq!(n, 20);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_switch_default() {\n        let source = r#\"\n            var result = 0;\n            var x = 99;\n            switch (x) {\n                case 1:\n                    result = 10;\n                    break;\n                case 2:\n                    result = 20;\n                    break;\n                default:\n                    result = 999;\n                    break;\n            }\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"result\") {\n            assert_eq!(n, 999);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_switch_fallthrough() {\n        let source = r#\"\n            var result = 0;\n            var x = 1;\n            switch (x) {\n                case 1:\n                    result = result + 1;\n                case 2:\n                    result = result + 2;\n                    break;\n                case 3:\n                    result = result + 3;\n                    break;\n            }\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        // Without break after case 1, it falls through to case 2\n        if let Some(Value::Int(n)) = interp.env.get(\"result\") {\n            assert_eq!(n, 3); // 1 + 2\n        }\n    }\n\n    #[test]\n    fn test_interpreter_try_catch() {\n        let source = r#\"\n            var result = 0;\n            var caught = 0;\n            try {\n                result = 1;\n                var x = undefined_var;\n                result = 2;\n            } catch (e) {\n                caught = 1;\n            }\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"result\") {\n            assert_eq!(n, 1); // Executed until error\n        }\n        if let Some(Value::Int(n)) = interp.env.get(\"caught\") {\n            assert_eq!(n, 1); // Catch block executed\n        }\n    }\n\n    #[test]\n    fn test_interpreter_try_finally() {\n        let source = r#\"\n            var result = 0;\n            var finally_ran = 0;\n            try {\n                result = 1;\n            } finally {\n                finally_ran = 1;\n            }\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"result\") {\n            assert_eq!(n, 1);\n        }\n        if let Some(Value::Int(n)) = interp.env.get(\"finally_ran\") {\n            assert_eq!(n, 1);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_math_functions() {\n        let source = r#\"\n            var f = floor(3.7);\n            var c = ceil(3.2);\n            var r = round(3.5);\n            var s = sqrt(16.0);\n            var p = pow(2.0, 3.0);\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"f\") {\n            assert_eq!(n, 3);\n        }\n        if let Some(Value::Int(n)) = interp.env.get(\"c\") {\n            assert_eq!(n, 4);\n        }\n        if let Some(Value::Int(n)) = interp.env.get(\"r\") {\n            assert_eq!(n, 4);\n        }\n        if let Some(Value::Float(v)) = interp.env.get(\"s\") {\n            assert!((v - 4.0).abs() < 0.001);\n        }\n        if let Some(Value::Float(v)) = interp.env.get(\"p\") {\n            assert!((v - 8.0).abs() < 0.001);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_trig_functions() {\n        let source = r#\"\n            var s = sin(0.0);\n            var c = cos(0.0);\n            var t = tan(0.0);\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Float(v)) = interp.env.get(\"s\") {\n            assert!(v.abs() < 0.001); // sin(0) = 0\n        }\n        if let Some(Value::Float(v)) = interp.env.get(\"c\") {\n            assert!((v - 1.0).abs() < 0.001); // cos(0) = 1\n        }\n        if let Some(Value::Float(v)) = interp.env.get(\"t\") {\n            assert!(v.abs() < 0.001); // tan(0) = 0\n        }\n    }\n\n    #[test]\n    fn test_interpreter_abs_function() {\n        let source = r#\"\n            var a = abs(-5);\n            var b = abs(3.14);\n            var c = abs(-2.5);\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"a\") {\n            assert_eq!(n, 5);\n        }\n        if let Some(Value::Float(v)) = interp.env.get(\"b\") {\n            assert!((v - 3.14).abs() < 0.001);\n        }\n        if let Some(Value::Float(v)) = interp.env.get(\"c\") {\n            assert!((v - 2.5).abs() < 0.001);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_null_arithmetic() {\n        let source = r#\"\n            var a = 5 + NULL;\n            var b = NULL + 10;\n            var c = NULL - 5;\n            var d = 10 - NULL;\n            var e = NULL * 5;\n            var f = NULL / 5;\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        // Null is treated as 0 in arithmetic\n        if let Some(Value::Int(n)) = interp.env.get(\"a\") {\n            assert_eq!(n, 5);\n        }\n        if let Some(Value::Int(n)) = interp.env.get(\"b\") {\n            assert_eq!(n, 10);\n        }\n        if let Some(Value::Int(n)) = interp.env.get(\"c\") {\n            assert_eq!(n, -5);\n        }\n        if let Some(Value::Int(n)) = interp.env.get(\"d\") {\n            assert_eq!(n, 10);\n        }\n        if let Some(Value::Int(n)) = interp.env.get(\"e\") {\n            assert_eq!(n, 0);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_unsigned_right_shift() {\n        let source = \"var x = -1 >>> 1;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        // Unsigned right shift treats the value as unsigned\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert!(n > 0);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_class_definition_and_field_init() {\n        // Test class field initialization without 'new' keyword\n        let source = r#\"\n            public class TestPoint : OiObject {\n                var x = 10;\n                var y = 20;\n            }\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        // Verify class is registered\n        assert!(interp.classes.contains_key(\"TestPoint\"));\n        let class = interp.classes.get(\"TestPoint\").unwrap();\n        assert!(class.parent.is_some());\n    }\n\n    #[test]\n    fn test_interpreter_increment_decrement() {\n        let source = r#\"\n            var x = 5;\n            var a = x++;\n            var b = ++x;\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        // Post-increment may return different semantics in OFML\n        // Just test values are assigned\n        assert!(interp.env.get(\"a\").is_some());\n        assert!(interp.env.get(\"b\").is_some());\n    }\n\n    #[test]\n    fn test_interpreter_atan2() {\n        let source = r#\"\n            var a = atan2(1.0, 1.0);\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Float(v)) = interp.env.get(\"a\") {\n            // atan2(1, 1) = pi/4 ‚âà 0.785\n            assert!((v - std::f64::consts::FRAC_PI_4).abs() < 0.001);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_constants() {\n        let mut interp = Interpreter::new();\n\n        // Check PI constant\n        if let Some(Value::Float(pi)) = interp.env.get(\"sPi\") {\n            assert!((pi - std::f64::consts::PI).abs() < 0.0001);\n        }\n\n        // Check E constant\n        if let Some(Value::Float(e)) = interp.env.get(\"sE\") {\n            assert!((e - std::f64::consts::E).abs() < 0.0001);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_string_to_non_string_concat() {\n        let source = r#\"\n            var a = \"value: \" + 42;\n            var b = 100 + \" items\";\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::String(s)) = interp.env.get(\"a\") {\n            assert_eq!(s.as_str(), \"value: 42\");\n        }\n        if let Some(Value::String(s)) = interp.env.get(\"b\") {\n            assert_eq!(s.as_str(), \"100 items\");\n        }\n    }\n\n    #[test]\n    fn test_interpreter_division_by_zero() {\n        let source = \"var x = 10 / 0;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        let result = interp.execute(&ast);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_interpreter_modulo_by_zero() {\n        let source = \"var x = 10 % 0;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        let result = interp.execute(&ast);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_interpreter_float_modulo() {\n        let source = \"var x = 7.5 % 2.5;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Float(v)) = interp.env.get(\"x\") {\n            assert!(v.abs() < 0.001); // 7.5 % 2.5 = 0\n        }\n    }\n\n    #[test]\n    fn test_interpreter_default_translation_unit() {\n        // Default TranslationUnit returns empty fields\n        let default = TranslationUnit::default();\n        assert!(default.statements.is_empty());\n        assert!(default.imports.is_empty());\n        assert!(default.package.is_none());\n    }\n\n    #[test]\n    fn test_error_kind_return_variant() {\n        let kind = ErrorKind::Return(Value::Int(42));\n        if let ErrorKind::Return(val) = kind {\n            if let Value::Int(n) = val {\n                assert_eq!(n, 42);\n            }\n        }\n    }\n\n    #[test]\n    fn test_error_kind_break_continue() {\n        let _break = ErrorKind::Break;\n        let _continue = ErrorKind::Continue;\n        // Just testing they exist\n    }\n\n    #[test]\n    fn test_interp_error_from_string() {\n        let err: InterpError = \"test error\".to_string().into();\n        assert_eq!(err.message, \"test error\");\n        assert!(matches!(err.kind, ErrorKind::Runtime));\n    }\n\n    #[test]\n    fn test_interpreter_null_comparison() {\n        let source = r#\"\n            var a = NULL < 5;\n            var b = 5 > NULL;\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        // Null comparisons return false\n        if let Some(Value::Bool(v)) = interp.env.get(\"a\") {\n            assert!(!v);\n        }\n        if let Some(Value::Bool(v)) = interp.env.get(\"b\") {\n            assert!(!v);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_unary_negation_null() {\n        let source = \"var x = -NULL;\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"x\") {\n            assert_eq!(n, 0); // -NULL = 0\n        }\n    }\n\n    #[test]\n    fn test_interpreter_class_with_method() {\n        let source = r#\"\n            public class TestObj : OiObject {\n                var value = 42;\n\n                public func getValue() {\n                    return value;\n                }\n            }\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        // Verify class and method are registered\n        let class = interp.classes.get(\"TestObj\").unwrap();\n        assert!(class.methods.contains_key(\"getValue\"));\n    }\n\n    #[test]\n    fn test_interpreter_array_assignment() {\n        let source = r#\"\n            var arr = [0, 0, 0];\n            arr[0] = 1;\n            arr[1] = 2;\n            arr[2] = 3;\n            var sum = arr[0] + arr[1] + arr[2];\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"sum\") {\n            assert_eq!(n, 6);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_native_classes_registered() {\n        let interp = Interpreter::new();\n\n        // Check that various native classes exist\n        assert!(interp.classes.contains_key(\"OiObject\"));\n        assert!(interp.classes.contains_key(\"OiPart\"));\n        assert!(interp.classes.contains_key(\"OiGeometry\"));\n        assert!(interp.classes.contains_key(\"OiBlock\"));\n        assert!(interp.classes.contains_key(\"OiCylinder\"));\n        assert!(interp.classes.contains_key(\"OiSphere\"));\n    }\n\n    #[test]\n    fn test_interpreter_empty_array() {\n        let source = \"var arr = [];\";\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Array(arr)) = interp.env.get(\"arr\") {\n            assert!(arr.borrow().is_empty());\n        }\n    }\n\n    #[test]\n    fn test_interpreter_nested_arrays() {\n        let source = r#\"\n            var arr = [[1, 2], [3, 4]];\n            var first = arr[0];\n            var second = arr[1];\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Array(first)) = interp.env.get(\"first\") {\n            assert_eq!(first.borrow().len(), 2);\n        }\n    }\n\n    #[test]\n    fn test_interpreter_boolean_as_integers() {\n        // OFML uses 1 and 0 for boolean values\n        let source = r#\"\n            var t = 1;\n            var f = 0;\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(Value::Int(n)) = interp.env.get(\"t\") {\n            assert!(n != 0); // truthy\n        }\n        if let Some(Value::Int(n)) = interp.env.get(\"f\") {\n            assert_eq!(n, 0); // falsy\n        }\n    }\n\n    #[test]\n    fn test_interpreter_short_circuit_and() {\n        let source = r#\"\n            var called = 0;\n            func sideEffect() {\n                called = 1;\n                return 1;\n            }\n            var x = 0 && sideEffect();\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        // sideEffect should still be called due to eager evaluation\n        // but && short-circuits to false\n        if let Some(val) = interp.env.get(\"x\") {\n            assert!(!val.is_truthy());\n        }\n    }\n\n    #[test]\n    fn test_interpreter_short_circuit_or() {\n        let source = r#\"\n            var x = 1 || 0;\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        if let Some(val) = interp.env.get(\"x\") {\n            assert!(val.is_truthy());\n        }\n    }\n\n    #[test]\n    fn test_interpreter_function_with_no_return() {\n        let source = r#\"\n            func noReturn() {\n                var x = 1;\n            }\n            var result = noReturn();\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        // Function with no return should return Null\n        if let Some(val) = interp.env.get(\"result\") {\n            assert!(matches!(val, Value::Null));\n        }\n    }\n\n    #[test]\n    fn test_interpreter_closure_captures() {\n        let source = r#\"\n            func makeAdder(n) {\n                func add(x) {\n                    return n + x;\n                }\n                return add;\n            }\n            var add5 = makeAdder(5);\n        \"#;\n        let mut parser = Parser::new(source).unwrap();\n        let ast = parser.parse().unwrap();\n\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).unwrap();\n\n        assert!(interp.env.get(\"add5\").is_some());\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":6}},{"line":36,"address":[],"length":0,"stats":{"Line":12}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":4}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":3}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":132}},{"line":100,"address":[],"length":0,"stats":{"Line":264}},{"line":101,"address":[],"length":0,"stats":{"Line":264}},{"line":102,"address":[],"length":0,"stats":{"Line":264}},{"line":103,"address":[],"length":0,"stats":{"Line":264}},{"line":105,"address":[],"length":0,"stats":{"Line":264}},{"line":106,"address":[],"length":0,"stats":{"Line":264}},{"line":107,"address":[],"length":0,"stats":{"Line":132}},{"line":113,"address":[],"length":0,"stats":{"Line":264}},{"line":114,"address":[],"length":0,"stats":{"Line":264}},{"line":115,"address":[],"length":0,"stats":{"Line":264}},{"line":116,"address":[],"length":0,"stats":{"Line":132}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":3}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":132}},{"line":135,"address":[],"length":0,"stats":{"Line":132}},{"line":136,"address":[],"length":0,"stats":{"Line":396}},{"line":137,"address":[],"length":0,"stats":{"Line":132}},{"line":138,"address":[],"length":0,"stats":{"Line":396}},{"line":141,"address":[],"length":0,"stats":{"Line":264}},{"line":143,"address":[],"length":0,"stats":{"Line":133}},{"line":144,"address":[],"length":0,"stats":{"Line":6}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":264}},{"line":150,"address":[],"length":0,"stats":{"Line":133}},{"line":151,"address":[],"length":0,"stats":{"Line":6}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":264}},{"line":157,"address":[],"length":0,"stats":{"Line":133}},{"line":158,"address":[],"length":0,"stats":{"Line":6}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":264}},{"line":164,"address":[],"length":0,"stats":{"Line":132}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":264}},{"line":172,"address":[],"length":0,"stats":{"Line":132}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":264}},{"line":179,"address":[],"length":0,"stats":{"Line":133}},{"line":180,"address":[],"length":0,"stats":{"Line":6}},{"line":181,"address":[],"length":0,"stats":{"Line":6}},{"line":182,"address":[],"length":0,"stats":{"Line":2}},{"line":185,"address":[],"length":0,"stats":{"Line":264}},{"line":187,"address":[],"length":0,"stats":{"Line":132}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":264}},{"line":194,"address":[],"length":0,"stats":{"Line":132}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":264}},{"line":201,"address":[],"length":0,"stats":{"Line":133}},{"line":202,"address":[],"length":0,"stats":{"Line":6}},{"line":203,"address":[],"length":0,"stats":{"Line":6}},{"line":204,"address":[],"length":0,"stats":{"Line":2}},{"line":209,"address":[],"length":0,"stats":{"Line":660}},{"line":210,"address":[],"length":0,"stats":{"Line":132}},{"line":211,"address":[],"length":0,"stats":{"Line":660}},{"line":212,"address":[],"length":0,"stats":{"Line":132}},{"line":213,"address":[],"length":0,"stats":{"Line":396}},{"line":216,"address":[],"length":0,"stats":{"Line":660}},{"line":217,"address":[],"length":0,"stats":{"Line":792}},{"line":218,"address":[],"length":0,"stats":{"Line":132}},{"line":219,"address":[],"length":0,"stats":{"Line":396}},{"line":222,"address":[],"length":0,"stats":{"Line":660}},{"line":223,"address":[],"length":0,"stats":{"Line":132}},{"line":224,"address":[],"length":0,"stats":{"Line":660}},{"line":225,"address":[],"length":0,"stats":{"Line":132}},{"line":226,"address":[],"length":0,"stats":{"Line":396}},{"line":229,"address":[],"length":0,"stats":{"Line":660}},{"line":230,"address":[],"length":0,"stats":{"Line":792}},{"line":231,"address":[],"length":0,"stats":{"Line":132}},{"line":232,"address":[],"length":0,"stats":{"Line":396}},{"line":235,"address":[],"length":0,"stats":{"Line":660}},{"line":236,"address":[],"length":0,"stats":{"Line":792}},{"line":237,"address":[],"length":0,"stats":{"Line":132}},{"line":238,"address":[],"length":0,"stats":{"Line":396}},{"line":241,"address":[],"length":0,"stats":{"Line":660}},{"line":242,"address":[],"length":0,"stats":{"Line":792}},{"line":243,"address":[],"length":0,"stats":{"Line":528}},{"line":246,"address":[],"length":0,"stats":{"Line":660}},{"line":247,"address":[],"length":0,"stats":{"Line":132}},{"line":248,"address":[],"length":0,"stats":{"Line":660}},{"line":249,"address":[],"length":0,"stats":{"Line":132}},{"line":250,"address":[],"length":0,"stats":{"Line":396}},{"line":253,"address":[],"length":0,"stats":{"Line":660}},{"line":254,"address":[],"length":0,"stats":{"Line":132}},{"line":255,"address":[],"length":0,"stats":{"Line":660}},{"line":256,"address":[],"length":0,"stats":{"Line":132}},{"line":257,"address":[],"length":0,"stats":{"Line":396}},{"line":260,"address":[],"length":0,"stats":{"Line":660}},{"line":261,"address":[],"length":0,"stats":{"Line":132}},{"line":262,"address":[],"length":0,"stats":{"Line":660}},{"line":263,"address":[],"length":0,"stats":{"Line":132}},{"line":264,"address":[],"length":0,"stats":{"Line":396}},{"line":267,"address":[],"length":0,"stats":{"Line":660}},{"line":268,"address":[],"length":0,"stats":{"Line":132}},{"line":269,"address":[],"length":0,"stats":{"Line":660}},{"line":270,"address":[],"length":0,"stats":{"Line":132}},{"line":271,"address":[],"length":0,"stats":{"Line":396}},{"line":274,"address":[],"length":0,"stats":{"Line":660}},{"line":275,"address":[],"length":0,"stats":{"Line":132}},{"line":276,"address":[],"length":0,"stats":{"Line":660}},{"line":277,"address":[],"length":0,"stats":{"Line":132}},{"line":278,"address":[],"length":0,"stats":{"Line":396}},{"line":281,"address":[],"length":0,"stats":{"Line":660}},{"line":282,"address":[],"length":0,"stats":{"Line":132}},{"line":283,"address":[],"length":0,"stats":{"Line":660}},{"line":284,"address":[],"length":0,"stats":{"Line":132}},{"line":285,"address":[],"length":0,"stats":{"Line":396}},{"line":288,"address":[],"length":0,"stats":{"Line":660}},{"line":289,"address":[],"length":0,"stats":{"Line":792}},{"line":290,"address":[],"length":0,"stats":{"Line":132}},{"line":291,"address":[],"length":0,"stats":{"Line":396}},{"line":294,"address":[],"length":0,"stats":{"Line":660}},{"line":295,"address":[],"length":0,"stats":{"Line":132}},{"line":296,"address":[],"length":0,"stats":{"Line":660}},{"line":297,"address":[],"length":0,"stats":{"Line":132}},{"line":298,"address":[],"length":0,"stats":{"Line":396}},{"line":301,"address":[],"length":0,"stats":{"Line":660}},{"line":302,"address":[],"length":0,"stats":{"Line":792}},{"line":303,"address":[],"length":0,"stats":{"Line":132}},{"line":304,"address":[],"length":0,"stats":{"Line":396}},{"line":307,"address":[],"length":0,"stats":{"Line":660}},{"line":308,"address":[],"length":0,"stats":{"Line":132}},{"line":309,"address":[],"length":0,"stats":{"Line":660}},{"line":310,"address":[],"length":0,"stats":{"Line":132}},{"line":311,"address":[],"length":0,"stats":{"Line":396}},{"line":314,"address":[],"length":0,"stats":{"Line":132}},{"line":315,"address":[],"length":0,"stats":{"Line":528}},{"line":316,"address":[],"length":0,"stats":{"Line":132}},{"line":317,"address":[],"length":0,"stats":{"Line":660}},{"line":318,"address":[],"length":0,"stats":{"Line":132}},{"line":319,"address":[],"length":0,"stats":{"Line":396}},{"line":322,"address":[],"length":0,"stats":{"Line":660}},{"line":323,"address":[],"length":0,"stats":{"Line":132}},{"line":324,"address":[],"length":0,"stats":{"Line":660}},{"line":325,"address":[],"length":0,"stats":{"Line":132}},{"line":326,"address":[],"length":0,"stats":{"Line":396}},{"line":329,"address":[],"length":0,"stats":{"Line":264}},{"line":331,"address":[],"length":0,"stats":{"Line":132}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":264}},{"line":340,"address":[],"length":0,"stats":{"Line":132}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":264}},{"line":355,"address":[],"length":0,"stats":{"Line":132}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":264}},{"line":367,"address":[],"length":0,"stats":{"Line":132}},{"line":369,"address":[],"length":0,"stats":{"Line":264}},{"line":371,"address":[],"length":0,"stats":{"Line":132}},{"line":373,"address":[],"length":0,"stats":{"Line":264}},{"line":375,"address":[],"length":0,"stats":{"Line":132}},{"line":377,"address":[],"length":0,"stats":{"Line":264}},{"line":379,"address":[],"length":0,"stats":{"Line":132}},{"line":381,"address":[],"length":0,"stats":{"Line":264}},{"line":383,"address":[],"length":0,"stats":{"Line":132}},{"line":385,"address":[],"length":0,"stats":{"Line":264}},{"line":387,"address":[],"length":0,"stats":{"Line":132}},{"line":389,"address":[],"length":0,"stats":{"Line":264}},{"line":391,"address":[],"length":0,"stats":{"Line":132}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":264}},{"line":401,"address":[],"length":0,"stats":{"Line":132}},{"line":405,"address":[],"length":0,"stats":{"Line":264}},{"line":407,"address":[],"length":0,"stats":{"Line":132}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":264}},{"line":423,"address":[],"length":0,"stats":{"Line":132}},{"line":427,"address":[],"length":0,"stats":{"Line":264}},{"line":429,"address":[],"length":0,"stats":{"Line":132}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":264}},{"line":450,"address":[],"length":0,"stats":{"Line":132}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":264}},{"line":467,"address":[],"length":0,"stats":{"Line":132}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":264}},{"line":484,"address":[],"length":0,"stats":{"Line":132}},{"line":486,"address":[],"length":0,"stats":{"Line":264}},{"line":488,"address":[],"length":0,"stats":{"Line":132}},{"line":492,"address":[],"length":0,"stats":{"Line":264}},{"line":494,"address":[],"length":0,"stats":{"Line":132}},{"line":499,"address":[],"length":0,"stats":{"Line":264}},{"line":501,"address":[],"length":0,"stats":{"Line":132}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":264}},{"line":570,"address":[],"length":0,"stats":{"Line":132}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":264}},{"line":646,"address":[],"length":0,"stats":{"Line":132}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":264}},{"line":713,"address":[],"length":0,"stats":{"Line":132}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":718,"address":[],"length":0,"stats":{"Line":264}},{"line":720,"address":[],"length":0,"stats":{"Line":132}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":264}},{"line":727,"address":[],"length":0,"stats":{"Line":132}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":264}},{"line":734,"address":[],"length":0,"stats":{"Line":133}},{"line":735,"address":[],"length":0,"stats":{"Line":6}},{"line":736,"address":[],"length":0,"stats":{"Line":1}},{"line":739,"address":[],"length":0,"stats":{"Line":264}},{"line":741,"address":[],"length":0,"stats":{"Line":133}},{"line":742,"address":[],"length":0,"stats":{"Line":6}},{"line":743,"address":[],"length":0,"stats":{"Line":1}},{"line":746,"address":[],"length":0,"stats":{"Line":264}},{"line":748,"address":[],"length":0,"stats":{"Line":133}},{"line":749,"address":[],"length":0,"stats":{"Line":6}},{"line":750,"address":[],"length":0,"stats":{"Line":1}},{"line":753,"address":[],"length":0,"stats":{"Line":264}},{"line":755,"address":[],"length":0,"stats":{"Line":133}},{"line":756,"address":[],"length":0,"stats":{"Line":6}},{"line":757,"address":[],"length":0,"stats":{"Line":1}},{"line":760,"address":[],"length":0,"stats":{"Line":264}},{"line":762,"address":[],"length":0,"stats":{"Line":138}},{"line":763,"address":[],"length":0,"stats":{"Line":2}},{"line":764,"address":[],"length":0,"stats":{"Line":4}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":264}},{"line":772,"address":[],"length":0,"stats":{"Line":133}},{"line":773,"address":[],"length":0,"stats":{"Line":6}},{"line":774,"address":[],"length":0,"stats":{"Line":1}},{"line":779,"address":[],"length":0,"stats":{"Line":264}},{"line":781,"address":[],"length":0,"stats":{"Line":133}},{"line":782,"address":[],"length":0,"stats":{"Line":6}},{"line":783,"address":[],"length":0,"stats":{"Line":6}},{"line":784,"address":[],"length":0,"stats":{"Line":3}},{"line":785,"address":[],"length":0,"stats":{"Line":3}},{"line":786,"address":[],"length":0,"stats":{"Line":4}},{"line":787,"address":[],"length":0,"stats":{"Line":1}},{"line":788,"address":[],"length":0,"stats":{"Line":1}},{"line":795,"address":[],"length":0,"stats":{"Line":264}},{"line":797,"address":[],"length":0,"stats":{"Line":133}},{"line":799,"address":[],"length":0,"stats":{"Line":2}},{"line":800,"address":[],"length":0,"stats":{"Line":1}},{"line":801,"address":[],"length":0,"stats":{"Line":2}},{"line":802,"address":[],"length":0,"stats":{"Line":1}},{"line":803,"address":[],"length":0,"stats":{"Line":5}},{"line":805,"address":[],"length":0,"stats":{"Line":4}},{"line":806,"address":[],"length":0,"stats":{"Line":2}},{"line":807,"address":[],"length":0,"stats":{"Line":2}},{"line":808,"address":[],"length":0,"stats":{"Line":1}},{"line":811,"address":[],"length":0,"stats":{"Line":1}},{"line":816,"address":[],"length":0,"stats":{"Line":264}},{"line":818,"address":[],"length":0,"stats":{"Line":132}},{"line":819,"address":[],"length":0,"stats":{"Line":0}},{"line":820,"address":[],"length":0,"stats":{"Line":0}},{"line":827,"address":[],"length":0,"stats":{"Line":264}},{"line":829,"address":[],"length":0,"stats":{"Line":132}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":832,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":836,"address":[],"length":0,"stats":{"Line":0}},{"line":837,"address":[],"length":0,"stats":{"Line":0}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":264}},{"line":846,"address":[],"length":0,"stats":{"Line":132}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":264}},{"line":863,"address":[],"length":0,"stats":{"Line":132}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":866,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}},{"line":881,"address":[],"length":0,"stats":{"Line":264}},{"line":883,"address":[],"length":0,"stats":{"Line":132}},{"line":884,"address":[],"length":0,"stats":{"Line":0}},{"line":885,"address":[],"length":0,"stats":{"Line":0}},{"line":886,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":894,"address":[],"length":0,"stats":{"Line":264}},{"line":896,"address":[],"length":0,"stats":{"Line":132}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":264}},{"line":905,"address":[],"length":0,"stats":{"Line":132}},{"line":907,"address":[],"length":0,"stats":{"Line":0}},{"line":912,"address":[],"length":0,"stats":{"Line":264}},{"line":914,"address":[],"length":0,"stats":{"Line":132}},{"line":915,"address":[],"length":0,"stats":{"Line":0}},{"line":916,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":920,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[],"length":0,"stats":{"Line":264}},{"line":932,"address":[],"length":0,"stats":{"Line":132}},{"line":933,"address":[],"length":0,"stats":{"Line":0}},{"line":934,"address":[],"length":0,"stats":{"Line":0}},{"line":936,"address":[],"length":0,"stats":{"Line":0}},{"line":937,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":941,"address":[],"length":0,"stats":{"Line":0}},{"line":942,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":944,"address":[],"length":0,"stats":{"Line":0}},{"line":945,"address":[],"length":0,"stats":{"Line":0}},{"line":946,"address":[],"length":0,"stats":{"Line":0}},{"line":949,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":952,"address":[],"length":0,"stats":{"Line":0}},{"line":954,"address":[],"length":0,"stats":{"Line":0}},{"line":959,"address":[],"length":0,"stats":{"Line":264}},{"line":961,"address":[],"length":0,"stats":{"Line":132}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":965,"address":[],"length":0,"stats":{"Line":0}},{"line":968,"address":[],"length":0,"stats":{"Line":0}},{"line":970,"address":[],"length":0,"stats":{"Line":0}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":972,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[],"length":0,"stats":{"Line":0}},{"line":977,"address":[],"length":0,"stats":{"Line":0}},{"line":983,"address":[],"length":0,"stats":{"Line":0}},{"line":988,"address":[],"length":0,"stats":{"Line":264}},{"line":990,"address":[],"length":0,"stats":{"Line":132}},{"line":991,"address":[],"length":0,"stats":{"Line":0}},{"line":992,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[],"length":0,"stats":{"Line":0}},{"line":995,"address":[],"length":0,"stats":{"Line":0}},{"line":996,"address":[],"length":0,"stats":{"Line":0}},{"line":997,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1004,"address":[],"length":0,"stats":{"Line":264}},{"line":1006,"address":[],"length":0,"stats":{"Line":132}},{"line":1008,"address":[],"length":0,"stats":{"Line":0}},{"line":1013,"address":[],"length":0,"stats":{"Line":264}},{"line":1015,"address":[],"length":0,"stats":{"Line":132}},{"line":1017,"address":[],"length":0,"stats":{"Line":0}},{"line":1022,"address":[],"length":0,"stats":{"Line":264}},{"line":1024,"address":[],"length":0,"stats":{"Line":132}},{"line":1028,"address":[],"length":0,"stats":{"Line":264}},{"line":1030,"address":[],"length":0,"stats":{"Line":132}},{"line":1031,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1033,"address":[],"length":0,"stats":{"Line":0}},{"line":1034,"address":[],"length":0,"stats":{"Line":0}},{"line":1035,"address":[],"length":0,"stats":{"Line":0}},{"line":1036,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":0}},{"line":1038,"address":[],"length":0,"stats":{"Line":0}},{"line":1040,"address":[],"length":0,"stats":{"Line":0}},{"line":1045,"address":[],"length":0,"stats":{"Line":264}},{"line":1047,"address":[],"length":0,"stats":{"Line":132}},{"line":1048,"address":[],"length":0,"stats":{"Line":0}},{"line":1049,"address":[],"length":0,"stats":{"Line":0}},{"line":1050,"address":[],"length":0,"stats":{"Line":0}},{"line":1051,"address":[],"length":0,"stats":{"Line":0}},{"line":1052,"address":[],"length":0,"stats":{"Line":0}},{"line":1053,"address":[],"length":0,"stats":{"Line":0}},{"line":1054,"address":[],"length":0,"stats":{"Line":0}},{"line":1055,"address":[],"length":0,"stats":{"Line":0}},{"line":1057,"address":[],"length":0,"stats":{"Line":0}},{"line":1062,"address":[],"length":0,"stats":{"Line":264}},{"line":1064,"address":[],"length":0,"stats":{"Line":132}},{"line":1066,"address":[],"length":0,"stats":{"Line":264}},{"line":1068,"address":[],"length":0,"stats":{"Line":132}},{"line":1070,"address":[],"length":0,"stats":{"Line":264}},{"line":1072,"address":[],"length":0,"stats":{"Line":132}},{"line":1076,"address":[],"length":0,"stats":{"Line":264}},{"line":1078,"address":[],"length":0,"stats":{"Line":132}},{"line":1082,"address":[],"length":0,"stats":{"Line":264}},{"line":1084,"address":[],"length":0,"stats":{"Line":132}},{"line":1088,"address":[],"length":0,"stats":{"Line":264}},{"line":1090,"address":[],"length":0,"stats":{"Line":132}},{"line":1091,"address":[],"length":0,"stats":{"Line":0}},{"line":1096,"address":[],"length":0,"stats":{"Line":264}},{"line":1098,"address":[],"length":0,"stats":{"Line":132}},{"line":1099,"address":[],"length":0,"stats":{"Line":0}},{"line":1100,"address":[],"length":0,"stats":{"Line":0}},{"line":1101,"address":[],"length":0,"stats":{"Line":0}},{"line":1102,"address":[],"length":0,"stats":{"Line":0}},{"line":1103,"address":[],"length":0,"stats":{"Line":0}},{"line":1104,"address":[],"length":0,"stats":{"Line":0}},{"line":1105,"address":[],"length":0,"stats":{"Line":0}},{"line":1106,"address":[],"length":0,"stats":{"Line":0}},{"line":1107,"address":[],"length":0,"stats":{"Line":0}},{"line":1108,"address":[],"length":0,"stats":{"Line":0}},{"line":1109,"address":[],"length":0,"stats":{"Line":0}},{"line":1110,"address":[],"length":0,"stats":{"Line":0}},{"line":1111,"address":[],"length":0,"stats":{"Line":0}},{"line":1112,"address":[],"length":0,"stats":{"Line":0}},{"line":1113,"address":[],"length":0,"stats":{"Line":0}},{"line":1115,"address":[],"length":0,"stats":{"Line":0}},{"line":1120,"address":[],"length":0,"stats":{"Line":264}},{"line":1122,"address":[],"length":0,"stats":{"Line":132}},{"line":1127,"address":[],"length":0,"stats":{"Line":2378}},{"line":1128,"address":[],"length":0,"stats":{"Line":4756}},{"line":1129,"address":[],"length":0,"stats":{"Line":7134}},{"line":1130,"address":[],"length":0,"stats":{"Line":4756}},{"line":1131,"address":[],"length":0,"stats":{"Line":4756}},{"line":1132,"address":[],"length":0,"stats":{"Line":4756}},{"line":1133,"address":[],"length":0,"stats":{"Line":4756}},{"line":1134,"address":[],"length":0,"stats":{"Line":4756}},{"line":1135,"address":[],"length":0,"stats":{"Line":2378}},{"line":1136,"address":[],"length":0,"stats":{"Line":4756}},{"line":1137,"address":[],"length":0,"stats":{"Line":7134}},{"line":1138,"address":[],"length":0,"stats":{"Line":4756}},{"line":1139,"address":[],"length":0,"stats":{"Line":2378}},{"line":1140,"address":[],"length":0,"stats":{"Line":2378}},{"line":1146,"address":[],"length":0,"stats":{"Line":132}},{"line":1148,"address":[],"length":0,"stats":{"Line":264}},{"line":1150,"address":[],"length":0,"stats":{"Line":132}},{"line":1151,"address":[],"length":0,"stats":{"Line":0}},{"line":1156,"address":[],"length":0,"stats":{"Line":264}},{"line":1158,"address":[],"length":0,"stats":{"Line":132}},{"line":1159,"address":[],"length":0,"stats":{"Line":0}},{"line":1160,"address":[],"length":0,"stats":{"Line":0}},{"line":1165,"address":[],"length":0,"stats":{"Line":264}},{"line":1167,"address":[],"length":0,"stats":{"Line":132}},{"line":1168,"address":[],"length":0,"stats":{"Line":0}},{"line":1169,"address":[],"length":0,"stats":{"Line":0}},{"line":1174,"address":[],"length":0,"stats":{"Line":264}},{"line":1176,"address":[],"length":0,"stats":{"Line":132}},{"line":1177,"address":[],"length":0,"stats":{"Line":0}},{"line":1178,"address":[],"length":0,"stats":{"Line":0}},{"line":1183,"address":[],"length":0,"stats":{"Line":264}},{"line":1185,"address":[],"length":0,"stats":{"Line":132}},{"line":1186,"address":[],"length":0,"stats":{"Line":0}},{"line":1187,"address":[],"length":0,"stats":{"Line":0}},{"line":1188,"address":[],"length":0,"stats":{"Line":0}},{"line":1189,"address":[],"length":0,"stats":{"Line":0}},{"line":1190,"address":[],"length":0,"stats":{"Line":0}},{"line":1191,"address":[],"length":0,"stats":{"Line":0}},{"line":1192,"address":[],"length":0,"stats":{"Line":0}},{"line":1193,"address":[],"length":0,"stats":{"Line":0}},{"line":1199,"address":[],"length":0,"stats":{"Line":108}},{"line":1202,"address":[],"length":0,"stats":{"Line":108}},{"line":1203,"address":[],"length":0,"stats":{"Line":108}},{"line":1204,"address":[],"length":0,"stats":{"Line":108}},{"line":1205,"address":[],"length":0,"stats":{"Line":120}},{"line":1206,"address":[],"length":0,"stats":{"Line":108}},{"line":1209,"address":[],"length":0,"stats":{"Line":216}},{"line":1211,"address":[],"length":0,"stats":{"Line":484}},{"line":1212,"address":[],"length":0,"stats":{"Line":756}},{"line":1216,"address":[],"length":0,"stats":{"Line":212}},{"line":1218,"address":[],"length":0,"stats":{"Line":106}},{"line":1222,"address":[],"length":0,"stats":{"Line":404}},{"line":1223,"address":[],"length":0,"stats":{"Line":404}},{"line":1224,"address":[],"length":0,"stats":{"Line":568}},{"line":1225,"address":[],"length":0,"stats":{"Line":0}},{"line":1226,"address":[],"length":0,"stats":{"Line":0}},{"line":1227,"address":[],"length":0,"stats":{"Line":0}},{"line":1229,"address":[],"length":0,"stats":{"Line":0}},{"line":1231,"address":[],"length":0,"stats":{"Line":68}},{"line":1232,"address":[],"length":0,"stats":{"Line":36}},{"line":1233,"address":[],"length":0,"stats":{"Line":320}},{"line":1234,"address":[],"length":0,"stats":{"Line":280}},{"line":1235,"address":[],"length":0,"stats":{"Line":164}},{"line":1236,"address":[],"length":0,"stats":{"Line":8}},{"line":1237,"address":[],"length":0,"stats":{"Line":16}},{"line":1238,"address":[],"length":0,"stats":{"Line":8}},{"line":1239,"address":[],"length":0,"stats":{"Line":12}},{"line":1240,"address":[],"length":0,"stats":{"Line":70}},{"line":1241,"address":[],"length":0,"stats":{"Line":6}},{"line":1242,"address":[],"length":0,"stats":{"Line":12}},{"line":1243,"address":[],"length":0,"stats":{"Line":6}},{"line":1245,"address":[],"length":0,"stats":{"Line":9}},{"line":1246,"address":[],"length":0,"stats":{"Line":18}},{"line":1247,"address":[],"length":0,"stats":{"Line":9}},{"line":1249,"address":[],"length":0,"stats":{"Line":0}},{"line":1250,"address":[],"length":0,"stats":{"Line":0}},{"line":1251,"address":[],"length":0,"stats":{"Line":0}},{"line":1253,"address":[],"length":0,"stats":{"Line":8}},{"line":1254,"address":[],"length":0,"stats":{"Line":12}},{"line":1255,"address":[],"length":0,"stats":{"Line":0}},{"line":1260,"address":[],"length":0,"stats":{"Line":142}},{"line":1261,"address":[],"length":0,"stats":{"Line":423}},{"line":1262,"address":[],"length":0,"stats":{"Line":429}},{"line":1264,"address":[],"length":0,"stats":{"Line":0}},{"line":1266,"address":[],"length":0,"stats":{"Line":556}},{"line":1267,"address":[],"length":0,"stats":{"Line":139}},{"line":1271,"address":[],"length":0,"stats":{"Line":17}},{"line":1273,"address":[],"length":0,"stats":{"Line":51}},{"line":1275,"address":[],"length":0,"stats":{"Line":51}},{"line":1278,"address":[],"length":0,"stats":{"Line":34}},{"line":1279,"address":[],"length":0,"stats":{"Line":0}},{"line":1282,"address":[],"length":0,"stats":{"Line":68}},{"line":1283,"address":[],"length":0,"stats":{"Line":68}},{"line":1286,"address":[],"length":0,"stats":{"Line":0}},{"line":1289,"address":[],"length":0,"stats":{"Line":34}},{"line":1290,"address":[],"length":0,"stats":{"Line":34}},{"line":1291,"address":[],"length":0,"stats":{"Line":34}},{"line":1294,"address":[],"length":0,"stats":{"Line":55}},{"line":1295,"address":[],"length":0,"stats":{"Line":19}},{"line":1296,"address":[],"length":0,"stats":{"Line":30}},{"line":1297,"address":[],"length":0,"stats":{"Line":60}},{"line":1298,"address":[],"length":0,"stats":{"Line":60}},{"line":1299,"address":[],"length":0,"stats":{"Line":60}},{"line":1300,"address":[],"length":0,"stats":{"Line":60}},{"line":1301,"address":[],"length":0,"stats":{"Line":45}},{"line":1302,"address":[],"length":0,"stats":{"Line":45}},{"line":1304,"address":[],"length":0,"stats":{"Line":60}},{"line":1306,"address":[],"length":0,"stats":{"Line":0}},{"line":1307,"address":[],"length":0,"stats":{"Line":0}},{"line":1308,"address":[],"length":0,"stats":{"Line":0}},{"line":1309,"address":[],"length":0,"stats":{"Line":0}},{"line":1310,"address":[],"length":0,"stats":{"Line":0}},{"line":1311,"address":[],"length":0,"stats":{"Line":0}},{"line":1312,"address":[],"length":0,"stats":{"Line":0}},{"line":1314,"address":[],"length":0,"stats":{"Line":0}},{"line":1316,"address":[],"length":0,"stats":{"Line":4}},{"line":1317,"address":[],"length":0,"stats":{"Line":8}},{"line":1318,"address":[],"length":0,"stats":{"Line":0}},{"line":1319,"address":[],"length":0,"stats":{"Line":0}},{"line":1321,"address":[],"length":0,"stats":{"Line":0}},{"line":1323,"address":[],"length":0,"stats":{"Line":0}},{"line":1326,"address":[],"length":0,"stats":{"Line":0}},{"line":1332,"address":[],"length":0,"stats":{"Line":51}},{"line":1333,"address":[],"length":0,"stats":{"Line":51}},{"line":1334,"address":[],"length":0,"stats":{"Line":51}},{"line":1335,"address":[],"length":0,"stats":{"Line":34}},{"line":1336,"address":[],"length":0,"stats":{"Line":34}},{"line":1337,"address":[],"length":0,"stats":{"Line":34}},{"line":1338,"address":[],"length":0,"stats":{"Line":34}},{"line":1339,"address":[],"length":0,"stats":{"Line":17}},{"line":1343,"address":[],"length":0,"stats":{"Line":102}},{"line":1346,"address":[],"length":0,"stats":{"Line":34}},{"line":1347,"address":[],"length":0,"stats":{"Line":85}},{"line":1349,"address":[],"length":0,"stats":{"Line":68}},{"line":1351,"address":[],"length":0,"stats":{"Line":17}},{"line":1355,"address":[],"length":0,"stats":{"Line":9}},{"line":1356,"address":[],"length":0,"stats":{"Line":27}},{"line":1357,"address":[],"length":0,"stats":{"Line":27}},{"line":1358,"address":[],"length":0,"stats":{"Line":27}},{"line":1359,"address":[],"length":0,"stats":{"Line":18}},{"line":1360,"address":[],"length":0,"stats":{"Line":9}},{"line":1361,"address":[],"length":0,"stats":{"Line":9}},{"line":1363,"address":[],"length":0,"stats":{"Line":36}},{"line":1364,"address":[],"length":0,"stats":{"Line":9}},{"line":1368,"address":[],"length":0,"stats":{"Line":96}},{"line":1369,"address":[],"length":0,"stats":{"Line":192}},{"line":1370,"address":[],"length":0,"stats":{"Line":192}},{"line":1372,"address":[],"length":0,"stats":{"Line":331}},{"line":1373,"address":[],"length":0,"stats":{"Line":276}},{"line":1374,"address":[],"length":0,"stats":{"Line":194}},{"line":1375,"address":[],"length":0,"stats":{"Line":41}},{"line":1376,"address":[],"length":0,"stats":{"Line":82}},{"line":1377,"address":[],"length":0,"stats":{"Line":41}},{"line":1382,"address":[],"length":0,"stats":{"Line":110}},{"line":1383,"address":[],"length":0,"stats":{"Line":55}},{"line":1387,"address":[],"length":0,"stats":{"Line":41}},{"line":1388,"address":[],"length":0,"stats":{"Line":164}},{"line":1389,"address":[],"length":0,"stats":{"Line":82}},{"line":1390,"address":[],"length":0,"stats":{"Line":45}},{"line":1391,"address":[],"length":0,"stats":{"Line":27}},{"line":1392,"address":[],"length":0,"stats":{"Line":3}},{"line":1394,"address":[],"length":0,"stats":{"Line":25}},{"line":1399,"address":[],"length":0,"stats":{"Line":2}},{"line":1401,"address":[],"length":0,"stats":{"Line":4}},{"line":1402,"address":[],"length":0,"stats":{"Line":4}},{"line":1404,"address":[],"length":0,"stats":{"Line":11}},{"line":1405,"address":[],"length":0,"stats":{"Line":11}},{"line":1408,"address":[],"length":0,"stats":{"Line":0}},{"line":1410,"address":[],"length":0,"stats":{"Line":44}},{"line":1411,"address":[],"length":0,"stats":{"Line":11}},{"line":1412,"address":[],"length":0,"stats":{"Line":1}},{"line":1414,"address":[],"length":0,"stats":{"Line":30}},{"line":1415,"address":[],"length":0,"stats":{"Line":18}},{"line":1416,"address":[],"length":0,"stats":{"Line":3}},{"line":1417,"address":[],"length":0,"stats":{"Line":0}},{"line":1418,"address":[],"length":0,"stats":{"Line":0}},{"line":1421,"address":[],"length":0,"stats":{"Line":2}},{"line":1425,"address":[],"length":0,"stats":{"Line":4}},{"line":1427,"address":[],"length":0,"stats":{"Line":8}},{"line":1428,"address":[],"length":0,"stats":{"Line":8}},{"line":1430,"address":[],"length":0,"stats":{"Line":14}},{"line":1431,"address":[],"length":0,"stats":{"Line":14}},{"line":1433,"address":[],"length":0,"stats":{"Line":0}},{"line":1435,"address":[],"length":0,"stats":{"Line":42}},{"line":1436,"address":[],"length":0,"stats":{"Line":22}},{"line":1437,"address":[],"length":0,"stats":{"Line":7}},{"line":1438,"address":[],"length":0,"stats":{"Line":6}},{"line":1439,"address":[],"length":0,"stats":{"Line":0}},{"line":1441,"address":[],"length":0,"stats":{"Line":52}},{"line":1442,"address":[],"length":0,"stats":{"Line":13}},{"line":1443,"address":[],"length":0,"stats":{"Line":3}},{"line":1446,"address":[],"length":0,"stats":{"Line":4}},{"line":1450,"address":[],"length":0,"stats":{"Line":2}},{"line":1452,"address":[],"length":0,"stats":{"Line":4}},{"line":1455,"address":[],"length":0,"stats":{"Line":4}},{"line":1456,"address":[],"length":0,"stats":{"Line":6}},{"line":1459,"address":[],"length":0,"stats":{"Line":4}},{"line":1460,"address":[],"length":0,"stats":{"Line":4}},{"line":1462,"address":[],"length":0,"stats":{"Line":17}},{"line":1463,"address":[],"length":0,"stats":{"Line":17}},{"line":1465,"address":[],"length":0,"stats":{"Line":0}},{"line":1469,"address":[],"length":0,"stats":{"Line":34}},{"line":1470,"address":[],"length":0,"stats":{"Line":68}},{"line":1471,"address":[],"length":0,"stats":{"Line":17}},{"line":1472,"address":[],"length":0,"stats":{"Line":2}},{"line":1477,"address":[],"length":0,"stats":{"Line":45}},{"line":1478,"address":[],"length":0,"stats":{"Line":20}},{"line":1479,"address":[],"length":0,"stats":{"Line":10}},{"line":1480,"address":[],"length":0,"stats":{"Line":15}},{"line":1481,"address":[],"length":0,"stats":{"Line":0}},{"line":1482,"address":[],"length":0,"stats":{"Line":0}},{"line":1483,"address":[],"length":0,"stats":{"Line":0}},{"line":1488,"address":[],"length":0,"stats":{"Line":30}},{"line":1489,"address":[],"length":0,"stats":{"Line":45}},{"line":1493,"address":[],"length":0,"stats":{"Line":4}},{"line":1494,"address":[],"length":0,"stats":{"Line":2}},{"line":1498,"address":[],"length":0,"stats":{"Line":3}},{"line":1499,"address":[],"length":0,"stats":{"Line":12}},{"line":1500,"address":[],"length":0,"stats":{"Line":6}},{"line":1501,"address":[],"length":0,"stats":{"Line":6}},{"line":1502,"address":[],"length":0,"stats":{"Line":0}},{"line":1505,"address":[],"length":0,"stats":{"Line":0}},{"line":1507,"address":[],"length":0,"stats":{"Line":0}},{"line":1508,"address":[],"length":0,"stats":{"Line":0}},{"line":1510,"address":[],"length":0,"stats":{"Line":0}},{"line":1512,"address":[],"length":0,"stats":{"Line":0}},{"line":1515,"address":[],"length":0,"stats":{"Line":6}},{"line":1516,"address":[],"length":0,"stats":{"Line":6}},{"line":1518,"address":[],"length":0,"stats":{"Line":28}},{"line":1519,"address":[],"length":0,"stats":{"Line":52}},{"line":1520,"address":[],"length":0,"stats":{"Line":39}},{"line":1521,"address":[],"length":0,"stats":{"Line":20}},{"line":1522,"address":[],"length":0,"stats":{"Line":7}},{"line":1523,"address":[],"length":0,"stats":{"Line":6}},{"line":1524,"address":[],"length":0,"stats":{"Line":0}},{"line":1525,"address":[],"length":0,"stats":{"Line":0}},{"line":1526,"address":[],"length":0,"stats":{"Line":0}},{"line":1531,"address":[],"length":0,"stats":{"Line":6}},{"line":1532,"address":[],"length":0,"stats":{"Line":3}},{"line":1536,"address":[],"length":0,"stats":{"Line":14}},{"line":1537,"address":[],"length":0,"stats":{"Line":42}},{"line":1538,"address":[],"length":0,"stats":{"Line":42}},{"line":1540,"address":[],"length":0,"stats":{"Line":0}},{"line":1542,"address":[],"length":0,"stats":{"Line":14}},{"line":1543,"address":[],"length":0,"stats":{"Line":28}},{"line":1544,"address":[],"length":0,"stats":{"Line":14}},{"line":1549,"address":[],"length":0,"stats":{"Line":2}},{"line":1550,"address":[],"length":0,"stats":{"Line":6}},{"line":1551,"address":[],"length":0,"stats":{"Line":1}},{"line":1552,"address":[],"length":0,"stats":{"Line":2}},{"line":1553,"address":[],"length":0,"stats":{"Line":3}},{"line":1555,"address":[],"length":0,"stats":{"Line":1}},{"line":1557,"address":[],"length":0,"stats":{"Line":1}},{"line":1558,"address":[],"length":0,"stats":{"Line":0}},{"line":1559,"address":[],"length":0,"stats":{"Line":1}},{"line":1563,"address":[],"length":0,"stats":{"Line":2}},{"line":1564,"address":[],"length":0,"stats":{"Line":2}},{"line":1565,"address":[],"length":0,"stats":{"Line":3}},{"line":1566,"address":[],"length":0,"stats":{"Line":2}},{"line":1567,"address":[],"length":0,"stats":{"Line":4}},{"line":1569,"address":[],"length":0,"stats":{"Line":4}},{"line":1570,"address":[],"length":0,"stats":{"Line":2}},{"line":1572,"address":[],"length":0,"stats":{"Line":1}},{"line":1573,"address":[],"length":0,"stats":{"Line":0}},{"line":1575,"address":[],"length":0,"stats":{"Line":1}},{"line":1577,"address":[],"length":0,"stats":{"Line":0}},{"line":1578,"address":[],"length":0,"stats":{"Line":0}},{"line":1580,"address":[],"length":0,"stats":{"Line":0}},{"line":1583,"address":[],"length":0,"stats":{"Line":0}},{"line":1584,"address":[],"length":0,"stats":{"Line":0}},{"line":1585,"address":[],"length":0,"stats":{"Line":0}},{"line":1587,"address":[],"length":0,"stats":{"Line":0}},{"line":1593,"address":[],"length":0,"stats":{"Line":3}},{"line":1594,"address":[],"length":0,"stats":{"Line":12}},{"line":1595,"address":[],"length":0,"stats":{"Line":6}},{"line":1596,"address":[],"length":0,"stats":{"Line":6}},{"line":1597,"address":[],"length":0,"stats":{"Line":6}},{"line":1600,"address":[],"length":0,"stats":{"Line":18}},{"line":1601,"address":[],"length":0,"stats":{"Line":12}},{"line":1602,"address":[],"length":0,"stats":{"Line":1}},{"line":1603,"address":[],"length":0,"stats":{"Line":1}},{"line":1605,"address":[],"length":0,"stats":{"Line":10}},{"line":1606,"address":[],"length":0,"stats":{"Line":20}},{"line":1607,"address":[],"length":0,"stats":{"Line":15}},{"line":1608,"address":[],"length":0,"stats":{"Line":2}},{"line":1610,"address":[],"length":0,"stats":{"Line":5}},{"line":1611,"address":[],"length":0,"stats":{"Line":11}},{"line":1612,"address":[],"length":0,"stats":{"Line":15}},{"line":1613,"address":[],"length":0,"stats":{"Line":6}},{"line":1614,"address":[],"length":0,"stats":{"Line":6}},{"line":1615,"address":[],"length":0,"stats":{"Line":0}},{"line":1619,"address":[],"length":0,"stats":{"Line":0}},{"line":1625,"address":[],"length":0,"stats":{"Line":1}},{"line":1626,"address":[],"length":0,"stats":{"Line":2}},{"line":1627,"address":[],"length":0,"stats":{"Line":2}},{"line":1628,"address":[],"length":0,"stats":{"Line":4}},{"line":1629,"address":[],"length":0,"stats":{"Line":6}},{"line":1630,"address":[],"length":0,"stats":{"Line":2}},{"line":1631,"address":[],"length":0,"stats":{"Line":3}},{"line":1632,"address":[],"length":0,"stats":{"Line":0}},{"line":1639,"address":[],"length":0,"stats":{"Line":0}},{"line":1643,"address":[],"length":0,"stats":{"Line":1057}},{"line":1645,"address":[],"length":0,"stats":{"Line":1057}},{"line":1646,"address":[],"length":0,"stats":{"Line":1057}},{"line":1647,"address":[],"length":0,"stats":{"Line":0}},{"line":1649,"address":[],"length":0,"stats":{"Line":1057}},{"line":1650,"address":[],"length":0,"stats":{"Line":708}},{"line":1651,"address":[],"length":0,"stats":{"Line":50}},{"line":1652,"address":[],"length":0,"stats":{"Line":39}},{"line":1653,"address":[],"length":0,"stats":{"Line":48}},{"line":1654,"address":[],"length":0,"stats":{"Line":14}},{"line":1655,"address":[],"length":0,"stats":{"Line":4}},{"line":1656,"address":[],"length":0,"stats":{"Line":0}},{"line":1657,"address":[],"length":0,"stats":{"Line":956}},{"line":1658,"address":[],"length":0,"stats":{"Line":0}},{"line":1659,"address":[],"length":0,"stats":{"Line":60}},{"line":1660,"address":[],"length":0,"stats":{"Line":0}},{"line":1661,"address":[],"length":0,"stats":{"Line":888}},{"line":1662,"address":[],"length":0,"stats":{"Line":48}},{"line":1663,"address":[],"length":0,"stats":{"Line":8}},{"line":1664,"address":[],"length":0,"stats":{"Line":328}},{"line":1665,"address":[],"length":0,"stats":{"Line":208}},{"line":1666,"address":[],"length":0,"stats":{"Line":24}},{"line":1667,"address":[],"length":0,"stats":{"Line":0}},{"line":1668,"address":[],"length":0,"stats":{"Line":0}},{"line":1669,"address":[],"length":0,"stats":{"Line":0}},{"line":1670,"address":[],"length":0,"stats":{"Line":12}},{"line":1674,"address":[],"length":0,"stats":{"Line":2}},{"line":1675,"address":[],"length":0,"stats":{"Line":2}},{"line":1677,"address":[],"length":0,"stats":{"Line":2}},{"line":1678,"address":[],"length":0,"stats":{"Line":2}},{"line":1681,"address":[],"length":0,"stats":{"Line":239}},{"line":1683,"address":[],"length":0,"stats":{"Line":716}},{"line":1684,"address":[],"length":0,"stats":{"Line":238}},{"line":1688,"address":[],"length":0,"stats":{"Line":1}},{"line":1689,"address":[],"length":0,"stats":{"Line":0}},{"line":1690,"address":[],"length":0,"stats":{"Line":0}},{"line":1694,"address":[],"length":0,"stats":{"Line":2}},{"line":1695,"address":[],"length":0,"stats":{"Line":1}},{"line":1696,"address":[],"length":0,"stats":{"Line":1}},{"line":1700,"address":[],"length":0,"stats":{"Line":0}},{"line":1702,"address":[],"length":0,"stats":{"Line":0}},{"line":1703,"address":[],"length":0,"stats":{"Line":0}},{"line":1704,"address":[],"length":0,"stats":{"Line":0}},{"line":1705,"address":[],"length":0,"stats":{"Line":0}},{"line":1706,"address":[],"length":0,"stats":{"Line":0}},{"line":1709,"address":[],"length":0,"stats":{"Line":15}},{"line":1710,"address":[],"length":0,"stats":{"Line":231}},{"line":1711,"address":[],"length":0,"stats":{"Line":45}},{"line":1714,"address":[],"length":0,"stats":{"Line":222}},{"line":1715,"address":[],"length":0,"stats":{"Line":888}},{"line":1716,"address":[],"length":0,"stats":{"Line":888}},{"line":1718,"address":[],"length":0,"stats":{"Line":222}},{"line":1719,"address":[],"length":0,"stats":{"Line":320}},{"line":1720,"address":[],"length":0,"stats":{"Line":28}},{"line":1721,"address":[],"length":0,"stats":{"Line":40}},{"line":1722,"address":[],"length":0,"stats":{"Line":16}},{"line":1723,"address":[],"length":0,"stats":{"Line":92}},{"line":1724,"address":[],"length":0,"stats":{"Line":44}},{"line":1725,"address":[],"length":0,"stats":{"Line":4}},{"line":1726,"address":[],"length":0,"stats":{"Line":214}},{"line":1727,"address":[],"length":0,"stats":{"Line":36}},{"line":1728,"address":[],"length":0,"stats":{"Line":64}},{"line":1729,"address":[],"length":0,"stats":{"Line":54}},{"line":1730,"address":[],"length":0,"stats":{"Line":10}},{"line":1731,"address":[],"length":0,"stats":{"Line":10}},{"line":1732,"address":[],"length":0,"stats":{"Line":6}},{"line":1733,"address":[],"length":0,"stats":{"Line":6}},{"line":1734,"address":[],"length":0,"stats":{"Line":6}},{"line":1735,"address":[],"length":0,"stats":{"Line":6}},{"line":1736,"address":[],"length":0,"stats":{"Line":6}},{"line":1737,"address":[],"length":0,"stats":{"Line":5}},{"line":1738,"address":[],"length":0,"stats":{"Line":0}},{"line":1739,"address":[],"length":0,"stats":{"Line":0}},{"line":1740,"address":[],"length":0,"stats":{"Line":0}},{"line":1744,"address":[],"length":0,"stats":{"Line":81}},{"line":1745,"address":[],"length":0,"stats":{"Line":162}},{"line":1746,"address":[],"length":0,"stats":{"Line":222}},{"line":1747,"address":[],"length":0,"stats":{"Line":0}},{"line":1748,"address":[],"length":0,"stats":{"Line":3}},{"line":1749,"address":[],"length":0,"stats":{"Line":0}},{"line":1751,"address":[],"length":0,"stats":{"Line":2}},{"line":1752,"address":[],"length":0,"stats":{"Line":0}},{"line":1753,"address":[],"length":0,"stats":{"Line":2}},{"line":1754,"address":[],"length":0,"stats":{"Line":0}},{"line":1755,"address":[],"length":0,"stats":{"Line":0}},{"line":1756,"address":[],"length":0,"stats":{"Line":4}},{"line":1757,"address":[],"length":0,"stats":{"Line":4}},{"line":1759,"address":[],"length":0,"stats":{"Line":5}},{"line":1760,"address":[],"length":0,"stats":{"Line":2}},{"line":1761,"address":[],"length":0,"stats":{"Line":1}},{"line":1762,"address":[],"length":0,"stats":{"Line":1}},{"line":1764,"address":[],"length":0,"stats":{"Line":5}},{"line":1765,"address":[],"length":0,"stats":{"Line":2}},{"line":1766,"address":[],"length":0,"stats":{"Line":1}},{"line":1767,"address":[],"length":0,"stats":{"Line":1}},{"line":1769,"address":[],"length":0,"stats":{"Line":0}},{"line":1770,"address":[],"length":0,"stats":{"Line":0}},{"line":1771,"address":[],"length":0,"stats":{"Line":0}},{"line":1772,"address":[],"length":0,"stats":{"Line":0}},{"line":1777,"address":[],"length":0,"stats":{"Line":8}},{"line":1778,"address":[],"length":0,"stats":{"Line":16}},{"line":1779,"address":[],"length":0,"stats":{"Line":18}},{"line":1780,"address":[],"length":0,"stats":{"Line":0}},{"line":1781,"address":[],"length":0,"stats":{"Line":0}},{"line":1782,"address":[],"length":0,"stats":{"Line":0}},{"line":1784,"address":[],"length":0,"stats":{"Line":2}},{"line":1785,"address":[],"length":0,"stats":{"Line":0}},{"line":1786,"address":[],"length":0,"stats":{"Line":2}},{"line":1787,"address":[],"length":0,"stats":{"Line":0}},{"line":1788,"address":[],"length":0,"stats":{"Line":0}},{"line":1789,"address":[],"length":0,"stats":{"Line":0}},{"line":1793,"address":[],"length":0,"stats":{"Line":11}},{"line":1794,"address":[],"length":0,"stats":{"Line":22}},{"line":1795,"address":[],"length":0,"stats":{"Line":27}},{"line":1796,"address":[],"length":0,"stats":{"Line":3}},{"line":1797,"address":[],"length":0,"stats":{"Line":0}},{"line":1798,"address":[],"length":0,"stats":{"Line":0}},{"line":1800,"address":[],"length":0,"stats":{"Line":1}},{"line":1801,"address":[],"length":0,"stats":{"Line":0}},{"line":1805,"address":[],"length":0,"stats":{"Line":5}},{"line":1806,"address":[],"length":0,"stats":{"Line":10}},{"line":1807,"address":[],"length":0,"stats":{"Line":6}},{"line":1808,"address":[],"length":0,"stats":{"Line":3}},{"line":1809,"address":[],"length":0,"stats":{"Line":1}},{"line":1811,"address":[],"length":0,"stats":{"Line":2}},{"line":1813,"address":[],"length":0,"stats":{"Line":3}},{"line":1814,"address":[],"length":0,"stats":{"Line":0}},{"line":1815,"address":[],"length":0,"stats":{"Line":0}},{"line":1817,"address":[],"length":0,"stats":{"Line":1}},{"line":1818,"address":[],"length":0,"stats":{"Line":0}},{"line":1819,"address":[],"length":0,"stats":{"Line":0}},{"line":1820,"address":[],"length":0,"stats":{"Line":0}},{"line":1824,"address":[],"length":0,"stats":{"Line":23}},{"line":1825,"address":[],"length":0,"stats":{"Line":46}},{"line":1826,"address":[],"length":0,"stats":{"Line":44}},{"line":1827,"address":[],"length":0,"stats":{"Line":22}},{"line":1828,"address":[],"length":0,"stats":{"Line":1}},{"line":1830,"address":[],"length":0,"stats":{"Line":21}},{"line":1832,"address":[],"length":0,"stats":{"Line":3}},{"line":1833,"address":[],"length":0,"stats":{"Line":0}},{"line":1837,"address":[],"length":0,"stats":{"Line":62}},{"line":1842,"address":[],"length":0,"stats":{"Line":244}},{"line":1843,"address":[],"length":0,"stats":{"Line":2}},{"line":1845,"address":[],"length":0,"stats":{"Line":120}},{"line":1847,"address":[],"length":0,"stats":{"Line":60}},{"line":1848,"address":[],"length":0,"stats":{"Line":120}},{"line":1850,"address":[],"length":0,"stats":{"Line":60}},{"line":1851,"address":[],"length":0,"stats":{"Line":120}},{"line":1854,"address":[],"length":0,"stats":{"Line":6}},{"line":1858,"address":[],"length":0,"stats":{"Line":12}},{"line":1860,"address":[],"length":0,"stats":{"Line":6}},{"line":1861,"address":[],"length":0,"stats":{"Line":12}},{"line":1863,"address":[],"length":0,"stats":{"Line":6}},{"line":1864,"address":[],"length":0,"stats":{"Line":12}},{"line":1867,"address":[],"length":0,"stats":{"Line":0}},{"line":1869,"address":[],"length":0,"stats":{"Line":0}},{"line":1870,"address":[],"length":0,"stats":{"Line":0}},{"line":1871,"address":[],"length":0,"stats":{"Line":0}},{"line":1873,"address":[],"length":0,"stats":{"Line":0}},{"line":1875,"address":[],"length":0,"stats":{"Line":0}},{"line":1876,"address":[],"length":0,"stats":{"Line":0}},{"line":1877,"address":[],"length":0,"stats":{"Line":0}},{"line":1879,"address":[],"length":0,"stats":{"Line":0}},{"line":1881,"address":[],"length":0,"stats":{"Line":0}},{"line":1883,"address":[],"length":0,"stats":{"Line":0}},{"line":1884,"address":[],"length":0,"stats":{"Line":0}},{"line":1886,"address":[],"length":0,"stats":{"Line":0}},{"line":1890,"address":[],"length":0,"stats":{"Line":12}},{"line":1891,"address":[],"length":0,"stats":{"Line":48}},{"line":1892,"address":[],"length":0,"stats":{"Line":12}},{"line":1893,"address":[],"length":0,"stats":{"Line":7}},{"line":1894,"address":[],"length":0,"stats":{"Line":8}},{"line":1895,"address":[],"length":0,"stats":{"Line":4}},{"line":1896,"address":[],"length":0,"stats":{"Line":1}},{"line":1897,"address":[],"length":0,"stats":{"Line":0}},{"line":1899,"address":[],"length":0,"stats":{"Line":0}},{"line":1900,"address":[],"length":0,"stats":{"Line":3}},{"line":1902,"address":[],"length":0,"stats":{"Line":0}},{"line":1904,"address":[],"length":0,"stats":{"Line":0}},{"line":1905,"address":[],"length":0,"stats":{"Line":0}},{"line":1907,"address":[],"length":0,"stats":{"Line":0}},{"line":1910,"address":[],"length":0,"stats":{"Line":0}},{"line":1911,"address":[],"length":0,"stats":{"Line":0}},{"line":1912,"address":[],"length":0,"stats":{"Line":0}},{"line":1917,"address":[],"length":0,"stats":{"Line":4}},{"line":1919,"address":[],"length":0,"stats":{"Line":2}},{"line":1920,"address":[],"length":0,"stats":{"Line":2}},{"line":1923,"address":[],"length":0,"stats":{"Line":0}},{"line":1925,"address":[],"length":0,"stats":{"Line":0}},{"line":1926,"address":[],"length":0,"stats":{"Line":0}},{"line":1931,"address":[],"length":0,"stats":{"Line":2}},{"line":1932,"address":[],"length":0,"stats":{"Line":8}},{"line":1933,"address":[],"length":0,"stats":{"Line":4}},{"line":1934,"address":[],"length":0,"stats":{"Line":3}},{"line":1936,"address":[],"length":0,"stats":{"Line":3}},{"line":1940,"address":[],"length":0,"stats":{"Line":82}},{"line":1941,"address":[],"length":0,"stats":{"Line":328}},{"line":1944,"address":[],"length":0,"stats":{"Line":164}},{"line":1945,"address":[],"length":0,"stats":{"Line":78}},{"line":1947,"address":[],"length":0,"stats":{"Line":16}},{"line":1948,"address":[],"length":0,"stats":{"Line":4}},{"line":1949,"address":[],"length":0,"stats":{"Line":4}},{"line":1950,"address":[],"length":0,"stats":{"Line":4}},{"line":1951,"address":[],"length":0,"stats":{"Line":4}},{"line":1952,"address":[],"length":0,"stats":{"Line":4}},{"line":1953,"address":[],"length":0,"stats":{"Line":0}},{"line":1954,"address":[],"length":0,"stats":{"Line":0}},{"line":1960,"address":[],"length":0,"stats":{"Line":82}},{"line":1961,"address":[],"length":0,"stats":{"Line":156}},{"line":1962,"address":[],"length":0,"stats":{"Line":312}},{"line":1964,"address":[],"length":0,"stats":{"Line":0}},{"line":1965,"address":[],"length":0,"stats":{"Line":0}},{"line":1966,"address":[],"length":0,"stats":{"Line":0}},{"line":1968,"address":[],"length":0,"stats":{"Line":4}},{"line":1969,"address":[],"length":0,"stats":{"Line":16}},{"line":1970,"address":[],"length":0,"stats":{"Line":16}},{"line":1971,"address":[],"length":0,"stats":{"Line":24}},{"line":1973,"address":[],"length":0,"stats":{"Line":0}},{"line":1976,"address":[],"length":0,"stats":{"Line":82}},{"line":1979,"address":[],"length":0,"stats":{"Line":52}},{"line":1981,"address":[],"length":0,"stats":{"Line":431}},{"line":1982,"address":[],"length":0,"stats":{"Line":104}},{"line":1985,"address":[],"length":0,"stats":{"Line":55}},{"line":1986,"address":[],"length":0,"stats":{"Line":12}},{"line":1987,"address":[],"length":0,"stats":{"Line":15}},{"line":1991,"address":[],"length":0,"stats":{"Line":49}},{"line":1992,"address":[],"length":0,"stats":{"Line":0}},{"line":1993,"address":[],"length":0,"stats":{"Line":0}},{"line":1994,"address":[],"length":0,"stats":{"Line":0}},{"line":1997,"address":[],"length":0,"stats":{"Line":0}},{"line":1999,"address":[],"length":0,"stats":{"Line":0}},{"line":2001,"address":[],"length":0,"stats":{"Line":0}},{"line":2002,"address":[],"length":0,"stats":{"Line":0}},{"line":2004,"address":[],"length":0,"stats":{"Line":0}},{"line":2008,"address":[],"length":0,"stats":{"Line":0}},{"line":2009,"address":[],"length":0,"stats":{"Line":0}},{"line":2010,"address":[],"length":0,"stats":{"Line":0}},{"line":2012,"address":[],"length":0,"stats":{"Line":0}},{"line":2014,"address":[],"length":0,"stats":{"Line":0}},{"line":2015,"address":[],"length":0,"stats":{"Line":0}},{"line":2016,"address":[],"length":0,"stats":{"Line":0}},{"line":2019,"address":[],"length":0,"stats":{"Line":0}},{"line":2020,"address":[],"length":0,"stats":{"Line":0}},{"line":2021,"address":[],"length":0,"stats":{"Line":0}},{"line":2022,"address":[],"length":0,"stats":{"Line":0}},{"line":2025,"address":[],"length":0,"stats":{"Line":0}},{"line":2026,"address":[],"length":0,"stats":{"Line":0}},{"line":2027,"address":[],"length":0,"stats":{"Line":0}},{"line":2028,"address":[],"length":0,"stats":{"Line":0}},{"line":2029,"address":[],"length":0,"stats":{"Line":0}},{"line":2030,"address":[],"length":0,"stats":{"Line":0}},{"line":2032,"address":[],"length":0,"stats":{"Line":0}},{"line":2037,"address":[],"length":0,"stats":{"Line":0}},{"line":2041,"address":[],"length":0,"stats":{"Line":0}},{"line":2042,"address":[],"length":0,"stats":{"Line":0}},{"line":2050,"address":[],"length":0,"stats":{"Line":98}},{"line":2051,"address":[],"length":0,"stats":{"Line":63}},{"line":2053,"address":[],"length":0,"stats":{"Line":42}},{"line":2054,"address":[],"length":0,"stats":{"Line":28}},{"line":2055,"address":[],"length":0,"stats":{"Line":0}},{"line":2058,"address":[],"length":0,"stats":{"Line":28}},{"line":2059,"address":[],"length":0,"stats":{"Line":98}},{"line":2060,"address":[],"length":0,"stats":{"Line":84}},{"line":2061,"address":[],"length":0,"stats":{"Line":0}},{"line":2064,"address":[],"length":0,"stats":{"Line":126}},{"line":2065,"address":[],"length":0,"stats":{"Line":56}},{"line":2066,"address":[],"length":0,"stats":{"Line":14}},{"line":2067,"address":[],"length":0,"stats":{"Line":0}},{"line":2068,"address":[],"length":0,"stats":{"Line":0}},{"line":2069,"address":[],"length":0,"stats":{"Line":0}},{"line":2071,"address":[],"length":0,"stats":{"Line":14}},{"line":2075,"address":[],"length":0,"stats":{"Line":28}},{"line":2076,"address":[],"length":0,"stats":{"Line":42}},{"line":2077,"address":[],"length":0,"stats":{"Line":60}},{"line":2083,"address":[],"length":0,"stats":{"Line":148}},{"line":2084,"address":[],"length":0,"stats":{"Line":37}},{"line":2085,"address":[],"length":0,"stats":{"Line":65}},{"line":2086,"address":[],"length":0,"stats":{"Line":60}},{"line":2087,"address":[],"length":0,"stats":{"Line":45}},{"line":2089,"address":[],"length":0,"stats":{"Line":0}},{"line":2090,"address":[],"length":0,"stats":{"Line":0}},{"line":2091,"address":[],"length":0,"stats":{"Line":0}},{"line":2092,"address":[],"length":0,"stats":{"Line":0}},{"line":2097,"address":[],"length":0,"stats":{"Line":22}},{"line":2101,"address":[],"length":0,"stats":{"Line":22}},{"line":2102,"address":[],"length":0,"stats":{"Line":22}},{"line":2105,"address":[],"length":0,"stats":{"Line":22}},{"line":2106,"address":[],"length":0,"stats":{"Line":0}},{"line":2107,"address":[],"length":0,"stats":{"Line":0}},{"line":2108,"address":[],"length":0,"stats":{"Line":0}},{"line":2109,"address":[],"length":0,"stats":{"Line":0}},{"line":2114,"address":[],"length":0,"stats":{"Line":22}},{"line":2115,"address":[],"length":0,"stats":{"Line":0}},{"line":2117,"address":[],"length":0,"stats":{"Line":0}},{"line":2120,"address":[],"length":0,"stats":{"Line":88}},{"line":2121,"address":[],"length":0,"stats":{"Line":0}},{"line":2122,"address":[],"length":0,"stats":{"Line":0}},{"line":2125,"address":[],"length":0,"stats":{"Line":44}},{"line":2128,"address":[],"length":0,"stats":{"Line":80}},{"line":2129,"address":[],"length":0,"stats":{"Line":84}},{"line":2130,"address":[],"length":0,"stats":{"Line":36}},{"line":2134,"address":[],"length":0,"stats":{"Line":88}},{"line":2135,"address":[],"length":0,"stats":{"Line":16}},{"line":2136,"address":[],"length":0,"stats":{"Line":42}},{"line":2137,"address":[],"length":0,"stats":{"Line":28}},{"line":2138,"address":[],"length":0,"stats":{"Line":14}},{"line":2140,"address":[],"length":0,"stats":{"Line":0}},{"line":2143,"address":[],"length":0,"stats":{"Line":0}},{"line":2144,"address":[],"length":0,"stats":{"Line":0}},{"line":2145,"address":[],"length":0,"stats":{"Line":0}},{"line":2146,"address":[],"length":0,"stats":{"Line":0}},{"line":2150,"address":[],"length":0,"stats":{"Line":44}},{"line":2151,"address":[],"length":0,"stats":{"Line":22}},{"line":2152,"address":[],"length":0,"stats":{"Line":22}},{"line":2155,"address":[],"length":0,"stats":{"Line":22}},{"line":2162,"address":[],"length":0,"stats":{"Line":22}},{"line":2163,"address":[],"length":0,"stats":{"Line":0}},{"line":2164,"address":[],"length":0,"stats":{"Line":0}},{"line":2165,"address":[],"length":0,"stats":{"Line":22}},{"line":2167,"address":[],"length":0,"stats":{"Line":66}},{"line":2170,"address":[],"length":0,"stats":{"Line":22}},{"line":2171,"address":[],"length":0,"stats":{"Line":22}},{"line":2172,"address":[],"length":0,"stats":{"Line":0}},{"line":2173,"address":[],"length":0,"stats":{"Line":0}},{"line":2175,"address":[],"length":0,"stats":{"Line":0}},{"line":2176,"address":[],"length":0,"stats":{"Line":0}},{"line":2178,"address":[],"length":0,"stats":{"Line":0}},{"line":2179,"address":[],"length":0,"stats":{"Line":0}},{"line":2180,"address":[],"length":0,"stats":{"Line":0}},{"line":2181,"address":[],"length":0,"stats":{"Line":0}},{"line":2182,"address":[],"length":0,"stats":{"Line":0}},{"line":2184,"address":[],"length":0,"stats":{"Line":0}},{"line":2186,"address":[],"length":0,"stats":{"Line":0}},{"line":2188,"address":[],"length":0,"stats":{"Line":0}},{"line":2192,"address":[],"length":0,"stats":{"Line":0}},{"line":2194,"address":[],"length":0,"stats":{"Line":0}},{"line":2197,"address":[],"length":0,"stats":{"Line":0}},{"line":2199,"address":[],"length":0,"stats":{"Line":22}},{"line":2200,"address":[],"length":0,"stats":{"Line":0}},{"line":2202,"address":[],"length":0,"stats":{"Line":22}},{"line":2205,"address":[],"length":0,"stats":{"Line":0}},{"line":2206,"address":[],"length":0,"stats":{"Line":0}},{"line":2207,"address":[],"length":0,"stats":{"Line":0}},{"line":2208,"address":[],"length":0,"stats":{"Line":0}},{"line":2209,"address":[],"length":0,"stats":{"Line":0}},{"line":2210,"address":[],"length":0,"stats":{"Line":0}},{"line":2211,"address":[],"length":0,"stats":{"Line":0}},{"line":2212,"address":[],"length":0,"stats":{"Line":0}},{"line":2213,"address":[],"length":0,"stats":{"Line":0}},{"line":2215,"address":[],"length":0,"stats":{"Line":0}},{"line":2218,"address":[],"length":0,"stats":{"Line":0}},{"line":2219,"address":[],"length":0,"stats":{"Line":0}},{"line":2220,"address":[],"length":0,"stats":{"Line":0}},{"line":2223,"address":[],"length":0,"stats":{"Line":0}},{"line":2224,"address":[],"length":0,"stats":{"Line":0}},{"line":2225,"address":[],"length":0,"stats":{"Line":0}},{"line":2228,"address":[],"length":0,"stats":{"Line":0}},{"line":2230,"address":[],"length":0,"stats":{"Line":22}},{"line":2234,"address":[],"length":0,"stats":{"Line":0}},{"line":2235,"address":[],"length":0,"stats":{"Line":0}},{"line":2236,"address":[],"length":0,"stats":{"Line":0}},{"line":2238,"address":[],"length":0,"stats":{"Line":0}},{"line":2240,"address":[],"length":0,"stats":{"Line":22}},{"line":2242,"address":[],"length":0,"stats":{"Line":0}},{"line":2243,"address":[],"length":0,"stats":{"Line":0}},{"line":2245,"address":[],"length":0,"stats":{"Line":0}},{"line":2246,"address":[],"length":0,"stats":{"Line":0}},{"line":2247,"address":[],"length":0,"stats":{"Line":0}},{"line":2248,"address":[],"length":0,"stats":{"Line":0}},{"line":2249,"address":[],"length":0,"stats":{"Line":0}},{"line":2250,"address":[],"length":0,"stats":{"Line":0}},{"line":2253,"address":[],"length":0,"stats":{"Line":0}},{"line":2254,"address":[],"length":0,"stats":{"Line":0}},{"line":2255,"address":[],"length":0,"stats":{"Line":0}},{"line":2256,"address":[],"length":0,"stats":{"Line":0}},{"line":2257,"address":[],"length":0,"stats":{"Line":0}},{"line":2259,"address":[],"length":0,"stats":{"Line":0}},{"line":2261,"address":[],"length":0,"stats":{"Line":0}},{"line":2262,"address":[],"length":0,"stats":{"Line":0}},{"line":2263,"address":[],"length":0,"stats":{"Line":0}},{"line":2266,"address":[],"length":0,"stats":{"Line":0}},{"line":2268,"address":[],"length":0,"stats":{"Line":22}},{"line":2270,"address":[],"length":0,"stats":{"Line":0}},{"line":2271,"address":[],"length":0,"stats":{"Line":0}},{"line":2272,"address":[],"length":0,"stats":{"Line":0}},{"line":2273,"address":[],"length":0,"stats":{"Line":0}},{"line":2274,"address":[],"length":0,"stats":{"Line":0}},{"line":2275,"address":[],"length":0,"stats":{"Line":0}},{"line":2276,"address":[],"length":0,"stats":{"Line":0}},{"line":2278,"address":[],"length":0,"stats":{"Line":0}},{"line":2280,"address":[],"length":0,"stats":{"Line":0}},{"line":2282,"address":[],"length":0,"stats":{"Line":22}},{"line":2284,"address":[],"length":0,"stats":{"Line":0}},{"line":2285,"address":[],"length":0,"stats":{"Line":0}},{"line":2286,"address":[],"length":0,"stats":{"Line":0}},{"line":2287,"address":[],"length":0,"stats":{"Line":0}},{"line":2288,"address":[],"length":0,"stats":{"Line":0}},{"line":2289,"address":[],"length":0,"stats":{"Line":0}},{"line":2290,"address":[],"length":0,"stats":{"Line":0}},{"line":2292,"address":[],"length":0,"stats":{"Line":0}},{"line":2293,"address":[],"length":0,"stats":{"Line":0}},{"line":2294,"address":[],"length":0,"stats":{"Line":0}},{"line":2295,"address":[],"length":0,"stats":{"Line":0}},{"line":2297,"address":[],"length":0,"stats":{"Line":0}},{"line":2300,"address":[],"length":0,"stats":{"Line":0}},{"line":2301,"address":[],"length":0,"stats":{"Line":0}},{"line":2302,"address":[],"length":0,"stats":{"Line":0}},{"line":2303,"address":[],"length":0,"stats":{"Line":0}},{"line":2305,"address":[],"length":0,"stats":{"Line":0}},{"line":2306,"address":[],"length":0,"stats":{"Line":0}},{"line":2307,"address":[],"length":0,"stats":{"Line":0}},{"line":2310,"address":[],"length":0,"stats":{"Line":22}},{"line":2312,"address":[],"length":0,"stats":{"Line":2}},{"line":2313,"address":[],"length":0,"stats":{"Line":3}},{"line":2314,"address":[],"length":0,"stats":{"Line":2}},{"line":2315,"address":[],"length":0,"stats":{"Line":2}},{"line":2316,"address":[],"length":0,"stats":{"Line":2}},{"line":2318,"address":[],"length":0,"stats":{"Line":2}},{"line":2319,"address":[],"length":0,"stats":{"Line":4}},{"line":2320,"address":[],"length":0,"stats":{"Line":1}},{"line":2323,"address":[],"length":0,"stats":{"Line":1}},{"line":2325,"address":[],"length":0,"stats":{"Line":21}},{"line":2326,"address":[],"length":0,"stats":{"Line":0}},{"line":2327,"address":[],"length":0,"stats":{"Line":0}},{"line":2328,"address":[],"length":0,"stats":{"Line":0}},{"line":2330,"address":[],"length":0,"stats":{"Line":0}},{"line":2332,"address":[],"length":0,"stats":{"Line":21}},{"line":2334,"address":[],"length":0,"stats":{"Line":0}},{"line":2335,"address":[],"length":0,"stats":{"Line":0}},{"line":2336,"address":[],"length":0,"stats":{"Line":0}},{"line":2337,"address":[],"length":0,"stats":{"Line":0}},{"line":2338,"address":[],"length":0,"stats":{"Line":0}},{"line":2340,"address":[],"length":0,"stats":{"Line":0}},{"line":2342,"address":[],"length":0,"stats":{"Line":42}},{"line":2344,"address":[],"length":0,"stats":{"Line":0}},{"line":2345,"address":[],"length":0,"stats":{"Line":0}},{"line":2346,"address":[],"length":0,"stats":{"Line":0}},{"line":2347,"address":[],"length":0,"stats":{"Line":0}},{"line":2348,"address":[],"length":0,"stats":{"Line":0}},{"line":2350,"address":[],"length":0,"stats":{"Line":0}},{"line":2352,"address":[],"length":0,"stats":{"Line":21}},{"line":2353,"address":[],"length":0,"stats":{"Line":0}},{"line":2354,"address":[],"length":0,"stats":{"Line":0}},{"line":2355,"address":[],"length":0,"stats":{"Line":0}},{"line":2356,"address":[],"length":0,"stats":{"Line":0}},{"line":2357,"address":[],"length":0,"stats":{"Line":0}},{"line":2359,"address":[],"length":0,"stats":{"Line":0}},{"line":2361,"address":[],"length":0,"stats":{"Line":21}},{"line":2362,"address":[],"length":0,"stats":{"Line":0}},{"line":2364,"address":[],"length":0,"stats":{"Line":21}},{"line":2366,"address":[],"length":0,"stats":{"Line":0}},{"line":2367,"address":[],"length":0,"stats":{"Line":0}},{"line":2368,"address":[],"length":0,"stats":{"Line":0}},{"line":2370,"address":[],"length":0,"stats":{"Line":0}},{"line":2372,"address":[],"length":0,"stats":{"Line":0}},{"line":2374,"address":[],"length":0,"stats":{"Line":21}},{"line":2375,"address":[],"length":0,"stats":{"Line":3}},{"line":2376,"address":[],"length":0,"stats":{"Line":2}},{"line":2378,"address":[],"length":0,"stats":{"Line":0}},{"line":2380,"address":[],"length":0,"stats":{"Line":20}},{"line":2381,"address":[],"length":0,"stats":{"Line":20}},{"line":2383,"address":[],"length":0,"stats":{"Line":20}},{"line":2385,"address":[],"length":0,"stats":{"Line":5}},{"line":2387,"address":[],"length":0,"stats":{"Line":15}},{"line":2388,"address":[],"length":0,"stats":{"Line":0}},{"line":2389,"address":[],"length":0,"stats":{"Line":0}},{"line":2390,"address":[],"length":0,"stats":{"Line":0}},{"line":2393,"address":[],"length":0,"stats":{"Line":0}},{"line":2395,"address":[],"length":0,"stats":{"Line":15}},{"line":2397,"address":[],"length":0,"stats":{"Line":0}},{"line":2398,"address":[],"length":0,"stats":{"Line":0}},{"line":2399,"address":[],"length":0,"stats":{"Line":0}},{"line":2400,"address":[],"length":0,"stats":{"Line":0}},{"line":2401,"address":[],"length":0,"stats":{"Line":0}},{"line":2403,"address":[],"length":0,"stats":{"Line":0}},{"line":2405,"address":[],"length":0,"stats":{"Line":15}},{"line":2406,"address":[],"length":0,"stats":{"Line":0}},{"line":2407,"address":[],"length":0,"stats":{"Line":0}},{"line":2408,"address":[],"length":0,"stats":{"Line":0}},{"line":2409,"address":[],"length":0,"stats":{"Line":0}},{"line":2410,"address":[],"length":0,"stats":{"Line":0}},{"line":2411,"address":[],"length":0,"stats":{"Line":0}},{"line":2413,"address":[],"length":0,"stats":{"Line":0}},{"line":2415,"address":[],"length":0,"stats":{"Line":0}},{"line":2417,"address":[],"length":0,"stats":{"Line":15}},{"line":2418,"address":[],"length":0,"stats":{"Line":0}},{"line":2419,"address":[],"length":0,"stats":{"Line":0}},{"line":2421,"address":[],"length":0,"stats":{"Line":15}},{"line":2422,"address":[],"length":0,"stats":{"Line":0}},{"line":2423,"address":[],"length":0,"stats":{"Line":0}},{"line":2424,"address":[],"length":0,"stats":{"Line":0}},{"line":2426,"address":[],"length":0,"stats":{"Line":0}},{"line":2428,"address":[],"length":0,"stats":{"Line":0}},{"line":2430,"address":[],"length":0,"stats":{"Line":15}},{"line":2432,"address":[],"length":0,"stats":{"Line":0}},{"line":2434,"address":[],"length":0,"stats":{"Line":15}},{"line":2437,"address":[],"length":0,"stats":{"Line":1}},{"line":2438,"address":[],"length":0,"stats":{"Line":2}},{"line":2439,"address":[],"length":0,"stats":{"Line":1}},{"line":2442,"address":[],"length":0,"stats":{"Line":5}},{"line":2444,"address":[],"length":0,"stats":{"Line":1}},{"line":2445,"address":[],"length":0,"stats":{"Line":5}},{"line":2447,"address":[],"length":0,"stats":{"Line":4}},{"line":2448,"address":[],"length":0,"stats":{"Line":2}},{"line":2449,"address":[],"length":0,"stats":{"Line":2}},{"line":2450,"address":[],"length":0,"stats":{"Line":1}},{"line":2453,"address":[],"length":0,"stats":{"Line":2}},{"line":2454,"address":[],"length":0,"stats":{"Line":2}},{"line":2455,"address":[],"length":0,"stats":{"Line":1}},{"line":2458,"address":[],"length":0,"stats":{"Line":1}},{"line":2459,"address":[],"length":0,"stats":{"Line":0}},{"line":2460,"address":[],"length":0,"stats":{"Line":0}},{"line":2461,"address":[],"length":0,"stats":{"Line":0}},{"line":2465,"address":[],"length":0,"stats":{"Line":1}},{"line":2467,"address":[],"length":0,"stats":{"Line":0}},{"line":2469,"address":[],"length":0,"stats":{"Line":14}},{"line":2471,"address":[],"length":0,"stats":{"Line":0}},{"line":2472,"address":[],"length":0,"stats":{"Line":0}},{"line":2473,"address":[],"length":0,"stats":{"Line":0}},{"line":2474,"address":[],"length":0,"stats":{"Line":0}},{"line":2477,"address":[],"length":0,"stats":{"Line":0}},{"line":2478,"address":[],"length":0,"stats":{"Line":0}},{"line":2480,"address":[],"length":0,"stats":{"Line":0}},{"line":2482,"address":[],"length":0,"stats":{"Line":14}},{"line":2484,"address":[],"length":0,"stats":{"Line":0}},{"line":2485,"address":[],"length":0,"stats":{"Line":0}},{"line":2486,"address":[],"length":0,"stats":{"Line":0}},{"line":2487,"address":[],"length":0,"stats":{"Line":0}},{"line":2488,"address":[],"length":0,"stats":{"Line":0}},{"line":2490,"address":[],"length":0,"stats":{"Line":0}},{"line":2492,"address":[],"length":0,"stats":{"Line":14}},{"line":2494,"address":[],"length":0,"stats":{"Line":0}},{"line":2495,"address":[],"length":0,"stats":{"Line":0}},{"line":2496,"address":[],"length":0,"stats":{"Line":0}},{"line":2498,"address":[],"length":0,"stats":{"Line":0}},{"line":2500,"address":[],"length":0,"stats":{"Line":0}},{"line":2502,"address":[],"length":0,"stats":{"Line":14}},{"line":2504,"address":[],"length":0,"stats":{"Line":0}},{"line":2505,"address":[],"length":0,"stats":{"Line":0}},{"line":2506,"address":[],"length":0,"stats":{"Line":0}},{"line":2507,"address":[],"length":0,"stats":{"Line":0}},{"line":2508,"address":[],"length":0,"stats":{"Line":0}},{"line":2509,"address":[],"length":0,"stats":{"Line":0}},{"line":2510,"address":[],"length":0,"stats":{"Line":0}},{"line":2511,"address":[],"length":0,"stats":{"Line":0}},{"line":2512,"address":[],"length":0,"stats":{"Line":0}},{"line":2513,"address":[],"length":0,"stats":{"Line":0}},{"line":2514,"address":[],"length":0,"stats":{"Line":0}},{"line":2518,"address":[],"length":0,"stats":{"Line":0}},{"line":2520,"address":[],"length":0,"stats":{"Line":14}},{"line":2522,"address":[],"length":0,"stats":{"Line":0}},{"line":2523,"address":[],"length":0,"stats":{"Line":0}},{"line":2525,"address":[],"length":0,"stats":{"Line":0}},{"line":2526,"address":[],"length":0,"stats":{"Line":0}},{"line":2527,"address":[],"length":0,"stats":{"Line":0}},{"line":2528,"address":[],"length":0,"stats":{"Line":0}},{"line":2530,"address":[],"length":0,"stats":{"Line":0}},{"line":2531,"address":[],"length":0,"stats":{"Line":0}},{"line":2532,"address":[],"length":0,"stats":{"Line":0}},{"line":2533,"address":[],"length":0,"stats":{"Line":0}},{"line":2537,"address":[],"length":0,"stats":{"Line":0}},{"line":2538,"address":[],"length":0,"stats":{"Line":0}},{"line":2539,"address":[],"length":0,"stats":{"Line":0}},{"line":2540,"address":[],"length":0,"stats":{"Line":0}},{"line":2543,"address":[],"length":0,"stats":{"Line":14}},{"line":2545,"address":[],"length":0,"stats":{"Line":0}},{"line":2547,"address":[],"length":0,"stats":{"Line":14}},{"line":2553,"address":[],"length":0,"stats":{"Line":0}},{"line":2555,"address":[],"length":0,"stats":{"Line":14}},{"line":2558,"address":[],"length":0,"stats":{"Line":2}},{"line":2559,"address":[],"length":0,"stats":{"Line":2}},{"line":2560,"address":[],"length":0,"stats":{"Line":2}},{"line":2561,"address":[],"length":0,"stats":{"Line":6}},{"line":2563,"address":[],"length":0,"stats":{"Line":4}},{"line":2565,"address":[],"length":0,"stats":{"Line":4}},{"line":2570,"address":[],"length":0,"stats":{"Line":6}},{"line":2571,"address":[],"length":0,"stats":{"Line":4}},{"line":2574,"address":[],"length":0,"stats":{"Line":6}},{"line":2575,"address":[],"length":0,"stats":{"Line":4}},{"line":2578,"address":[],"length":0,"stats":{"Line":4}},{"line":2579,"address":[],"length":0,"stats":{"Line":6}},{"line":2580,"address":[],"length":0,"stats":{"Line":3}},{"line":2581,"address":[],"length":0,"stats":{"Line":3}},{"line":2583,"address":[],"length":0,"stats":{"Line":5}},{"line":2584,"address":[],"length":0,"stats":{"Line":7}},{"line":2586,"address":[],"length":0,"stats":{"Line":2}},{"line":2589,"address":[],"length":0,"stats":{"Line":6}},{"line":2590,"address":[],"length":0,"stats":{"Line":4}},{"line":2592,"address":[],"length":0,"stats":{"Line":2}},{"line":2594,"address":[],"length":0,"stats":{"Line":4}},{"line":2595,"address":[],"length":0,"stats":{"Line":10}},{"line":2597,"address":[],"length":0,"stats":{"Line":8}},{"line":2598,"address":[],"length":0,"stats":{"Line":8}},{"line":2601,"address":[],"length":0,"stats":{"Line":2}},{"line":2603,"address":[],"length":0,"stats":{"Line":12}},{"line":2604,"address":[],"length":0,"stats":{"Line":4}},{"line":2605,"address":[],"length":0,"stats":{"Line":3}},{"line":2606,"address":[],"length":0,"stats":{"Line":4}},{"line":2607,"address":[],"length":0,"stats":{"Line":4}},{"line":2608,"address":[],"length":0,"stats":{"Line":3}},{"line":2610,"address":[],"length":0,"stats":{"Line":1}},{"line":2612,"address":[],"length":0,"stats":{"Line":11}},{"line":2614,"address":[],"length":0,"stats":{"Line":2}},{"line":2615,"address":[],"length":0,"stats":{"Line":2}},{"line":2617,"address":[],"length":0,"stats":{"Line":4}},{"line":2618,"address":[],"length":0,"stats":{"Line":2}},{"line":2619,"address":[],"length":0,"stats":{"Line":2}},{"line":2620,"address":[],"length":0,"stats":{"Line":2}},{"line":2621,"address":[],"length":0,"stats":{"Line":3}},{"line":2623,"address":[],"length":0,"stats":{"Line":1}},{"line":2625,"address":[],"length":0,"stats":{"Line":10}},{"line":2626,"address":[],"length":0,"stats":{"Line":0}},{"line":2627,"address":[],"length":0,"stats":{"Line":0}},{"line":2628,"address":[],"length":0,"stats":{"Line":0}},{"line":2629,"address":[],"length":0,"stats":{"Line":0}},{"line":2630,"address":[],"length":0,"stats":{"Line":0}},{"line":2633,"address":[],"length":0,"stats":{"Line":0}},{"line":2635,"address":[],"length":0,"stats":{"Line":0}},{"line":2637,"address":[],"length":0,"stats":{"Line":10}},{"line":2639,"address":[],"length":0,"stats":{"Line":0}},{"line":2640,"address":[],"length":0,"stats":{"Line":0}},{"line":2642,"address":[],"length":0,"stats":{"Line":0}},{"line":2643,"address":[],"length":0,"stats":{"Line":0}},{"line":2644,"address":[],"length":0,"stats":{"Line":0}},{"line":2645,"address":[],"length":0,"stats":{"Line":0}},{"line":2646,"address":[],"length":0,"stats":{"Line":0}},{"line":2648,"address":[],"length":0,"stats":{"Line":0}},{"line":2650,"address":[],"length":0,"stats":{"Line":10}},{"line":2652,"address":[],"length":0,"stats":{"Line":0}},{"line":2653,"address":[],"length":0,"stats":{"Line":0}},{"line":2654,"address":[],"length":0,"stats":{"Line":0}},{"line":2655,"address":[],"length":0,"stats":{"Line":0}},{"line":2656,"address":[],"length":0,"stats":{"Line":0}},{"line":2659,"address":[],"length":0,"stats":{"Line":0}},{"line":2661,"address":[],"length":0,"stats":{"Line":0}},{"line":2663,"address":[],"length":0,"stats":{"Line":10}},{"line":2664,"address":[],"length":0,"stats":{"Line":3}},{"line":2665,"address":[],"length":0,"stats":{"Line":1}},{"line":2666,"address":[],"length":0,"stats":{"Line":1}},{"line":2668,"address":[],"length":0,"stats":{"Line":7}},{"line":2670,"address":[],"length":0,"stats":{"Line":2}},{"line":2672,"address":[],"length":0,"stats":{"Line":9}},{"line":2675,"address":[],"length":0,"stats":{"Line":0}},{"line":2677,"address":[],"length":0,"stats":{"Line":36}},{"line":2678,"address":[],"length":0,"stats":{"Line":36}},{"line":2679,"address":[],"length":0,"stats":{"Line":36}},{"line":2680,"address":[],"length":0,"stats":{"Line":36}},{"line":2681,"address":[],"length":0,"stats":{"Line":36}},{"line":2682,"address":[],"length":0,"stats":{"Line":45}},{"line":2683,"address":[],"length":0,"stats":{"Line":18}},{"line":2685,"address":[],"length":0,"stats":{"Line":0}},{"line":2687,"address":[],"length":0,"stats":{"Line":9}},{"line":2689,"address":[],"length":0,"stats":{"Line":0}},{"line":2691,"address":[],"length":0,"stats":{"Line":9}},{"line":2693,"address":[],"length":0,"stats":{"Line":0}},{"line":2695,"address":[],"length":0,"stats":{"Line":0}},{"line":2696,"address":[],"length":0,"stats":{"Line":0}},{"line":2697,"address":[],"length":0,"stats":{"Line":0}},{"line":2698,"address":[],"length":0,"stats":{"Line":0}},{"line":2699,"address":[],"length":0,"stats":{"Line":0}},{"line":2700,"address":[],"length":0,"stats":{"Line":0}},{"line":2702,"address":[],"length":0,"stats":{"Line":9}},{"line":2704,"address":[],"length":0,"stats":{"Line":0}},{"line":2705,"address":[],"length":0,"stats":{"Line":0}},{"line":2706,"address":[],"length":0,"stats":{"Line":0}},{"line":2709,"address":[],"length":0,"stats":{"Line":0}},{"line":2711,"address":[],"length":0,"stats":{"Line":9}},{"line":2713,"address":[],"length":0,"stats":{"Line":0}},{"line":2714,"address":[],"length":0,"stats":{"Line":0}},{"line":2715,"address":[],"length":0,"stats":{"Line":0}},{"line":2716,"address":[],"length":0,"stats":{"Line":0}},{"line":2717,"address":[],"length":0,"stats":{"Line":0}},{"line":2718,"address":[],"length":0,"stats":{"Line":0}},{"line":2719,"address":[],"length":0,"stats":{"Line":0}},{"line":2721,"address":[],"length":0,"stats":{"Line":9}},{"line":2723,"address":[],"length":0,"stats":{"Line":0}},{"line":2724,"address":[],"length":0,"stats":{"Line":0}},{"line":2726,"address":[],"length":0,"stats":{"Line":0}},{"line":2728,"address":[],"length":0,"stats":{"Line":9}},{"line":2732,"address":[],"length":0,"stats":{"Line":27}},{"line":2733,"address":[],"length":0,"stats":{"Line":27}},{"line":2734,"address":[],"length":0,"stats":{"Line":27}},{"line":2735,"address":[],"length":0,"stats":{"Line":18}},{"line":2736,"address":[],"length":0,"stats":{"Line":54}},{"line":2737,"address":[],"length":0,"stats":{"Line":18}},{"line":2738,"address":[],"length":0,"stats":{"Line":9}},{"line":2741,"address":[],"length":0,"stats":{"Line":0}},{"line":2742,"address":[],"length":0,"stats":{"Line":0}},{"line":2743,"address":[],"length":0,"stats":{"Line":0}},{"line":2748,"address":[],"length":0,"stats":{"Line":0}},{"line":2750,"address":[],"length":0,"stats":{"Line":0}},{"line":2752,"address":[],"length":0,"stats":{"Line":0}},{"line":2756,"address":[],"length":0,"stats":{"Line":0}},{"line":2758,"address":[],"length":0,"stats":{"Line":0}},{"line":2761,"address":[],"length":0,"stats":{"Line":0}},{"line":2762,"address":[],"length":0,"stats":{"Line":0}},{"line":2763,"address":[],"length":0,"stats":{"Line":0}},{"line":2767,"address":[],"length":0,"stats":{"Line":0}},{"line":2773,"address":[],"length":0,"stats":{"Line":0}},{"line":2774,"address":[],"length":0,"stats":{"Line":0}},{"line":2775,"address":[],"length":0,"stats":{"Line":0}},{"line":2776,"address":[],"length":0,"stats":{"Line":0}},{"line":2777,"address":[],"length":0,"stats":{"Line":0}},{"line":2778,"address":[],"length":0,"stats":{"Line":0}},{"line":2780,"address":[],"length":0,"stats":{"Line":0}},{"line":2782,"address":[],"length":0,"stats":{"Line":0}},{"line":2783,"address":[],"length":0,"stats":{"Line":0}},{"line":2784,"address":[],"length":0,"stats":{"Line":0}},{"line":2785,"address":[],"length":0,"stats":{"Line":0}},{"line":2786,"address":[],"length":0,"stats":{"Line":0}},{"line":2788,"address":[],"length":0,"stats":{"Line":0}},{"line":2791,"address":[],"length":0,"stats":{"Line":0}},{"line":2792,"address":[],"length":0,"stats":{"Line":0}},{"line":2793,"address":[],"length":0,"stats":{"Line":0}},{"line":2795,"address":[],"length":0,"stats":{"Line":0}},{"line":2797,"address":[],"length":0,"stats":{"Line":0}},{"line":2798,"address":[],"length":0,"stats":{"Line":0}},{"line":2799,"address":[],"length":0,"stats":{"Line":0}},{"line":2801,"address":[],"length":0,"stats":{"Line":0}},{"line":2803,"address":[],"length":0,"stats":{"Line":0}},{"line":2804,"address":[],"length":0,"stats":{"Line":0}},{"line":2805,"address":[],"length":0,"stats":{"Line":0}},{"line":2806,"address":[],"length":0,"stats":{"Line":0}},{"line":2807,"address":[],"length":0,"stats":{"Line":0}},{"line":2811,"address":[],"length":0,"stats":{"Line":0}},{"line":2813,"address":[],"length":0,"stats":{"Line":0}},{"line":2814,"address":[],"length":0,"stats":{"Line":0}},{"line":2815,"address":[],"length":0,"stats":{"Line":0}},{"line":2816,"address":[],"length":0,"stats":{"Line":0}},{"line":2817,"address":[],"length":0,"stats":{"Line":0}},{"line":2818,"address":[],"length":0,"stats":{"Line":0}},{"line":2819,"address":[],"length":0,"stats":{"Line":0}},{"line":2821,"address":[],"length":0,"stats":{"Line":0}},{"line":2824,"address":[],"length":0,"stats":{"Line":0}},{"line":2825,"address":[],"length":0,"stats":{"Line":0}},{"line":2827,"address":[],"length":0,"stats":{"Line":0}},{"line":2828,"address":[],"length":0,"stats":{"Line":0}},{"line":2829,"address":[],"length":0,"stats":{"Line":0}},{"line":2830,"address":[],"length":0,"stats":{"Line":0}},{"line":2833,"address":[],"length":0,"stats":{"Line":0}},{"line":2835,"address":[],"length":0,"stats":{"Line":0}},{"line":2836,"address":[],"length":0,"stats":{"Line":0}},{"line":2837,"address":[],"length":0,"stats":{"Line":0}},{"line":2838,"address":[],"length":0,"stats":{"Line":0}},{"line":2839,"address":[],"length":0,"stats":{"Line":0}},{"line":2840,"address":[],"length":0,"stats":{"Line":0}},{"line":2843,"address":[],"length":0,"stats":{"Line":0}},{"line":2845,"address":[],"length":0,"stats":{"Line":0}},{"line":2846,"address":[],"length":0,"stats":{"Line":0}},{"line":2847,"address":[],"length":0,"stats":{"Line":0}},{"line":2852,"address":[],"length":0,"stats":{"Line":0}},{"line":2858,"address":[],"length":0,"stats":{"Line":0}},{"line":2859,"address":[],"length":0,"stats":{"Line":0}},{"line":2860,"address":[],"length":0,"stats":{"Line":0}},{"line":2861,"address":[],"length":0,"stats":{"Line":0}},{"line":2862,"address":[],"length":0,"stats":{"Line":0}},{"line":2863,"address":[],"length":0,"stats":{"Line":0}},{"line":2864,"address":[],"length":0,"stats":{"Line":0}},{"line":2866,"address":[],"length":0,"stats":{"Line":0}},{"line":2869,"address":[],"length":0,"stats":{"Line":0}},{"line":2870,"address":[],"length":0,"stats":{"Line":0}},{"line":2873,"address":[],"length":0,"stats":{"Line":0}},{"line":2875,"address":[],"length":0,"stats":{"Line":0}},{"line":2877,"address":[],"length":0,"stats":{"Line":0}},{"line":2878,"address":[],"length":0,"stats":{"Line":0}},{"line":2879,"address":[],"length":0,"stats":{"Line":0}},{"line":2881,"address":[],"length":0,"stats":{"Line":0}},{"line":2882,"address":[],"length":0,"stats":{"Line":0}},{"line":2883,"address":[],"length":0,"stats":{"Line":0}},{"line":2888,"address":[],"length":0,"stats":{"Line":0}},{"line":2894,"address":[],"length":0,"stats":{"Line":0}},{"line":2895,"address":[],"length":0,"stats":{"Line":0}},{"line":2896,"address":[],"length":0,"stats":{"Line":0}},{"line":2897,"address":[],"length":0,"stats":{"Line":0}},{"line":2899,"address":[],"length":0,"stats":{"Line":0}},{"line":2900,"address":[],"length":0,"stats":{"Line":0}},{"line":2902,"address":[],"length":0,"stats":{"Line":0}},{"line":2903,"address":[],"length":0,"stats":{"Line":0}},{"line":2906,"address":[],"length":0,"stats":{"Line":0}},{"line":2907,"address":[],"length":0,"stats":{"Line":0}},{"line":2908,"address":[],"length":0,"stats":{"Line":0}},{"line":2909,"address":[],"length":0,"stats":{"Line":0}},{"line":2912,"address":[],"length":0,"stats":{"Line":0}},{"line":2914,"address":[],"length":0,"stats":{"Line":0}},{"line":2915,"address":[],"length":0,"stats":{"Line":0}},{"line":2917,"address":[],"length":0,"stats":{"Line":0}},{"line":2918,"address":[],"length":0,"stats":{"Line":0}},{"line":2921,"address":[],"length":0,"stats":{"Line":0}},{"line":2922,"address":[],"length":0,"stats":{"Line":0}},{"line":2923,"address":[],"length":0,"stats":{"Line":0}},{"line":2924,"address":[],"length":0,"stats":{"Line":0}},{"line":2926,"address":[],"length":0,"stats":{"Line":0}},{"line":2928,"address":[],"length":0,"stats":{"Line":0}},{"line":2930,"address":[],"length":0,"stats":{"Line":0}},{"line":2932,"address":[],"length":0,"stats":{"Line":0}},{"line":2933,"address":[],"length":0,"stats":{"Line":0}},{"line":2935,"address":[],"length":0,"stats":{"Line":0}},{"line":2936,"address":[],"length":0,"stats":{"Line":0}},{"line":2937,"address":[],"length":0,"stats":{"Line":0}},{"line":2939,"address":[],"length":0,"stats":{"Line":0}},{"line":2940,"address":[],"length":0,"stats":{"Line":0}},{"line":2941,"address":[],"length":0,"stats":{"Line":0}},{"line":2943,"address":[],"length":0,"stats":{"Line":0}},{"line":2944,"address":[],"length":0,"stats":{"Line":0}},{"line":2946,"address":[],"length":0,"stats":{"Line":0}},{"line":2948,"address":[],"length":0,"stats":{"Line":0}},{"line":2949,"address":[],"length":0,"stats":{"Line":0}},{"line":2950,"address":[],"length":0,"stats":{"Line":0}},{"line":2951,"address":[],"length":0,"stats":{"Line":0}},{"line":2952,"address":[],"length":0,"stats":{"Line":0}},{"line":2953,"address":[],"length":0,"stats":{"Line":0}},{"line":2955,"address":[],"length":0,"stats":{"Line":0}},{"line":2956,"address":[],"length":0,"stats":{"Line":0}},{"line":2957,"address":[],"length":0,"stats":{"Line":0}},{"line":2959,"address":[],"length":0,"stats":{"Line":0}},{"line":2961,"address":[],"length":0,"stats":{"Line":0}},{"line":2962,"address":[],"length":0,"stats":{"Line":0}},{"line":2963,"address":[],"length":0,"stats":{"Line":0}},{"line":2965,"address":[],"length":0,"stats":{"Line":0}},{"line":2967,"address":[],"length":0,"stats":{"Line":0}},{"line":2968,"address":[],"length":0,"stats":{"Line":0}},{"line":2969,"address":[],"length":0,"stats":{"Line":0}},{"line":2971,"address":[],"length":0,"stats":{"Line":0}},{"line":2973,"address":[],"length":0,"stats":{"Line":0}},{"line":2975,"address":[],"length":0,"stats":{"Line":0}},{"line":2976,"address":[],"length":0,"stats":{"Line":0}},{"line":2977,"address":[],"length":0,"stats":{"Line":0}},{"line":2978,"address":[],"length":0,"stats":{"Line":0}},{"line":2979,"address":[],"length":0,"stats":{"Line":0}},{"line":2981,"address":[],"length":0,"stats":{"Line":0}},{"line":2983,"address":[],"length":0,"stats":{"Line":0}},{"line":2985,"address":[],"length":0,"stats":{"Line":0}},{"line":2986,"address":[],"length":0,"stats":{"Line":0}},{"line":2987,"address":[],"length":0,"stats":{"Line":0}},{"line":2988,"address":[],"length":0,"stats":{"Line":0}},{"line":2991,"address":[],"length":0,"stats":{"Line":0}},{"line":2992,"address":[],"length":0,"stats":{"Line":0}},{"line":2993,"address":[],"length":0,"stats":{"Line":0}},{"line":2995,"address":[],"length":0,"stats":{"Line":0}},{"line":2997,"address":[],"length":0,"stats":{"Line":0}},{"line":2998,"address":[],"length":0,"stats":{"Line":0}},{"line":3000,"address":[],"length":0,"stats":{"Line":0}},{"line":3001,"address":[],"length":0,"stats":{"Line":0}},{"line":3004,"address":[],"length":0,"stats":{"Line":0}},{"line":3005,"address":[],"length":0,"stats":{"Line":0}},{"line":3006,"address":[],"length":0,"stats":{"Line":0}},{"line":3007,"address":[],"length":0,"stats":{"Line":0}},{"line":3012,"address":[],"length":0,"stats":{"Line":0}},{"line":3018,"address":[],"length":0,"stats":{"Line":0}},{"line":3019,"address":[],"length":0,"stats":{"Line":0}},{"line":3022,"address":[],"length":0,"stats":{"Line":9}},{"line":3029,"address":[],"length":0,"stats":{"Line":27}},{"line":3030,"address":[],"length":0,"stats":{"Line":27}},{"line":3032,"address":[],"length":0,"stats":{"Line":36}},{"line":3033,"address":[],"length":0,"stats":{"Line":27}},{"line":3034,"address":[],"length":0,"stats":{"Line":18}},{"line":3035,"address":[],"length":0,"stats":{"Line":9}},{"line":3039,"address":[],"length":0,"stats":{"Line":13}},{"line":3040,"address":[],"length":0,"stats":{"Line":6}},{"line":3041,"address":[],"length":0,"stats":{"Line":10}},{"line":3043,"address":[],"length":0,"stats":{"Line":4}},{"line":3044,"address":[],"length":0,"stats":{"Line":4}},{"line":3045,"address":[],"length":0,"stats":{"Line":4}},{"line":3046,"address":[],"length":0,"stats":{"Line":8}},{"line":3050,"address":[],"length":0,"stats":{"Line":36}},{"line":3051,"address":[],"length":0,"stats":{"Line":9}},{"line":3052,"address":[],"length":0,"stats":{"Line":38}},{"line":3053,"address":[],"length":0,"stats":{"Line":4}},{"line":3054,"address":[],"length":0,"stats":{"Line":8}},{"line":3058,"address":[],"length":0,"stats":{"Line":18}},{"line":3059,"address":[],"length":0,"stats":{"Line":28}},{"line":3062,"address":[],"length":0,"stats":{"Line":6}},{"line":3063,"address":[],"length":0,"stats":{"Line":2}},{"line":3064,"address":[],"length":0,"stats":{"Line":4}},{"line":3066,"address":[],"length":0,"stats":{"Line":10}},{"line":3067,"address":[],"length":0,"stats":{"Line":10}},{"line":3068,"address":[],"length":0,"stats":{"Line":10}},{"line":3071,"address":[],"length":0,"stats":{"Line":0}},{"line":3073,"address":[],"length":0,"stats":{"Line":12}},{"line":3074,"address":[],"length":0,"stats":{"Line":7}},{"line":3075,"address":[],"length":0,"stats":{"Line":28}},{"line":3078,"address":[],"length":0,"stats":{"Line":0}},{"line":3079,"address":[],"length":0,"stats":{"Line":0}},{"line":3080,"address":[],"length":0,"stats":{"Line":0}},{"line":3082,"address":[],"length":0,"stats":{"Line":0}},{"line":3083,"address":[],"length":0,"stats":{"Line":0}},{"line":3086,"address":[],"length":0,"stats":{"Line":0}},{"line":3088,"address":[],"length":0,"stats":{"Line":0}},{"line":3089,"address":[],"length":0,"stats":{"Line":0}},{"line":3090,"address":[],"length":0,"stats":{"Line":35}},{"line":3093,"address":[],"length":0,"stats":{"Line":0}},{"line":3094,"address":[],"length":0,"stats":{"Line":0}},{"line":3095,"address":[],"length":0,"stats":{"Line":0}},{"line":3096,"address":[],"length":0,"stats":{"Line":0}},{"line":3097,"address":[],"length":0,"stats":{"Line":0}},{"line":3098,"address":[],"length":0,"stats":{"Line":0}},{"line":3101,"address":[],"length":0,"stats":{"Line":35}},{"line":3105,"address":[],"length":0,"stats":{"Line":18}},{"line":3106,"address":[],"length":0,"stats":{"Line":36}},{"line":3112,"address":[],"length":0,"stats":{"Line":18}},{"line":3113,"address":[],"length":0,"stats":{"Line":18}},{"line":3114,"address":[],"length":0,"stats":{"Line":63}},{"line":3115,"address":[],"length":0,"stats":{"Line":108}},{"line":3117,"address":[],"length":0,"stats":{"Line":81}},{"line":3118,"address":[],"length":0,"stats":{"Line":36}},{"line":3119,"address":[],"length":0,"stats":{"Line":9}},{"line":3121,"address":[],"length":0,"stats":{"Line":0}},{"line":3122,"address":[],"length":0,"stats":{"Line":0}},{"line":3124,"address":[],"length":0,"stats":{"Line":9}},{"line":3127,"address":[],"length":0,"stats":{"Line":9}},{"line":3130,"address":[],"length":0,"stats":{"Line":63}},{"line":3131,"address":[],"length":0,"stats":{"Line":36}},{"line":3132,"address":[],"length":0,"stats":{"Line":9}},{"line":3133,"address":[],"length":0,"stats":{"Line":0}},{"line":3135,"address":[],"length":0,"stats":{"Line":0}},{"line":3136,"address":[],"length":0,"stats":{"Line":0}},{"line":3137,"address":[],"length":0,"stats":{"Line":0}},{"line":3138,"address":[],"length":0,"stats":{"Line":0}},{"line":3140,"address":[],"length":0,"stats":{"Line":0}},{"line":3142,"address":[],"length":0,"stats":{"Line":0}},{"line":3143,"address":[],"length":0,"stats":{"Line":0}},{"line":3145,"address":[],"length":0,"stats":{"Line":0}},{"line":3147,"address":[],"length":0,"stats":{"Line":0}},{"line":3148,"address":[],"length":0,"stats":{"Line":0}},{"line":3149,"address":[],"length":0,"stats":{"Line":0}},{"line":3150,"address":[],"length":0,"stats":{"Line":0}},{"line":3152,"address":[],"length":0,"stats":{"Line":9}},{"line":3158,"address":[],"length":0,"stats":{"Line":27}},{"line":3159,"address":[],"length":0,"stats":{"Line":21}},{"line":3160,"address":[],"length":0,"stats":{"Line":14}},{"line":3162,"address":[],"length":0,"stats":{"Line":35}},{"line":3163,"address":[],"length":0,"stats":{"Line":14}},{"line":3166,"address":[],"length":0,"stats":{"Line":9}},{"line":3171,"address":[],"length":0,"stats":{"Line":9}},{"line":3177,"address":[],"length":0,"stats":{"Line":9}},{"line":3178,"address":[],"length":0,"stats":{"Line":8}},{"line":3179,"address":[],"length":0,"stats":{"Line":4}},{"line":3180,"address":[],"length":0,"stats":{"Line":4}},{"line":3182,"address":[],"length":0,"stats":{"Line":0}},{"line":3184,"address":[],"length":0,"stats":{"Line":6}},{"line":3189,"address":[],"length":0,"stats":{"Line":35}},{"line":3190,"address":[],"length":0,"stats":{"Line":21}},{"line":3194,"address":[],"length":0,"stats":{"Line":9}},{"line":3195,"address":[],"length":0,"stats":{"Line":2}},{"line":3196,"address":[],"length":0,"stats":{"Line":9}},{"line":3197,"address":[],"length":0,"stats":{"Line":41}},{"line":3199,"address":[],"length":0,"stats":{"Line":28}},{"line":3200,"address":[],"length":0,"stats":{"Line":28}},{"line":3201,"address":[],"length":0,"stats":{"Line":0}},{"line":3205,"address":[],"length":0,"stats":{"Line":28}},{"line":3206,"address":[],"length":0,"stats":{"Line":84}},{"line":3208,"address":[],"length":0,"stats":{"Line":56}},{"line":3209,"address":[],"length":0,"stats":{"Line":175}},{"line":3210,"address":[],"length":0,"stats":{"Line":77}},{"line":3211,"address":[],"length":0,"stats":{"Line":7}},{"line":3213,"address":[],"length":0,"stats":{"Line":210}},{"line":3214,"address":[],"length":0,"stats":{"Line":98}},{"line":3215,"address":[],"length":0,"stats":{"Line":21}},{"line":3216,"address":[],"length":0,"stats":{"Line":0}},{"line":3217,"address":[],"length":0,"stats":{"Line":0}},{"line":3219,"address":[],"length":0,"stats":{"Line":21}},{"line":3223,"address":[],"length":0,"stats":{"Line":21}},{"line":3227,"address":[],"length":0,"stats":{"Line":14}},{"line":3228,"address":[],"length":0,"stats":{"Line":12}},{"line":3229,"address":[],"length":0,"stats":{"Line":14}},{"line":3279,"address":[],"length":0,"stats":{"Line":0}},{"line":3280,"address":[],"length":0,"stats":{"Line":0}},{"line":3281,"address":[],"length":0,"stats":{"Line":0}},{"line":3282,"address":[],"length":0,"stats":{"Line":0}},{"line":3283,"address":[],"length":0,"stats":{"Line":0}},{"line":3284,"address":[],"length":0,"stats":{"Line":0}},{"line":3285,"address":[],"length":0,"stats":{"Line":0}},{"line":3286,"address":[],"length":0,"stats":{"Line":0}},{"line":3288,"address":[],"length":0,"stats":{"Line":0}},{"line":3292,"address":[],"length":0,"stats":{"Line":4}},{"line":3293,"address":[],"length":0,"stats":{"Line":4}},{"line":3294,"address":[],"length":0,"stats":{"Line":4}},{"line":3295,"address":[],"length":0,"stats":{"Line":8}},{"line":3297,"address":[],"length":0,"stats":{"Line":4}},{"line":3298,"address":[],"length":0,"stats":{"Line":8}},{"line":3299,"address":[],"length":0,"stats":{"Line":8}},{"line":3300,"address":[],"length":0,"stats":{"Line":11}},{"line":3301,"address":[],"length":0,"stats":{"Line":3}},{"line":3304,"address":[],"length":0,"stats":{"Line":3}},{"line":3305,"address":[],"length":0,"stats":{"Line":2}},{"line":3307,"address":[],"length":0,"stats":{"Line":2}},{"line":3309,"address":[],"length":0,"stats":{"Line":4}},{"line":3311,"address":[],"length":0,"stats":{"Line":0}},{"line":3312,"address":[],"length":0,"stats":{"Line":0}},{"line":3313,"address":[],"length":0,"stats":{"Line":0}},{"line":3314,"address":[],"length":0,"stats":{"Line":0}},{"line":3315,"address":[],"length":0,"stats":{"Line":0}},{"line":3317,"address":[],"length":0,"stats":{"Line":0}},{"line":3318,"address":[],"length":0,"stats":{"Line":0}},{"line":3322,"address":[],"length":0,"stats":{"Line":0}},{"line":3324,"address":[],"length":0,"stats":{"Line":0}},{"line":3326,"address":[],"length":0,"stats":{"Line":0}},{"line":3327,"address":[],"length":0,"stats":{"Line":0}},{"line":3328,"address":[],"length":0,"stats":{"Line":0}},{"line":3329,"address":[],"length":0,"stats":{"Line":0}},{"line":3331,"address":[],"length":0,"stats":{"Line":0}},{"line":3332,"address":[],"length":0,"stats":{"Line":0}},{"line":3334,"address":[],"length":0,"stats":{"Line":0}},{"line":3338,"address":[],"length":0,"stats":{"Line":6}},{"line":3339,"address":[],"length":0,"stats":{"Line":24}},{"line":3340,"address":[],"length":0,"stats":{"Line":24}},{"line":3342,"address":[],"length":0,"stats":{"Line":6}},{"line":3343,"address":[],"length":0,"stats":{"Line":6}},{"line":3344,"address":[],"length":0,"stats":{"Line":12}},{"line":3346,"address":[],"length":0,"stats":{"Line":6}},{"line":3347,"address":[],"length":0,"stats":{"Line":24}},{"line":3349,"address":[],"length":0,"stats":{"Line":0}},{"line":3350,"address":[],"length":0,"stats":{"Line":0}},{"line":3351,"address":[],"length":0,"stats":{"Line":0}},{"line":3352,"address":[],"length":0,"stats":{"Line":0}},{"line":3353,"address":[],"length":0,"stats":{"Line":0}},{"line":3355,"address":[],"length":0,"stats":{"Line":0}},{"line":3357,"address":[],"length":0,"stats":{"Line":0}},{"line":3358,"address":[],"length":0,"stats":{"Line":0}},{"line":3360,"address":[],"length":0,"stats":{"Line":0}},{"line":3362,"address":[],"length":0,"stats":{"Line":0}},{"line":3363,"address":[],"length":0,"stats":{"Line":0}},{"line":3364,"address":[],"length":0,"stats":{"Line":0}},{"line":3365,"address":[],"length":0,"stats":{"Line":0}},{"line":3369,"address":[],"length":0,"stats":{"Line":0}},{"line":3371,"address":[],"length":0,"stats":{"Line":0}},{"line":3373,"address":[],"length":0,"stats":{"Line":0}},{"line":3374,"address":[],"length":0,"stats":{"Line":0}},{"line":3375,"address":[],"length":0,"stats":{"Line":0}},{"line":3376,"address":[],"length":0,"stats":{"Line":0}},{"line":3378,"address":[],"length":0,"stats":{"Line":0}},{"line":3379,"address":[],"length":0,"stats":{"Line":0}},{"line":3380,"address":[],"length":0,"stats":{"Line":0}},{"line":3381,"address":[],"length":0,"stats":{"Line":0}},{"line":3382,"address":[],"length":0,"stats":{"Line":0}},{"line":3383,"address":[],"length":0,"stats":{"Line":0}},{"line":3387,"address":[],"length":0,"stats":{"Line":0}},{"line":3391,"address":[],"length":0,"stats":{"Line":0}},{"line":3393,"address":[],"length":0,"stats":{"Line":0}},{"line":3394,"address":[],"length":0,"stats":{"Line":0}},{"line":3395,"address":[],"length":0,"stats":{"Line":0}},{"line":3400,"address":[],"length":0,"stats":{"Line":0}},{"line":3401,"address":[],"length":0,"stats":{"Line":0}},{"line":3402,"address":[],"length":0,"stats":{"Line":0}},{"line":3403,"address":[],"length":0,"stats":{"Line":0}},{"line":3405,"address":[],"length":0,"stats":{"Line":0}},{"line":3406,"address":[],"length":0,"stats":{"Line":0}},{"line":3407,"address":[],"length":0,"stats":{"Line":0}},{"line":3408,"address":[],"length":0,"stats":{"Line":0}},{"line":3409,"address":[],"length":0,"stats":{"Line":0}},{"line":3410,"address":[],"length":0,"stats":{"Line":0}},{"line":3411,"address":[],"length":0,"stats":{"Line":0}},{"line":3412,"address":[],"length":0,"stats":{"Line":0}},{"line":3414,"address":[],"length":0,"stats":{"Line":0}},{"line":3416,"address":[],"length":0,"stats":{"Line":0}},{"line":3417,"address":[],"length":0,"stats":{"Line":0}},{"line":3418,"address":[],"length":0,"stats":{"Line":0}},{"line":3419,"address":[],"length":0,"stats":{"Line":0}},{"line":3421,"address":[],"length":0,"stats":{"Line":0}},{"line":3422,"address":[],"length":0,"stats":{"Line":0}},{"line":3424,"address":[],"length":0,"stats":{"Line":0}},{"line":3426,"address":[],"length":0,"stats":{"Line":0}},{"line":3430,"address":[],"length":0,"stats":{"Line":0}},{"line":3431,"address":[],"length":0,"stats":{"Line":0}},{"line":3433,"address":[],"length":0,"stats":{"Line":0}},{"line":3434,"address":[],"length":0,"stats":{"Line":0}},{"line":3436,"address":[],"length":0,"stats":{"Line":0}},{"line":3437,"address":[],"length":0,"stats":{"Line":0}},{"line":3440,"address":[],"length":0,"stats":{"Line":0}},{"line":3441,"address":[],"length":0,"stats":{"Line":0}},{"line":3444,"address":[],"length":0,"stats":{"Line":0}},{"line":3445,"address":[],"length":0,"stats":{"Line":0}},{"line":3447,"address":[],"length":0,"stats":{"Line":0}},{"line":3449,"address":[],"length":0,"stats":{"Line":0}},{"line":3451,"address":[],"length":0,"stats":{"Line":0}},{"line":3452,"address":[],"length":0,"stats":{"Line":0}},{"line":3454,"address":[],"length":0,"stats":{"Line":0}},{"line":3456,"address":[],"length":0,"stats":{"Line":0}},{"line":3459,"address":[],"length":0,"stats":{"Line":0}},{"line":3460,"address":[],"length":0,"stats":{"Line":0}},{"line":3461,"address":[],"length":0,"stats":{"Line":0}},{"line":3464,"address":[],"length":0,"stats":{"Line":0}},{"line":3466,"address":[],"length":0,"stats":{"Line":0}},{"line":3468,"address":[],"length":0,"stats":{"Line":0}},{"line":3469,"address":[],"length":0,"stats":{"Line":0}},{"line":3471,"address":[],"length":0,"stats":{"Line":0}},{"line":3472,"address":[],"length":0,"stats":{"Line":0}},{"line":3474,"address":[],"length":0,"stats":{"Line":0}},{"line":3475,"address":[],"length":0,"stats":{"Line":0}},{"line":3476,"address":[],"length":0,"stats":{"Line":0}},{"line":3481,"address":[],"length":0,"stats":{"Line":0}},{"line":3483,"address":[],"length":0,"stats":{"Line":0}},{"line":3484,"address":[],"length":0,"stats":{"Line":0}},{"line":3485,"address":[],"length":0,"stats":{"Line":0}},{"line":3490,"address":[],"length":0,"stats":{"Line":0}},{"line":3491,"address":[],"length":0,"stats":{"Line":0}},{"line":3492,"address":[],"length":0,"stats":{"Line":0}},{"line":3494,"address":[],"length":0,"stats":{"Line":0}},{"line":3495,"address":[],"length":0,"stats":{"Line":0}},{"line":3496,"address":[],"length":0,"stats":{"Line":0}},{"line":3498,"address":[],"length":0,"stats":{"Line":0}},{"line":3504,"address":[],"length":0,"stats":{"Line":0}},{"line":3505,"address":[],"length":0,"stats":{"Line":0}}],"covered":943,"coverable":1978},{"path":["/","workspace","crates","ofml-lib","src","lexer.rs"],"content":"//! OFML Lexer - Based on official OFML 2.0 specification\n//! See: docs/3d-rendering/ofml_analysis/ofml_spec.pdf\n\nuse logos::Logos;\n\n/// Token types for the OFML language\n/// Based on Section 3.2 of OFML specification\n#[derive(Logos, Debug, Clone, PartialEq)]\n#[logos(skip r\"[ \\t\\r\\n\\x0B\\x0C]+\")] // whitespace including VT, FF\n#[logos(skip r\"//[^\\r\\n]*\")] // line comments\n#[logos(skip r\"#[^\\r\\n]*\")] // hash-style line comments (used in some OFML files)\n#[logos(skip r\"/\\*([^*]|\\*[^/])*\\*/\")] // block comments\npub enum Token {\n    // ============================================================\n    // Keywords (Section 3.2.4)\n    // ============================================================\n    #[token(\"abstract\")]\n    Abstract,\n    #[token(\"break\")]\n    Break,\n    #[token(\"case\")]\n    Case,\n    #[token(\"catch\")]\n    Catch,\n    #[token(\"class\")]\n    Class,\n    #[token(\"continue\")]\n    Continue,\n    #[token(\"default\")]\n    Default,\n    #[token(\"do\")]\n    Do,\n    #[token(\"else\")]\n    Else,\n    #[token(\"final\")]\n    Final,\n    #[token(\"finally\")]\n    Finally,\n    #[token(\"for\")]\n    For,\n    #[token(\"foreach\")]\n    Foreach,\n    #[token(\"func\")]\n    Func,\n    #[token(\"goto\")]\n    Goto,\n    #[token(\"if\")]\n    If,\n    #[token(\"import\")]\n    Import,\n    #[token(\"instanceof\")]\n    Instanceof,\n    #[token(\"native\")]\n    Native,\n    #[token(\"operator\")]\n    Operator,\n    #[token(\"package\")]\n    Package,\n    #[token(\"private\")]\n    Private,\n    #[token(\"protected\")]\n    Protected,\n    #[token(\"public\")]\n    Public,\n    #[token(\"return\")]\n    Return,\n    #[token(\"rule\")]\n    Rule,\n    #[token(\"self\")]\n    SelfKw,\n    #[token(\"static\")]\n    Static,\n    #[token(\"super\")]\n    Super,\n    #[token(\"switch\")]\n    Switch,\n    #[token(\"throw\")]\n    Throw,\n    #[token(\"transient\")]\n    Transient,\n    #[token(\"try\")]\n    Try,\n    #[token(\"var\")]\n    Var,\n    #[token(\"while\")]\n    While,\n    #[token(\"NULL\")]\n    Null,\n\n    // ============================================================\n    // Operators (Section 3.2.6) - ordered by length for matching\n    // ============================================================\n\n    // Triple-character operators\n    #[token(\">>>=\")]\n    GtGtGtEq,\n    #[token(\">>>\")]\n    GtGtGt,\n    #[token(\"<<=\")]\n    LtLtEq,\n    #[token(\">>=\")]\n    GtGtEq,\n\n    // Double-character operators\n    #[token(\"++\")]\n    PlusPlus,\n    #[token(\"--\")]\n    MinusMinus,\n    #[token(\"!!\")]\n    BangBang,\n    #[token(\"==\")]\n    EqEq,\n    #[token(\"!=\")]\n    BangEq,\n    #[token(\"~=\")]\n    TildeEq,\n    #[token(\"<=\")]\n    LtEq,\n    #[token(\">=\")]\n    GtEq,\n    #[token(\"<<\")]\n    LtLt,\n    #[token(\">>\")]\n    GtGt,\n    #[token(\"&&\")]\n    AmpAmp,\n    #[token(\"||\")]\n    PipePipe,\n    #[token(\"=>\")]\n    FatArrow,\n    #[token(\"<?\")]\n    LtQuestion,\n    #[token(\">?\")]\n    GtQuestion,\n    #[token(\"*=\")]\n    StarEq,\n    #[token(\"/=\")]\n    SlashEq,\n    #[token(\"%=\")]\n    PercentEq,\n    #[token(\"+=\")]\n    PlusEq,\n    #[token(\"-=\")]\n    MinusEq,\n    #[token(\"&=\")]\n    AmpEq,\n    #[token(\"^=\")]\n    CaretEq,\n    #[token(\"|=\")]\n    PipeEq,\n    #[token(\"::\")]\n    ColonColon,\n    #[token(\"@(\")]\n    AtLParen,\n\n    // Single-character operators\n    #[token(\".\")]\n    Dot,\n    #[token(\"!\")]\n    Bang,\n    #[token(\"~\")]\n    Tilde,\n    #[token(\"$\")]\n    Dollar,\n    #[token(\"*\")]\n    Star,\n    #[token(\"/\")]\n    Slash,\n    #[token(\"%\")]\n    Percent,\n    #[token(\"+\")]\n    Plus,\n    #[token(\"-\")]\n    Minus,\n    #[token(\"<\")]\n    Lt,\n    #[token(\">\")]\n    Gt,\n    #[token(\"&\")]\n    Amp,\n    #[token(\"^\")]\n    Caret,\n    #[token(\"|\")]\n    Pipe,\n    #[token(\"?\")]\n    Question,\n    #[token(\":\")]\n    Colon,\n    #[token(\"=\")]\n    Eq,\n    #[token(\",\")]\n    Comma,\n    #[token(\"@\")]\n    At,\n\n    // ============================================================\n    // Delimiters (Section 3.2.7)\n    // ============================================================\n    #[token(\"(\")]\n    LParen,\n    #[token(\")\")]\n    RParen,\n    #[token(\"{\")]\n    LBrace,\n    #[token(\"}\")]\n    RBrace,\n    #[token(\"[\")]\n    LBracket,\n    #[token(\"]\")]\n    RBracket,\n    #[token(\";\")]\n    Semi,\n    #[token(\"...\")]\n    Ellipsis,\n\n    // ============================================================\n    // Literals (Section 3.2.5)\n    // ============================================================\n\n    // Hexadecimal integer: 0x... or 0X...\n    #[regex(r\"0[xX][0-9a-fA-F]+\", |lex| {\n        i64::from_str_radix(&lex.slice()[2..], 16).ok()\n    })]\n    HexInt(i64),\n\n    // Octal integer: 0...\n    #[regex(r\"0[0-7]+\", |lex| {\n        i64::from_str_radix(&lex.slice()[1..], 8).ok()\n    })]\n    OctInt(i64),\n\n    // Decimal integer\n    #[regex(r\"[1-9][0-9]*\", |lex| lex.slice().parse::<i64>().ok())]\n    DecInt(i64),\n\n    // Zero (special case - could be start of octal but alone is 0)\n    #[token(\"0\", |_| Some(0i64))]\n    Zero(i64),\n\n    // Floating point numbers\n    #[regex(r\"[0-9]+\\.[0-9]*([eE][+-]?[0-9]+)?\", |lex| lex.slice().parse::<f64>().ok())]\n    #[regex(r\"\\.[0-9]+([eE][+-]?[0-9]+)?\", |lex| lex.slice().parse::<f64>().ok())]\n    #[regex(r\"[0-9]+[eE][+-]?[0-9]+\", |lex| lex.slice().parse::<f64>().ok())]\n    Float(f64),\n\n    // String literal (double quotes)\n    #[regex(r#\"\"([^\"\\\\]|\\\\.)*\"\"#, |lex| {\n        let s = lex.slice();\n        unescape_string(&s[1..s.len()-1])\n    })]\n    StringLit(String),\n\n    // Character literal (single quotes) -> treated as integer\n    #[regex(r\"'([^'\\\\]|\\\\.)'\", |lex| {\n        let s = lex.slice();\n        parse_char_literal(&s[1..s.len()-1])\n    })]\n    CharLit(i64),\n\n    // Symbol literal: @identifier\n    #[regex(r\"@[a-zA-Z_][a-zA-Z0-9_]*\", |lex| lex.slice()[1..].to_string())]\n    Symbol(String),\n\n    // ============================================================\n    // Identifier (Section 3.2.3)\n    // ============================================================\n    #[regex(r\"[a-zA-Z_][a-zA-Z0-9_]*\", |lex| lex.slice().to_string(), priority = 1)]\n    Ident(String),\n}\n\n/// Unescape string literals according to OFML spec (Section 3.2.5)\nfn unescape_string(s: &str) -> String {\n    let mut result = String::with_capacity(s.len());\n    let mut chars = s.chars().peekable();\n\n    while let Some(c) = chars.next() {\n        if c == '\\\\' {\n            match chars.next() {\n                Some('a') => result.push('\\x07'), // BEL\n                Some('b') => result.push('\\x08'), // BS\n                Some('t') => result.push('\\t'),   // HT\n                Some('n') => result.push('\\n'),   // NL\n                Some('v') => result.push('\\x0B'), // VT\n                Some('f') => result.push('\\x0C'), // FF\n                Some('r') => result.push('\\r'),   // CR\n                Some('\"') => result.push('\"'),\n                Some('\\'') => result.push('\\''),\n                Some('\\\\') => result.push('\\\\'),\n                Some('x') => {\n                    // Hex escape: \\xHH...\n                    let mut hex = String::new();\n                    while let Some(&c) = chars.peek() {\n                        if c.is_ascii_hexdigit() {\n                            hex.push(chars.next().unwrap());\n                        } else {\n                            break;\n                        }\n                    }\n                    if let Ok(code) = u32::from_str_radix(&hex, 16) {\n                        if let Some(ch) = char::from_u32(code) {\n                            result.push(ch);\n                        }\n                    }\n                }\n                Some(c) if c.is_ascii_digit() && c != '8' && c != '9' => {\n                    // Octal escape: \\OOO\n                    let mut oct = String::from(c);\n                    for _ in 0..2 {\n                        if let Some(&c) = chars.peek() {\n                            if ('0'..='7').contains(&c) {\n                                oct.push(chars.next().unwrap());\n                            } else {\n                                break;\n                            }\n                        }\n                    }\n                    if let Ok(code) = u32::from_str_radix(&oct, 8) {\n                        if let Some(ch) = char::from_u32(code) {\n                            result.push(ch);\n                        }\n                    }\n                }\n                Some(c) => {\n                    result.push('\\\\');\n                    result.push(c);\n                }\n                None => result.push('\\\\'),\n            }\n        } else {\n            result.push(c);\n        }\n    }\n    result\n}\n\n/// Parse character literal to integer value\nfn parse_char_literal(s: &str) -> i64 {\n    let unescaped = unescape_string(s);\n    unescaped.chars().next().map(|c| c as i64).unwrap_or(0)\n}\n\nimpl Token {\n    /// Get integer value from any integer token type\n    pub fn as_int(&self) -> Option<i64> {\n        match self {\n            Token::DecInt(n)\n            | Token::HexInt(n)\n            | Token::OctInt(n)\n            | Token::Zero(n)\n            | Token::CharLit(n) => Some(*n),\n            _ => None,\n        }\n    }\n\n    /// Get float value\n    pub fn as_float(&self) -> Option<f64> {\n        match self {\n            Token::Float(f) => Some(*f),\n            _ => None,\n        }\n    }\n\n    /// Get string value\n    pub fn as_string(&self) -> Option<&str> {\n        match self {\n            Token::StringLit(s) => Some(s),\n            _ => None,\n        }\n    }\n\n    /// Check if token is a keyword\n    pub fn is_keyword(&self) -> bool {\n        matches!(\n            self,\n            Token::Abstract\n                | Token::Break\n                | Token::Case\n                | Token::Catch\n                | Token::Class\n                | Token::Continue\n                | Token::Default\n                | Token::Do\n                | Token::Else\n                | Token::Final\n                | Token::Finally\n                | Token::For\n                | Token::Foreach\n                | Token::Func\n                | Token::Goto\n                | Token::If\n                | Token::Import\n                | Token::Instanceof\n                | Token::Native\n                | Token::Operator\n                | Token::Package\n                | Token::Private\n                | Token::Protected\n                | Token::Public\n                | Token::Return\n                | Token::Rule\n                | Token::SelfKw\n                | Token::Static\n                | Token::Super\n                | Token::Switch\n                | Token::Throw\n                | Token::Transient\n                | Token::Try\n                | Token::Var\n                | Token::While\n                | Token::Null\n        )\n    }\n}\n\n/// A token with source location information\n#[derive(Debug, Clone)]\npub struct SpannedToken {\n    pub token: Token,\n    pub span: std::ops::Range<usize>,\n}\n\n/// Lexer error\n#[derive(Debug, Clone)]\npub struct LexError {\n    pub span: std::ops::Range<usize>,\n    pub slice: String,\n}\n\nimpl std::fmt::Display for LexError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(\n            f,\n            \"Unexpected token '{}' at position {}\",\n            self.slice, self.span.start\n        )\n    }\n}\n\nimpl std::error::Error for LexError {}\n\n/// Tokenize source code into a vector of spanned tokens\npub fn tokenize(source: &str) -> Result<Vec<SpannedToken>, LexError> {\n    let mut lexer = Token::lexer(source);\n    let mut tokens = Vec::new();\n\n    while let Some(result) = lexer.next() {\n        match result {\n            Ok(token) => tokens.push(SpannedToken {\n                token,\n                span: lexer.span(),\n            }),\n            Err(_) => {\n                return Err(LexError {\n                    span: lexer.span(),\n                    slice: source[lexer.span()].to_string(),\n                });\n            }\n        }\n    }\n\n    Ok(tokens)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_keywords() {\n        let tokens: Vec<_> = Token::lexer(\"package import class var func rule\")\n            .filter_map(|r| r.ok())\n            .collect();\n        assert_eq!(\n            tokens,\n            vec![\n                Token::Package,\n                Token::Import,\n                Token::Class,\n                Token::Var,\n                Token::Func,\n                Token::Rule,\n            ]\n        );\n    }\n\n    #[test]\n    fn test_all_keywords() {\n        let source = \"abstract break case catch class continue default do else \\\n                      final finally for foreach func goto if import instanceof \\\n                      native operator package private protected public return \\\n                      rule self static super switch throw transient try var while NULL\";\n        let tokens: Vec<_> = Token::lexer(source).filter_map(|r| r.ok()).collect();\n        assert_eq!(tokens.len(), 36); // 36 keywords total\n        assert!(tokens.iter().all(|t| t.is_keyword()));\n    }\n\n    #[test]\n    fn test_symbols() {\n        let tokens: Vec<_> = Token::lexer(\"@Width @GWK_ANBAU @_private\")\n            .filter_map(|r| r.ok())\n            .collect();\n        assert_eq!(\n            tokens,\n            vec![\n                Token::Symbol(\"Width\".to_string()),\n                Token::Symbol(\"GWK_ANBAU\".to_string()),\n                Token::Symbol(\"_private\".to_string()),\n            ]\n        );\n    }\n\n    #[test]\n    fn test_integers() {\n        let tokens: Vec<_> = Token::lexer(\"123 0 0x1F 0777\")\n            .filter_map(|r| r.ok())\n            .collect();\n        assert_eq!(tokens[0].as_int(), Some(123));\n        assert_eq!(tokens[1].as_int(), Some(0));\n        assert_eq!(tokens[2].as_int(), Some(31)); // 0x1F\n        assert_eq!(tokens[3].as_int(), Some(511)); // 0777 octal\n    }\n\n    #[test]\n    fn test_floats() {\n        let tokens: Vec<_> = Token::lexer(\"3.14 .5 1e10 2.5e-3\")\n            .filter_map(|r| r.ok())\n            .collect();\n        assert_eq!(tokens[0].as_float(), Some(3.14));\n        assert_eq!(tokens[1].as_float(), Some(0.5));\n        assert_eq!(tokens[2].as_float(), Some(1e10));\n        assert_eq!(tokens[3].as_float(), Some(2.5e-3));\n    }\n\n    #[test]\n    fn test_strings() {\n        let tokens: Vec<_> = Token::lexer(r#\"\"hello\" \"world\\n\" \"tab\\there\"\"#)\n            .filter_map(|r| r.ok())\n            .collect();\n        assert_eq!(tokens[0].as_string(), Some(\"hello\"));\n        assert_eq!(tokens[1].as_string(), Some(\"world\\n\"));\n        assert_eq!(tokens[2].as_string(), Some(\"tab\\there\"));\n    }\n\n    #[test]\n    fn test_operators() {\n        let tokens: Vec<_> = Token::lexer(\"+ - * / % == != <= >= && || ++ -- << >>\")\n            .filter_map(|r| r.ok())\n            .collect();\n        assert_eq!(\n            tokens,\n            vec![\n                Token::Plus,\n                Token::Minus,\n                Token::Star,\n                Token::Slash,\n                Token::Percent,\n                Token::EqEq,\n                Token::BangEq,\n                Token::LtEq,\n                Token::GtEq,\n                Token::AmpAmp,\n                Token::PipePipe,\n                Token::PlusPlus,\n                Token::MinusMinus,\n                Token::LtLt,\n                Token::GtGt,\n            ]\n        );\n    }\n\n    #[test]\n    fn test_class_decl() {\n        let source = \"public class WkPlGroup: OiObject { }\";\n        let tokens: Vec<_> = Token::lexer(source).filter_map(|r| r.ok()).collect();\n        assert_eq!(\n            tokens,\n            vec![\n                Token::Public,\n                Token::Class,\n                Token::Ident(\"WkPlGroup\".to_string()),\n                Token::Colon,\n                Token::Ident(\"OiObject\".to_string()),\n                Token::LBrace,\n                Token::RBrace,\n            ]\n        );\n    }\n\n    #[test]\n    fn test_qualified_name() {\n        let source = \"::vitra::workit::*\";\n        let tokens: Vec<_> = Token::lexer(source).filter_map(|r| r.ok()).collect();\n        assert_eq!(\n            tokens,\n            vec![\n                Token::ColonColon,\n                Token::Ident(\"vitra\".to_string()),\n                Token::ColonColon,\n                Token::Ident(\"workit\".to_string()),\n                Token::ColonColon,\n                Token::Star,\n            ]\n        );\n    }\n\n    #[test]\n    fn test_symbol_array() {\n        let source = \"@(item1, item2)\";\n        let tokens: Vec<_> = Token::lexer(source).filter_map(|r| r.ok()).collect();\n        assert_eq!(\n            tokens,\n            vec![\n                Token::AtLParen,\n                Token::Ident(\"item1\".to_string()),\n                Token::Comma,\n                Token::Ident(\"item2\".to_string()),\n                Token::RParen,\n            ]\n        );\n    }\n\n    #[test]\n    fn test_real_cls_snippet() {\n        let source = r#\"\n            var sAddTables = Hash();\n            sAddTables[@W140] = [\"89209701\", \"\"];\n        \"#;\n        let tokens: Vec<_> = Token::lexer(source).filter_map(|r| r.ok()).collect();\n        // Should parse without errors\n        assert!(tokens.len() > 10);\n    }\n\n    #[test]\n    fn test_comments() {\n        let source = r#\"\n            // This is a comment\n            var x = 1; // inline comment\n            /* block\n               comment */\n            var y = 2;\n        \"#;\n        let tokens: Vec<_> = Token::lexer(source).filter_map(|r| r.ok()).collect();\n        // Comments should be skipped\n        let idents: Vec<_> = tokens\n            .iter()\n            .filter_map(|t| {\n                if let Token::Ident(s) = t {\n                    Some(s.as_str())\n                } else {\n                    None\n                }\n            })\n            .collect();\n        assert_eq!(idents, vec![\"x\", \"y\"]);\n    }\n\n    #[test]\n    fn test_hash_comment() {\n        let source = \"# this is a comment\\nvar x = 1;\";\n        let tokens: Vec<_> = Token::lexer(source).filter_map(|r| r.ok()).collect();\n        assert_eq!(\n            tokens,\n            vec![\n                Token::Var,\n                Token::Ident(\"x\".to_string()),\n                Token::Eq,\n                Token::DecInt(1),\n                Token::Semi,\n            ]\n        );\n    }\n\n    #[test]\n    fn test_unescape_string_basic() {\n        assert_eq!(unescape_string(\"hello\"), \"hello\");\n        assert_eq!(unescape_string(\"\"), \"\");\n    }\n\n    #[test]\n    fn test_unescape_string_escape_sequences() {\n        assert_eq!(unescape_string(r\"\\n\"), \"\\n\");\n        assert_eq!(unescape_string(r\"\\t\"), \"\\t\");\n        assert_eq!(unescape_string(r\"\\r\"), \"\\r\");\n        assert_eq!(unescape_string(r\"\\\\\"), \"\\\\\");\n        assert_eq!(unescape_string(r#\"\\\"\"#), \"\\\"\");\n        assert_eq!(unescape_string(r\"\\'\"), \"'\");\n        assert_eq!(unescape_string(r\"\\a\"), \"\\x07\"); // BEL\n        assert_eq!(unescape_string(r\"\\b\"), \"\\x08\"); // BS\n        assert_eq!(unescape_string(r\"\\v\"), \"\\x0B\"); // VT\n        assert_eq!(unescape_string(r\"\\f\"), \"\\x0C\"); // FF\n    }\n\n    #[test]\n    fn test_unescape_string_hex() {\n        assert_eq!(unescape_string(r\"\\x41\"), \"A\");\n        assert_eq!(unescape_string(r\"\\x20\"), \" \");\n        assert_eq!(unescape_string(r\"\\x7A\"), \"z\");\n    }\n\n    #[test]\n    fn test_unescape_string_octal() {\n        assert_eq!(unescape_string(r\"\\101\"), \"A\"); // 65 in octal\n        assert_eq!(unescape_string(r\"\\040\"), \" \"); // 32 in octal\n        assert_eq!(unescape_string(r\"\\0\"), \"\\0\");\n    }\n\n    #[test]\n    fn test_unescape_string_unknown_escape() {\n        // Unknown escape sequences are kept as-is\n        assert_eq!(unescape_string(r\"\\z\"), \"\\\\z\");\n        assert_eq!(unescape_string(r\"\\9\"), \"\\\\9\"); // 8 and 9 are not octal\n    }\n\n    #[test]\n    fn test_unescape_string_trailing_backslash() {\n        assert_eq!(unescape_string(r\"\\\"), \"\\\\\");\n    }\n\n    #[test]\n    fn test_parse_char_literal() {\n        assert_eq!(parse_char_literal(\"a\"), 97);\n        assert_eq!(parse_char_literal(\"A\"), 65);\n        assert_eq!(parse_char_literal(\"0\"), 48);\n        assert_eq!(parse_char_literal(r\"\\n\"), 10);\n        assert_eq!(parse_char_literal(r\"\\t\"), 9);\n    }\n\n    #[test]\n    fn test_parse_char_literal_empty() {\n        assert_eq!(parse_char_literal(\"\"), 0);\n    }\n\n    #[test]\n    fn test_token_as_int() {\n        assert_eq!(Token::DecInt(42).as_int(), Some(42));\n        assert_eq!(Token::HexInt(255).as_int(), Some(255));\n        assert_eq!(Token::OctInt(64).as_int(), Some(64));\n        assert_eq!(Token::Zero(0).as_int(), Some(0));\n        assert_eq!(Token::CharLit(65).as_int(), Some(65));\n        assert_eq!(Token::Float(3.14).as_int(), None);\n        assert_eq!(Token::StringLit(\"test\".to_string()).as_int(), None);\n    }\n\n    #[test]\n    fn test_token_as_float() {\n        assert_eq!(Token::Float(3.14).as_float(), Some(3.14));\n        assert_eq!(Token::DecInt(42).as_float(), None);\n    }\n\n    #[test]\n    fn test_token_as_string() {\n        assert_eq!(\n            Token::StringLit(\"hello\".to_string()).as_string(),\n            Some(\"hello\")\n        );\n        assert_eq!(Token::DecInt(42).as_string(), None);\n    }\n\n    #[test]\n    fn test_token_is_keyword() {\n        assert!(Token::Abstract.is_keyword());\n        assert!(Token::Break.is_keyword());\n        assert!(Token::While.is_keyword());\n        assert!(Token::Null.is_keyword());\n        assert!(!Token::DecInt(42).is_keyword());\n        assert!(!Token::Ident(\"foo\".to_string()).is_keyword());\n        assert!(!Token::Plus.is_keyword());\n    }\n\n    #[test]\n    fn test_spanned_token_debug_clone() {\n        let spanned = SpannedToken {\n            token: Token::Plus,\n            span: 0..1,\n        };\n        let debug = format!(\"{:?}\", spanned);\n        assert!(debug.contains(\"SpannedToken\"));\n        let cloned = spanned.clone();\n        assert_eq!(cloned.span, spanned.span);\n    }\n\n    #[test]\n    fn test_lex_error_display() {\n        let err = LexError {\n            span: 5..10,\n            slice: \"@@@\".to_string(),\n        };\n        let display = err.to_string();\n        assert!(display.contains(\"Unexpected token\"));\n        assert!(display.contains(\"@@@\"));\n        assert!(display.contains(\"5\"));\n    }\n\n    #[test]\n    fn test_lex_error_is_error() {\n        let err = LexError {\n            span: 0..1,\n            slice: \"~\".to_string(),\n        };\n        let _: &dyn std::error::Error = &err;\n    }\n\n    #[test]\n    fn test_lex_error_debug_clone() {\n        let err = LexError {\n            span: 0..5,\n            slice: \"error\".to_string(),\n        };\n        let debug = format!(\"{:?}\", err);\n        assert!(debug.contains(\"LexError\"));\n        let cloned = err.clone();\n        assert_eq!(cloned.slice, err.slice);\n    }\n\n    #[test]\n    fn test_tokenize_success() {\n        let result = tokenize(\"var x = 1;\");\n        assert!(result.is_ok());\n        let tokens = result.unwrap();\n        assert_eq!(tokens.len(), 5);\n        assert_eq!(tokens[0].token, Token::Var);\n        assert_eq!(tokens[1].token, Token::Ident(\"x\".to_string()));\n    }\n\n    #[test]\n    fn test_tokenize_with_spans() {\n        let result = tokenize(\"x + y\");\n        assert!(result.is_ok());\n        let tokens = result.unwrap();\n        assert_eq!(tokens[0].span, 0..1);\n        assert_eq!(tokens[1].span, 2..3);\n        assert_eq!(tokens[2].span, 4..5);\n    }\n\n    #[test]\n    fn test_tokenize_error() {\n        // This should cause a lexer error with an invalid character sequence\n        let result = tokenize(\"var x = `backtick`;\");\n        assert!(result.is_err());\n        let err = result.unwrap_err();\n        assert!(err.slice.contains(\"`\"));\n    }\n\n    #[test]\n    fn test_triple_char_operators() {\n        let tokens: Vec<_> = Token::lexer(\">>>= >>> <<= >>=\")\n            .filter_map(|r| r.ok())\n            .collect();\n        assert_eq!(\n            tokens,\n            vec![Token::GtGtGtEq, Token::GtGtGt, Token::LtLtEq, Token::GtGtEq,]\n        );\n    }\n\n    #[test]\n    fn test_double_char_operators() {\n        let tokens: Vec<_> = Token::lexer(\"!! ~= => <? >? *= /= %= += -= &= ^= |= ::\")\n            .filter_map(|r| r.ok())\n            .collect();\n        assert_eq!(\n            tokens,\n            vec![\n                Token::BangBang,\n                Token::TildeEq,\n                Token::FatArrow,\n                Token::LtQuestion,\n                Token::GtQuestion,\n                Token::StarEq,\n                Token::SlashEq,\n                Token::PercentEq,\n                Token::PlusEq,\n                Token::MinusEq,\n                Token::AmpEq,\n                Token::CaretEq,\n                Token::PipeEq,\n                Token::ColonColon,\n            ]\n        );\n    }\n\n    #[test]\n    fn test_single_char_operators() {\n        let tokens: Vec<_> = Token::lexer(\". ! ~ $ < > & ^ | ? : = , @\")\n            .filter_map(|r| r.ok())\n            .collect();\n        assert_eq!(\n            tokens,\n            vec![\n                Token::Dot,\n                Token::Bang,\n                Token::Tilde,\n                Token::Dollar,\n                Token::Lt,\n                Token::Gt,\n                Token::Amp,\n                Token::Caret,\n                Token::Pipe,\n                Token::Question,\n                Token::Colon,\n                Token::Eq,\n                Token::Comma,\n                Token::At,\n            ]\n        );\n    }\n\n    #[test]\n    fn test_delimiters() {\n        let tokens: Vec<_> = Token::lexer(\"( ) { } [ ] ; ...\")\n            .filter_map(|r| r.ok())\n            .collect();\n        assert_eq!(\n            tokens,\n            vec![\n                Token::LParen,\n                Token::RParen,\n                Token::LBrace,\n                Token::RBrace,\n                Token::LBracket,\n                Token::RBracket,\n                Token::Semi,\n                Token::Ellipsis,\n            ]\n        );\n    }\n\n    #[test]\n    fn test_char_literals() {\n        let tokens: Vec<_> = Token::lexer(\"'a' 'Z' '\\\\n' '0'\")\n            .filter_map(|r| r.ok())\n            .collect();\n        assert_eq!(tokens[0].as_int(), Some(97)); // 'a'\n        assert_eq!(tokens[1].as_int(), Some(90)); // 'Z'\n        assert_eq!(tokens[2].as_int(), Some(10)); // '\\n'\n        assert_eq!(tokens[3].as_int(), Some(48)); // '0'\n    }\n\n    #[test]\n    fn test_hex_uppercase() {\n        let tokens: Vec<_> = Token::lexer(\"0XFF 0XAB\").filter_map(|r| r.ok()).collect();\n        assert_eq!(tokens[0].as_int(), Some(255));\n        assert_eq!(tokens[1].as_int(), Some(171));\n    }\n\n    #[test]\n    fn test_float_exponent_positive() {\n        let tokens: Vec<_> = Token::lexer(\"1e+5 2.5E+10\")\n            .filter_map(|r| r.ok())\n            .collect();\n        assert_eq!(tokens[0].as_float(), Some(1e5));\n        assert_eq!(tokens[1].as_float(), Some(2.5e10));\n    }\n\n    #[test]\n    fn test_token_debug() {\n        let token = Token::Ident(\"test\".to_string());\n        let debug = format!(\"{:?}\", token);\n        assert!(debug.contains(\"Ident\"));\n        assert!(debug.contains(\"test\"));\n    }\n\n    #[test]\n    fn test_token_clone() {\n        let token = Token::StringLit(\"hello\".to_string());\n        let cloned = token.clone();\n        assert_eq!(token, cloned);\n    }\n\n    #[test]\n    fn test_token_eq() {\n        assert_eq!(Token::Plus, Token::Plus);\n        assert_ne!(Token::Plus, Token::Minus);\n        assert_eq!(Token::DecInt(42), Token::DecInt(42));\n        assert_ne!(Token::DecInt(42), Token::DecInt(43));\n    }\n\n    #[test]\n    fn test_whitespace_handling() {\n        // Test various whitespace characters\n        let source = \"var\\tx\\x0B=\\x0C1;\";\n        let tokens: Vec<_> = Token::lexer(source).filter_map(|r| r.ok()).collect();\n        assert_eq!(tokens.len(), 5);\n    }\n}\n","traces":[{"line":272,"address":[],"length":0,"stats":{"Line":154}},{"line":273,"address":[],"length":0,"stats":{"Line":616}},{"line":274,"address":[],"length":0,"stats":{"Line":616}},{"line":276,"address":[],"length":0,"stats":{"Line":2088}},{"line":277,"address":[],"length":0,"stats":{"Line":967}},{"line":278,"address":[],"length":0,"stats":{"Line":62}},{"line":279,"address":[],"length":0,"stats":{"Line":2}},{"line":280,"address":[],"length":0,"stats":{"Line":2}},{"line":281,"address":[],"length":0,"stats":{"Line":6}},{"line":282,"address":[],"length":0,"stats":{"Line":14}},{"line":283,"address":[],"length":0,"stats":{"Line":2}},{"line":284,"address":[],"length":0,"stats":{"Line":2}},{"line":285,"address":[],"length":0,"stats":{"Line":2}},{"line":286,"address":[],"length":0,"stats":{"Line":10}},{"line":287,"address":[],"length":0,"stats":{"Line":2}},{"line":288,"address":[],"length":0,"stats":{"Line":2}},{"line":291,"address":[],"length":0,"stats":{"Line":6}},{"line":292,"address":[],"length":0,"stats":{"Line":15}},{"line":293,"address":[],"length":0,"stats":{"Line":18}},{"line":294,"address":[],"length":0,"stats":{"Line":24}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":6}},{"line":300,"address":[],"length":0,"stats":{"Line":9}},{"line":301,"address":[],"length":0,"stats":{"Line":6}},{"line":305,"address":[],"length":0,"stats":{"Line":24}},{"line":307,"address":[],"length":0,"stats":{"Line":9}},{"line":308,"address":[],"length":0,"stats":{"Line":9}},{"line":309,"address":[],"length":0,"stats":{"Line":10}},{"line":310,"address":[],"length":0,"stats":{"Line":16}},{"line":311,"address":[],"length":0,"stats":{"Line":16}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":6}},{"line":318,"address":[],"length":0,"stats":{"Line":9}},{"line":319,"address":[],"length":0,"stats":{"Line":6}},{"line":323,"address":[],"length":0,"stats":{"Line":4}},{"line":324,"address":[],"length":0,"stats":{"Line":6}},{"line":325,"address":[],"length":0,"stats":{"Line":4}},{"line":327,"address":[],"length":0,"stats":{"Line":2}},{"line":330,"address":[],"length":0,"stats":{"Line":1872}},{"line":333,"address":[],"length":0,"stats":{"Line":154}},{"line":337,"address":[],"length":0,"stats":{"Line":12}},{"line":338,"address":[],"length":0,"stats":{"Line":36}},{"line":339,"address":[],"length":0,"stats":{"Line":59}},{"line":344,"address":[],"length":0,"stats":{"Line":17}},{"line":345,"address":[],"length":0,"stats":{"Line":17}},{"line":346,"address":[],"length":0,"stats":{"Line":2}},{"line":347,"address":[],"length":0,"stats":{"Line":4}},{"line":348,"address":[],"length":0,"stats":{"Line":2}},{"line":349,"address":[],"length":0,"stats":{"Line":2}},{"line":350,"address":[],"length":0,"stats":{"Line":20}},{"line":351,"address":[],"length":0,"stats":{"Line":2}},{"line":356,"address":[],"length":0,"stats":{"Line":8}},{"line":357,"address":[],"length":0,"stats":{"Line":8}},{"line":358,"address":[],"length":0,"stats":{"Line":14}},{"line":359,"address":[],"length":0,"stats":{"Line":1}},{"line":364,"address":[],"length":0,"stats":{"Line":5}},{"line":365,"address":[],"length":0,"stats":{"Line":5}},{"line":366,"address":[],"length":0,"stats":{"Line":8}},{"line":367,"address":[],"length":0,"stats":{"Line":1}},{"line":372,"address":[],"length":0,"stats":{"Line":43}},{"line":373,"address":[],"length":0,"stats":{"Line":3}},{"line":374,"address":[],"length":0,"stats":{"Line":43}},{"line":430,"address":[],"length":0,"stats":{"Line":2}},{"line":431,"address":[],"length":0,"stats":{"Line":2}},{"line":432,"address":[],"length":0,"stats":{"Line":2}},{"line":442,"address":[],"length":0,"stats":{"Line":218}},{"line":443,"address":[],"length":0,"stats":{"Line":654}},{"line":444,"address":[],"length":0,"stats":{"Line":436}},{"line":446,"address":[],"length":0,"stats":{"Line":21889}},{"line":447,"address":[],"length":0,"stats":{"Line":10836}},{"line":448,"address":[],"length":0,"stats":{"Line":43340}},{"line":449,"address":[],"length":0,"stats":{"Line":21670}},{"line":450,"address":[],"length":0,"stats":{"Line":10835}},{"line":453,"address":[],"length":0,"stats":{"Line":1}},{"line":454,"address":[],"length":0,"stats":{"Line":3}},{"line":455,"address":[],"length":0,"stats":{"Line":2}},{"line":461,"address":[],"length":0,"stats":{"Line":217}}],"covered":75,"coverable":77},{"path":["/","workspace","crates","ofml-lib","src","lib.rs"],"content":"//! OFML Interpreter - A Rust implementation of the Office Furniture Modeling Language\n//!\n//! This interpreter implements the OFML 2.0 specification for parsing and executing\n//! CLS (Class) files used in office furniture configuration systems.\n//!\n//! # Quick Start\n//!\n//! ```ignore\n//! use ofml_lib::oap::engine::ConfigurationEngine;\n//! use ofml_lib::oap::families::FamilyConfiguration;\n//!\n//! // Create a configuration engine\n//! let mut engine = ConfigurationEngine::new(\"/path/to/ofmldata\");\n//!\n//! // Load product families for a manufacturer\n//! let families = engine.load_families(\"vitra\").to_vec();\n//!\n//! // Configure a product\n//! if let Some(family) = families.first() {\n//!     let family_id = family.id.clone();\n//!     let properties = engine.get_family_properties(\"vitra\", &family_id);\n//!     let config = FamilyConfiguration::new(&family_id, &properties);\n//!     let price = engine.calculate_family_price(\n//!         \"vitra\",\n//!         family,\n//!         &config,\n//!         chrono::Local::now().date_naive(),\n//!     );\n//! }\n//! ```\n//!\n//! # Architecture\n//!\n//! ## Core OFML Modules\n//! - [`lexer`]: Tokenizes OFML source code\n//! - [`ast`]: Abstract Syntax Tree types\n//! - [`parser`]: Recursive descent parser\n//! - [`interpreter`]: Runtime execution engine\n//! - [`geometry`]: 3D geometry and transform handling\n//! - [`ebase_expr`]: EBASE PostScript-like expression evaluator\n//! - [`gobject`]: GObject type system\n//! - [`property`]: Property system for product configuration\n//! - [`ofml_classes`]: OFML framework classes (Go*, Oi*)\n//! - [`material`]: Material system (MAT files, textures)\n//! - [`geometry2d`]: 2D representation for floor plans\n//! - [`attachment`]: Attachment points system\n//!\n//! ## OAP Configurator Modules\n//! - [`oap::engine`]: Configuration engine with price calculation\n//! - [`oap::families`]: Product family grouping and configuration\n//! - [`oap::ocd`]: OCD data reader (articles, prices, texts)\n//! - [`oap::ocd_properties`]: OCD property definitions and values\n//! - [`oap::price`]: Pricing calculation utilities\n\n// Core modules (existing)\npub mod ast;\npub mod ebase;\npub mod env;\npub mod geometry;\npub mod interpreter;\npub mod lexer;\npub mod ofml;\npub mod parser;\npub mod scene;\npub mod value;\n\n// New modules for OFML CLS interpreter completion\npub mod alb_loader;\npub mod article;\npub mod attachment;\npub mod ebase_expr;\npub mod errors;\npub mod geometry2d;\npub mod gobject;\npub mod material;\npub mod ofml_classes;\npub mod operations;\npub mod property;\npub mod texture;\npub mod xoi_framework;\n\n// OAP Configurator modules\npub mod oap;\n\n// Re-exports for convenient access\npub use env::{Environment, Scope};\npub use interpreter::Interpreter;\npub use lexer::{tokenize, LexError, SpannedToken, Token};\npub use scene::{Axis, Geometry, SceneGraph, SceneNode};\npub use value::{ClassValue, FuncValue, ObjInstance, PropertyDef, Value};\n\n// New re-exports\npub use article::{ArticleConfig, ArticleLoader, PropertyValue, Variant, VariantGroup};\npub use article::{DIM_DEPTH, DIM_HEIGHT, DIM_WIDTH, MAT_BASIC, MAT_COLOR_PREFIX};\npub use attachment::{\n    load_all_attachments, load_attachment_from_record, load_attpt_table, load_oppattpt_table,\n    load_stdattpt_table, AttachmentPoint, AttachmentPointBuilder, AttachmentPointSet,\n    AttachmentType,\n};\npub use ebase::{read_ocd, read_odb2d, OcdRecord, Odb2dRecord};\npub use ebase_expr::{EbaseEvaluator, EbaseResult, EbaseToken, EbaseValue};\npub use errors::{\n    ArticleError, AttachmentError, EbaseExprError, GObjectError, Geometry2DError, MaterialError,\n    OfmlClassError, PropertyError,\n};\npub use geometry2d::{\n    odb2d_to_attributes, odb2d_to_primitive, process_odb2d_records, G2DAttributes, G2DCompound,\n    G2DPrimitive, Transform2D,\n};\npub use gobject::GValue;\npub use material::{MaterialDef, TextureDef, TextureProjection};\npub use ofml_classes::{\n    GeometryTransform, GoMirrorParams, GoXLRTransYLRTransParams, GoXLTransParams, GoYLTransParams,\n    GoZLTransParams, MirrorAxis, OfmlClassInstance, OfmlClassRegistry, OfmlClassType,\n    PrimitiveGeometry,\n};\npub use property::{PropertyState, PropertyType};\npub use texture::{TextureCache, TextureData};\n\n// Operations - high-level reusable functions\npub use operations::{\n    apply_transforms, assemble_product, evaluate_expression, export_2d_floorplan, export_to_glb,\n    load_and_merge_geometry, load_geometry_data, load_geometry_file, merge_scenes,\n    validate_geometry, OperationError, ProductConfig, ProductResult, ValidationResult,\n};\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    /// Helper to create and run OFML code\n    fn run_ofml(code: &str) -> Interpreter {\n        let mut parser = parser::Parser::new(code).expect(\"Failed to create parser\");\n        let ast = parser.parse().expect(\"Failed to parse\");\n        let mut interp = Interpreter::new();\n        interp.execute(&ast).expect(\"Failed to execute\");\n        interp\n    }\n\n    #[test]\n    fn test_property_system_basic() {\n        let code = r#\"\n            class TestObj : OiPart {\n                func initialize() {\n                    setupProperty(@myProp, [\"Label\", NULL, NULL, 0, \"ch @opt1 @opt2\"], 1);\n                    setPropValue(@myProp, @opt1);\n                }\n            }\n            var obj = TestObj();\n        \"#;\n\n        let interp = run_ofml(code);\n\n        // Check that object was created\n        let obj = interp.env.get(\"obj\").expect(\"obj should exist\");\n        if let Value::Object(instance) = obj {\n            let inst = instance.borrow();\n            // Check property was set\n            assert!(\n                inst.properties.contains_key(\"myProp\"),\n                \"myProp should exist\"\n            );\n            // Check property definition was created\n            assert!(\n                inst.prop_defs.contains_key(\"myProp\"),\n                \"property definition should exist\"\n            );\n            let prop_def = &inst.prop_defs[\"myProp\"];\n            assert_eq!(prop_def.sort_order, 1);\n        } else {\n            panic!(\"obj should be an Object\");\n        }\n    }\n\n    #[test]\n    fn test_get_set_prop_value() {\n        let code = r#\"\n            class TestObj : OiPart {\n                func initialize() {\n                    setPropValue(@color, @red);\n                }\n                func getColor() {\n                    return getPropValue(@color);\n                }\n            }\n            var obj = TestObj();\n            var color = obj.getColor();\n        \"#;\n\n        let interp = run_ofml(code);\n\n        let color = interp.env.get(\"color\").expect(\"color should exist\");\n        if let Value::Symbol(s) = color {\n            assert_eq!(s.as_str(), \"red\");\n        } else {\n            panic!(\"color should be a Symbol\");\n        }\n    }\n\n    #[test]\n    fn test_prop_state() {\n        let code = r#\"\n            class TestObj : OiPart {\n                func initialize() {\n                    setupProperty(@myProp, [\"Label\", NULL, NULL, 0, NULL], 1);\n                    setPropState(@myProp, 0);\n                }\n            }\n            var obj = TestObj();\n        \"#;\n\n        let interp = run_ofml(code);\n\n        let obj = interp.env.get(\"obj\").expect(\"obj should exist\");\n        if let Value::Object(instance) = obj {\n            let inst = instance.borrow();\n            assert_eq!(inst.prop_states.get(\"myProp\"), Some(&0));\n        } else {\n            panic!(\"obj should be an Object\");\n        }\n    }\n\n    #[test]\n    fn test_get_property_keys() {\n        let code = r#\"\n            class TestObj : OiPart {\n                func initialize() {\n                    setPropValue(@prop1, 10);\n                    setPropValue(@prop2, 20);\n                }\n                func getKeys() {\n                    return getPropertyKeys();\n                }\n            }\n            var obj = TestObj();\n            var keys = obj.getKeys();\n        \"#;\n\n        let interp = run_ofml(code);\n\n        let keys = interp.env.get(\"keys\").expect(\"keys should exist\");\n        if let Value::Array(arr) = keys {\n            let arr = arr.borrow();\n            assert_eq!(arr.len(), 2);\n        } else {\n            panic!(\"keys should be an Array\");\n        }\n    }\n\n    #[test]\n    fn test_oi_block_creation() {\n        let code = r#\"\n            class TestPart : OiPart {\n                func initialize() {\n                    OiBlock(self, @geo, [0.1, 0.2, 0.3]);\n                }\n            }\n            var part = TestPart();\n        \"#;\n\n        let interp = run_ofml(code);\n\n        // Check that the scene has a block\n        assert!(\n            interp.scene.mesh_count() >= 1,\n            \"Scene should have at least one mesh\"\n        );\n    }\n\n    #[test]\n    fn test_set_material() {\n        let code = r#\"\n            class TestBlock : OiPart {\n                func initialize() {\n                    OiBlock(self, @geo, [1, 1, 1]);\n                    setMaterial(\"::test::material::grey\");\n                }\n            }\n            var block = TestBlock();\n        \"#;\n\n        let interp = run_ofml(code);\n\n        let block = interp.env.get(\"block\").expect(\"block should exist\");\n        if let Value::Object(instance) = block {\n            let inst = instance.borrow();\n            let mat = inst.properties.get(\"material\");\n            assert!(mat.is_some(), \"material property should exist\");\n            if let Some(Value::String(s)) = mat {\n                assert!(s.contains(\"grey\"));\n            }\n        } else {\n            panic!(\"block should be an Object\");\n        }\n    }\n\n    #[test]\n    fn test_get_pd_manager() {\n        let code = r#\"\n            var pdm = getPDManager();\n            var pdb = pdm.getProductDB(@test_product);\n        \"#;\n\n        let interp = run_ofml(code);\n\n        // Check PDManager was created\n        let pdm = interp.env.get(\"pdm\").expect(\"pdm should exist\");\n        if let Value::Object(instance) = pdm {\n            assert_eq!(instance.borrow().class.name, \"PDManager\");\n        } else {\n            panic!(\"pdm should be an Object\");\n        }\n\n        // Check ProductDB was created\n        let pdb = interp.env.get(\"pdb\").expect(\"pdb should exist\");\n        if let Value::Object(instance) = pdb {\n            assert_eq!(instance.borrow().class.name, \"ProductDB\");\n        } else {\n            panic!(\"pdb should be an Object\");\n        }\n    }\n\n    #[test]\n    fn test_math_functions() {\n        let code = r#\"\n            var a = fabs(-5.5);\n            var m = Mod(10.5, 3);  // [3, 1.5]\n        \"#;\n\n        let interp = run_ofml(code);\n\n        let a = interp.env.get(\"a\").expect(\"a should exist\");\n        if let Value::Float(f) = a {\n            assert!((f - 5.5).abs() < 0.001);\n        } else {\n            panic!(\"a should be a Float\");\n        }\n\n        let m = interp.env.get(\"m\").expect(\"m should exist\");\n        if let Value::Array(arr) = m {\n            let arr = arr.borrow();\n            assert_eq!(arr.len(), 2);\n            if let Value::Float(quot) = &arr[0] {\n                assert!((quot - 3.0).abs() < 0.001);\n            }\n        } else {\n            panic!(\"m should be an Array\");\n        }\n    }\n\n    #[test]\n    fn test_remove_property() {\n        let code = r#\"\n            class TestObj : OiPart {\n                func initialize() {\n                    setPropValue(@myProp, 42);\n                    removeProperty(@myProp);\n                }\n            }\n            var obj = TestObj();\n        \"#;\n\n        let interp = run_ofml(code);\n\n        let obj = interp.env.get(\"obj\").expect(\"obj should exist\");\n        if let Value::Object(instance) = obj {\n            let inst = instance.borrow();\n            assert!(\n                !inst.properties.contains_key(\"myProp\"),\n                \"myProp should be removed\"\n            );\n        } else {\n            panic!(\"obj should be an Object\");\n        }\n    }\n\n    #[test]\n    fn test_scene_graph_material_color() {\n        // Test that material colors are derived from material names\n        use scene::SceneGraph;\n\n        let mut sg = SceneGraph::new();\n        let node = sg.create_block(\"test\".to_string(), [1.0, 1.0, 1.0], None);\n        node.borrow_mut().material = \"::test::material::grey\".to_string();\n\n        let scene3ds = sg.to_scene();\n\n        // Check that material was created\n        assert!(scene3ds.materials.contains_key(\"::test::material::grey\"));\n        let mat = &scene3ds.materials[\"::test::material::grey\"];\n        // Grey material should have grey-ish colors\n        assert!((mat.diffuse[0] - 0.5).abs() < 0.1);\n        assert!((mat.diffuse[1] - 0.5).abs() < 0.1);\n        assert!((mat.diffuse[2] - 0.5).abs() < 0.1);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","src","material.rs"],"content":"//! Material System - MAT file parsing and material management.\n//!\n//! This module implements material handling for OFML products including:\n//! - MAT file parsing\n//! - Texture loading and projection\n//! - Material resolution from expressions\n//! - GLB material export\n\nuse std::collections::HashMap;\n\nuse crate::errors::MaterialError;\n\n/// Texture projection modes from OFML spec.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]\npub enum TextureProjection {\n    /// Planar projection from X axis\n    #[default]\n    ProjectX,\n    /// Planar projection from Y axis\n    ProjectY,\n    /// Planar projection from Z axis\n    ProjectZ,\n    /// Cylindrical projection\n    Cylindrical,\n    /// Spherical projection\n    Spherical,\n    /// Conical projection\n    Conical,\n    /// Circle projection\n    Circle,\n}\n\nimpl TextureProjection {\n    /// Parse from OFML projection mode string.\n    pub fn parse(s: &str) -> Self {\n        match s.to_lowercase().as_str() {\n            \"prjx\" | \"project_x\" | \"x\" => TextureProjection::ProjectX,\n            \"prjy\" | \"project_y\" | \"y\" => TextureProjection::ProjectY,\n            \"prjz\" | \"project_z\" | \"z\" => TextureProjection::ProjectZ,\n            \"cyl\" | \"cylindrical\" => TextureProjection::Cylindrical,\n            \"sph\" | \"spherical\" => TextureProjection::Spherical,\n            \"cone\" | \"conical\" => TextureProjection::Conical,\n            \"circ\" | \"circle\" => TextureProjection::Circle,\n            _ => TextureProjection::ProjectZ,\n        }\n    }\n\n    /// Get the OFML mode string.\n    pub fn to_ofml_str(&self) -> &'static str {\n        match self {\n            TextureProjection::ProjectX => \"prjx\",\n            TextureProjection::ProjectY => \"prjy\",\n            TextureProjection::ProjectZ => \"prjz\",\n            TextureProjection::Cylindrical => \"cyl\",\n            TextureProjection::Spherical => \"sph\",\n            TextureProjection::Conical => \"cone\",\n            TextureProjection::Circle => \"circ\",\n        }\n    }\n}\n\n/// Texture definition including projection parameters.\n#[derive(Debug, Clone)]\npub struct TextureDef {\n    /// Texture filename\n    pub filename: String,\n    /// Projection mode\n    pub projection: TextureProjection,\n    /// U scale factor\n    pub u_scale: f32,\n    /// V scale factor\n    pub v_scale: f32,\n    /// U offset\n    pub u_offset: f32,\n    /// V offset\n    pub v_offset: f32,\n    /// Rotation angle (radians)\n    pub rotation: f32,\n}\n\nimpl TextureDef {\n    /// Create a new texture definition with defaults.\n    pub fn new(filename: impl Into<String>) -> Self {\n        Self {\n            filename: filename.into(),\n            projection: TextureProjection::default(),\n            u_scale: 1.0,\n            v_scale: 1.0,\n            u_offset: 0.0,\n            v_offset: 0.0,\n            rotation: 0.0,\n        }\n    }\n\n    /// Set the projection mode.\n    pub fn with_projection(mut self, projection: TextureProjection) -> Self {\n        self.projection = projection;\n        self\n    }\n\n    /// Set UV scale.\n    pub fn with_scale(mut self, u_scale: f32, v_scale: f32) -> Self {\n        self.u_scale = u_scale;\n        self.v_scale = v_scale;\n        self\n    }\n\n    /// Set UV offset.\n    pub fn with_offset(mut self, u_offset: f32, v_offset: f32) -> Self {\n        self.u_offset = u_offset;\n        self.v_offset = v_offset;\n        self\n    }\n\n    /// Set rotation.\n    pub fn with_rotation(mut self, rotation: f32) -> Self {\n        self.rotation = rotation;\n        self\n    }\n}\n\n/// Full material definition from MAT file or EBASE.\n#[derive(Debug, Clone)]\npub struct MaterialDef {\n    /// Material name/identifier\n    pub name: String,\n    /// Ambient color [R, G, B, A]\n    pub ambient: [f32; 4],\n    /// Diffuse color [R, G, B, A]\n    pub diffuse: [f32; 4],\n    /// Specular color [R, G, B, A]\n    pub specular: [f32; 4],\n    /// Shininess exponent (0-1000)\n    pub shininess: f32,\n    /// Transparency (0.0 = opaque, 1.0 = fully transparent)\n    pub transparency: f32,\n    /// Texture file reference\n    pub texture: Option<TextureDef>,\n}\n\nimpl MaterialDef {\n    /// Create a new material with default grey color.\n    pub fn new(name: impl Into<String>) -> Self {\n        Self {\n            name: name.into(),\n            ambient: [0.2, 0.2, 0.2, 1.0],\n            diffuse: [0.6, 0.6, 0.6, 1.0],\n            specular: [0.3, 0.3, 0.3, 1.0],\n            shininess: 32.0,\n            transparency: 0.0,\n            texture: None,\n        }\n    }\n\n    /// Create a material from color name.\n    pub fn from_color_name(name: &str) -> Self {\n        let (diffuse, ambient, specular) = Self::color_from_name(name);\n        Self {\n            name: name.to_string(),\n            ambient,\n            diffuse,\n            specular,\n            shininess: 32.0,\n            transparency: 0.0,\n            texture: None,\n        }\n    }\n\n    /// Get color components from a color name.\n    fn color_from_name(name: &str) -> ([f32; 4], [f32; 4], [f32; 4]) {\n        let lower = name.to_lowercase();\n\n        // Extract color from material name patterns\n        let diffuse = if lower.contains(\"white\") {\n            [0.9, 0.9, 0.9, 1.0]\n        } else if lower.contains(\"black\") {\n            [0.1, 0.1, 0.1, 1.0]\n        } else if lower.contains(\"red\") {\n            [0.8, 0.2, 0.2, 1.0]\n        } else if lower.contains(\"green\") {\n            [0.2, 0.8, 0.2, 1.0]\n        } else if lower.contains(\"blue\") {\n            [0.2, 0.2, 0.8, 1.0]\n        } else if lower.contains(\"grey\") || lower.contains(\"gray\") {\n            [0.5, 0.5, 0.5, 1.0]\n        } else if lower.contains(\"wood\") || lower.contains(\"oak\") || lower.contains(\"walnut\") {\n            [0.6, 0.4, 0.2, 1.0]\n        } else if lower.contains(\"metal\") || lower.contains(\"steel\") || lower.contains(\"chrome\") {\n            [0.7, 0.7, 0.75, 1.0]\n        } else if lower.contains(\"silver\") {\n            [0.75, 0.75, 0.75, 1.0]\n        } else if lower.contains(\"gold\") {\n            [0.8, 0.7, 0.2, 1.0]\n        } else {\n            // Default grey\n            [0.5, 0.5, 0.5, 1.0]\n        };\n\n        let ambient = [diffuse[0] * 0.3, diffuse[1] * 0.3, diffuse[2] * 0.3, 1.0];\n\n        let specular = if lower.contains(\"metal\") || lower.contains(\"chrome\") {\n            [0.8, 0.8, 0.8, 1.0]\n        } else {\n            [0.3, 0.3, 0.3, 1.0]\n        };\n\n        (diffuse, ambient, specular)\n    }\n\n    /// Set the diffuse color.\n    pub fn with_diffuse(mut self, r: f32, g: f32, b: f32, a: f32) -> Self {\n        self.diffuse = [r, g, b, a];\n        self\n    }\n\n    /// Set the ambient color.\n    pub fn with_ambient(mut self, r: f32, g: f32, b: f32, a: f32) -> Self {\n        self.ambient = [r, g, b, a];\n        self\n    }\n\n    /// Set the specular color.\n    pub fn with_specular(mut self, r: f32, g: f32, b: f32, a: f32) -> Self {\n        self.specular = [r, g, b, a];\n        self\n    }\n\n    /// Set the shininess.\n    pub fn with_shininess(mut self, shininess: f32) -> Self {\n        self.shininess = shininess;\n        self\n    }\n\n    /// Set the transparency.\n    pub fn with_transparency(mut self, transparency: f32) -> Self {\n        self.transparency = transparency;\n        self\n    }\n\n    /// Set the texture.\n    pub fn with_texture(mut self, texture: TextureDef) -> Self {\n        self.texture = Some(texture);\n        self\n    }\n\n    /// Check if material has transparency.\n    pub fn is_transparent(&self) -> bool {\n        self.transparency > 0.0 || self.diffuse[3] < 1.0\n    }\n\n    /// Parse a color from \"r g b\" or \"r g b a\" format.\n    pub fn parse_color(value: &str) -> Result<[f32; 4], MaterialError> {\n        let parts: Vec<&str> = value.split_whitespace().collect();\n        if parts.len() < 3 {\n            return Err(MaterialError::InvalidProperty {\n                property: \"color\".to_string(),\n                message: format!(\"Invalid color value: {}\", value),\n            });\n        }\n\n        let r: f32 = parts[0]\n            .parse()\n            .map_err(|_| MaterialError::InvalidProperty {\n                property: \"color\".to_string(),\n                message: format!(\"Invalid red component: {}\", parts[0]),\n            })?;\n        let g: f32 = parts[1]\n            .parse()\n            .map_err(|_| MaterialError::InvalidProperty {\n                property: \"color\".to_string(),\n                message: format!(\"Invalid green component: {}\", parts[1]),\n            })?;\n        let b: f32 = parts[2]\n            .parse()\n            .map_err(|_| MaterialError::InvalidProperty {\n                property: \"color\".to_string(),\n                message: format!(\"Invalid blue component: {}\", parts[2]),\n            })?;\n        let a: f32 = parts.get(3).and_then(|s| s.parse().ok()).unwrap_or(1.0);\n\n        Ok([r, g, b, a])\n    }\n}\n\nimpl Default for MaterialDef {\n    fn default() -> Self {\n        Self::new(\"default\")\n    }\n}\n\n/// MAT file parser.\npub struct MatParser;\n\nimpl MatParser {\n    /// Parse a MAT file content.\n    ///\n    /// # Arguments\n    ///\n    /// * `content` - The MAT file content as a string\n    /// * `name` - The material name to use\n    ///\n    /// # Returns\n    ///\n    /// The parsed MaterialDef.\n    pub fn parse(content: &str, name: &str) -> Result<MaterialDef, MaterialError> {\n        let mut material = MaterialDef::new(name);\n\n        for (line_num, line) in content.lines().enumerate() {\n            let line = line.trim();\n\n            // Skip comments and empty lines\n            if line.is_empty() || line.starts_with('#') || line.starts_with(\"//\") {\n                continue;\n            }\n\n            // Parse key-value pairs\n            let parts: Vec<&str> = line.splitn(2, char::is_whitespace).collect();\n            if parts.len() < 2 {\n                continue;\n            }\n\n            let key = parts[0].to_lowercase();\n            let value = parts[1].trim();\n\n            match key.as_str() {\n                \"amb\" | \"ambient\" => {\n                    material.ambient = Self::parse_color(value, line_num)?;\n                }\n                \"dif\" | \"diffuse\" => {\n                    material.diffuse = Self::parse_color(value, line_num)?;\n                }\n                \"spe\" | \"specular\" => {\n                    material.specular = Self::parse_color(value, line_num)?;\n                }\n                \"shi\" | \"shininess\" => {\n                    material.shininess = value.parse().map_err(|_| MaterialError::ParseError {\n                        line: line_num + 1,\n                        message: format!(\"Invalid shininess value: {}\", value),\n                    })?;\n                }\n                \"tra\" | \"transparency\" => {\n                    material.transparency =\n                        value.parse().map_err(|_| MaterialError::ParseError {\n                            line: line_num + 1,\n                            message: format!(\"Invalid transparency value: {}\", value),\n                        })?;\n                }\n                \"tex\" | \"texture\" => {\n                    material.texture = Some(TextureDef::new(value));\n                }\n                \"prj\" | \"projection\" => {\n                    if let Some(ref mut tex) = material.texture {\n                        tex.projection = TextureProjection::parse(value);\n                    }\n                }\n                _ => {\n                    // Ignore unknown keys\n                }\n            }\n        }\n\n        Ok(material)\n    }\n\n    /// Parse inline material definition ($ syntax).\n    ///\n    /// Format: `$ amb r g b; dif r g b; spe r g b; shi s; tra t`\n    pub fn parse_inline(inline: &str, name: &str) -> Result<MaterialDef, MaterialError> {\n        let mut material = MaterialDef::new(name);\n\n        // Remove leading $ if present\n        let content = inline.trim_start_matches('$').trim();\n\n        // Split by semicolon\n        for part in content.split(';') {\n            let part = part.trim();\n            if part.is_empty() {\n                continue;\n            }\n\n            let tokens: Vec<&str> = part.split_whitespace().collect();\n            if tokens.is_empty() {\n                continue;\n            }\n\n            match tokens[0].to_lowercase().as_str() {\n                \"amb\" | \"ambient\" if tokens.len() >= 4 => {\n                    material.ambient = Self::parse_color_tokens(&tokens[1..4])?;\n                }\n                \"dif\" | \"diffuse\" if tokens.len() >= 4 => {\n                    material.diffuse = Self::parse_color_tokens(&tokens[1..4])?;\n                }\n                \"spe\" | \"specular\" if tokens.len() >= 4 => {\n                    material.specular = Self::parse_color_tokens(&tokens[1..4])?;\n                }\n                \"shi\" | \"shininess\" if tokens.len() >= 2 => {\n                    material.shininess = tokens[1].parse().unwrap_or(32.0);\n                }\n                \"tra\" | \"transparency\" if tokens.len() >= 2 => {\n                    material.transparency = tokens[1].parse().unwrap_or(0.0);\n                }\n                _ => {}\n            }\n        }\n\n        Ok(material)\n    }\n\n    /// Parse a color from \"r g b\" or \"r g b a\" format.\n    fn parse_color(value: &str, line: usize) -> Result<[f32; 4], MaterialError> {\n        let parts: Vec<&str> = value.split_whitespace().collect();\n        if parts.len() < 3 {\n            return Err(MaterialError::ParseError {\n                line: line + 1,\n                message: format!(\"Invalid color value: {}\", value),\n            });\n        }\n\n        let r: f32 = parts[0].parse().map_err(|_| MaterialError::ParseError {\n            line: line + 1,\n            message: format!(\"Invalid red component: {}\", parts[0]),\n        })?;\n        let g: f32 = parts[1].parse().map_err(|_| MaterialError::ParseError {\n            line: line + 1,\n            message: format!(\"Invalid green component: {}\", parts[1]),\n        })?;\n        let b: f32 = parts[2].parse().map_err(|_| MaterialError::ParseError {\n            line: line + 1,\n            message: format!(\"Invalid blue component: {}\", parts[2]),\n        })?;\n        let a: f32 = parts.get(3).and_then(|s| s.parse().ok()).unwrap_or(1.0);\n\n        Ok([r, g, b, a])\n    }\n\n    /// Parse color from token slice.\n    fn parse_color_tokens(tokens: &[&str]) -> Result<[f32; 4], MaterialError> {\n        if tokens.len() < 3 {\n            return Err(MaterialError::InvalidProperty {\n                property: \"color\".to_string(),\n                message: \"Need at least 3 color components\".to_string(),\n            });\n        }\n\n        let r: f32 = tokens[0].parse().unwrap_or(0.5);\n        let g: f32 = tokens[1].parse().unwrap_or(0.5);\n        let b: f32 = tokens[2].parse().unwrap_or(0.5);\n        let a: f32 = tokens.get(3).and_then(|s| s.parse().ok()).unwrap_or(1.0);\n\n        Ok([r, g, b, a])\n    }\n}\n\n/// Material cache and resolver.\npub struct MaterialResolver {\n    /// Cached material definitions\n    materials: HashMap<String, MaterialDef>,\n    /// Fallback material\n    fallback: MaterialDef,\n}\n\nimpl MaterialResolver {\n    /// Create a new material resolver.\n    pub fn new() -> Self {\n        Self {\n            materials: HashMap::new(),\n            fallback: MaterialDef::new(\"fallback\").with_diffuse(0.8, 0.0, 0.8, 1.0), // Magenta for missing materials\n        }\n    }\n\n    /// Register a material.\n    pub fn register(&mut self, material: MaterialDef) {\n        self.materials.insert(material.name.clone(), material);\n    }\n\n    /// Resolve a material by name or expression.\n    pub fn resolve(&self, name: &str) -> &MaterialDef {\n        // Direct lookup\n        if let Some(mat) = self.materials.get(name) {\n            return mat;\n        }\n\n        // Try without namespace prefix\n        let short_name = name.split(\"::\").last().unwrap_or(name);\n        if let Some(mat) = self.materials.get(short_name) {\n            return mat;\n        }\n\n        // Return fallback\n        &self.fallback\n    }\n\n    /// Resolve and get owned material (creates from color name if not found).\n    pub fn resolve_or_create(&self, name: &str) -> MaterialDef {\n        if let Some(mat) = self.materials.get(name) {\n            return mat.clone();\n        }\n\n        // Try without namespace prefix\n        let short_name = name.split(\"::\").last().unwrap_or(name);\n        if let Some(mat) = self.materials.get(short_name) {\n            return mat.clone();\n        }\n\n        // Create from color name\n        MaterialDef::from_color_name(name)\n    }\n\n    /// Check if material exists.\n    pub fn contains(&self, name: &str) -> bool {\n        self.materials.contains_key(name)\n    }\n\n    /// Get all material names.\n    pub fn names(&self) -> Vec<&String> {\n        self.materials.keys().collect()\n    }\n\n    /// Set the fallback material.\n    pub fn set_fallback(&mut self, material: MaterialDef) {\n        self.fallback = material;\n    }\n}\n\n/// EBASE material table entry.\n///\n/// EBASE mat tables store material definitions in a tab-separated format:\n/// `name\\tamb\\tdif\\tspe\\tshi\\ttra\\ttex\\tprj`\n#[derive(Debug, Clone)]\npub struct EbaseMaterialEntry {\n    /// Material name/key\n    pub name: String,\n    /// Ambient color string (e.g., \"0.2 0.2 0.2\")\n    pub ambient: Option<String>,\n    /// Diffuse color string (e.g., \"0.6 0.6 0.6\")\n    pub diffuse: Option<String>,\n    /// Specular color string (e.g., \"0.3 0.3 0.3\")\n    pub specular: Option<String>,\n    /// Shininess value\n    pub shininess: Option<f32>,\n    /// Transparency value\n    pub transparency: Option<f32>,\n    /// Texture filename\n    pub texture: Option<String>,\n    /// Texture projection mode\n    pub projection: Option<String>,\n}\n\nimpl EbaseMaterialEntry {\n    /// Convert to a MaterialDef.\n    pub fn to_material_def(&self) -> MaterialDef {\n        let mut mat = MaterialDef::new(&self.name);\n\n        if let Some(ref amb) = self.ambient {\n            if let Ok(color) = MaterialDef::parse_color(amb) {\n                mat.ambient = color;\n            }\n        }\n\n        if let Some(ref dif) = self.diffuse {\n            if let Ok(color) = MaterialDef::parse_color(dif) {\n                mat.diffuse = color;\n            }\n        }\n\n        if let Some(ref spe) = self.specular {\n            if let Ok(color) = MaterialDef::parse_color(spe) {\n                mat.specular = color;\n            }\n        }\n\n        if let Some(shi) = self.shininess {\n            mat.shininess = shi;\n        }\n\n        if let Some(tra) = self.transparency {\n            mat.transparency = tra;\n        }\n\n        if let Some(ref tex) = self.texture {\n            let mut tex_def = TextureDef::new(tex);\n            if let Some(ref prj) = self.projection {\n                tex_def.projection = TextureProjection::parse(prj);\n            }\n            mat.texture = Some(tex_def);\n        }\n\n        mat\n    }\n}\n\n/// Parse EBASE mat table data.\n///\n/// EBASE mat tables use a simple line-based format:\n/// - Lines starting with `#` are comments\n/// - Empty lines are skipped\n/// - Format: `name <tab> property=value <tab> property=value ...`\n///\n/// Properties can include:\n/// - `amb=r g b` or `ambient=r g b` - Ambient color\n/// - `dif=r g b` or `diffuse=r g b` - Diffuse color\n/// - `spe=r g b` or `specular=r g b` - Specular color\n/// - `shi=value` or `shininess=value` - Shininess\n/// - `tra=value` or `transparency=value` - Transparency\n/// - `tex=filename` or `texture=filename` - Texture file\n/// - `prj=mode` or `projection=mode` - Texture projection\npub fn parse_ebase_mat_table(data: &str) -> Vec<EbaseMaterialEntry> {\n    let mut entries = Vec::new();\n\n    for line in data.lines() {\n        let line = line.trim();\n\n        // Skip comments and empty lines\n        if line.is_empty() || line.starts_with('#') {\n            continue;\n        }\n\n        // Split by tabs or multiple spaces\n        let parts: Vec<&str> = line\n            .split(['\\t', ';'])\n            .map(|s| s.trim())\n            .filter(|s| !s.is_empty())\n            .collect();\n\n        if parts.is_empty() {\n            continue;\n        }\n\n        let name = parts[0].to_string();\n        let mut entry = EbaseMaterialEntry {\n            name,\n            ambient: None,\n            diffuse: None,\n            specular: None,\n            shininess: None,\n            transparency: None,\n            texture: None,\n            projection: None,\n        };\n\n        // Parse remaining parts as key=value pairs\n        for part in &parts[1..] {\n            if let Some((key, value)) = part.split_once('=') {\n                let key = key.trim().to_lowercase();\n                let value = value.trim();\n\n                match key.as_str() {\n                    \"amb\" | \"ambient\" => entry.ambient = Some(value.to_string()),\n                    \"dif\" | \"diffuse\" => entry.diffuse = Some(value.to_string()),\n                    \"spe\" | \"specular\" => entry.specular = Some(value.to_string()),\n                    \"shi\" | \"shininess\" => entry.shininess = value.parse().ok(),\n                    \"tra\" | \"transparency\" => entry.transparency = value.parse().ok(),\n                    \"tex\" | \"texture\" => entry.texture = Some(value.to_string()),\n                    \"prj\" | \"projection\" => entry.projection = Some(value.to_string()),\n                    _ => {}\n                }\n            }\n        }\n\n        entries.push(entry);\n    }\n\n    entries\n}\n\n/// Load materials from EBASE mat table data into a resolver.\npub fn load_ebase_materials(data: &str, resolver: &mut MaterialResolver) {\n    for entry in parse_ebase_mat_table(data) {\n        let mat = entry.to_material_def();\n        resolver.register(mat);\n    }\n}\n\nimpl Default for MaterialResolver {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_texture_projection() {\n        assert_eq!(\n            TextureProjection::parse(\"prjx\"),\n            TextureProjection::ProjectX\n        );\n        assert_eq!(\n            TextureProjection::parse(\"prjy\"),\n            TextureProjection::ProjectY\n        );\n        assert_eq!(\n            TextureProjection::parse(\"prjz\"),\n            TextureProjection::ProjectZ\n        );\n        assert_eq!(\n            TextureProjection::parse(\"cyl\"),\n            TextureProjection::Cylindrical\n        );\n        assert_eq!(\n            TextureProjection::parse(\"sph\"),\n            TextureProjection::Spherical\n        );\n\n        assert_eq!(TextureProjection::ProjectX.to_ofml_str(), \"prjx\");\n    }\n\n    #[test]\n    fn test_texture_def() {\n        let tex = TextureDef::new(\"wood.png\")\n            .with_projection(TextureProjection::ProjectY)\n            .with_scale(2.0, 2.0)\n            .with_offset(0.5, 0.5);\n\n        assert_eq!(tex.filename, \"wood.png\");\n        assert_eq!(tex.projection, TextureProjection::ProjectY);\n        assert_eq!(tex.u_scale, 2.0);\n        assert_eq!(tex.v_scale, 2.0);\n    }\n\n    #[test]\n    fn test_material_def() {\n        let mat = MaterialDef::new(\"test_material\")\n            .with_diffuse(0.8, 0.2, 0.2, 1.0)\n            .with_shininess(64.0)\n            .with_transparency(0.5);\n\n        assert_eq!(mat.name, \"test_material\");\n        assert_eq!(mat.diffuse[0], 0.8);\n        assert_eq!(mat.shininess, 64.0);\n        assert_eq!(mat.transparency, 0.5);\n        assert!(mat.is_transparent());\n    }\n\n    #[test]\n    fn test_material_from_color_name() {\n        let mat = MaterialDef::from_color_name(\"::test::material::grey\");\n        assert!(mat.diffuse[0] > 0.4 && mat.diffuse[0] < 0.6);\n\n        let mat = MaterialDef::from_color_name(\"wood_oak\");\n        assert!(mat.diffuse[0] > mat.diffuse[2]); // More red/brown than blue\n    }\n\n    #[test]\n    fn test_mat_parser() {\n        let content = r#\"\n            # Comment\n            amb 0.2 0.2 0.2\n            dif 0.8 0.4 0.2\n            spe 0.3 0.3 0.3\n            shi 32\n            tra 0.0\n        \"#;\n\n        let mat = MatParser::parse(content, \"test\").unwrap();\n        assert_eq!(mat.ambient, [0.2, 0.2, 0.2, 1.0]);\n        assert_eq!(mat.diffuse, [0.8, 0.4, 0.2, 1.0]);\n        assert_eq!(mat.shininess, 32.0);\n    }\n\n    #[test]\n    fn test_mat_parser_inline() {\n        let inline = \"$ amb 0.2 0.2 0.2; dif 0.8 0.4 0.2; shi 64\";\n\n        let mat = MatParser::parse_inline(inline, \"inline_test\").unwrap();\n        assert_eq!(mat.ambient, [0.2, 0.2, 0.2, 1.0]);\n        assert_eq!(mat.diffuse, [0.8, 0.4, 0.2, 1.0]);\n        assert_eq!(mat.shininess, 64.0);\n    }\n\n    #[test]\n    fn test_material_resolver() {\n        let mut resolver = MaterialResolver::new();\n\n        let mat = MaterialDef::new(\"test_material\").with_diffuse(1.0, 0.0, 0.0, 1.0);\n        resolver.register(mat);\n\n        let resolved = resolver.resolve(\"test_material\");\n        assert_eq!(resolved.diffuse[0], 1.0);\n\n        // Fallback for unknown\n        let unknown = resolver.resolve(\"unknown_material\");\n        assert_eq!(unknown.name, \"fallback\");\n    }\n\n    #[test]\n    fn test_material_resolver_or_create() {\n        let resolver = MaterialResolver::new();\n\n        // Creates from color name when not registered\n        let mat = resolver.resolve_or_create(\"wood_panel\");\n        assert!(mat.diffuse[0] > mat.diffuse[2]); // Wood-like color\n    }\n\n    #[test]\n    fn test_material_def_parse_color() {\n        // Basic RGB color\n        let color = MaterialDef::parse_color(\"0.8 0.4 0.2\").unwrap();\n        assert!((color[0] - 0.8).abs() < 0.001);\n        assert!((color[1] - 0.4).abs() < 0.001);\n        assert!((color[2] - 0.2).abs() < 0.001);\n        assert!((color[3] - 1.0).abs() < 0.001); // Default alpha\n\n        // RGBA color\n        let color = MaterialDef::parse_color(\"0.5 0.5 0.5 0.7\").unwrap();\n        assert!((color[3] - 0.7).abs() < 0.001);\n\n        // Invalid color - too few components\n        assert!(MaterialDef::parse_color(\"0.8 0.4\").is_err());\n    }\n\n    #[test]\n    fn test_parse_ebase_mat_table_basic() {\n        let data = r#\"\n# Comment line\nwood_oak\tdif=0.6 0.4 0.2\tamb=0.2 0.1 0.05\tshi=32\nmetal_chrome\tdif=0.8 0.8 0.85\tspe=0.9 0.9 0.9\tshi=128\n\"#;\n\n        let entries = parse_ebase_mat_table(data);\n        assert_eq!(entries.len(), 2);\n\n        // Check first entry\n        assert_eq!(entries[0].name, \"wood_oak\");\n        assert_eq!(entries[0].diffuse, Some(\"0.6 0.4 0.2\".to_string()));\n        assert_eq!(entries[0].ambient, Some(\"0.2 0.1 0.05\".to_string()));\n        assert_eq!(entries[0].shininess, Some(32.0));\n\n        // Check second entry\n        assert_eq!(entries[1].name, \"metal_chrome\");\n        assert_eq!(entries[1].specular, Some(\"0.9 0.9 0.9\".to_string()));\n        assert_eq!(entries[1].shininess, Some(128.0));\n    }\n\n    #[test]\n    fn test_parse_ebase_mat_table_with_texture() {\n        let data = \"textured_wood\ttex=wood.png\tprj=prjz\tdif=0.5 0.5 0.5\";\n\n        let entries = parse_ebase_mat_table(data);\n        assert_eq!(entries.len(), 1);\n        assert_eq!(entries[0].texture, Some(\"wood.png\".to_string()));\n        assert_eq!(entries[0].projection, Some(\"prjz\".to_string()));\n    }\n\n    #[test]\n    fn test_parse_ebase_mat_table_semicolon_separator() {\n        let data = \"glass_material;dif=0.9 0.9 0.95;tra=0.5;shi=256\";\n\n        let entries = parse_ebase_mat_table(data);\n        assert_eq!(entries.len(), 1);\n        assert_eq!(entries[0].name, \"glass_material\");\n        assert_eq!(entries[0].transparency, Some(0.5));\n    }\n\n    #[test]\n    fn test_ebase_material_entry_to_material_def() {\n        let entry = EbaseMaterialEntry {\n            name: \"test_material\".to_string(),\n            ambient: Some(\"0.2 0.2 0.2\".to_string()),\n            diffuse: Some(\"0.8 0.4 0.2\".to_string()),\n            specular: Some(\"0.3 0.3 0.3\".to_string()),\n            shininess: Some(64.0),\n            transparency: Some(0.1),\n            texture: Some(\"wood.png\".to_string()),\n            projection: Some(\"prjy\".to_string()),\n        };\n\n        let mat = entry.to_material_def();\n        assert_eq!(mat.name, \"test_material\");\n        assert!((mat.ambient[0] - 0.2).abs() < 0.001);\n        assert!((mat.diffuse[0] - 0.8).abs() < 0.001);\n        assert!((mat.specular[0] - 0.3).abs() < 0.001);\n        assert_eq!(mat.shininess, 64.0);\n        assert_eq!(mat.transparency, 0.1);\n        assert!(mat.texture.is_some());\n        let tex = mat.texture.unwrap();\n        assert_eq!(tex.filename, \"wood.png\");\n        assert_eq!(tex.projection, TextureProjection::ProjectY);\n    }\n\n    #[test]\n    fn test_load_ebase_materials() {\n        let data = r#\"\nmat_red\tdif=0.9 0.1 0.1\nmat_blue\tdif=0.1 0.1 0.9\n\"#;\n\n        let mut resolver = MaterialResolver::new();\n        load_ebase_materials(data, &mut resolver);\n\n        assert!(resolver.contains(\"mat_red\"));\n        assert!(resolver.contains(\"mat_blue\"));\n\n        let red = resolver.resolve(\"mat_red\");\n        assert!(red.diffuse[0] > red.diffuse[2]); // More red than blue\n\n        let blue = resolver.resolve(\"mat_blue\");\n        assert!(blue.diffuse[2] > blue.diffuse[0]); // More blue than red\n    }\n\n    #[test]\n    fn test_parse_ebase_mat_table_empty_lines() {\n        let data = r#\"\n\n# Header comment\n\nmaterial1\tdif=0.5 0.5 0.5\n\n# Another comment\n\nmaterial2\tdif=0.3 0.3 0.3\n\n\"#;\n\n        let entries = parse_ebase_mat_table(data);\n        assert_eq!(entries.len(), 2);\n        assert_eq!(entries[0].name, \"material1\");\n        assert_eq!(entries[1].name, \"material2\");\n    }\n\n    #[test]\n    fn test_ebase_material_entry_minimal() {\n        // Entry with only name, no properties\n        let entry = EbaseMaterialEntry {\n            name: \"minimal_mat\".to_string(),\n            ambient: None,\n            diffuse: None,\n            specular: None,\n            shininess: None,\n            transparency: None,\n            texture: None,\n            projection: None,\n        };\n\n        let mat = entry.to_material_def();\n        assert_eq!(mat.name, \"minimal_mat\");\n        // Should have default values\n        assert_eq!(mat.shininess, 32.0);\n        assert_eq!(mat.transparency, 0.0);\n    }\n\n    #[test]\n    fn test_texture_projection_default() {\n        let default: TextureProjection = Default::default();\n        assert_eq!(default, TextureProjection::ProjectX);\n    }\n\n    #[test]\n    fn test_texture_projection_parse_aliases() {\n        // Test all aliases\n        assert_eq!(TextureProjection::parse(\"project_x\"), TextureProjection::ProjectX);\n        assert_eq!(TextureProjection::parse(\"x\"), TextureProjection::ProjectX);\n        assert_eq!(TextureProjection::parse(\"project_y\"), TextureProjection::ProjectY);\n        assert_eq!(TextureProjection::parse(\"y\"), TextureProjection::ProjectY);\n        assert_eq!(TextureProjection::parse(\"project_z\"), TextureProjection::ProjectZ);\n        assert_eq!(TextureProjection::parse(\"z\"), TextureProjection::ProjectZ);\n        assert_eq!(TextureProjection::parse(\"cylindrical\"), TextureProjection::Cylindrical);\n        assert_eq!(TextureProjection::parse(\"spherical\"), TextureProjection::Spherical);\n        assert_eq!(TextureProjection::parse(\"cone\"), TextureProjection::Conical);\n        assert_eq!(TextureProjection::parse(\"conical\"), TextureProjection::Conical);\n        assert_eq!(TextureProjection::parse(\"circ\"), TextureProjection::Circle);\n        assert_eq!(TextureProjection::parse(\"circle\"), TextureProjection::Circle);\n        // Unknown defaults to ProjectZ\n        assert_eq!(TextureProjection::parse(\"unknown\"), TextureProjection::ProjectZ);\n    }\n\n    #[test]\n    fn test_texture_projection_to_ofml_str_all() {\n        assert_eq!(TextureProjection::ProjectY.to_ofml_str(), \"prjy\");\n        assert_eq!(TextureProjection::ProjectZ.to_ofml_str(), \"prjz\");\n        assert_eq!(TextureProjection::Cylindrical.to_ofml_str(), \"cyl\");\n        assert_eq!(TextureProjection::Spherical.to_ofml_str(), \"sph\");\n        assert_eq!(TextureProjection::Conical.to_ofml_str(), \"cone\");\n        assert_eq!(TextureProjection::Circle.to_ofml_str(), \"circ\");\n    }\n\n    #[test]\n    fn test_texture_projection_clone() {\n        let proj = TextureProjection::Cylindrical;\n        let cloned = proj.clone();\n        assert_eq!(cloned, TextureProjection::Cylindrical);\n    }\n\n    #[test]\n    fn test_texture_def_with_rotation() {\n        let tex = TextureDef::new(\"image.png\")\n            .with_rotation(std::f32::consts::PI / 4.0);\n        assert!((tex.rotation - std::f32::consts::PI / 4.0).abs() < 0.0001);\n    }\n\n    #[test]\n    fn test_texture_def_clone() {\n        let tex = TextureDef::new(\"clone.png\")\n            .with_scale(2.0, 3.0)\n            .with_offset(0.1, 0.2);\n        let cloned = tex.clone();\n        assert_eq!(cloned.filename, \"clone.png\");\n        assert_eq!(cloned.u_scale, 2.0);\n        assert_eq!(cloned.v_scale, 3.0);\n        assert_eq!(cloned.u_offset, 0.1);\n        assert_eq!(cloned.v_offset, 0.2);\n    }\n\n    #[test]\n    fn test_texture_def_debug() {\n        let tex = TextureDef::new(\"debug.png\");\n        let debug_str = format!(\"{:?}\", tex);\n        assert!(debug_str.contains(\"debug.png\"));\n    }\n\n    #[test]\n    fn test_material_def_with_texture() {\n        let tex = TextureDef::new(\"material_tex.png\");\n        let mat = MaterialDef::new(\"textured_mat\").with_texture(tex);\n        assert!(mat.texture.is_some());\n        assert_eq!(mat.texture.unwrap().filename, \"material_tex.png\");\n    }\n\n    #[test]\n    fn test_material_def_with_ambient() {\n        let mat = MaterialDef::new(\"ambient_test\").with_ambient(0.1, 0.2, 0.3, 0.4);\n        assert_eq!(mat.ambient, [0.1, 0.2, 0.3, 0.4]);\n    }\n\n    #[test]\n    fn test_material_def_with_specular() {\n        let mat = MaterialDef::new(\"specular_test\").with_specular(0.7, 0.8, 0.9, 1.0);\n        assert_eq!(mat.specular, [0.7, 0.8, 0.9, 1.0]);\n    }\n\n    #[test]\n    fn test_material_def_is_transparent_from_diffuse_alpha() {\n        let mat = MaterialDef::new(\"alpha_transparent\").with_diffuse(1.0, 1.0, 1.0, 0.5);\n        assert!(mat.is_transparent());\n    }\n\n    #[test]\n    fn test_material_def_is_not_transparent() {\n        let mat = MaterialDef::new(\"opaque\")\n            .with_diffuse(1.0, 1.0, 1.0, 1.0)\n            .with_transparency(0.0);\n        assert!(!mat.is_transparent());\n    }\n\n    #[test]\n    fn test_material_def_clone() {\n        let mat = MaterialDef::new(\"cloneable\")\n            .with_diffuse(0.5, 0.5, 0.5, 1.0)\n            .with_shininess(100.0);\n        let cloned = mat.clone();\n        assert_eq!(cloned.name, \"cloneable\");\n        assert_eq!(cloned.shininess, 100.0);\n    }\n\n    #[test]\n    fn test_material_def_debug() {\n        let mat = MaterialDef::new(\"debug_mat\");\n        let debug_str = format!(\"{:?}\", mat);\n        assert!(debug_str.contains(\"debug_mat\"));\n    }\n\n    #[test]\n    fn test_material_def_default() {\n        let mat = MaterialDef::default();\n        assert_eq!(mat.name, \"default\");\n    }\n\n    #[test]\n    fn test_material_color_from_name_all_colors() {\n        // Test all color name patterns\n        let white = MaterialDef::from_color_name(\"white_material\");\n        assert!(white.diffuse[0] > 0.8);\n\n        let black = MaterialDef::from_color_name(\"black_material\");\n        assert!(black.diffuse[0] < 0.2);\n\n        let red = MaterialDef::from_color_name(\"red_paint\");\n        assert!(red.diffuse[0] > red.diffuse[1] && red.diffuse[0] > red.diffuse[2]);\n\n        let green = MaterialDef::from_color_name(\"green_surface\");\n        assert!(green.diffuse[1] > green.diffuse[0] && green.diffuse[1] > green.diffuse[2]);\n\n        let blue = MaterialDef::from_color_name(\"blue_fabric\");\n        assert!(blue.diffuse[2] > blue.diffuse[0] && blue.diffuse[2] > blue.diffuse[1]);\n\n        let gray = MaterialDef::from_color_name(\"gray_metal\");\n        let grey = MaterialDef::from_color_name(\"grey_plastic\");\n        assert!((gray.diffuse[0] - gray.diffuse[1]).abs() < 0.01);\n        assert!((grey.diffuse[0] - grey.diffuse[1]).abs() < 0.01);\n\n        let walnut = MaterialDef::from_color_name(\"walnut_finish\");\n        assert!(walnut.diffuse[0] > walnut.diffuse[2]); // Wood-like\n\n        let steel = MaterialDef::from_color_name(\"steel_frame\");\n        let chrome = MaterialDef::from_color_name(\"chrome_handle\");\n        let metal = MaterialDef::from_color_name(\"metal_bracket\");\n        // Metal has higher specular\n        assert!(chrome.specular[0] > 0.5);\n        assert!(steel.specular[0] > 0.5 || metal.specular[0] > 0.5);\n\n        let silver = MaterialDef::from_color_name(\"silver_trim\");\n        assert!(silver.diffuse[0] > 0.7);\n\n        let gold = MaterialDef::from_color_name(\"gold_accent\");\n        assert!(gold.diffuse[0] > gold.diffuse[2]); // Yellow-ish\n    }\n\n    #[test]\n    fn test_material_parse_color_invalid_components() {\n        // Invalid number format\n        let result = MaterialDef::parse_color(\"abc 0.5 0.5\");\n        assert!(result.is_err());\n\n        let result = MaterialDef::parse_color(\"0.5 xyz 0.5\");\n        assert!(result.is_err());\n\n        let result = MaterialDef::parse_color(\"0.5 0.5 zzz\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_mat_parser_with_texture() {\n        let content = r#\"\n            dif 0.5 0.5 0.5\n            tex wood_grain.jpg\n            prj prjy\n        \"#;\n\n        let mat = MatParser::parse(content, \"textured\").unwrap();\n        assert!(mat.texture.is_some());\n        let tex = mat.texture.unwrap();\n        assert_eq!(tex.filename, \"wood_grain.jpg\");\n        assert_eq!(tex.projection, TextureProjection::ProjectY);\n    }\n\n    #[test]\n    fn test_mat_parser_projection_without_texture() {\n        // Projection line without a texture should be ignored\n        let content = r#\"\n            dif 0.5 0.5 0.5\n            prj prjy\n        \"#;\n\n        let mat = MatParser::parse(content, \"no_tex\").unwrap();\n        assert!(mat.texture.is_none());\n    }\n\n    #[test]\n    fn test_mat_parser_comments() {\n        let content = r#\"\n            # This is a comment\n            // This is also a comment\n            dif 0.8 0.2 0.1\n            # Another comment\n        \"#;\n\n        let mat = MatParser::parse(content, \"commented\").unwrap();\n        assert!((mat.diffuse[0] - 0.8).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_mat_parser_long_form_keys() {\n        let content = r#\"\n            ambient 0.1 0.1 0.1\n            diffuse 0.5 0.5 0.5\n            specular 0.3 0.3 0.3\n            shininess 50\n            transparency 0.2\n            texture myfile.png\n            projection cylindrical\n        \"#;\n\n        let mat = MatParser::parse(content, \"long_form\").unwrap();\n        assert!((mat.ambient[0] - 0.1).abs() < 0.001);\n        assert!((mat.diffuse[0] - 0.5).abs() < 0.001);\n        assert!((mat.specular[0] - 0.3).abs() < 0.001);\n        assert_eq!(mat.shininess, 50.0);\n        assert!((mat.transparency - 0.2).abs() < 0.001);\n        let tex = mat.texture.unwrap();\n        assert_eq!(tex.filename, \"myfile.png\");\n        assert_eq!(tex.projection, TextureProjection::Cylindrical);\n    }\n\n    #[test]\n    fn test_mat_parser_invalid_shininess() {\n        let content = \"shi not_a_number\";\n        let result = MatParser::parse(content, \"invalid\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_mat_parser_invalid_transparency() {\n        let content = \"tra invalid\";\n        let result = MatParser::parse(content, \"invalid\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_mat_parser_invalid_color() {\n        let content = \"dif 0.5 0.5\"; // Too few components\n        let result = MatParser::parse(content, \"invalid\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_mat_parser_inline_without_dollar() {\n        // Should work without leading $\n        let inline = \"amb 0.3 0.3 0.3; dif 0.7 0.7 0.7\";\n        let mat = MatParser::parse_inline(inline, \"no_dollar\").unwrap();\n        assert!((mat.ambient[0] - 0.3).abs() < 0.001);\n        assert!((mat.diffuse[0] - 0.7).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_mat_parser_inline_transparency() {\n        let inline = \"$ tra 0.5\";\n        let mat = MatParser::parse_inline(inline, \"transparent\").unwrap();\n        assert_eq!(mat.transparency, 0.5);\n    }\n\n    #[test]\n    fn test_mat_parser_inline_specular() {\n        let inline = \"$ spe 0.9 0.9 0.9\";\n        let mat = MatParser::parse_inline(inline, \"shiny\").unwrap();\n        assert!((mat.specular[0] - 0.9).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_mat_parser_inline_empty() {\n        let inline = \"\";\n        let mat = MatParser::parse_inline(inline, \"empty\").unwrap();\n        // Should return material with default values\n        assert_eq!(mat.name, \"empty\");\n    }\n\n    #[test]\n    fn test_mat_parser_inline_unknown_key() {\n        let inline = \"$ unknown 1 2 3\";\n        // Should not fail, just ignore unknown keys\n        let mat = MatParser::parse_inline(inline, \"unknown_key\").unwrap();\n        assert_eq!(mat.name, \"unknown_key\");\n    }\n\n    #[test]\n    fn test_mat_parser_parse_color_tokens_too_few() {\n        // Test private function edge case via inline parsing\n        let inline = \"$ amb 0.5 0.5\"; // Only 2 components\n        let mat = MatParser::parse_inline(inline, \"short\").unwrap();\n        // Should not update ambient (needs 3+ components)\n        assert_eq!(mat.ambient, [0.2, 0.2, 0.2, 1.0]); // Default\n    }\n\n    #[test]\n    fn test_material_resolver_resolve_namespace() {\n        let mut resolver = MaterialResolver::new();\n        let mat = MaterialDef::new(\"test_material\").with_diffuse(1.0, 0.0, 0.0, 1.0);\n        resolver.register(mat);\n\n        // Should resolve without namespace\n        let resolved = resolver.resolve(\"::some::namespace::test_material\");\n        assert_eq!(resolved.diffuse[0], 1.0);\n    }\n\n    #[test]\n    fn test_material_resolver_names() {\n        let mut resolver = MaterialResolver::new();\n        resolver.register(MaterialDef::new(\"mat_a\"));\n        resolver.register(MaterialDef::new(\"mat_b\"));\n\n        let names = resolver.names();\n        assert_eq!(names.len(), 2);\n        assert!(names.iter().any(|n| *n == \"mat_a\"));\n        assert!(names.iter().any(|n| *n == \"mat_b\"));\n    }\n\n    #[test]\n    fn test_material_resolver_set_fallback() {\n        let mut resolver = MaterialResolver::new();\n        let custom_fallback = MaterialDef::new(\"custom_fallback\").with_diffuse(0.0, 1.0, 0.0, 1.0);\n        resolver.set_fallback(custom_fallback);\n\n        let fallback = resolver.resolve(\"nonexistent\");\n        assert_eq!(fallback.name, \"custom_fallback\");\n        assert_eq!(fallback.diffuse[1], 1.0); // Green\n    }\n\n    #[test]\n    fn test_material_resolver_default() {\n        let resolver = MaterialResolver::default();\n        // Should have fallback material\n        let fallback = resolver.resolve(\"nonexistent\");\n        assert_eq!(fallback.name, \"fallback\");\n    }\n\n    #[test]\n    fn test_material_resolver_resolve_or_create_namespace() {\n        let mut resolver = MaterialResolver::new();\n        let mat = MaterialDef::new(\"metal_chrome\").with_diffuse(0.8, 0.8, 0.8, 1.0);\n        resolver.register(mat);\n\n        let resolved = resolver.resolve_or_create(\"::ns::metal_chrome\");\n        assert_eq!(resolved.diffuse[0], 0.8);\n    }\n\n    #[test]\n    fn test_ebase_material_entry_debug() {\n        let entry = EbaseMaterialEntry {\n            name: \"debug_entry\".to_string(),\n            ambient: None,\n            diffuse: None,\n            specular: None,\n            shininess: None,\n            transparency: None,\n            texture: None,\n            projection: None,\n        };\n        let debug_str = format!(\"{:?}\", entry);\n        assert!(debug_str.contains(\"debug_entry\"));\n    }\n\n    #[test]\n    fn test_ebase_material_entry_clone() {\n        let entry = EbaseMaterialEntry {\n            name: \"cloneable_entry\".to_string(),\n            ambient: Some(\"0.5 0.5 0.5\".to_string()),\n            diffuse: None,\n            specular: None,\n            shininess: Some(64.0),\n            transparency: None,\n            texture: None,\n            projection: None,\n        };\n        let cloned = entry.clone();\n        assert_eq!(cloned.name, \"cloneable_entry\");\n        assert_eq!(cloned.shininess, Some(64.0));\n    }\n\n    #[test]\n    fn test_ebase_material_entry_with_invalid_color() {\n        // Entry with invalid color string should use defaults\n        let entry = EbaseMaterialEntry {\n            name: \"invalid_color\".to_string(),\n            ambient: Some(\"invalid\".to_string()),\n            diffuse: Some(\"also invalid\".to_string()),\n            specular: Some(\"not a color\".to_string()),\n            shininess: None,\n            transparency: None,\n            texture: None,\n            projection: None,\n        };\n\n        let mat = entry.to_material_def();\n        assert_eq!(mat.name, \"invalid_color\");\n        // Should have default values since colors are invalid\n        assert_eq!(mat.ambient, [0.2, 0.2, 0.2, 1.0]);\n        assert_eq!(mat.diffuse, [0.6, 0.6, 0.6, 1.0]);\n        assert_eq!(mat.specular, [0.3, 0.3, 0.3, 1.0]);\n    }\n\n    #[test]\n    fn test_parse_ebase_mat_table_unknown_property() {\n        let data = \"material_name\tunknown_prop=some_value\tdif=0.5 0.5 0.5\";\n        let entries = parse_ebase_mat_table(data);\n        assert_eq!(entries.len(), 1);\n        assert_eq!(entries[0].diffuse, Some(\"0.5 0.5 0.5\".to_string()));\n    }\n\n    #[test]\n    fn test_parse_ebase_mat_table_no_value() {\n        // Property without = sign should be ignored\n        let data = \"material_name\tnoequal\tdif=0.5 0.5 0.5\";\n        let entries = parse_ebase_mat_table(data);\n        assert_eq!(entries.len(), 1);\n        assert_eq!(entries[0].diffuse, Some(\"0.5 0.5 0.5\".to_string()));\n    }\n}\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":21}},{"line":36,"address":[],"length":0,"stats":{"Line":21}},{"line":37,"address":[],"length":0,"stats":{"Line":63}},{"line":38,"address":[],"length":0,"stats":{"Line":52}},{"line":39,"address":[],"length":0,"stats":{"Line":39}},{"line":40,"address":[],"length":0,"stats":{"Line":22}},{"line":41,"address":[],"length":0,"stats":{"Line":15}},{"line":42,"address":[],"length":0,"stats":{"Line":11}},{"line":43,"address":[],"length":0,"stats":{"Line":7}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":7}},{"line":50,"address":[],"length":0,"stats":{"Line":7}},{"line":51,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":53,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":8}},{"line":85,"address":[],"length":0,"stats":{"Line":16}},{"line":86,"address":[],"length":0,"stats":{"Line":8}},{"line":96,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":2}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":2}},{"line":112,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":1}},{"line":117,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":43}},{"line":145,"address":[],"length":0,"stats":{"Line":129}},{"line":146,"address":[],"length":0,"stats":{"Line":86}},{"line":147,"address":[],"length":0,"stats":{"Line":86}},{"line":148,"address":[],"length":0,"stats":{"Line":43}},{"line":156,"address":[],"length":0,"stats":{"Line":16}},{"line":157,"address":[],"length":0,"stats":{"Line":64}},{"line":159,"address":[],"length":0,"stats":{"Line":48}},{"line":170,"address":[],"length":0,"stats":{"Line":16}},{"line":171,"address":[],"length":0,"stats":{"Line":48}},{"line":174,"address":[],"length":0,"stats":{"Line":32}},{"line":175,"address":[],"length":0,"stats":{"Line":1}},{"line":176,"address":[],"length":0,"stats":{"Line":15}},{"line":177,"address":[],"length":0,"stats":{"Line":1}},{"line":178,"address":[],"length":0,"stats":{"Line":14}},{"line":179,"address":[],"length":0,"stats":{"Line":1}},{"line":180,"address":[],"length":0,"stats":{"Line":13}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":12}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":20}},{"line":185,"address":[],"length":0,"stats":{"Line":3}},{"line":186,"address":[],"length":0,"stats":{"Line":20}},{"line":187,"address":[],"length":0,"stats":{"Line":3}},{"line":188,"address":[],"length":0,"stats":{"Line":12}},{"line":189,"address":[],"length":0,"stats":{"Line":3}},{"line":190,"address":[],"length":0,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":48}},{"line":201,"address":[],"length":0,"stats":{"Line":46}},{"line":202,"address":[],"length":0,"stats":{"Line":3}},{"line":204,"address":[],"length":0,"stats":{"Line":13}},{"line":207,"address":[],"length":0,"stats":{"Line":32}},{"line":211,"address":[],"length":0,"stats":{"Line":16}},{"line":212,"address":[],"length":0,"stats":{"Line":48}},{"line":213,"address":[],"length":0,"stats":{"Line":16}},{"line":217,"address":[],"length":0,"stats":{"Line":1}},{"line":218,"address":[],"length":0,"stats":{"Line":3}},{"line":219,"address":[],"length":0,"stats":{"Line":1}},{"line":223,"address":[],"length":0,"stats":{"Line":1}},{"line":224,"address":[],"length":0,"stats":{"Line":3}},{"line":225,"address":[],"length":0,"stats":{"Line":1}},{"line":229,"address":[],"length":0,"stats":{"Line":2}},{"line":230,"address":[],"length":0,"stats":{"Line":2}},{"line":231,"address":[],"length":0,"stats":{"Line":2}},{"line":235,"address":[],"length":0,"stats":{"Line":2}},{"line":236,"address":[],"length":0,"stats":{"Line":2}},{"line":237,"address":[],"length":0,"stats":{"Line":2}},{"line":241,"address":[],"length":0,"stats":{"Line":1}},{"line":242,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":1}},{"line":247,"address":[],"length":0,"stats":{"Line":3}},{"line":248,"address":[],"length":0,"stats":{"Line":5}},{"line":252,"address":[],"length":0,"stats":{"Line":14}},{"line":253,"address":[],"length":0,"stats":{"Line":70}},{"line":254,"address":[],"length":0,"stats":{"Line":14}},{"line":255,"address":[],"length":0,"stats":{"Line":3}},{"line":256,"address":[],"length":0,"stats":{"Line":9}},{"line":257,"address":[],"length":0,"stats":{"Line":3}},{"line":261,"address":[],"length":0,"stats":{"Line":29}},{"line":263,"address":[],"length":0,"stats":{"Line":11}},{"line":264,"address":[],"length":0,"stats":{"Line":4}},{"line":265,"address":[],"length":0,"stats":{"Line":6}},{"line":267,"address":[],"length":0,"stats":{"Line":25}},{"line":269,"address":[],"length":0,"stats":{"Line":9}},{"line":270,"address":[],"length":0,"stats":{"Line":2}},{"line":271,"address":[],"length":0,"stats":{"Line":3}},{"line":273,"address":[],"length":0,"stats":{"Line":22}},{"line":275,"address":[],"length":0,"stats":{"Line":8}},{"line":276,"address":[],"length":0,"stats":{"Line":2}},{"line":277,"address":[],"length":0,"stats":{"Line":3}},{"line":279,"address":[],"length":0,"stats":{"Line":38}},{"line":281,"address":[],"length":0,"stats":{"Line":21}},{"line":286,"address":[],"length":0,"stats":{"Line":1}},{"line":287,"address":[],"length":0,"stats":{"Line":1}},{"line":305,"address":[],"length":0,"stats":{"Line":8}},{"line":306,"address":[],"length":0,"stats":{"Line":24}},{"line":308,"address":[],"length":0,"stats":{"Line":94}},{"line":309,"address":[],"length":0,"stats":{"Line":105}},{"line":312,"address":[],"length":0,"stats":{"Line":164}},{"line":313,"address":[],"length":0,"stats":{"Line":14}},{"line":317,"address":[],"length":0,"stats":{"Line":105}},{"line":318,"address":[],"length":0,"stats":{"Line":21}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":63}},{"line":323,"address":[],"length":0,"stats":{"Line":63}},{"line":325,"address":[],"length":0,"stats":{"Line":21}},{"line":326,"address":[],"length":0,"stats":{"Line":41}},{"line":327,"address":[],"length":0,"stats":{"Line":6}},{"line":329,"address":[],"length":0,"stats":{"Line":33}},{"line":330,"address":[],"length":0,"stats":{"Line":19}},{"line":332,"address":[],"length":0,"stats":{"Line":25}},{"line":333,"address":[],"length":0,"stats":{"Line":6}},{"line":335,"address":[],"length":0,"stats":{"Line":20}},{"line":336,"address":[],"length":0,"stats":{"Line":9}},{"line":337,"address":[],"length":0,"stats":{"Line":1}},{"line":338,"address":[],"length":0,"stats":{"Line":2}},{"line":341,"address":[],"length":0,"stats":{"Line":14}},{"line":343,"address":[],"length":0,"stats":{"Line":9}},{"line":344,"address":[],"length":0,"stats":{"Line":1}},{"line":345,"address":[],"length":0,"stats":{"Line":2}},{"line":348,"address":[],"length":0,"stats":{"Line":11}},{"line":349,"address":[],"length":0,"stats":{"Line":4}},{"line":351,"address":[],"length":0,"stats":{"Line":4}},{"line":352,"address":[],"length":0,"stats":{"Line":7}},{"line":353,"address":[],"length":0,"stats":{"Line":2}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":5}},{"line":368,"address":[],"length":0,"stats":{"Line":7}},{"line":369,"address":[],"length":0,"stats":{"Line":21}},{"line":372,"address":[],"length":0,"stats":{"Line":21}},{"line":375,"address":[],"length":0,"stats":{"Line":24}},{"line":376,"address":[],"length":0,"stats":{"Line":30}},{"line":377,"address":[],"length":0,"stats":{"Line":20}},{"line":378,"address":[],"length":0,"stats":{"Line":1}},{"line":381,"address":[],"length":0,"stats":{"Line":45}},{"line":382,"address":[],"length":0,"stats":{"Line":18}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":18}},{"line":387,"address":[],"length":0,"stats":{"Line":15}},{"line":388,"address":[],"length":0,"stats":{"Line":4}},{"line":390,"address":[],"length":0,"stats":{"Line":10}},{"line":391,"address":[],"length":0,"stats":{"Line":4}},{"line":393,"address":[],"length":0,"stats":{"Line":7}},{"line":394,"address":[],"length":0,"stats":{"Line":2}},{"line":396,"address":[],"length":0,"stats":{"Line":6}},{"line":397,"address":[],"length":0,"stats":{"Line":2}},{"line":399,"address":[],"length":0,"stats":{"Line":4}},{"line":400,"address":[],"length":0,"stats":{"Line":2}},{"line":402,"address":[],"length":0,"stats":{"Line":2}},{"line":406,"address":[],"length":0,"stats":{"Line":7}},{"line":410,"address":[],"length":0,"stats":{"Line":10}},{"line":411,"address":[],"length":0,"stats":{"Line":50}},{"line":412,"address":[],"length":0,"stats":{"Line":10}},{"line":413,"address":[],"length":0,"stats":{"Line":1}},{"line":414,"address":[],"length":0,"stats":{"Line":2}},{"line":415,"address":[],"length":0,"stats":{"Line":1}},{"line":419,"address":[],"length":0,"stats":{"Line":45}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":45}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":45}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":45}},{"line":433,"address":[],"length":0,"stats":{"Line":27}},{"line":437,"address":[],"length":0,"stats":{"Line":5}},{"line":438,"address":[],"length":0,"stats":{"Line":5}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":25}},{"line":446,"address":[],"length":0,"stats":{"Line":25}},{"line":447,"address":[],"length":0,"stats":{"Line":25}},{"line":448,"address":[],"length":0,"stats":{"Line":30}},{"line":450,"address":[],"length":0,"stats":{"Line":15}},{"line":464,"address":[],"length":0,"stats":{"Line":8}},{"line":466,"address":[],"length":0,"stats":{"Line":16}},{"line":467,"address":[],"length":0,"stats":{"Line":8}},{"line":472,"address":[],"length":0,"stats":{"Line":7}},{"line":473,"address":[],"length":0,"stats":{"Line":35}},{"line":477,"address":[],"length":0,"stats":{"Line":7}},{"line":479,"address":[],"length":0,"stats":{"Line":17}},{"line":480,"address":[],"length":0,"stats":{"Line":3}},{"line":484,"address":[],"length":0,"stats":{"Line":24}},{"line":485,"address":[],"length":0,"stats":{"Line":9}},{"line":486,"address":[],"length":0,"stats":{"Line":1}},{"line":490,"address":[],"length":0,"stats":{"Line":3}},{"line":494,"address":[],"length":0,"stats":{"Line":2}},{"line":495,"address":[],"length":0,"stats":{"Line":4}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":12}},{"line":501,"address":[],"length":0,"stats":{"Line":5}},{"line":502,"address":[],"length":0,"stats":{"Line":2}},{"line":506,"address":[],"length":0,"stats":{"Line":2}},{"line":510,"address":[],"length":0,"stats":{"Line":2}},{"line":511,"address":[],"length":0,"stats":{"Line":6}},{"line":515,"address":[],"length":0,"stats":{"Line":1}},{"line":516,"address":[],"length":0,"stats":{"Line":3}},{"line":520,"address":[],"length":0,"stats":{"Line":1}},{"line":521,"address":[],"length":0,"stats":{"Line":2}},{"line":551,"address":[],"length":0,"stats":{"Line":5}},{"line":552,"address":[],"length":0,"stats":{"Line":15}},{"line":554,"address":[],"length":0,"stats":{"Line":7}},{"line":555,"address":[],"length":0,"stats":{"Line":4}},{"line":556,"address":[],"length":0,"stats":{"Line":1}},{"line":560,"address":[],"length":0,"stats":{"Line":9}},{"line":561,"address":[],"length":0,"stats":{"Line":10}},{"line":562,"address":[],"length":0,"stats":{"Line":3}},{"line":566,"address":[],"length":0,"stats":{"Line":7}},{"line":567,"address":[],"length":0,"stats":{"Line":4}},{"line":568,"address":[],"length":0,"stats":{"Line":1}},{"line":572,"address":[],"length":0,"stats":{"Line":7}},{"line":573,"address":[],"length":0,"stats":{"Line":1}},{"line":576,"address":[],"length":0,"stats":{"Line":7}},{"line":577,"address":[],"length":0,"stats":{"Line":1}},{"line":580,"address":[],"length":0,"stats":{"Line":6}},{"line":581,"address":[],"length":0,"stats":{"Line":3}},{"line":582,"address":[],"length":0,"stats":{"Line":3}},{"line":583,"address":[],"length":0,"stats":{"Line":1}},{"line":585,"address":[],"length":0,"stats":{"Line":2}},{"line":588,"address":[],"length":0,"stats":{"Line":5}},{"line":607,"address":[],"length":0,"stats":{"Line":7}},{"line":608,"address":[],"length":0,"stats":{"Line":14}},{"line":610,"address":[],"length":0,"stats":{"Line":35}},{"line":611,"address":[],"length":0,"stats":{"Line":63}},{"line":614,"address":[],"length":0,"stats":{"Line":68}},{"line":615,"address":[],"length":0,"stats":{"Line":11}},{"line":619,"address":[],"length":0,"stats":{"Line":30}},{"line":620,"address":[],"length":0,"stats":{"Line":20}},{"line":621,"address":[],"length":0,"stats":{"Line":70}},{"line":622,"address":[],"length":0,"stats":{"Line":70}},{"line":625,"address":[],"length":0,"stats":{"Line":20}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":30}},{"line":642,"address":[],"length":0,"stats":{"Line":30}},{"line":643,"address":[],"length":0,"stats":{"Line":58}},{"line":644,"address":[],"length":0,"stats":{"Line":57}},{"line":645,"address":[],"length":0,"stats":{"Line":57}},{"line":647,"address":[],"length":0,"stats":{"Line":19}},{"line":648,"address":[],"length":0,"stats":{"Line":39}},{"line":649,"address":[],"length":0,"stats":{"Line":46}},{"line":650,"address":[],"length":0,"stats":{"Line":17}},{"line":651,"address":[],"length":0,"stats":{"Line":17}},{"line":652,"address":[],"length":0,"stats":{"Line":9}},{"line":653,"address":[],"length":0,"stats":{"Line":7}},{"line":654,"address":[],"length":0,"stats":{"Line":5}},{"line":655,"address":[],"length":0,"stats":{"Line":1}},{"line":660,"address":[],"length":0,"stats":{"Line":30}},{"line":663,"address":[],"length":0,"stats":{"Line":7}},{"line":667,"address":[],"length":0,"stats":{"Line":1}},{"line":668,"address":[],"length":0,"stats":{"Line":6}},{"line":669,"address":[],"length":0,"stats":{"Line":8}},{"line":670,"address":[],"length":0,"stats":{"Line":4}},{"line":675,"address":[],"length":0,"stats":{"Line":1}},{"line":676,"address":[],"length":0,"stats":{"Line":1}}],"covered":262,"coverable":277},{"path":["/","workspace","crates","ofml-lib","src","oap","actions.rs"],"content":"//! OAP Actions processing\n//!\n//! This module handles OAP actions that modify configuration state:\n//! - OAPCreateObjectAction: Create child articles\n//! - OAPPropEditAction: Propagate property changes\n//! - OAPShowMediaAction: Reference images/previews\n\nuse std::collections::HashMap;\n\nuse super::config::Configuration;\nuse super::ocd_relation::parse_condition;\nuse serde::{Deserialize, Serialize};\n\n/// OAP action types\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum OAPAction {\n    /// Create a child object/sub-article\n    CreateObject(OAPCreateObjectAction),\n    /// Edit/propagate property values\n    PropEdit(OAPPropEditAction),\n    /// Show media reference\n    ShowMedia(OAPShowMediaAction),\n}\n\n/// Action to create a child object\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OAPCreateObjectAction {\n    /// Class name of the object to create\n    pub class_name: String,\n    /// Properties to set on the new object\n    pub properties: Vec<(String, String)>,\n    /// Parent relationship type\n    pub relationship: String,\n}\n\n/// Action to edit properties\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OAPPropEditAction {\n    /// Target property name\n    pub property_name: String,\n    /// New value expression\n    pub value_expression: String,\n    /// Condition for when to apply\n    pub condition: Option<String>,\n}\n\n/// Action to show media\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OAPShowMediaAction {\n    /// Media type (image, video, etc.)\n    pub media_type: String,\n    /// Path or URL to media\n    pub media_path: String,\n}\n\n/// Result of processing an OAP action\n#[derive(Debug, Clone)]\npub struct OAPActionResult {\n    /// Type of action executed\n    pub action_type: String,\n    /// Whether action completed successfully\n    pub success: bool,\n    /// New object if OAPCreateObjectAction\n    pub created_object: Option<Box<Configuration>>,\n    /// Property names changed by OAPPropEditAction\n    pub modified_properties: Vec<String>,\n    /// Media path/URL if OAPShowMediaAction\n    pub media_reference: Option<String>,\n    /// Error description if failed\n    pub error_message: Option<String>,\n}\n\nimpl OAPActionResult {\n    /// Create a successful result for CreateObject\n    pub fn create_object_success(config: Configuration) -> Self {\n        Self {\n            action_type: \"create\".to_string(),\n            success: true,\n            created_object: Some(Box::new(config)),\n            modified_properties: vec![],\n            media_reference: None,\n            error_message: None,\n        }\n    }\n\n    /// Create a successful result for PropEdit\n    pub fn prop_edit_success(modified: Vec<String>) -> Self {\n        Self {\n            action_type: \"edit\".to_string(),\n            success: true,\n            created_object: None,\n            modified_properties: modified,\n            media_reference: None,\n            error_message: None,\n        }\n    }\n\n    /// Create a skipped result for PropEdit (condition not met)\n    pub fn prop_edit_skipped(property: String, reason: String) -> Self {\n        Self {\n            action_type: \"edit_skipped\".to_string(),\n            success: true, // Not a failure, just skipped\n            created_object: None,\n            modified_properties: vec![property],\n            media_reference: None,\n            error_message: Some(reason),\n        }\n    }\n\n    /// Create a successful result for ShowMedia\n    pub fn show_media_success(path: String) -> Self {\n        Self {\n            action_type: \"media\".to_string(),\n            success: true,\n            created_object: None,\n            modified_properties: vec![],\n            media_reference: Some(path),\n            error_message: None,\n        }\n    }\n\n    /// Create a failure result\n    pub fn failure(action_type: &str, error: String) -> Self {\n        Self {\n            action_type: action_type.to_string(),\n            success: false,\n            created_object: None,\n            modified_properties: vec![],\n            media_reference: None,\n            error_message: Some(error),\n        }\n    }\n}\n\n/// OAP action processor\npub struct OAPActionProcessor {\n    // State for action processing\n}\n\nimpl OAPActionProcessor {\n    /// Create a new action processor\n    pub fn new() -> Self {\n        Self {}\n    }\n\n    /// Process an OAP action on a configuration\n    pub fn process(&self, action: &OAPAction, config: &mut Configuration) -> OAPActionResult {\n        match action {\n            OAPAction::CreateObject(create_action) => {\n                self.process_create_object(create_action, config)\n            }\n            OAPAction::PropEdit(edit_action) => self.process_prop_edit(edit_action, config),\n            OAPAction::ShowMedia(media_action) => self.process_show_media(media_action),\n        }\n    }\n\n    /// Process OAPCreateObjectAction\n    fn process_create_object(\n        &self,\n        action: &OAPCreateObjectAction,\n        parent: &mut Configuration,\n    ) -> OAPActionResult {\n        // Create a new sub-article configuration\n        let mut sub_config =\n            Configuration::new(action.class_name.clone(), parent.manufacturer_id.clone());\n\n        // Apply initial properties\n        for (name, value) in &action.properties {\n            // Parse and set property value\n            use crate::property::PropertyValue;\n            // Try to parse as different types\n            let pv = if let Ok(i) = value.parse::<i64>() {\n                PropertyValue::Int(i)\n            } else if let Ok(f) = value.parse::<f64>() {\n                PropertyValue::Float(f)\n            } else if value == \"true\" {\n                PropertyValue::Bool(true)\n            } else if value == \"false\" {\n                PropertyValue::Bool(false)\n            } else {\n                PropertyValue::String(value.clone())\n            };\n\n            sub_config.properties.values.insert(name.clone(), pv);\n        }\n\n        // Update variant code\n        sub_config.update_variant_code();\n\n        // Add to parent's sub-articles\n        parent.sub_articles.push(sub_config.clone());\n\n        OAPActionResult::create_object_success(sub_config)\n    }\n\n    /// Process OAPPropEditAction\n    fn process_prop_edit(\n        &self,\n        action: &OAPPropEditAction,\n        config: &mut Configuration,\n    ) -> OAPActionResult {\n        // Check condition if present\n        if let Some(ref condition) = action.condition {\n            use crate::property::PropertyValue;\n\n            // Convert config properties to HashMap<String, String> for evaluation\n            let props: HashMap<String, String> = config\n                .properties\n                .values\n                .iter()\n                .map(|(k, v)| {\n                    let value_str = match v {\n                        PropertyValue::Bool(b) => if *b { \"YES\" } else { \"NO\" }.to_string(),\n                        PropertyValue::Int(i) => i.to_string(),\n                        PropertyValue::Float(f) => f.to_string(),\n                        PropertyValue::String(s) => s.clone(),\n                        PropertyValue::Symbol(s) => s.clone(),\n                    };\n                    (k.clone(), value_str)\n                })\n                .collect();\n\n            // Parse and evaluate the condition\n            let parsed_condition = parse_condition(condition);\n            if !parsed_condition.evaluate(&props) {\n                // Condition not met, skip this action\n                return OAPActionResult::prop_edit_skipped(\n                    action.property_name.clone(),\n                    \"Condition not met\".to_string(),\n                );\n            }\n        }\n\n        // Parse and set the new value\n        use crate::property::PropertyValue;\n        let pv = if let Ok(i) = action.value_expression.parse::<i64>() {\n            PropertyValue::Int(i)\n        } else if let Ok(f) = action.value_expression.parse::<f64>() {\n            PropertyValue::Float(f)\n        } else if action.value_expression == \"true\" {\n            PropertyValue::Bool(true)\n        } else if action.value_expression == \"false\" {\n            PropertyValue::Bool(false)\n        } else {\n            PropertyValue::String(action.value_expression.clone())\n        };\n\n        config\n            .properties\n            .values\n            .insert(action.property_name.clone(), pv);\n\n        // Update variant code\n        config.update_variant_code();\n\n        OAPActionResult::prop_edit_success(vec![action.property_name.clone()])\n    }\n\n    /// Process OAPShowMediaAction\n    fn process_show_media(&self, action: &OAPShowMediaAction) -> OAPActionResult {\n        // Just return the media reference\n        OAPActionResult::show_media_success(action.media_path.clone())\n    }\n}\n\nimpl Default for OAPActionProcessor {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_create_object_action() {\n        let processor = OAPActionProcessor::new();\n        let mut config = Configuration::new(\"Parent\".to_string(), \"vitra\".to_string());\n\n        let action = OAPAction::CreateObject(OAPCreateObjectAction {\n            class_name: \"ChildPart\".to_string(),\n            properties: vec![(\"color\".to_string(), \"white\".to_string())],\n            relationship: \"child\".to_string(),\n        });\n\n        let result = processor.process(&action, &mut config);\n        assert!(result.success);\n        assert!(result.created_object.is_some());\n        assert_eq!(config.sub_articles.len(), 1);\n        assert_eq!(config.sub_articles[0].article_id, \"ChildPart\");\n    }\n\n    #[test]\n    fn test_prop_edit_action() {\n        let processor = OAPActionProcessor::new();\n        let mut config = Configuration::new(\"Article\".to_string(), \"vitra\".to_string());\n\n        let action = OAPAction::PropEdit(OAPPropEditAction {\n            property_name: \"height\".to_string(),\n            value_expression: \"720\".to_string(),\n            condition: None,\n        });\n\n        let result = processor.process(&action, &mut config);\n        assert!(result.success);\n        assert_eq!(result.modified_properties, vec![\"height\"]);\n\n        // Check property was set\n        use crate::property::PropertyValue;\n        assert_eq!(\n            config.properties.values.get(\"height\"),\n            Some(&PropertyValue::Int(720))\n        );\n    }\n\n    #[test]\n    fn test_show_media_action() {\n        let processor = OAPActionProcessor::new();\n        let mut config = Configuration::new(\"Article\".to_string(), \"vitra\".to_string());\n\n        let action = OAPAction::ShowMedia(OAPShowMediaAction {\n            media_type: \"image\".to_string(),\n            media_path: \"/images/preview.jpg\".to_string(),\n        });\n\n        let result = processor.process(&action, &mut config);\n        assert!(result.success);\n        assert_eq!(\n            result.media_reference,\n            Some(\"/images/preview.jpg\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_action_result_failure() {\n        let result = OAPActionResult::failure(\"create\", \"Class not found\".to_string());\n        assert!(!result.success);\n        assert_eq!(result.error_message, Some(\"Class not found\".to_string()));\n    }\n\n    #[test]\n    fn test_prop_edit_condition_met() {\n        use crate::property::PropertyValue;\n\n        let processor = OAPActionProcessor::new();\n        let mut config = Configuration::new(\"Article\".to_string(), \"vitra\".to_string());\n\n        // Set a property that the condition will check\n        config.properties.values.insert(\n            \"M_COLOR\".to_string(),\n            PropertyValue::String(\"WHITE\".to_string()),\n        );\n\n        // Create action with condition that should be met\n        let action = OAPAction::PropEdit(OAPPropEditAction {\n            property_name: \"price_modifier\".to_string(),\n            value_expression: \"100\".to_string(),\n            condition: Some(\"M_COLOR = 'WHITE'\".to_string()),\n        });\n\n        let result = processor.process(&action, &mut config);\n        assert!(result.success);\n        assert_eq!(result.action_type, \"edit\");\n        assert_eq!(result.modified_properties, vec![\"price_modifier\"]);\n\n        // Verify property was set\n        assert_eq!(\n            config.properties.values.get(\"price_modifier\"),\n            Some(&PropertyValue::Int(100))\n        );\n    }\n\n    #[test]\n    fn test_prop_edit_condition_not_met() {\n        use crate::property::PropertyValue;\n\n        let processor = OAPActionProcessor::new();\n        let mut config = Configuration::new(\"Article\".to_string(), \"vitra\".to_string());\n\n        // Set a property that the condition will check\n        config.properties.values.insert(\n            \"M_COLOR\".to_string(),\n            PropertyValue::String(\"BLACK\".to_string()),\n        );\n\n        // Create action with condition that should NOT be met\n        let action = OAPAction::PropEdit(OAPPropEditAction {\n            property_name: \"price_modifier\".to_string(),\n            value_expression: \"100\".to_string(),\n            condition: Some(\"M_COLOR = 'WHITE'\".to_string()),\n        });\n\n        let result = processor.process(&action, &mut config);\n        assert!(result.success); // Skipped is still success\n        assert_eq!(result.action_type, \"edit_skipped\");\n\n        // Verify property was NOT set\n        assert_eq!(config.properties.values.get(\"price_modifier\"), None);\n    }\n\n    #[test]\n    fn test_prop_edit_condition_and() {\n        use crate::property::PropertyValue;\n\n        let processor = OAPActionProcessor::new();\n        let mut config = Configuration::new(\"Article\".to_string(), \"vitra\".to_string());\n\n        config.properties.values.insert(\n            \"M_COLOR\".to_string(),\n            PropertyValue::String(\"WHITE\".to_string()),\n        );\n        config.properties.values.insert(\n            \"M_SIZE\".to_string(),\n            PropertyValue::String(\"LARGE\".to_string()),\n        );\n\n        // Test AND condition\n        let action = OAPAction::PropEdit(OAPPropEditAction {\n            property_name: \"modifier\".to_string(),\n            value_expression: \"50\".to_string(),\n            condition: Some(\"M_COLOR = 'WHITE' and M_SIZE = 'LARGE'\".to_string()),\n        });\n\n        let result = processor.process(&action, &mut config);\n        assert!(result.success);\n        assert_eq!(result.action_type, \"edit\");\n    }\n}\n","traces":[{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":3}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":80,"address":[],"length":0,"stats":{"Line":2}},{"line":87,"address":[],"length":0,"stats":{"Line":3}},{"line":89,"address":[],"length":0,"stats":{"Line":9}},{"line":99,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":3}},{"line":104,"address":[],"length":0,"stats":{"Line":3}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":117,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":125,"address":[],"length":0,"stats":{"Line":3}},{"line":128,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":1}},{"line":142,"address":[],"length":0,"stats":{"Line":6}},{"line":147,"address":[],"length":0,"stats":{"Line":6}},{"line":148,"address":[],"length":0,"stats":{"Line":6}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":4}},{"line":152,"address":[],"length":0,"stats":{"Line":20}},{"line":153,"address":[],"length":0,"stats":{"Line":4}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":5}},{"line":168,"address":[],"length":0,"stats":{"Line":4}},{"line":172,"address":[],"length":0,"stats":{"Line":2}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":5}},{"line":188,"address":[],"length":0,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":4}},{"line":193,"address":[],"length":0,"stats":{"Line":2}},{"line":197,"address":[],"length":0,"stats":{"Line":4}},{"line":203,"address":[],"length":0,"stats":{"Line":7}},{"line":207,"address":[],"length":0,"stats":{"Line":9}},{"line":208,"address":[],"length":0,"stats":{"Line":3}},{"line":209,"address":[],"length":0,"stats":{"Line":3}},{"line":211,"address":[],"length":0,"stats":{"Line":7}},{"line":212,"address":[],"length":0,"stats":{"Line":8}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":12}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":8}},{"line":224,"address":[],"length":0,"stats":{"Line":9}},{"line":225,"address":[],"length":0,"stats":{"Line":6}},{"line":227,"address":[],"length":0,"stats":{"Line":1}},{"line":228,"address":[],"length":0,"stats":{"Line":2}},{"line":229,"address":[],"length":0,"stats":{"Line":2}},{"line":236,"address":[],"length":0,"stats":{"Line":9}},{"line":237,"address":[],"length":0,"stats":{"Line":3}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":3}},{"line":249,"address":[],"length":0,"stats":{"Line":3}},{"line":250,"address":[],"length":0,"stats":{"Line":3}},{"line":251,"address":[],"length":0,"stats":{"Line":12}},{"line":254,"address":[],"length":0,"stats":{"Line":6}},{"line":256,"address":[],"length":0,"stats":{"Line":12}},{"line":260,"address":[],"length":0,"stats":{"Line":1}},{"line":262,"address":[],"length":0,"stats":{"Line":3}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}}],"covered":62,"coverable":79},{"path":["/","workspace","crates","ofml-lib","src","oap","catalog.rs"],"content":"//! XCF Catalog Loader - Parses eXtensible Catalog Format for product hierarchies\n//!\n//! XCF is the standard format used by pcon.configurator/pcon.basket for organizing\n//! products into human-readable category hierarchies. The format consists of CSV files:\n//!\n//! - `structure.csv` - Defines the tree hierarchy with folder/article nodes\n//! - `text.csv` - Multilingual labels for nodes\n//! - `article.csv` - Maps articles to their series directories\n//! - `resource.csv` - Resource references (images, icons)\n//! - `variant.csv` - Product variant definitions\n//!\n//! Catalogs can be stored as:\n//! - Plain CSV files in a `cat/` directory\n//! - ZIP archive (`xcf.zip`) containing CSV files\n\nuse std::collections::HashMap;\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::{Path, PathBuf};\n\nuse encoding_rs::WINDOWS_1252;\nuse serde::{Deserialize, Serialize};\n\n/// Type of node in the catalog tree\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]\npub enum NodeType {\n    /// Folder/category node\n    #[default]\n    Folder,\n    /// Article/product node\n    Article,\n    /// Root node (virtual)\n    Root,\n}\n\n/// A node in the catalog tree\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CatalogNode {\n    /// Node identifier (@FOLDERXXXX for folders, article_nr for articles)\n    pub id: String,\n    /// Display name (from text.csv)\n    pub name: String,\n    /// Node type (Folder or Article)\n    pub node_type: NodeType,\n    /// Hierarchy depth (1 = top level)\n    pub depth: u8,\n    /// Series reference for articles (e.g., \"::bisley::lf\")\n    pub series_ref: Option<String>,\n    /// Variant code for articles (e.g., \"1503\", \"1513\" for different configurations)\n    pub variant_code: Option<String>,\n    /// Child nodes\n    pub children: Vec<CatalogNode>,\n}\n\nimpl CatalogNode {\n    /// Create a new folder node\n    pub fn folder(id: &str, name: &str, depth: u8) -> Self {\n        Self {\n            id: id.to_string(),\n            name: name.to_string(),\n            node_type: NodeType::Folder,\n            depth,\n            series_ref: None,\n            variant_code: None,\n            children: Vec::new(),\n        }\n    }\n\n    /// Create a new article node\n    pub fn article(id: &str, name: &str, depth: u8, series_ref: Option<String>) -> Self {\n        Self {\n            id: id.to_string(),\n            name: name.to_string(),\n            node_type: NodeType::Article,\n            depth,\n            series_ref,\n            variant_code: None,\n            children: Vec::new(),\n        }\n    }\n\n    /// Create a new article node with variant code\n    pub fn article_with_variant(\n        id: &str,\n        name: &str,\n        depth: u8,\n        series_ref: Option<String>,\n        variant_code: Option<String>,\n    ) -> Self {\n        Self {\n            id: id.to_string(),\n            name: name.to_string(),\n            node_type: NodeType::Article,\n            depth,\n            series_ref,\n            variant_code,\n            children: Vec::new(),\n        }\n    }\n\n    /// Create root node\n    pub fn root() -> Self {\n        Self {\n            id: \"@ROOT\".to_string(),\n            name: \"Root\".to_string(),\n            node_type: NodeType::Root,\n            depth: 0,\n            series_ref: None,\n            variant_code: None,\n            children: Vec::new(),\n        }\n    }\n\n    /// Count total nodes (including self)\n    pub fn count(&self) -> usize {\n        1 + self.children.iter().map(|c| c.count()).sum::<usize>()\n    }\n\n    /// Count folders only\n    pub fn folder_count(&self) -> usize {\n        let self_count = if self.node_type == NodeType::Folder {\n            1\n        } else {\n            0\n        };\n        self_count\n            + self\n                .children\n                .iter()\n                .map(|c| c.folder_count())\n                .sum::<usize>()\n    }\n\n    /// Count articles only\n    pub fn article_count(&self) -> usize {\n        let self_count = if self.node_type == NodeType::Article {\n            1\n        } else {\n            0\n        };\n        self_count\n            + self\n                .children\n                .iter()\n                .map(|c| c.article_count())\n                .sum::<usize>()\n    }\n\n    /// Find a node by ID (recursive)\n    pub fn find(&self, id: &str) -> Option<&CatalogNode> {\n        if self.id == id {\n            return Some(self);\n        }\n        for child in &self.children {\n            if let Some(found) = child.find(id) {\n                return Some(found);\n            }\n        }\n        None\n    }\n\n    /// Get path to node (list of ancestor names)\n    pub fn path_to(&self, id: &str) -> Option<Vec<String>> {\n        if self.id == id {\n            return Some(vec![self.name.clone()]);\n        }\n        for child in &self.children {\n            if let Some(mut path) = child.path_to(id) {\n                path.insert(0, self.name.clone());\n                return Some(path);\n            }\n        }\n        None\n    }\n}\n\n/// Structure entry from structure.csv\n#[derive(Debug, Clone)]\nstruct StructureEntry {\n    id: String,\n    /// Variant code (e.g., \"1503\", \"1513\", or \"default\")\n    variant_code: Option<String>,\n    depth: u8,\n    node_type: NodeType,\n}\n\n/// Variant definition from variant.csv - maps article variants to property settings\n#[derive(Debug, Clone)]\npub struct VariantDefinition {\n    /// Article ID\n    pub article_id: String,\n    /// Variant code\n    pub variant_code: String,\n    /// Property settings in format \"PROPERTY_CLASS.PROPERTY=VALUE\"\n    pub property_settings: Vec<String>,\n}\n\n/// XCF Catalog - parsed catalog data\n#[derive(Debug, Clone)]\npub struct XcfCatalog {\n    /// Root node of the catalog tree\n    pub root: CatalogNode,\n    /// Text labels by (id, variant_code, language) - variant_code empty for folders\n    texts: HashMap<(String, String, String), String>,\n    /// Article to series mapping\n    articles: HashMap<String, String>,\n    /// Variant definitions - property settings for article variants\n    pub variants: HashMap<(String, String), VariantDefinition>,\n    /// Source path\n    pub source_path: PathBuf,\n}\n\nimpl XcfCatalog {\n    /// Get text for a node in specified language (without variant)\n    pub fn get_text(&self, id: &str, language: &str) -> Option<&str> {\n        self.get_text_variant(id, \"\", language)\n    }\n\n    /// Get text for a node with variant in specified language\n    pub fn get_text_variant(&self, id: &str, variant: &str, language: &str) -> Option<&str> {\n        self.texts\n            .get(&(id.to_string(), variant.to_string(), language.to_string()))\n            .map(|s| s.as_str())\n    }\n\n    /// Get text with fallback to German then English\n    pub fn get_text_with_fallback(&self, id: &str, language: &str) -> Option<&str> {\n        self.get_text_variant_with_fallback(id, \"\", language)\n    }\n\n    /// Get text with variant and fallback to German then English\n    pub fn get_text_variant_with_fallback(\n        &self,\n        id: &str,\n        variant: &str,\n        language: &str,\n    ) -> Option<&str> {\n        self.get_text_variant(id, variant, language)\n            .or_else(|| self.get_text_variant(id, variant, \"de\"))\n            .or_else(|| self.get_text_variant(id, variant, \"en\"))\n    }\n\n    /// Get variant definition for an article\n    pub fn get_variant(&self, article_id: &str, variant_code: &str) -> Option<&VariantDefinition> {\n        self.variants\n            .get(&(article_id.to_string(), variant_code.to_string()))\n    }\n\n    /// Get series reference for an article\n    pub fn get_series_ref(&self, article_id: &str) -> Option<&str> {\n        self.articles.get(article_id).map(|s| s.as_str())\n    }\n\n    /// Get all available languages\n    pub fn languages(&self) -> Vec<String> {\n        let mut langs: Vec<String> = self.texts.keys().map(|(_, _, lang)| lang.clone()).collect();\n        langs.sort();\n        langs.dedup();\n        langs\n    }\n\n    /// Get statistics\n    pub fn stats(&self) -> CatalogStats {\n        CatalogStats {\n            total_nodes: self.root.count(),\n            folder_count: self.root.folder_count(),\n            article_count: self.root.article_count(),\n            text_entries: self.texts.len(),\n            languages: self.languages(),\n        }\n    }\n}\n\n/// Catalog statistics\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CatalogStats {\n    pub total_nodes: usize,\n    pub folder_count: usize,\n    pub article_count: usize,\n    pub text_entries: usize,\n    pub languages: Vec<String>,\n}\n\n/// XCF Catalog Loader\npub struct CatalogLoader;\n\nimpl CatalogLoader {\n    /// Load catalog from a directory or ZIP file\n    ///\n    /// Automatically detects format:\n    /// - If path is a directory, looks for CSV files\n    /// - If path is a ZIP file, extracts and parses\n    /// - If path is a directory with xcf.zip, loads from ZIP\n    pub fn load(path: &Path, language: &str) -> Result<XcfCatalog, CatalogError> {\n        // Check for xcf.zip in directory\n        let zip_path = path.join(\"xcf.zip\");\n        if zip_path.exists() {\n            return Self::load_from_zip(&zip_path, language);\n        }\n\n        // Check if path itself is a ZIP\n        if path.extension().map(|e| e == \"zip\").unwrap_or(false) {\n            return Self::load_from_zip(path, language);\n        }\n\n        // Check for CSV files in directory\n        let structure_path = path.join(\"structure.csv\");\n        if structure_path.exists() {\n            return Self::load_from_csv_dir(path, language);\n        }\n\n        // Try cat/ subdirectory\n        let cat_path = path.join(\"cat\");\n        if cat_path.exists() {\n            let cat_zip = cat_path.join(\"xcf.zip\");\n            if cat_zip.exists() {\n                return Self::load_from_zip(&cat_zip, language);\n            }\n            let cat_structure = cat_path.join(\"structure.csv\");\n            if cat_structure.exists() {\n                return Self::load_from_csv_dir(&cat_path, language);\n            }\n        }\n\n        Err(CatalogError::NotFound(path.to_path_buf()))\n    }\n\n    /// Load catalog from CSV files in a directory\n    pub fn load_from_csv_dir(dir: &Path, language: &str) -> Result<XcfCatalog, CatalogError> {\n        let structure_path = dir.join(\"structure.csv\");\n        let text_path = dir.join(\"text.csv\");\n        let article_path = dir.join(\"article.csv\");\n        let variant_path = dir.join(\"variant.csv\");\n\n        // Read structure (with encoding conversion)\n        let structure_content = Self::read_file_with_encoding(&structure_path)?;\n        let structure_entries = Self::parse_structure_csv(&structure_content)?;\n\n        // Read texts\n        let texts = if text_path.exists() {\n            let text_content = Self::read_file_with_encoding(&text_path)?;\n            Self::parse_text_csv(&text_content)?\n        } else {\n            HashMap::new()\n        };\n\n        // Read articles\n        let articles = if article_path.exists() {\n            let article_content = Self::read_file_with_encoding(&article_path)?;\n            Self::parse_article_csv(&article_content)?\n        } else {\n            HashMap::new()\n        };\n\n        // Read variants\n        let variants = if variant_path.exists() {\n            let variant_content = Self::read_file_with_encoding(&variant_path)?;\n            Self::parse_variant_csv(&variant_content)?\n        } else {\n            HashMap::new()\n        };\n\n        // Build tree\n        let root = Self::build_tree(&structure_entries, &texts, &articles, language);\n\n        Ok(XcfCatalog {\n            root,\n            texts,\n            articles,\n            variants,\n            source_path: dir.to_path_buf(),\n        })\n    }\n\n    /// Read a file with automatic encoding detection (UTF-8 or Windows-1252)\n    fn read_file_with_encoding(path: &Path) -> Result<String, CatalogError> {\n        let bytes = std::fs::read(path)\n            .map_err(|e| CatalogError::IoError(path.to_path_buf(), e.to_string()))?;\n\n        // Try UTF-8 first\n        if let Ok(content) = String::from_utf8(bytes.clone()) {\n            return Ok(content);\n        }\n\n        // Fall back to Windows-1252 (common for German/European text)\n        let (content, _, had_errors) = WINDOWS_1252.decode(&bytes);\n        if had_errors {\n            return Err(CatalogError::IoError(\n                path.to_path_buf(),\n                \"Failed to decode file content\".to_string(),\n            ));\n        }\n\n        Ok(content.into_owned())\n    }\n\n    /// Load catalog from ZIP archive\n    pub fn load_from_zip(zip_path: &Path, language: &str) -> Result<XcfCatalog, CatalogError> {\n        let file = File::open(zip_path)\n            .map_err(|e| CatalogError::IoError(zip_path.to_path_buf(), e.to_string()))?;\n        let mut archive =\n            zip::ZipArchive::new(file).map_err(|e| CatalogError::ZipError(e.to_string()))?;\n\n        let mut structure_bytes = Vec::new();\n        let mut text_bytes = Vec::new();\n        let mut article_bytes = Vec::new();\n        let mut variant_bytes = Vec::new();\n\n        // Extract files from archive\n        for i in 0..archive.len() {\n            let mut file = archive\n                .by_index(i)\n                .map_err(|e| CatalogError::ZipError(e.to_string()))?;\n            let name = file.name().to_lowercase();\n\n            if name.ends_with(\"structure.csv\") {\n                file.read_to_end(&mut structure_bytes)\n                    .map_err(|e| CatalogError::IoError(zip_path.to_path_buf(), e.to_string()))?;\n            } else if name.ends_with(\"text.csv\") {\n                file.read_to_end(&mut text_bytes)\n                    .map_err(|e| CatalogError::IoError(zip_path.to_path_buf(), e.to_string()))?;\n            } else if name.ends_with(\"article.csv\") {\n                file.read_to_end(&mut article_bytes)\n                    .map_err(|e| CatalogError::IoError(zip_path.to_path_buf(), e.to_string()))?;\n            } else if name.ends_with(\"variant.csv\") {\n                file.read_to_end(&mut variant_bytes)\n                    .map_err(|e| CatalogError::IoError(zip_path.to_path_buf(), e.to_string()))?;\n            }\n        }\n\n        if structure_bytes.is_empty() {\n            return Err(CatalogError::MissingFile(\"structure.csv\".to_string()));\n        }\n\n        // Decode with encoding detection\n        let structure_content = Self::decode_bytes(&structure_bytes);\n        let text_content = Self::decode_bytes(&text_bytes);\n        let article_content = Self::decode_bytes(&article_bytes);\n        let variant_content = Self::decode_bytes(&variant_bytes);\n\n        let structure_entries = Self::parse_structure_csv(&structure_content)?;\n        let texts = if !text_content.is_empty() {\n            Self::parse_text_csv(&text_content)?\n        } else {\n            HashMap::new()\n        };\n        let articles = if !article_content.is_empty() {\n            Self::parse_article_csv(&article_content)?\n        } else {\n            HashMap::new()\n        };\n        let variants = if !variant_content.is_empty() {\n            Self::parse_variant_csv(&variant_content)?\n        } else {\n            HashMap::new()\n        };\n\n        let root = Self::build_tree(&structure_entries, &texts, &articles, language);\n\n        Ok(XcfCatalog {\n            root,\n            texts,\n            articles,\n            variants,\n            source_path: zip_path.to_path_buf(),\n        })\n    }\n\n    /// Decode bytes with automatic encoding detection\n    fn decode_bytes(bytes: &[u8]) -> String {\n        // Try UTF-8 first\n        if let Ok(content) = String::from_utf8(bytes.to_vec()) {\n            return content;\n        }\n        // Fall back to Windows-1252\n        let (content, _, _) = WINDOWS_1252.decode(bytes);\n        content.into_owned()\n    }\n\n    /// Parse structure.csv content\n    /// Format: \"ID\";variant_code;DEPTH;TYPE;\n    fn parse_structure_csv(content: &str) -> Result<Vec<StructureEntry>, CatalogError> {\n        let mut entries = Vec::new();\n\n        for line in content.lines() {\n            let line = line.trim();\n            if line.is_empty() || line.starts_with('#') {\n                continue;\n            }\n\n            let fields: Vec<&str> = Self::parse_csv_line(line);\n            if fields.len() < 4 {\n                continue;\n            }\n\n            let id = fields[0].trim_matches('\"').to_string();\n            if id.is_empty() || id == \"ID\" {\n                continue; // Skip header\n            }\n\n            // Capture variant code (second field) - \"default\" means no variant\n            let variant_str = fields[1].trim_matches('\"');\n            let variant_code = if variant_str.is_empty() || variant_str == \"default\" {\n                None\n            } else {\n                Some(variant_str.to_string())\n            };\n\n            let depth: u8 = fields[2].trim_matches('\"').parse().unwrap_or(1);\n            let type_str = fields[3].trim_matches('\"');\n            let node_type = match type_str {\n                \"F\" => NodeType::Folder,\n                \"A\" => NodeType::Article,\n                _ => NodeType::Folder,\n            };\n\n            entries.push(StructureEntry {\n                id,\n                variant_code,\n                depth,\n                node_type,\n            });\n        }\n\n        Ok(entries)\n    }\n\n    /// Parse text.csv content\n    /// Format: \"ID\";variant_code;LANG;\"TEXT\"\n    fn parse_text_csv(\n        content: &str,\n    ) -> Result<HashMap<(String, String, String), String>, CatalogError> {\n        let mut texts = HashMap::new();\n\n        for line in content.lines() {\n            let line = line.trim();\n            if line.is_empty() || line.starts_with('#') {\n                continue;\n            }\n\n            let fields: Vec<&str> = Self::parse_csv_line(line);\n            if fields.len() < 4 {\n                continue;\n            }\n\n            let id = fields[0].trim_matches('\"').to_string();\n            if id.is_empty() || id == \"ID\" {\n                continue; // Skip header\n            }\n\n            // Variant code (second field) - normalize \"default\" to empty string\n            let variant_str = fields[1].trim_matches('\"');\n            let variant = if variant_str == \"default\" {\n                String::new()\n            } else {\n                variant_str.to_string()\n            };\n\n            let language = fields[2].trim_matches('\"').to_string();\n            let text = fields[3].trim_matches('\"').to_string();\n\n            if !language.is_empty() && !text.is_empty() {\n                texts.insert((id, variant, language), text);\n            }\n        }\n\n        Ok(texts)\n    }\n\n    /// Parse variant.csv content\n    /// Format: \"ARTICLE_ID\";variant_code;\"PROPERTY_CLASS.PROPERTY=VALUE\"\n    fn parse_variant_csv(\n        content: &str,\n    ) -> Result<HashMap<(String, String), VariantDefinition>, CatalogError> {\n        let mut variants = HashMap::new();\n\n        for line in content.lines() {\n            let line = line.trim();\n            if line.is_empty() || line.starts_with('#') {\n                continue;\n            }\n\n            let fields: Vec<&str> = Self::parse_csv_line(line);\n            if fields.len() < 3 {\n                continue;\n            }\n\n            let article_id = fields[0].trim_matches('\"').to_string();\n            if article_id.is_empty() || article_id == \"ID\" {\n                continue;\n            }\n\n            let variant_code = fields[1].trim_matches('\"').to_string();\n            let settings_str = fields[2].trim_matches('\"');\n\n            // Parse property settings (may be multiple, separated by semicolons within the field)\n            let property_settings: Vec<String> = settings_str\n                .split(';')\n                .filter(|s| !s.is_empty())\n                .map(|s| s.to_string())\n                .collect();\n\n            variants.insert(\n                (article_id.clone(), variant_code.clone()),\n                VariantDefinition {\n                    article_id,\n                    variant_code,\n                    property_settings,\n                },\n            );\n        }\n\n        Ok(variants)\n    }\n\n    /// Parse article.csv content\n    /// Format: \"ARTICLE_NR\";default;0;;S;15;::mfr::series\n    fn parse_article_csv(content: &str) -> Result<HashMap<String, String>, CatalogError> {\n        let mut articles = HashMap::new();\n\n        for line in content.lines() {\n            let line = line.trim();\n            if line.is_empty() || line.starts_with('#') {\n                continue;\n            }\n\n            let fields: Vec<&str> = Self::parse_csv_line(line);\n            if fields.len() < 7 {\n                continue;\n            }\n\n            let id = fields[0].trim_matches('\"').to_string();\n            if id.is_empty() || id == \"ID\" || id.starts_with('@') {\n                continue; // Skip headers and folder references\n            }\n\n            let series_ref = fields[6].trim_matches('\"').to_string();\n            if !series_ref.is_empty() {\n                articles.insert(id, series_ref);\n            }\n        }\n\n        Ok(articles)\n    }\n\n    /// Parse a CSV line handling quoted fields with semicolons\n    fn parse_csv_line(line: &str) -> Vec<&str> {\n        let mut fields = Vec::new();\n        let mut start = 0;\n        let mut in_quotes = false;\n\n        for (i, c) in line.char_indices() {\n            match c {\n                '\"' => in_quotes = !in_quotes,\n                ';' if !in_quotes => {\n                    fields.push(&line[start..i]);\n                    start = i + 1;\n                }\n                _ => {}\n            }\n        }\n        // Add last field\n        if start < line.len() {\n            fields.push(&line[start..]);\n        }\n\n        fields\n    }\n\n    /// Build tree from structure entries\n    fn build_tree(\n        entries: &[StructureEntry],\n        texts: &HashMap<(String, String, String), String>,\n        articles: &HashMap<String, String>,\n        language: &str,\n    ) -> CatalogNode {\n        let mut root = CatalogNode::root();\n        let mut stack: Vec<(u8, usize)> = vec![(0, 0)]; // (depth, index in parent's children)\n\n        for entry in entries {\n            // Get variant string for text lookup\n            let variant_str = entry.variant_code.as_deref().unwrap_or(\"\");\n\n            // Get display name - try with variant first, then without\n            let name = texts\n                .get(&(\n                    entry.id.clone(),\n                    variant_str.to_string(),\n                    language.to_string(),\n                ))\n                .or_else(|| {\n                    texts.get(&(entry.id.clone(), variant_str.to_string(), \"de\".to_string()))\n                })\n                .or_else(|| {\n                    texts.get(&(entry.id.clone(), variant_str.to_string(), \"en\".to_string()))\n                })\n                // Fall back to no variant\n                .or_else(|| texts.get(&(entry.id.clone(), String::new(), language.to_string())))\n                .or_else(|| texts.get(&(entry.id.clone(), String::new(), \"de\".to_string())))\n                .or_else(|| texts.get(&(entry.id.clone(), String::new(), \"en\".to_string())))\n                .cloned()\n                .unwrap_or_else(|| entry.id.clone());\n\n            // Get series reference for articles\n            let series_ref = if entry.node_type == NodeType::Article {\n                articles.get(&entry.id).cloned()\n            } else {\n                None\n            };\n\n            let node = CatalogNode {\n                id: entry.id.clone(),\n                name,\n                node_type: entry.node_type,\n                depth: entry.depth,\n                series_ref,\n                variant_code: entry.variant_code.clone(),\n                children: Vec::new(),\n            };\n\n            // Find parent at correct depth\n            while stack.len() > 1\n                && stack\n                    .last()\n                    .map(|(d, _)| *d >= entry.depth)\n                    .unwrap_or(false)\n            {\n                stack.pop();\n            }\n\n            // Add to parent\n            if stack.is_empty() {\n                root.children.push(node);\n                stack.push((entry.depth, root.children.len() - 1));\n            } else {\n                // Navigate to the parent node\n                let mut current = &mut root;\n                for (_, idx) in stack.iter().skip(1) {\n                    current = &mut current.children[*idx];\n                }\n                current.children.push(node);\n                let new_idx = current.children.len() - 1;\n                stack.push((entry.depth, new_idx));\n            }\n        }\n\n        root\n    }\n}\n\n/// Catalog loader errors\n#[derive(Debug)]\npub enum CatalogError {\n    NotFound(PathBuf),\n    IoError(PathBuf, String),\n    ZipError(String),\n    ParseError(String),\n    MissingFile(String),\n}\n\nimpl std::fmt::Display for CatalogError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            CatalogError::NotFound(path) => write!(f, \"Catalog not found: {}\", path.display()),\n            CatalogError::IoError(path, msg) => {\n                write!(f, \"IO error reading {}: {}\", path.display(), msg)\n            }\n            CatalogError::ZipError(msg) => write!(f, \"ZIP error: {}\", msg),\n            CatalogError::ParseError(msg) => write!(f, \"Parse error: {}\", msg),\n            CatalogError::MissingFile(name) => write!(f, \"Missing required file: {}\", name),\n        }\n    }\n}\n\nimpl std::error::Error for CatalogError {}\n\n/// Catalog with metadata for sorting/selection\n#[derive(Debug)]\npub struct CatalogInfo {\n    /// Path to the catalog directory\n    pub path: PathBuf,\n    /// Whether this is a master catalog\n    pub is_master: bool,\n    /// Series/directory name\n    pub name: String,\n}\n\n/// Find all catalog directories for a manufacturer\npub fn find_manufacturer_catalogs(mfr_path: &Path) -> Vec<CatalogInfo> {\n    let mut catalogs = Vec::new();\n\n    // Check for master catalog at manufacturer level (e.g., bisley/catalog/)\n    let master_cat = mfr_path.join(\"catalog\");\n    if master_cat.exists() {\n        // Look for ANY/1/cat or DE/1/cat etc.\n        for region in std::fs::read_dir(&master_cat).into_iter().flatten().flatten() {\n            let region_path = region.path();\n            if region_path.is_dir() {\n                for version in std::fs::read_dir(&region_path).into_iter().flatten().flatten() {\n                    let cat_path = version.path().join(\"cat\");\n                    if cat_path.exists() {\n                        catalogs.push(CatalogInfo {\n                            path: cat_path,\n                            is_master: true,\n                            name: \"catalog\".to_string(),\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    // Check each series for catalogs\n    if let Ok(entries) = std::fs::read_dir(mfr_path) {\n        for entry in entries.flatten() {\n            let series_path = entry.path();\n            if series_path.is_dir() {\n                let series_name = series_path\n                    .file_name()\n                    .and_then(|n| n.to_str())\n                    .unwrap_or(\"\")\n                    .to_string();\n\n                // Skip non-series directories\n                if series_name == \"catalog\" || series_name.starts_with('.') {\n                    continue;\n                }\n\n                // Check if this is a master catalog (e.g., desks_m_cat, seating_m_cat)\n                let is_master = series_name.ends_with(\"_m_cat\");\n\n                // Look for cat directories in various locations\n                for region in [\"DE\", \"ANY\", \"EN\"] {\n                    for version in [\"1\", \"2\"] {\n                        let cat_path = series_path.join(region).join(version).join(\"cat\");\n                        if cat_path.exists() {\n                            let xcf_zip = cat_path.join(\"xcf.zip\");\n                            let structure_csv = cat_path.join(\"structure.csv\");\n                            if xcf_zip.exists() || structure_csv.exists() {\n                                catalogs.push(CatalogInfo {\n                                    path: cat_path,\n                                    is_master,\n                                    name: series_name.clone(),\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Sort: master catalogs first, then by name\n    catalogs.sort_by(|a, b| match (a.is_master, b.is_master) {\n        (true, false) => std::cmp::Ordering::Less,\n        (false, true) => std::cmp::Ordering::Greater,\n        _ => a.name.cmp(&b.name),\n    });\n\n    catalogs\n}\n\n/// Load the best available catalog for a manufacturer\n///\n/// Priority: master catalogs (catalog/, *_m_cat) > series catalogs\npub fn load_manufacturer_catalog(mfr_path: &Path, language: &str) -> Option<XcfCatalog> {\n    let catalogs = find_manufacturer_catalogs(mfr_path);\n\n    // Try master catalogs first (already sorted first)\n    for cat_info in &catalogs {\n        if cat_info.is_master {\n            if let Ok(catalog) = CatalogLoader::load(&cat_info.path, language) {\n                return Some(catalog);\n            }\n        }\n    }\n\n    // Fall back to first available series catalog\n    for cat_info in &catalogs {\n        if let Ok(catalog) = CatalogLoader::load(&cat_info.path, language) {\n            return Some(catalog);\n        }\n    }\n\n    None\n}\n\n/// Load only the master catalog for a manufacturer (no fallback to series catalogs)\n///\n/// Returns None if no master catalog exists (like Sedus which has per-series catalogs)\npub fn load_master_catalog(mfr_path: &Path, language: &str) -> Option<XcfCatalog> {\n    let catalogs = find_manufacturer_catalogs(mfr_path);\n\n    // Only try master catalogs\n    for cat_info in &catalogs {\n        if cat_info.is_master {\n            if let Ok(catalog) = CatalogLoader::load(&cat_info.path, language) {\n                return Some(catalog);\n            }\n        }\n    }\n\n    None\n}\n\n/// Check if a manufacturer has a master catalog\npub fn has_master_catalog(mfr_path: &Path) -> bool {\n    let catalogs = find_manufacturer_catalogs(mfr_path);\n    catalogs.iter().any(|c| c.is_master)\n}\n\n/// Load all available catalogs for a manufacturer\npub fn load_all_manufacturer_catalogs(\n    mfr_path: &Path,\n    language: &str,\n) -> Vec<(String, XcfCatalog)> {\n    let catalog_infos = find_manufacturer_catalogs(mfr_path);\n    let mut result = Vec::new();\n\n    for info in catalog_infos {\n        if info.is_master {\n            if let Ok(catalog) = CatalogLoader::load(&info.path, language) {\n                result.push((info.name, catalog));\n            }\n        }\n    }\n\n    result\n}\n\n// ============================================================================\n// Registry Parser - for manufacturer metadata and series display names\n// ============================================================================\n\n/// Parsed manufacturer registry information\n#[derive(Debug, Clone, Default)]\npub struct ManufacturerRegistry {\n    /// Manufacturer ID (e.g., \"sex\")\n    pub manufacturer: String,\n    /// Manufacturer ID code (e.g., \"SE\")\n    pub manufacturer_id: String,\n    /// Display name\n    pub manufacturer_name: String,\n    /// Series name mappings: series_id -> display_name\n    pub series_names: HashMap<String, String>,\n}\n\nimpl ManufacturerRegistry {\n    /// Load registry from a .cfg file (like SE.cfg)\n    pub fn load(path: &Path) -> Option<Self> {\n        let content = CatalogLoader::read_file_with_encoding(path).ok()?;\n        Self::parse(&content, \"de\")\n    }\n\n    /// Load registry with specific language\n    pub fn load_with_language(path: &Path, language: &str) -> Option<Self> {\n        let content = CatalogLoader::read_file_with_encoding(path).ok()?;\n        Self::parse(&content, language)\n    }\n\n    /// Parse registry content\n    fn parse(content: &str, language: &str) -> Option<Self> {\n        let mut registry = ManufacturerRegistry::default();\n        let mut current_section = String::new();\n        let mut lang_series_names: HashMap<String, String> = HashMap::new();\n\n        for line in content.lines() {\n            let line = line.trim();\n\n            // Skip comments and empty lines\n            if line.is_empty() || line.starts_with('#') {\n                continue;\n            }\n\n            // Section header\n            if line.starts_with('[') && line.ends_with(']') {\n                current_section = line[1..line.len() - 1].to_string();\n                continue;\n            }\n\n            // Key=Value pairs\n            if let Some((key, value)) = line.split_once('=') {\n                let key = key.trim();\n                let value = value.trim();\n\n                match current_section.as_str() {\n                    \"general\" => match key {\n                        \"manufacturer\" => registry.manufacturer = value.to_string(),\n                        \"manufacturer_id\" => registry.manufacturer_id = value.to_string(),\n                        \"manufacturer_name\" => {\n                            if registry.manufacturer_name.is_empty() {\n                                registry.manufacturer_name = value.to_string();\n                            }\n                        }\n                        _ if key.starts_with(\"series_name.\") => {\n                            if let Some(series_id) = key.strip_prefix(\"series_name.\") {\n                                registry\n                                    .series_names\n                                    .insert(series_id.to_lowercase(), value.to_string());\n                            }\n                        }\n                        _ => {}\n                    },\n                    section if section == language => {\n                        // Language-specific section overrides\n                        match key {\n                            \"manufacturer_name\" => {\n                                registry.manufacturer_name = value.to_string();\n                            }\n                            _ if key.starts_with(\"series_name.\") => {\n                                if let Some(series_id) = key.strip_prefix(\"series_name.\") {\n                                    lang_series_names\n                                        .insert(series_id.to_lowercase(), value.to_string());\n                                }\n                            }\n                            _ => {}\n                        }\n                    }\n                    _ => {}\n                }\n            }\n        }\n\n        // Override with language-specific names\n        for (k, v) in lang_series_names {\n            registry.series_names.insert(k, v);\n        }\n\n        if registry.manufacturer.is_empty() {\n            return None;\n        }\n\n        Some(registry)\n    }\n\n    /// Get display name for a series\n    pub fn get_series_name(&self, series_id: &str) -> Option<&str> {\n        self.series_names\n            .get(&series_id.to_lowercase())\n            .map(|s| s.as_str())\n    }\n}\n\n/// Find the manufacturer registry file\npub fn find_manufacturer_registry(data_path: &Path, manufacturer_id: &str) -> Option<PathBuf> {\n    let registry_dir = data_path.join(\"registry\");\n\n    // Try uppercase ID first (like SE.cfg for Sedus)\n    let uppercase_cfg = registry_dir.join(format!(\"{}.cfg\", manufacturer_id.to_uppercase()));\n    if uppercase_cfg.exists() {\n        return Some(uppercase_cfg);\n    }\n\n    // Try manufacturer code patterns\n    // Read from Manufacturers.ebase or iterate registry files\n    if let Ok(entries) = std::fs::read_dir(&registry_dir) {\n        for entry in entries.flatten() {\n            let path = entry.path();\n            if path.extension().is_some_and(|e| e == \"cfg\") {\n                if let Some(name) = path.file_stem().and_then(|n| n.to_str()) {\n                    // Skip series-specific configs (like sex_ai_DE_1.cfg)\n                    if name.contains('_') {\n                        continue;\n                    }\n                    // Check if this is a manufacturer registry\n                    if let Some(reg) = ManufacturerRegistry::load(&path) {\n                        if reg.manufacturer == manufacturer_id {\n                            return Some(path);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    None\n}\n\n/// Build an aggregated catalog from individual series catalogs\n///\n/// For manufacturers without a master catalog (like Sedus), this aggregates\n/// all series catalogs into a single virtual catalog using the registry\n/// for display names.\npub fn build_aggregated_catalog(\n    data_path: &Path,\n    mfr_path: &Path,\n    manufacturer_id: &str,\n    language: &str,\n) -> Option<XcfCatalog> {\n    // Load manufacturer registry for series names\n    let registry = find_manufacturer_registry(data_path, manufacturer_id)\n        .and_then(|p| ManufacturerRegistry::load_with_language(&p, language));\n\n    let catalog_infos = find_manufacturer_catalogs(mfr_path);\n\n    if catalog_infos.is_empty() {\n        return None;\n    }\n\n    // Build root node with series as children\n    let mut root = CatalogNode {\n        id: manufacturer_id.to_string(),\n        name: registry\n            .as_ref()\n            .map(|r| r.manufacturer_name.clone())\n            .unwrap_or_else(|| manufacturer_id.to_string()),\n        node_type: NodeType::Root,\n        depth: 0,\n        series_ref: None,\n        variant_code: None,\n        children: Vec::new(),\n    };\n\n    let mut texts: HashMap<(String, String, String), String> = HashMap::new();\n    let mut articles = HashMap::new();\n    let mut variants: HashMap<(String, String), VariantDefinition> = HashMap::new();\n\n    // Add each series as a top-level folder\n    for cat_info in &catalog_infos {\n        // Get display name from registry or catalog\n        let display_name = registry\n            .as_ref()\n            .and_then(|r| r.get_series_name(&cat_info.name).map(|s| s.to_string()))\n            .unwrap_or_else(|| cat_info.name.clone());\n\n        // Try to load the series catalog\n        if let Ok(series_catalog) = CatalogLoader::load(&cat_info.path, language) {\n            // If series catalog has meaningful content, use its structure\n            if !series_catalog.root.children.is_empty() {\n                // Check if the catalog has a single top-level folder with same/similar name\n                // If so, use that folder's children directly to avoid duplication like \"se:air > se:air\"\n                let effective_children = if series_catalog.root.children.len() == 1 {\n                    let first_child = &series_catalog.root.children[0];\n                    if first_child.node_type == NodeType::Folder\n                        && (first_child.name.to_lowercase() == display_name.to_lowercase()\n                            || first_child\n                                .name\n                                .to_lowercase()\n                                .contains(&cat_info.name.to_lowercase()))\n                    {\n                        // Skip the intermediate folder, use its children\n                        first_child.children.clone()\n                    } else {\n                        series_catalog.root.children.clone()\n                    }\n                } else {\n                    series_catalog.root.children.clone()\n                };\n\n                let mut series_node = CatalogNode {\n                    id: cat_info.name.clone(),\n                    name: display_name.clone(),\n                    node_type: NodeType::Folder,\n                    depth: 1,\n                    series_ref: Some(cat_info.name.clone()),\n                    variant_code: None,\n                    children: effective_children,\n                };\n\n                // Adjust depth of children\n                adjust_depths(&mut series_node, 1);\n\n                root.children.push(series_node);\n\n                // Merge texts, articles, and variants\n                for ((node_id, variant, lang), text) in series_catalog.texts {\n                    texts.insert((node_id, variant, lang), text);\n                }\n                for (article_id, series) in series_catalog.articles {\n                    articles.insert(article_id, series);\n                }\n                for (key, variant_def) in series_catalog.variants {\n                    variants.insert(key, variant_def);\n                }\n            }\n        } else {\n            // No catalog content, just add as empty folder\n            root.children.push(CatalogNode {\n                id: cat_info.name.clone(),\n                name: display_name,\n                node_type: NodeType::Folder,\n                depth: 1,\n                series_ref: Some(cat_info.name.clone()),\n                variant_code: None,\n                children: Vec::new(),\n            });\n        }\n    }\n\n    // Sort children by display name\n    root.children.sort_by(|a, b| a.name.cmp(&b.name));\n\n    Some(XcfCatalog {\n        root,\n        texts,\n        articles,\n        variants,\n        source_path: mfr_path.to_path_buf(),\n    })\n}\n\n/// Adjust node depths recursively\nfn adjust_depths(node: &mut CatalogNode, parent_depth: u8) {\n    node.depth = parent_depth + 1;\n    for child in &mut node.children {\n        adjust_depths(child, node.depth);\n    }\n}\n\n/// Smart catalog loader - returns master catalog if available, otherwise aggregated\npub fn load_smart_catalog(\n    data_path: &Path,\n    mfr_path: &Path,\n    manufacturer_id: &str,\n    language: &str,\n) -> Option<XcfCatalog> {\n    // First, try to load master catalog\n    if let Some(catalog) = load_master_catalog(mfr_path, language) {\n        return Some(catalog);\n    }\n\n    // Fall back to aggregated catalog from series + registry\n    build_aggregated_catalog(data_path, mfr_path, manufacturer_id, language)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_csv_line() {\n        let line = r#\"\"@FOLDER123\";default;1;F;\"#;\n        let fields = CatalogLoader::parse_csv_line(line);\n        // Trailing semicolon may or may not add empty field - we care about actual data fields\n        assert!(fields.len() >= 4);\n        assert_eq!(fields[0], \"\\\"@FOLDER123\\\"\");\n        assert_eq!(fields[2], \"1\");\n        assert_eq!(fields[3], \"F\");\n\n        // Test without trailing semicolon\n        let line2 = r#\"\"@FOLDER456\";default;2;A\"#;\n        let fields2 = CatalogLoader::parse_csv_line(line2);\n        assert_eq!(fields2.len(), 4);\n        assert_eq!(fields2[0], \"\\\"@FOLDER456\\\"\");\n        assert_eq!(fields2[3], \"A\");\n    }\n\n    #[test]\n    fn test_parse_structure_csv() {\n        let content = r#\"\n\"@FOLDER1\";default;1;F;\n\"@FOLDER2\";default;2;F;\n\"ARTICLE1\";default;3;A;\n\"#;\n        let entries = CatalogLoader::parse_structure_csv(content).unwrap();\n        assert_eq!(entries.len(), 3);\n        assert_eq!(entries[0].id, \"@FOLDER1\");\n        assert_eq!(entries[0].depth, 1);\n        assert_eq!(entries[0].node_type, NodeType::Folder);\n        assert_eq!(entries[2].node_type, NodeType::Article);\n    }\n\n    #[test]\n    fn test_parse_text_csv() {\n        let content = r#\"\n\"@FOLDER1\";default;de;\"Kategorie Eins\"\n\"@FOLDER1\";default;en;\"Category One\"\n\"@FOLDER2\";default;de;\"Unterkategorie\"\n\"#;\n        let texts = CatalogLoader::parse_text_csv(content).unwrap();\n        assert_eq!(texts.len(), 3);\n        // \"default\" is normalized to empty string\n        assert_eq!(\n            texts.get(&(\"@FOLDER1\".to_string(), String::new(), \"de\".to_string())),\n            Some(&\"Kategorie Eins\".to_string())\n        );\n        assert_eq!(\n            texts.get(&(\"@FOLDER1\".to_string(), String::new(), \"en\".to_string())),\n            Some(&\"Category One\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_build_tree() {\n        let entries = vec![\n            StructureEntry {\n                id: \"@FOLDER1\".to_string(),\n                variant_code: None,\n                depth: 1,\n                node_type: NodeType::Folder,\n            },\n            StructureEntry {\n                id: \"@FOLDER2\".to_string(),\n                variant_code: None,\n                depth: 2,\n                node_type: NodeType::Folder,\n            },\n            StructureEntry {\n                id: \"ART1\".to_string(),\n                variant_code: None,\n                depth: 3,\n                node_type: NodeType::Article,\n            },\n            StructureEntry {\n                id: \"@FOLDER3\".to_string(),\n                variant_code: None,\n                depth: 1,\n                node_type: NodeType::Folder,\n            },\n        ];\n        let mut texts = HashMap::new();\n        texts.insert(\n            (\"@FOLDER1\".to_string(), String::new(), \"de\".to_string()),\n            \"Hauptkategorie\".to_string(),\n        );\n        texts.insert(\n            (\"@FOLDER2\".to_string(), String::new(), \"de\".to_string()),\n            \"Unterkategorie\".to_string(),\n        );\n\n        let root = CatalogLoader::build_tree(&entries, &texts, &HashMap::new(), \"de\");\n\n        assert_eq!(root.children.len(), 2); // Two top-level folders\n        assert_eq!(root.children[0].name, \"Hauptkategorie\");\n        assert_eq!(root.children[0].children.len(), 1); // One child\n        assert_eq!(root.children[0].children[0].name, \"Unterkategorie\");\n        assert_eq!(root.children[0].children[0].children.len(), 1); // One article\n    }\n\n    #[test]\n    fn test_load_bisley_catalog() {\n        let path = Path::new(\"/reference/ofmldata/bisley/catalog/ANY/1/cat\");\n        if !path.exists() {\n            println!(\"Bisley catalog not found, skipping test\");\n            return;\n        }\n\n        let catalog = CatalogLoader::load(path, \"de\").expect(\"Should load catalog\");\n        let stats = catalog.stats();\n\n        println!(\"\\n=== Bisley Catalog Stats ===\");\n        println!(\"Total nodes: {}\", stats.total_nodes);\n        println!(\"Folders: {}\", stats.folder_count);\n        println!(\"Articles: {}\", stats.article_count);\n        println!(\"Languages: {:?}\", stats.languages);\n\n        // Print top-level categories\n        println!(\"\\nTop-level categories:\");\n        for child in &catalog.root.children {\n            println!(\n                \"  {} - {} ({} children)\",\n                child.id,\n                child.name,\n                child.children.len()\n            );\n        }\n\n        assert!(stats.folder_count > 0);\n    }\n\n    #[test]\n    fn test_load_kn_catalog() {\n        let path = Path::new(\"/reference/ofmldata/kn/desks_m_cat/DE/2/cat\");\n        if !path.exists() {\n            println!(\"K+N catalog not found, skipping test\");\n            return;\n        }\n\n        let catalog = CatalogLoader::load(path, \"de\").expect(\"Should load catalog\");\n        let stats = catalog.stats();\n\n        println!(\"\\n=== K√∂nig+Neurath Catalog Stats ===\");\n        println!(\"Total nodes: {}\", stats.total_nodes);\n        println!(\"Folders: {}\", stats.folder_count);\n        println!(\"Articles: {}\", stats.article_count);\n\n        // Print structure\n        println!(\"\\nCatalog structure:\");\n        fn print_tree(node: &CatalogNode, indent: usize) {\n            let prefix = \"  \".repeat(indent);\n            let type_char = match node.node_type {\n                NodeType::Folder => \"üìÅ\",\n                NodeType::Article => \"üìÑ\",\n                NodeType::Root => \"üè†\",\n            };\n            println!(\"{}{} {}\", prefix, type_char, node.name);\n            for child in node.children.iter().take(3) {\n                print_tree(child, indent + 1);\n            }\n            if node.children.len() > 3 {\n                println!(\"{}  ... and {} more\", prefix, node.children.len() - 3);\n            }\n        }\n        print_tree(&catalog.root, 0);\n    }\n\n    #[test]\n    fn test_find_manufacturer_catalogs() {\n        let bisley_path = Path::new(\"/reference/ofmldata/bisley\");\n        if !bisley_path.exists() {\n            println!(\"Bisley not found, skipping\");\n            return;\n        }\n\n        let catalogs = find_manufacturer_catalogs(bisley_path);\n        println!(\"\\nFound {} catalogs for Bisley:\", catalogs.len());\n        for cat in &catalogs {\n            println!(\n                \"  {} (master: {}) -> {}\",\n                cat.name,\n                cat.is_master,\n                cat.path.display()\n            );\n        }\n\n        assert!(!catalogs.is_empty());\n        // Master catalog should be first\n        assert!(catalogs[0].is_master, \"First catalog should be master\");\n    }\n\n    #[test]\n    fn test_find_kn_master_catalogs() {\n        let kn_path = Path::new(\"/reference/ofmldata/kn\");\n        if !kn_path.exists() {\n            println!(\"K+N not found, skipping\");\n            return;\n        }\n\n        let catalogs = find_manufacturer_catalogs(kn_path);\n        let master_catalogs: Vec<_> = catalogs.iter().filter(|c| c.is_master).collect();\n\n        println!(\"\\nFound {} master catalogs for K+N:\", master_catalogs.len());\n        for cat in &master_catalogs {\n            println!(\"  {} -> {}\", cat.name, cat.path.display());\n        }\n\n        // Should find desks_m_cat, konferenz_m_cat, seating_m_cat\n        assert!(\n            master_catalogs.len() >= 3,\n            \"K+N should have at least 3 master catalogs\"\n        );\n\n        // Master catalogs should be first in the list\n        assert!(catalogs[0].is_master, \"First catalog should be master\");\n    }\n\n    #[test]\n    fn test_load_sedus_registry() {\n        let data_path = Path::new(\"/reference/ofmldata\");\n        if !data_path.exists() {\n            println!(\"OFML data not found, skipping\");\n            return;\n        }\n\n        let reg_path = find_manufacturer_registry(data_path, \"sex\");\n        assert!(reg_path.is_some(), \"Should find Sedus registry\");\n\n        let reg = ManufacturerRegistry::load_with_language(&reg_path.unwrap(), \"de\");\n        assert!(reg.is_some(), \"Should parse Sedus registry\");\n\n        let reg = reg.unwrap();\n        println!(\"\\nSedus Registry:\");\n        println!(\n            \"  Manufacturer: {} ({})\",\n            reg.manufacturer_name, reg.manufacturer_id\n        );\n        println!(\"  Series names: {}\", reg.series_names.len());\n\n        // Check some known series names\n        assert_eq!(reg.get_series_name(\"ai\"), Some(\"se:air\"));\n        assert_eq!(reg.get_series_name(\"qb\"), Some(\"quarterback\"));\n        assert!(reg.series_names.len() > 30, \"Sedus should have many series\");\n    }\n\n    #[test]\n    fn test_build_sedus_aggregated_catalog() {\n        let data_path = Path::new(\"/reference/ofmldata\");\n        let mfr_path = data_path.join(\"sex\");\n        if !mfr_path.exists() {\n            println!(\"Sedus data not found, skipping\");\n            return;\n        }\n\n        let catalog = load_smart_catalog(data_path, &mfr_path, \"sex\", \"de\");\n        assert!(\n            catalog.is_some(),\n            \"Should build aggregated catalog for Sedus\"\n        );\n\n        let catalog = catalog.unwrap();\n        let stats = catalog.stats();\n        println!(\"\\nSedus Aggregated Catalog:\");\n        println!(\"  Categories: {}\", stats.folder_count);\n        println!(\"  Articles: {}\", stats.article_count);\n        println!(\"  Top-level entries: {}\", catalog.root.children.len());\n\n        // Should have many series as top-level entries\n        assert!(\n            catalog.root.children.len() > 20,\n            \"Sedus should have many series\"\n        );\n\n        // Check that series names are resolved\n        let has_se_air = catalog.root.children.iter().any(|c| c.name == \"se:air\");\n        let has_quarterback = catalog\n            .root\n            .children\n            .iter()\n            .any(|c| c.name == \"quarterback\");\n        assert!(has_se_air, \"Should have se:air series with display name\");\n        assert!(\n            has_quarterback,\n            \"Should have quarterback series with display name\"\n        );\n\n        println!(\"\\nFirst 10 series:\");\n        for child in catalog.root.children.iter().take(10) {\n            println!(\"  {} -> {}\", child.id, child.name);\n        }\n    }\n}\n","traces":[{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":46}},{"line":104,"address":[],"length":0,"stats":{"Line":138}},{"line":105,"address":[],"length":0,"stats":{"Line":138}},{"line":110,"address":[],"length":0,"stats":{"Line":46}},{"line":115,"address":[],"length":0,"stats":{"Line":4188}},{"line":116,"address":[],"length":0,"stats":{"Line":20934}},{"line":120,"address":[],"length":0,"stats":{"Line":4188}},{"line":121,"address":[],"length":0,"stats":{"Line":8376}},{"line":122,"address":[],"length":0,"stats":{"Line":867}},{"line":124,"address":[],"length":0,"stats":{"Line":3321}},{"line":126,"address":[],"length":0,"stats":{"Line":4188}},{"line":127,"address":[],"length":0,"stats":{"Line":4188}},{"line":128,"address":[],"length":0,"stats":{"Line":4188}},{"line":129,"address":[],"length":0,"stats":{"Line":4188}},{"line":130,"address":[],"length":0,"stats":{"Line":12558}},{"line":131,"address":[],"length":0,"stats":{"Line":4188}},{"line":135,"address":[],"length":0,"stats":{"Line":4188}},{"line":136,"address":[],"length":0,"stats":{"Line":8376}},{"line":137,"address":[],"length":0,"stats":{"Line":3318}},{"line":139,"address":[],"length":0,"stats":{"Line":870}},{"line":141,"address":[],"length":0,"stats":{"Line":4188}},{"line":142,"address":[],"length":0,"stats":{"Line":4188}},{"line":143,"address":[],"length":0,"stats":{"Line":4188}},{"line":144,"address":[],"length":0,"stats":{"Line":4188}},{"line":145,"address":[],"length":0,"stats":{"Line":12558}},{"line":146,"address":[],"length":0,"stats":{"Line":4188}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":3}},{"line":256,"address":[],"length":0,"stats":{"Line":57956}},{"line":257,"address":[],"length":0,"stats":{"Line":3}},{"line":258,"address":[],"length":0,"stats":{"Line":6}},{"line":259,"address":[],"length":0,"stats":{"Line":3}},{"line":263,"address":[],"length":0,"stats":{"Line":3}},{"line":265,"address":[],"length":0,"stats":{"Line":9}},{"line":266,"address":[],"length":0,"stats":{"Line":9}},{"line":267,"address":[],"length":0,"stats":{"Line":9}},{"line":268,"address":[],"length":0,"stats":{"Line":9}},{"line":269,"address":[],"length":0,"stats":{"Line":3}},{"line":294,"address":[],"length":0,"stats":{"Line":46}},{"line":296,"address":[],"length":0,"stats":{"Line":138}},{"line":297,"address":[],"length":0,"stats":{"Line":46}},{"line":298,"address":[],"length":0,"stats":{"Line":135}},{"line":302,"address":[],"length":0,"stats":{"Line":4}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":3}},{"line":308,"address":[],"length":0,"stats":{"Line":1}},{"line":309,"address":[],"length":0,"stats":{"Line":3}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":1}},{"line":330,"address":[],"length":0,"stats":{"Line":3}},{"line":331,"address":[],"length":0,"stats":{"Line":3}},{"line":332,"address":[],"length":0,"stats":{"Line":3}},{"line":333,"address":[],"length":0,"stats":{"Line":3}},{"line":336,"address":[],"length":0,"stats":{"Line":3}},{"line":337,"address":[],"length":0,"stats":{"Line":3}},{"line":340,"address":[],"length":0,"stats":{"Line":2}},{"line":341,"address":[],"length":0,"stats":{"Line":3}},{"line":342,"address":[],"length":0,"stats":{"Line":2}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":2}},{"line":349,"address":[],"length":0,"stats":{"Line":3}},{"line":350,"address":[],"length":0,"stats":{"Line":2}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":2}},{"line":357,"address":[],"length":0,"stats":{"Line":3}},{"line":358,"address":[],"length":0,"stats":{"Line":2}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":6}},{"line":366,"address":[],"length":0,"stats":{"Line":1}},{"line":367,"address":[],"length":0,"stats":{"Line":2}},{"line":368,"address":[],"length":0,"stats":{"Line":2}},{"line":369,"address":[],"length":0,"stats":{"Line":2}},{"line":370,"address":[],"length":0,"stats":{"Line":2}},{"line":371,"address":[],"length":0,"stats":{"Line":1}},{"line":376,"address":[],"length":0,"stats":{"Line":26}},{"line":377,"address":[],"length":0,"stats":{"Line":78}},{"line":378,"address":[],"length":0,"stats":{"Line":26}},{"line":381,"address":[],"length":0,"stats":{"Line":63}},{"line":382,"address":[],"length":0,"stats":{"Line":11}},{"line":386,"address":[],"length":0,"stats":{"Line":60}},{"line":387,"address":[],"length":0,"stats":{"Line":15}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":15}},{"line":398,"address":[],"length":0,"stats":{"Line":45}},{"line":399,"address":[],"length":0,"stats":{"Line":135}},{"line":400,"address":[],"length":0,"stats":{"Line":45}},{"line":401,"address":[],"length":0,"stats":{"Line":45}},{"line":402,"address":[],"length":0,"stats":{"Line":135}},{"line":404,"address":[],"length":0,"stats":{"Line":90}},{"line":405,"address":[],"length":0,"stats":{"Line":90}},{"line":406,"address":[],"length":0,"stats":{"Line":90}},{"line":407,"address":[],"length":0,"stats":{"Line":90}},{"line":410,"address":[],"length":0,"stats":{"Line":292}},{"line":411,"address":[],"length":0,"stats":{"Line":404}},{"line":412,"address":[],"length":0,"stats":{"Line":404}},{"line":413,"address":[],"length":0,"stats":{"Line":202}},{"line":414,"address":[],"length":0,"stats":{"Line":606}},{"line":416,"address":[],"length":0,"stats":{"Line":202}},{"line":417,"address":[],"length":0,"stats":{"Line":135}},{"line":418,"address":[],"length":0,"stats":{"Line":45}},{"line":419,"address":[],"length":0,"stats":{"Line":157}},{"line":420,"address":[],"length":0,"stats":{"Line":135}},{"line":421,"address":[],"length":0,"stats":{"Line":45}},{"line":422,"address":[],"length":0,"stats":{"Line":112}},{"line":423,"address":[],"length":0,"stats":{"Line":135}},{"line":424,"address":[],"length":0,"stats":{"Line":45}},{"line":425,"address":[],"length":0,"stats":{"Line":67}},{"line":426,"address":[],"length":0,"stats":{"Line":66}},{"line":427,"address":[],"length":0,"stats":{"Line":22}},{"line":431,"address":[],"length":0,"stats":{"Line":90}},{"line":432,"address":[],"length":0,"stats":{"Line":1}},{"line":436,"address":[],"length":0,"stats":{"Line":132}},{"line":437,"address":[],"length":0,"stats":{"Line":132}},{"line":438,"address":[],"length":0,"stats":{"Line":132}},{"line":439,"address":[],"length":0,"stats":{"Line":132}},{"line":441,"address":[],"length":0,"stats":{"Line":132}},{"line":442,"address":[],"length":0,"stats":{"Line":88}},{"line":443,"address":[],"length":0,"stats":{"Line":88}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":88}},{"line":448,"address":[],"length":0,"stats":{"Line":88}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":88}},{"line":453,"address":[],"length":0,"stats":{"Line":44}},{"line":455,"address":[],"length":0,"stats":{"Line":22}},{"line":458,"address":[],"length":0,"stats":{"Line":264}},{"line":460,"address":[],"length":0,"stats":{"Line":44}},{"line":461,"address":[],"length":0,"stats":{"Line":88}},{"line":462,"address":[],"length":0,"stats":{"Line":88}},{"line":463,"address":[],"length":0,"stats":{"Line":88}},{"line":464,"address":[],"length":0,"stats":{"Line":88}},{"line":465,"address":[],"length":0,"stats":{"Line":44}},{"line":470,"address":[],"length":0,"stats":{"Line":176}},{"line":472,"address":[],"length":0,"stats":{"Line":486}},{"line":473,"address":[],"length":0,"stats":{"Line":134}},{"line":476,"address":[],"length":0,"stats":{"Line":126}},{"line":477,"address":[],"length":0,"stats":{"Line":84}},{"line":482,"address":[],"length":0,"stats":{"Line":46}},{"line":483,"address":[],"length":0,"stats":{"Line":92}},{"line":485,"address":[],"length":0,"stats":{"Line":4278}},{"line":486,"address":[],"length":0,"stats":{"Line":12558}},{"line":487,"address":[],"length":0,"stats":{"Line":16742}},{"line":488,"address":[],"length":0,"stats":{"Line":1}},{"line":491,"address":[],"length":0,"stats":{"Line":16740}},{"line":492,"address":[],"length":0,"stats":{"Line":4185}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":12555}},{"line":497,"address":[],"length":0,"stats":{"Line":12555}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":12555}},{"line":503,"address":[],"length":0,"stats":{"Line":16740}},{"line":504,"address":[],"length":0,"stats":{"Line":4065}},{"line":506,"address":[],"length":0,"stats":{"Line":120}},{"line":509,"address":[],"length":0,"stats":{"Line":20925}},{"line":510,"address":[],"length":0,"stats":{"Line":12555}},{"line":511,"address":[],"length":0,"stats":{"Line":8370}},{"line":512,"address":[],"length":0,"stats":{"Line":4715}},{"line":513,"address":[],"length":0,"stats":{"Line":6974}},{"line":514,"address":[],"length":0,"stats":{"Line":336}},{"line":517,"address":[],"length":0,"stats":{"Line":12555}},{"line":518,"address":[],"length":0,"stats":{"Line":8370}},{"line":519,"address":[],"length":0,"stats":{"Line":8370}},{"line":520,"address":[],"length":0,"stats":{"Line":4185}},{"line":521,"address":[],"length":0,"stats":{"Line":4185}},{"line":525,"address":[],"length":0,"stats":{"Line":46}},{"line":530,"address":[],"length":0,"stats":{"Line":46}},{"line":533,"address":[],"length":0,"stats":{"Line":92}},{"line":535,"address":[],"length":0,"stats":{"Line":31170}},{"line":536,"address":[],"length":0,"stats":{"Line":93234}},{"line":537,"address":[],"length":0,"stats":{"Line":124310}},{"line":538,"address":[],"length":0,"stats":{"Line":1}},{"line":541,"address":[],"length":0,"stats":{"Line":124308}},{"line":542,"address":[],"length":0,"stats":{"Line":31077}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":93231}},{"line":547,"address":[],"length":0,"stats":{"Line":93231}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":93231}},{"line":553,"address":[],"length":0,"stats":{"Line":62154}},{"line":554,"address":[],"length":0,"stats":{"Line":30167}},{"line":556,"address":[],"length":0,"stats":{"Line":1820}},{"line":559,"address":[],"length":0,"stats":{"Line":93231}},{"line":560,"address":[],"length":0,"stats":{"Line":93231}},{"line":562,"address":[],"length":0,"stats":{"Line":93231}},{"line":563,"address":[],"length":0,"stats":{"Line":124308}},{"line":567,"address":[],"length":0,"stats":{"Line":46}},{"line":572,"address":[],"length":0,"stats":{"Line":23}},{"line":575,"address":[],"length":0,"stats":{"Line":46}},{"line":577,"address":[],"length":0,"stats":{"Line":213}},{"line":578,"address":[],"length":0,"stats":{"Line":501}},{"line":579,"address":[],"length":0,"stats":{"Line":668}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":668}},{"line":584,"address":[],"length":0,"stats":{"Line":167}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":501}},{"line":589,"address":[],"length":0,"stats":{"Line":501}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":501}},{"line":594,"address":[],"length":0,"stats":{"Line":501}},{"line":597,"address":[],"length":0,"stats":{"Line":501}},{"line":599,"address":[],"length":0,"stats":{"Line":731}},{"line":600,"address":[],"length":0,"stats":{"Line":731}},{"line":603,"address":[],"length":0,"stats":{"Line":334}},{"line":604,"address":[],"length":0,"stats":{"Line":501}},{"line":605,"address":[],"length":0,"stats":{"Line":167}},{"line":606,"address":[],"length":0,"stats":{"Line":334}},{"line":607,"address":[],"length":0,"stats":{"Line":167}},{"line":608,"address":[],"length":0,"stats":{"Line":167}},{"line":613,"address":[],"length":0,"stats":{"Line":23}},{"line":618,"address":[],"length":0,"stats":{"Line":45}},{"line":619,"address":[],"length":0,"stats":{"Line":90}},{"line":621,"address":[],"length":0,"stats":{"Line":8157}},{"line":622,"address":[],"length":0,"stats":{"Line":24201}},{"line":623,"address":[],"length":0,"stats":{"Line":32268}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":32268}},{"line":628,"address":[],"length":0,"stats":{"Line":8067}},{"line":629,"address":[],"length":0,"stats":{"Line":1378}},{"line":632,"address":[],"length":0,"stats":{"Line":20067}},{"line":633,"address":[],"length":0,"stats":{"Line":26756}},{"line":634,"address":[],"length":0,"stats":{"Line":2}},{"line":637,"address":[],"length":0,"stats":{"Line":20061}},{"line":638,"address":[],"length":0,"stats":{"Line":13374}},{"line":639,"address":[],"length":0,"stats":{"Line":20061}},{"line":643,"address":[],"length":0,"stats":{"Line":45}},{"line":647,"address":[],"length":0,"stats":{"Line":43498}},{"line":648,"address":[],"length":0,"stats":{"Line":86996}},{"line":649,"address":[],"length":0,"stats":{"Line":86996}},{"line":650,"address":[],"length":0,"stats":{"Line":86996}},{"line":652,"address":[],"length":0,"stats":{"Line":4281706}},{"line":653,"address":[],"length":0,"stats":{"Line":158829}},{"line":654,"address":[],"length":0,"stats":{"Line":144644}},{"line":655,"address":[],"length":0,"stats":{"Line":317428}},{"line":656,"address":[],"length":0,"stats":{"Line":634856}},{"line":657,"address":[],"length":0,"stats":{"Line":158714}},{"line":659,"address":[],"length":0,"stats":{"Line":1793997}},{"line":663,"address":[],"length":0,"stats":{"Line":124930}},{"line":664,"address":[],"length":0,"stats":{"Line":113802}},{"line":667,"address":[],"length":0,"stats":{"Line":43498}},{"line":671,"address":[],"length":0,"stats":{"Line":46}},{"line":677,"address":[],"length":0,"stats":{"Line":92}},{"line":678,"address":[],"length":0,"stats":{"Line":184}},{"line":680,"address":[],"length":0,"stats":{"Line":8418}},{"line":682,"address":[],"length":0,"stats":{"Line":20930}},{"line":685,"address":[],"length":0,"stats":{"Line":8372}},{"line":686,"address":[],"length":0,"stats":{"Line":8372}},{"line":687,"address":[],"length":0,"stats":{"Line":12558}},{"line":688,"address":[],"length":0,"stats":{"Line":12558}},{"line":689,"address":[],"length":0,"stats":{"Line":4186}},{"line":691,"address":[],"length":0,"stats":{"Line":4188}},{"line":692,"address":[],"length":0,"stats":{"Line":14}},{"line":694,"address":[],"length":0,"stats":{"Line":4188}},{"line":695,"address":[],"length":0,"stats":{"Line":14}},{"line":698,"address":[],"length":0,"stats":{"Line":4198}},{"line":699,"address":[],"length":0,"stats":{"Line":4198}},{"line":700,"address":[],"length":0,"stats":{"Line":4198}},{"line":702,"address":[],"length":0,"stats":{"Line":4190}},{"line":705,"address":[],"length":0,"stats":{"Line":8372}},{"line":706,"address":[],"length":0,"stats":{"Line":13276}},{"line":708,"address":[],"length":0,"stats":{"Line":867}},{"line":712,"address":[],"length":0,"stats":{"Line":12558}},{"line":714,"address":[],"length":0,"stats":{"Line":8372}},{"line":715,"address":[],"length":0,"stats":{"Line":8372}},{"line":717,"address":[],"length":0,"stats":{"Line":8372}},{"line":718,"address":[],"length":0,"stats":{"Line":4186}},{"line":722,"address":[],"length":0,"stats":{"Line":8246}},{"line":723,"address":[],"length":0,"stats":{"Line":8175}},{"line":724,"address":[],"length":0,"stats":{"Line":8175}},{"line":725,"address":[],"length":0,"stats":{"Line":24525}},{"line":726,"address":[],"length":0,"stats":{"Line":8175}},{"line":728,"address":[],"length":0,"stats":{"Line":4060}},{"line":732,"address":[],"length":0,"stats":{"Line":8372}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":8372}},{"line":738,"address":[],"length":0,"stats":{"Line":31156}},{"line":739,"address":[],"length":0,"stats":{"Line":11392}},{"line":741,"address":[],"length":0,"stats":{"Line":12558}},{"line":742,"address":[],"length":0,"stats":{"Line":8372}},{"line":743,"address":[],"length":0,"stats":{"Line":12558}},{"line":747,"address":[],"length":0,"stats":{"Line":46}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":4}},{"line":790,"address":[],"length":0,"stats":{"Line":8}},{"line":793,"address":[],"length":0,"stats":{"Line":12}},{"line":794,"address":[],"length":0,"stats":{"Line":4}},{"line":796,"address":[],"length":0,"stats":{"Line":6}},{"line":797,"address":[],"length":0,"stats":{"Line":3}},{"line":798,"address":[],"length":0,"stats":{"Line":1}},{"line":799,"address":[],"length":0,"stats":{"Line":6}},{"line":800,"address":[],"length":0,"stats":{"Line":2}},{"line":801,"address":[],"length":0,"stats":{"Line":2}},{"line":802,"address":[],"length":0,"stats":{"Line":3}},{"line":803,"address":[],"length":0,"stats":{"Line":2}},{"line":804,"address":[],"length":0,"stats":{"Line":1}},{"line":805,"address":[],"length":0,"stats":{"Line":1}},{"line":814,"address":[],"length":0,"stats":{"Line":8}},{"line":815,"address":[],"length":0,"stats":{"Line":235}},{"line":816,"address":[],"length":0,"stats":{"Line":681}},{"line":817,"address":[],"length":0,"stats":{"Line":227}},{"line":818,"address":[],"length":0,"stats":{"Line":450}},{"line":820,"address":[],"length":0,"stats":{"Line":675}},{"line":825,"address":[],"length":0,"stats":{"Line":449}},{"line":826,"address":[],"length":0,"stats":{"Line":1}},{"line":830,"address":[],"length":0,"stats":{"Line":448}},{"line":833,"address":[],"length":0,"stats":{"Line":1120}},{"line":834,"address":[],"length":0,"stats":{"Line":2016}},{"line":835,"address":[],"length":0,"stats":{"Line":5376}},{"line":836,"address":[],"length":0,"stats":{"Line":1344}},{"line":837,"address":[],"length":0,"stats":{"Line":298}},{"line":838,"address":[],"length":0,"stats":{"Line":298}},{"line":839,"address":[],"length":0,"stats":{"Line":335}},{"line":840,"address":[],"length":0,"stats":{"Line":447}},{"line":841,"address":[],"length":0,"stats":{"Line":298}},{"line":842,"address":[],"length":0,"stats":{"Line":298}},{"line":843,"address":[],"length":0,"stats":{"Line":149}},{"line":854,"address":[],"length":0,"stats":{"Line":918}},{"line":855,"address":[],"length":0,"stats":{"Line":27}},{"line":856,"address":[],"length":0,"stats":{"Line":24}},{"line":857,"address":[],"length":0,"stats":{"Line":2577}},{"line":860,"address":[],"length":0,"stats":{"Line":4}},{"line":866,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":879,"address":[],"length":0,"stats":{"Line":0}},{"line":880,"address":[],"length":0,"stats":{"Line":0}},{"line":881,"address":[],"length":0,"stats":{"Line":0}},{"line":885,"address":[],"length":0,"stats":{"Line":0}},{"line":891,"address":[],"length":0,"stats":{"Line":1}},{"line":892,"address":[],"length":0,"stats":{"Line":3}},{"line":895,"address":[],"length":0,"stats":{"Line":89}},{"line":896,"address":[],"length":0,"stats":{"Line":44}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":1}},{"line":907,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":920,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[],"length":0,"stats":{"Line":0}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":923,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":20}},{"line":951,"address":[],"length":0,"stats":{"Line":80}},{"line":952,"address":[],"length":0,"stats":{"Line":60}},{"line":956,"address":[],"length":0,"stats":{"Line":2}},{"line":957,"address":[],"length":0,"stats":{"Line":8}},{"line":958,"address":[],"length":0,"stats":{"Line":6}},{"line":962,"address":[],"length":0,"stats":{"Line":22}},{"line":963,"address":[],"length":0,"stats":{"Line":44}},{"line":964,"address":[],"length":0,"stats":{"Line":44}},{"line":965,"address":[],"length":0,"stats":{"Line":66}},{"line":967,"address":[],"length":0,"stats":{"Line":7276}},{"line":968,"address":[],"length":0,"stats":{"Line":21696}},{"line":971,"address":[],"length":0,"stats":{"Line":28532}},{"line":972,"address":[],"length":0,"stats":{"Line":326}},{"line":976,"address":[],"length":0,"stats":{"Line":14024}},{"line":977,"address":[],"length":0,"stats":{"Line":424}},{"line":978,"address":[],"length":0,"stats":{"Line":106}},{"line":982,"address":[],"length":0,"stats":{"Line":20400}},{"line":983,"address":[],"length":0,"stats":{"Line":20400}},{"line":984,"address":[],"length":0,"stats":{"Line":20400}},{"line":986,"address":[],"length":0,"stats":{"Line":13600}},{"line":987,"address":[],"length":0,"stats":{"Line":8064}},{"line":988,"address":[],"length":0,"stats":{"Line":1338}},{"line":989,"address":[],"length":0,"stats":{"Line":1324}},{"line":990,"address":[],"length":0,"stats":{"Line":1282}},{"line":991,"address":[],"length":0,"stats":{"Line":54}},{"line":992,"address":[],"length":0,"stats":{"Line":36}},{"line":995,"address":[],"length":0,"stats":{"Line":3582}},{"line":996,"address":[],"length":0,"stats":{"Line":3162}},{"line":997,"address":[],"length":0,"stats":{"Line":2108}},{"line":998,"address":[],"length":0,"stats":{"Line":2108}},{"line":999,"address":[],"length":0,"stats":{"Line":4216}},{"line":1002,"address":[],"length":0,"stats":{"Line":210}},{"line":1004,"address":[],"length":0,"stats":{"Line":7562}},{"line":1006,"address":[],"length":0,"stats":{"Line":1024}},{"line":1007,"address":[],"length":0,"stats":{"Line":1048}},{"line":1008,"address":[],"length":0,"stats":{"Line":24}},{"line":1010,"address":[],"length":0,"stats":{"Line":3060}},{"line":1011,"address":[],"length":0,"stats":{"Line":3036}},{"line":1012,"address":[],"length":0,"stats":{"Line":2024}},{"line":1013,"address":[],"length":0,"stats":{"Line":4048}},{"line":1016,"address":[],"length":0,"stats":{"Line":12}},{"line":1019,"address":[],"length":0,"stats":{"Line":4454}},{"line":1025,"address":[],"length":0,"stats":{"Line":4070}},{"line":1026,"address":[],"length":0,"stats":{"Line":3036}},{"line":1029,"address":[],"length":0,"stats":{"Line":44}},{"line":1030,"address":[],"length":0,"stats":{"Line":8}},{"line":1033,"address":[],"length":0,"stats":{"Line":14}},{"line":1037,"address":[],"length":0,"stats":{"Line":46}},{"line":1038,"address":[],"length":0,"stats":{"Line":46}},{"line":1039,"address":[],"length":0,"stats":{"Line":92}},{"line":1040,"address":[],"length":0,"stats":{"Line":138}},{"line":1045,"address":[],"length":0,"stats":{"Line":2}},{"line":1046,"address":[],"length":0,"stats":{"Line":6}},{"line":1049,"address":[],"length":0,"stats":{"Line":12}},{"line":1050,"address":[],"length":0,"stats":{"Line":2}},{"line":1051,"address":[],"length":0,"stats":{"Line":0}},{"line":1056,"address":[],"length":0,"stats":{"Line":4}},{"line":1057,"address":[],"length":0,"stats":{"Line":812}},{"line":1058,"address":[],"length":0,"stats":{"Line":2424}},{"line":1059,"address":[],"length":0,"stats":{"Line":3192}},{"line":1060,"address":[],"length":0,"stats":{"Line":3940}},{"line":1062,"address":[],"length":0,"stats":{"Line":1576}},{"line":1063,"address":[],"length":0,"stats":{"Line":768}},{"line":1066,"address":[],"length":0,"stats":{"Line":32}},{"line":1067,"address":[],"length":0,"stats":{"Line":12}},{"line":1068,"address":[],"length":0,"stats":{"Line":2}},{"line":1076,"address":[],"length":0,"stats":{"Line":0}},{"line":1084,"address":[],"length":0,"stats":{"Line":1}},{"line":1091,"address":[],"length":0,"stats":{"Line":4}},{"line":1092,"address":[],"length":0,"stats":{"Line":4}},{"line":1094,"address":[],"length":0,"stats":{"Line":3}},{"line":1096,"address":[],"length":0,"stats":{"Line":2}},{"line":1097,"address":[],"length":0,"stats":{"Line":0}},{"line":1102,"address":[],"length":0,"stats":{"Line":2}},{"line":1103,"address":[],"length":0,"stats":{"Line":1}},{"line":1111,"address":[],"length":0,"stats":{"Line":1}},{"line":1114,"address":[],"length":0,"stats":{"Line":3}},{"line":1115,"address":[],"length":0,"stats":{"Line":2}},{"line":1116,"address":[],"length":0,"stats":{"Line":3}},{"line":1119,"address":[],"length":0,"stats":{"Line":89}},{"line":1121,"address":[],"length":0,"stats":{"Line":88}},{"line":1123,"address":[],"length":0,"stats":{"Line":308}},{"line":1124,"address":[],"length":0,"stats":{"Line":44}},{"line":1127,"address":[],"length":0,"stats":{"Line":131}},{"line":1129,"address":[],"length":0,"stats":{"Line":43}},{"line":1132,"address":[],"length":0,"stats":{"Line":86}},{"line":1133,"address":[],"length":0,"stats":{"Line":84}},{"line":1134,"address":[],"length":0,"stats":{"Line":42}},{"line":1135,"address":[],"length":0,"stats":{"Line":84}},{"line":1136,"address":[],"length":0,"stats":{"Line":10}},{"line":1137,"address":[],"length":0,"stats":{"Line":10}},{"line":1138,"address":[],"length":0,"stats":{"Line":10}},{"line":1139,"address":[],"length":0,"stats":{"Line":10}},{"line":1142,"address":[],"length":0,"stats":{"Line":82}},{"line":1144,"address":[],"length":0,"stats":{"Line":2}},{"line":1147,"address":[],"length":0,"stats":{"Line":2}},{"line":1151,"address":[],"length":0,"stats":{"Line":129}},{"line":1152,"address":[],"length":0,"stats":{"Line":129}},{"line":1155,"address":[],"length":0,"stats":{"Line":86}},{"line":1161,"address":[],"length":0,"stats":{"Line":86}},{"line":1163,"address":[],"length":0,"stats":{"Line":129}},{"line":1166,"address":[],"length":0,"stats":{"Line":35251}},{"line":1167,"address":[],"length":0,"stats":{"Line":23472}},{"line":1169,"address":[],"length":0,"stats":{"Line":171}},{"line":1170,"address":[],"length":0,"stats":{"Line":96}},{"line":1172,"address":[],"length":0,"stats":{"Line":643}},{"line":1173,"address":[],"length":0,"stats":{"Line":450}},{"line":1178,"address":[],"length":0,"stats":{"Line":3}},{"line":1179,"address":[],"length":0,"stats":{"Line":3}},{"line":1180,"address":[],"length":0,"stats":{"Line":2}},{"line":1181,"address":[],"length":0,"stats":{"Line":2}},{"line":1182,"address":[],"length":0,"stats":{"Line":1}},{"line":1183,"address":[],"length":0,"stats":{"Line":2}},{"line":1184,"address":[],"length":0,"stats":{"Line":1}},{"line":1185,"address":[],"length":0,"stats":{"Line":1}},{"line":1191,"address":[],"length":0,"stats":{"Line":650}},{"line":1193,"address":[],"length":0,"stats":{"Line":1}},{"line":1194,"address":[],"length":0,"stats":{"Line":2}},{"line":1195,"address":[],"length":0,"stats":{"Line":2}},{"line":1196,"address":[],"length":0,"stats":{"Line":2}},{"line":1197,"address":[],"length":0,"stats":{"Line":2}},{"line":1198,"address":[],"length":0,"stats":{"Line":1}},{"line":1203,"address":[],"length":0,"stats":{"Line":937}},{"line":1204,"address":[],"length":0,"stats":{"Line":937}},{"line":1205,"address":[],"length":0,"stats":{"Line":3619}},{"line":1206,"address":[],"length":0,"stats":{"Line":1788}},{"line":1211,"address":[],"length":0,"stats":{"Line":1}},{"line":1218,"address":[],"length":0,"stats":{"Line":2}},{"line":1219,"address":[],"length":0,"stats":{"Line":0}},{"line":1223,"address":[],"length":0,"stats":{"Line":5}}],"covered":434,"coverable":541},{"path":["/","workspace","crates","ofml-lib","src","oap","config.rs"],"content":"//! Configuration state management for OAP articles\n//!\n//! This module provides the Configuration struct that represents\n//! a configured product instance with property values.\n\nuse std::collections::HashMap;\n\nuse chrono::{DateTime, Utc};\n\nuse super::{ExportData, ExportSurcharge, PriceResult};\nuse crate::oap::format_german_price;\nuse crate::property::PropertyManager;\n\n/// Represents a configured product instance with property values.\n#[derive(Debug, Clone)]\npub struct Configuration {\n    /// Source article ID\n    pub article_id: String,\n    /// Parent manufacturer\n    pub manufacturer_id: String,\n    /// Article number from EBASE\n    pub article_number: Option<String>,\n    /// Property values and states\n    pub properties: PropertyManager,\n    /// Generated variant code\n    pub variant_code: String,\n    /// Looked up price (optional)\n    pub price: Option<PriceResult>,\n    /// Child configurations (sub-articles)\n    pub sub_articles: Vec<Configuration>,\n    /// Creation timestamp\n    pub created_at: DateTime<Utc>,\n}\n\nimpl Configuration {\n    /// Create a new configuration for an article\n    pub fn new(article_id: String, manufacturer_id: String) -> Self {\n        Self {\n            article_id,\n            manufacturer_id,\n            article_number: None,\n            properties: PropertyManager::new(),\n            variant_code: String::new(),\n            price: None,\n            sub_articles: Vec::new(),\n            created_at: Utc::now(),\n        }\n    }\n\n    /// Create a new configuration with property manager\n    pub fn with_properties(\n        article_id: String,\n        manufacturer_id: String,\n        properties: PropertyManager,\n    ) -> Self {\n        Self {\n            article_id,\n            manufacturer_id,\n            article_number: None,\n            properties,\n            variant_code: String::new(),\n            price: None,\n            sub_articles: Vec::new(),\n            created_at: Utc::now(),\n        }\n    }\n\n    /// Update the variant code based on current property values\n    pub fn update_variant_code(&mut self) {\n        self.variant_code = super::variant::generate_variant_code(&self.properties);\n    }\n\n    /// Check if the configuration is valid (all required properties set)\n    pub fn is_valid(&self) -> bool {\n        // For now, consider valid if we have a non-empty variant code\n        // or at least some properties set\n        !self.variant_code.is_empty() || !self.properties.values.is_empty()\n    }\n\n    /// Convert to export data format\n    pub fn to_export_data(&self) -> ExportData {\n        let mut properties = HashMap::new();\n\n        for (name, value) in &self.properties.values {\n            let json_value = match value {\n                crate::property::PropertyValue::Bool(b) => serde_json::Value::Bool(*b),\n                crate::property::PropertyValue::Int(i) => {\n                    serde_json::Value::Number(serde_json::Number::from(*i))\n                }\n                crate::property::PropertyValue::Float(f) => serde_json::Value::Number(\n                    serde_json::Number::from_f64(*f).unwrap_or(serde_json::Number::from(0)),\n                ),\n                crate::property::PropertyValue::String(s) => serde_json::Value::String(s.clone()),\n                crate::property::PropertyValue::Symbol(s) => serde_json::Value::String(s.clone()),\n            };\n            properties.insert(name.clone(), json_value);\n        }\n\n        let (base_price, surcharges, total_price, currency, price_date) =\n            if let Some(ref price) = self.price {\n                (\n                    Some(format_german_price(price.base_price)),\n                    Some(\n                        price\n                            .surcharges\n                            .iter()\n                            .map(|s| ExportSurcharge {\n                                name: s.name.clone(),\n                                amount: format_german_price(s.amount),\n                                is_percentage: s.is_percentage,\n                            })\n                            .collect(),\n                    ),\n                    Some(format_german_price(price.total_price)),\n                    Some(price.currency.clone()),\n                    Some(price.price_date.format(\"%Y-%m-%d\").to_string()),\n                )\n            } else {\n                (None, None, None, None, None)\n            };\n\n        ExportData {\n            manufacturer: self.manufacturer_id.clone(),\n            article: self.article_id.clone(),\n            article_number: self.article_number.clone(),\n            variant_code: self.variant_code.clone(),\n            properties,\n            base_price,\n            surcharges,\n            total_price,\n            currency,\n            price_date,\n            sub_articles: self\n                .sub_articles\n                .iter()\n                .map(|s| s.to_export_data())\n                .collect(),\n            exported_at: Utc::now().to_rfc3339(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::property::PropertyValue;\n\n    #[test]\n    fn test_configuration_new() {\n        let config = Configuration::new(\"ViTable_Round\".to_string(), \"vitra\".to_string());\n        assert_eq!(config.article_id, \"ViTable_Round\");\n        assert_eq!(config.manufacturer_id, \"vitra\");\n        assert!(config.variant_code.is_empty());\n        assert!(config.price.is_none());\n        assert!(config.sub_articles.is_empty());\n    }\n\n    #[test]\n    fn test_configuration_to_export_data() {\n        let mut config = Configuration::new(\"ViTable_Round\".to_string(), \"vitra\".to_string());\n        config.variant_code = \"H720_D1200\".to_string();\n        config.article_number = Some(\"48-123-456\".to_string());\n\n        let export = config.to_export_data();\n        assert_eq!(export.manufacturer, \"vitra\");\n        assert_eq!(export.article, \"ViTable_Round\");\n        assert_eq!(export.variant_code, \"H720_D1200\");\n        assert!(!export.exported_at.is_empty());\n    }\n\n    #[test]\n    fn test_configuration_with_properties() {\n        let mut properties = PropertyManager::new();\n        properties.set(\"HEIGHT\", PropertyValue::Int(720));\n        properties.set(\"DIAMETER\", PropertyValue::Int(1200));\n\n        let config = Configuration::with_properties(\n            \"ViTable_Round\".to_string(),\n            \"vitra\".to_string(),\n            properties,\n        );\n\n        assert_eq!(config.article_id, \"ViTable_Round\");\n        assert!(!config.properties.values.is_empty());\n    }\n\n    #[test]\n    fn test_configuration_is_valid_with_properties() {\n        let mut properties = PropertyManager::new();\n        properties.set(\"HEIGHT\", PropertyValue::Int(720));\n\n        let config = Configuration::with_properties(\n            \"article\".to_string(),\n            \"mfr\".to_string(),\n            properties,\n        );\n\n        assert!(config.is_valid());\n    }\n\n    #[test]\n    fn test_configuration_is_valid_with_variant_code() {\n        let mut config = Configuration::new(\"article\".to_string(), \"mfr\".to_string());\n        config.variant_code = \"VARIANT\".to_string();\n        assert!(config.is_valid());\n    }\n\n    #[test]\n    fn test_configuration_is_not_valid_empty() {\n        let config = Configuration::new(\"article\".to_string(), \"mfr\".to_string());\n        assert!(!config.is_valid());\n    }\n\n    #[test]\n    fn test_configuration_clone() {\n        let mut config = Configuration::new(\"article\".to_string(), \"mfr\".to_string());\n        config.variant_code = \"TEST\".to_string();\n\n        let cloned = config.clone();\n        assert_eq!(cloned.article_id, \"article\");\n        assert_eq!(cloned.variant_code, \"TEST\");\n    }\n\n    #[test]\n    fn test_configuration_debug() {\n        let config = Configuration::new(\"article\".to_string(), \"mfr\".to_string());\n        let debug_str = format!(\"{:?}\", config);\n        assert!(debug_str.contains(\"Configuration\"));\n        assert!(debug_str.contains(\"article\"));\n    }\n\n    #[test]\n    fn test_configuration_export_with_properties() {\n        let mut properties = PropertyManager::new();\n        properties.set(\"HEIGHT\", PropertyValue::Int(720));\n        properties.set(\"WIDTH\", PropertyValue::Float(100.5));\n        properties.set(\"ACTIVE\", PropertyValue::Bool(true));\n        properties.set(\"NAME\", PropertyValue::String(\"Test\".to_string()));\n        properties.set(\"COLOR\", PropertyValue::Symbol(\"RED\".to_string()));\n\n        let config = Configuration::with_properties(\n            \"article\".to_string(),\n            \"mfr\".to_string(),\n            properties,\n        );\n\n        let export = config.to_export_data();\n        assert!(export.properties.contains_key(\"HEIGHT\"));\n        assert!(export.properties.contains_key(\"WIDTH\"));\n        assert!(export.properties.contains_key(\"ACTIVE\"));\n        assert!(export.properties.contains_key(\"NAME\"));\n        assert!(export.properties.contains_key(\"COLOR\"));\n    }\n\n    #[test]\n    fn test_configuration_export_no_price() {\n        let config = Configuration::new(\"article\".to_string(), \"mfr\".to_string());\n        let export = config.to_export_data();\n        assert!(export.base_price.is_none());\n        assert!(export.surcharges.is_none());\n        assert!(export.total_price.is_none());\n        assert!(export.currency.is_none());\n    }\n\n    #[test]\n    fn test_configuration_with_sub_articles() {\n        let mut config = Configuration::new(\"parent\".to_string(), \"mfr\".to_string());\n        let child = Configuration::new(\"child\".to_string(), \"mfr\".to_string());\n        config.sub_articles.push(child);\n\n        let export = config.to_export_data();\n        assert_eq!(export.sub_articles.len(), 1);\n        assert_eq!(export.sub_articles[0].article, \"child\");\n    }\n\n    #[test]\n    fn test_configuration_created_at() {\n        let before = Utc::now();\n        let config = Configuration::new(\"article\".to_string(), \"mfr\".to_string());\n        let after = Utc::now();\n\n        assert!(config.created_at >= before);\n        assert!(config.created_at <= after);\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":20}},{"line":42,"address":[],"length":0,"stats":{"Line":40}},{"line":43,"address":[],"length":0,"stats":{"Line":40}},{"line":45,"address":[],"length":0,"stats":{"Line":20}},{"line":46,"address":[],"length":0,"stats":{"Line":20}},{"line":51,"address":[],"length":0,"stats":{"Line":3}},{"line":61,"address":[],"length":0,"stats":{"Line":6}},{"line":63,"address":[],"length":0,"stats":{"Line":3}},{"line":64,"address":[],"length":0,"stats":{"Line":3}},{"line":69,"address":[],"length":0,"stats":{"Line":4}},{"line":70,"address":[],"length":0,"stats":{"Line":12}},{"line":74,"address":[],"length":0,"stats":{"Line":3}},{"line":77,"address":[],"length":0,"stats":{"Line":5}},{"line":81,"address":[],"length":0,"stats":{"Line":8}},{"line":82,"address":[],"length":0,"stats":{"Line":16}},{"line":84,"address":[],"length":0,"stats":{"Line":23}},{"line":85,"address":[],"length":0,"stats":{"Line":10}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":3}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":25}},{"line":99,"address":[],"length":0,"stats":{"Line":40}},{"line":100,"address":[],"length":0,"stats":{"Line":8}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":32}},{"line":123,"address":[],"length":0,"stats":{"Line":16}},{"line":124,"address":[],"length":0,"stats":{"Line":16}},{"line":125,"address":[],"length":0,"stats":{"Line":16}},{"line":126,"address":[],"length":0,"stats":{"Line":16}},{"line":133,"address":[],"length":0,"stats":{"Line":8}},{"line":138,"address":[],"length":0,"stats":{"Line":16}}],"covered":33,"coverable":45},{"path":["/","workspace","crates","ofml-lib","src","oap","engine.rs"],"content":"//! Configuration Engine - Core of the OAP configurator\n//!\n//! This module provides the ConfigurationEngine that connects:\n//! - OAM data (article ‚Üí CLS class mappings)\n//! - OCD data (articles, prices, texts)\n//! - CLS interpreter (property extraction, rules)\n//! - Price calculation with var_cond matching\n//!\n//! ## Price Calculation Flow\n//!\n//! 1. Two-pass lookup: exact article match first, then wildcard fallback\n//! 2. Base price (level 'B') applied first\n//! 3. Surcharges (level 'X') accumulated and added\n//! 4. Discounts (level 'D') subtracted last\n//!\n//! See `/docs/OCD-PRICING-IMPLEMENTATION.md` for full details.\n\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\n\nuse rust_decimal::Decimal;\nuse tracing::{debug, instrument, trace, warn};\n\nuse crate::alb_loader::AlbLoader;\nuse crate::ast::{ClassMember, Expr, Stmt};\nuse crate::parser::Parser;\nuse crate::property::{PropertyDef, PropertyManager, PropertyType, PropertyValue};\n\nuse super::families::{FamilyConfiguration, FamilyLoader, FamilyProperty, ProductFamily};\nuse super::oam::{load_manufacturer_oam, ArticleMapping, OamData};\nuse super::ocd::{load_articles_with_descriptions, OcdArticle, OcdPrice, OcdReader};\nuse super::ocd_relation::RelationRuleReader;\nuse super::{Article, PriceResult, Surcharge};\n\n/// Helper struct for rounded prices\nstruct RoundedPrices {\n    base_price: Decimal,\n    net_price: Decimal,\n    total_price: Decimal,\n}\n\n/// Error types for the configuration engine\n#[derive(Debug, Clone, thiserror::Error)]\npub enum EngineError {\n    /// Article not found in manufacturer data\n    #[error(\"Article '{article}' not found in manufacturer '{manufacturer}' data. Check if the article number is correct and the data directory is up to date.\")]\n    ArticleNotFound {\n        article: String,\n        manufacturer: String,\n    },\n\n    /// Legacy: Article not found (simple)\n    #[error(\"Article not found: {0}\")]\n    ArticleNotFoundSimple(String),\n\n    /// Article exists but is not configurable (no CLS class mapping)\n    #[error(\"Article '{article}' is not configurable. It exists in the catalog but has no CLS class mapping for property configuration.\")]\n    NotConfigurable { article: String },\n\n    /// CLS class referenced by OAM mapping was not found\n    #[error(\"CLS class '{class}' not found for article '{article}'. The ALB package may be missing or corrupted.\")]\n    ClassNotFound { article: String, class: String },\n\n    /// Property manipulation error\n    #[error(\"Property error for '{property}': {message}\")]\n    PropertyError { property: String, message: String },\n\n    /// Price lookup or calculation error\n    #[error(\"Price calculation failed for article '{article}': {message}\")]\n    PriceError { article: String, message: String },\n\n    /// File or data I/O error\n    #[error(\"I/O error accessing '{path}': {message}\")]\n    IoError { path: String, message: String },\n\n    /// CLS interpreter execution error\n    #[error(\"Interpreter error in class '{class}': {message}\")]\n    InterpreterError { class: String, message: String },\n\n    /// Data format error in OCD or EBase files\n    #[error(\"Data format error in '{file}': {message}\")]\n    DataFormatError { file: String, message: String },\n\n    /// Missing required data\n    #[error(\"Missing required data: {0}\")]\n    MissingData(String),\n}\n\n/// Cache statistics for debugging and monitoring\n#[derive(Debug, Clone)]\npub struct CacheStats {\n    /// Number of cached OAM entries\n    pub oam_entries: usize,\n    /// Number of cached article lists\n    pub article_entries: usize,\n    /// Number of cached family loaders\n    pub family_entries: usize,\n    /// Number of cached OCD readers\n    pub ocd_entries: usize,\n}\n\n/// An article enriched with OAM mapping information\n#[derive(Debug, Clone)]\npub struct EnrichedArticle {\n    /// Original OCD article data\n    pub article: OcdArticle,\n    /// Short description\n    pub description: String,\n    /// Whether this article has a CLS class (is configurable)\n    pub is_configurable: bool,\n    /// OAM mapping (if available)\n    pub mapping: Option<ArticleMapping>,\n}\n\nimpl EnrichedArticle {\n    /// Convert to simple Article for display\n    pub fn to_article(&self) -> Article {\n        Article {\n            id: self.article.article_nr.clone(),\n            manufacturer_id: self.article.manufacturer.clone(),\n            series_id: Some(self.article.series.clone()),\n            short_description: self.description.clone(),\n            long_description: None,\n            base_article_number: self.article.article_nr.clone(),\n            has_configuration: self.is_configurable,\n        }\n    }\n}\n\n/// A loaded configuration with properties from CLS class\n#[derive(Debug, Clone)]\npub struct LoadedConfiguration {\n    /// Article information\n    pub article: EnrichedArticle,\n    /// Manufacturer ID\n    pub manufacturer_id: String,\n    /// Property manager with definitions and values\n    pub properties: PropertyManager,\n    /// Current price (if available)\n    pub price: Option<PriceResult>,\n    /// Path to the ALB/package that contains this article\n    pub package_path: Option<PathBuf>,\n    /// OFML class name\n    pub ofml_class: Option<String>,\n}\n\n/// Configuration Engine - main API for article configuration\npub struct ConfigurationEngine {\n    /// Path to ofmldata directory\n    data_path: PathBuf,\n    /// Cached OAM data per manufacturer\n    oam_cache: HashMap<String, OamData>,\n    /// Cached article lists per manufacturer\n    article_cache: HashMap<String, Vec<EnrichedArticle>>,\n    /// Cached family loaders per manufacturer\n    family_cache: HashMap<String, FamilyLoader>,\n    /// ALB loader for loading CLS classes\n    alb_loader: AlbLoader,\n}\n\nimpl ConfigurationEngine {\n    /// Create a new configuration engine\n    pub fn new(data_path: impl Into<PathBuf>) -> Self {\n        let path: PathBuf = data_path.into();\n        Self {\n            alb_loader: AlbLoader::new(&path),\n            data_path: path,\n            oam_cache: HashMap::new(),\n            article_cache: HashMap::new(),\n            family_cache: HashMap::new(),\n        }\n    }\n\n    /// Get cache statistics (includes global OCD cache)\n    #[allow(dead_code)]\n    pub fn cache_stats(&self) -> CacheStats {\n        CacheStats {\n            oam_entries: self.oam_cache.len(),\n            article_entries: self.article_cache.len(),\n            family_entries: self.family_cache.len(),\n            ocd_entries: super::ocd::ocd_cache_size(),\n        }\n    }\n\n    /// Load product families for a manufacturer (cached)\n    #[instrument(skip(self), fields(manufacturer = %manufacturer_id))]\n    pub fn load_families(&mut self, manufacturer_id: &str) -> &[ProductFamily] {\n        if !self.family_cache.contains_key(manufacturer_id) {\n            let mfr_path = self.data_path.join(manufacturer_id);\n            let loader = FamilyLoader::load(&mfr_path, \"DE\");\n            self.family_cache\n                .insert(manufacturer_id.to_string(), loader);\n        }\n        self.family_cache\n            .get(manufacturer_id)\n            .map(|l| l.get_families())\n            .unwrap_or(&[])\n    }\n\n    /// Get a product family by ID\n    pub fn get_family(&mut self, manufacturer_id: &str, family_id: &str) -> Option<ProductFamily> {\n        self.load_families(manufacturer_id);\n        self.family_cache\n            .get(manufacturer_id)\n            .and_then(|l| l.get_family(family_id))\n            .cloned()\n    }\n\n    /// Get configurable properties for a product family\n    pub fn get_family_properties(\n        &mut self,\n        manufacturer_id: &str,\n        family_id: &str,\n    ) -> Vec<FamilyProperty> {\n        self.load_families(manufacturer_id);\n        if let Some(loader) = self.family_cache.get(manufacturer_id) {\n            if let Some(family) = loader.get_family(family_id) {\n                return loader.get_properties_for_family(family);\n            }\n        }\n        Vec::new()\n    }\n\n    /// Get configurable properties for a product family with current selections\n    ///\n    /// This method takes the current property selections into account when\n    /// determining available values for TABLE-based properties. Use this\n    /// when you need to refresh property options after a selection change.\n    pub fn get_family_properties_with_selections(\n        &mut self,\n        manufacturer_id: &str,\n        family_id: &str,\n        current_selections: &std::collections::HashMap<String, String>,\n    ) -> Vec<FamilyProperty> {\n        self.load_families(manufacturer_id);\n        if let Some(loader) = self.family_cache.get(manufacturer_id) {\n            if let Some(family) = loader.get_family(family_id) {\n                return loader.get_properties_for_family_with_selections(family, current_selections);\n            }\n        }\n        Vec::new()\n    }\n\n    /// Get packaging information for an article\n    ///\n    /// Returns the first matching packaging entry for the given article.\n    /// Dimensions are in the unit specified in the packaging data (usually mm or cm).\n    pub fn get_packaging_for_article(\n        &self,\n        manufacturer_id: &str,\n        article_nr: &str,\n    ) -> Option<super::ocd_properties::OcdPackaging> {\n        let mfr_path = self.data_path.join(manufacturer_id);\n        let prop_reader = super::ocd_properties::load_manufacturer_properties(&mfr_path);\n        let packaging = prop_reader.get_packaging(article_nr);\n        packaging.first().cloned().cloned()\n    }\n\n    /// Get data version information for a manufacturer\n    ///\n    /// Returns a formatted version string including validity dates if available.\n    pub fn get_data_version(&self, manufacturer_id: &str) -> Option<String> {\n        let mfr_path = self.data_path.join(manufacturer_id);\n        let prop_reader = super::ocd_properties::load_manufacturer_properties(&mfr_path);\n        prop_reader.get_data_version().map(|v| {\n            if !v.date_from.is_empty() && !v.date_to.is_empty() {\n                format!(\"{} ({} - {})\", v.data_version, v.date_from, v.date_to)\n            } else if !v.date_from.is_empty() {\n                format!(\"{} (ab {})\", v.data_version, v.date_from)\n            } else {\n                v.data_version.clone()\n            }\n        })\n    }\n\n    /// Check if data is valid for a given date and return a warning if not\n    pub fn get_data_validity_warning(\n        &self,\n        manufacturer_id: &str,\n        date: chrono::NaiveDate,\n    ) -> Option<String> {\n        let mfr_path = self.data_path.join(manufacturer_id);\n        let prop_reader = super::ocd_properties::load_manufacturer_properties(&mfr_path);\n        prop_reader.get_data_validity_warning(date)\n    }\n\n    /// Format a variant code using manufacturer's code scheme\n    pub fn format_variant_code(&self, manufacturer_id: &str, variant_code: &str) -> String {\n        let mfr_path = self.data_path.join(manufacturer_id);\n        let prop_reader = super::ocd_properties::load_manufacturer_properties(&mfr_path);\n        prop_reader.format_variant_code(variant_code)\n    }\n\n    /// Get the variant code separator from manufacturer's code scheme\n    ///\n    /// Returns the separator character(s) used in variant codes, defaults to \"_\"\n    pub fn get_varcode_separator(&self, manufacturer_id: &str) -> String {\n        let mfr_path = self.data_path.join(manufacturer_id);\n        let prop_reader = super::ocd_properties::load_manufacturer_properties(&mfr_path);\n\n        // Try to find a code scheme and return its separator\n        if let Some(scheme) = prop_reader\n            .get_code_scheme(\"DEFAULT\")\n            .or_else(|| prop_reader.get_code_scheme(\"1\"))\n        {\n            if !scheme.varcode_sep.is_empty() {\n                return scheme.varcode_sep.clone();\n            }\n        }\n        \"_\".to_string()\n    }\n\n    /// Check if a product is a composite\n    pub fn is_composite(&self, manufacturer_id: &str, product_id: &str) -> bool {\n        let mfr_path = self.data_path.join(manufacturer_id);\n        let prop_reader = super::ocd_properties::load_manufacturer_properties(&mfr_path);\n        prop_reader.get_composite(product_id).is_some()\n    }\n\n    /// Get composite information for a product\n    pub fn get_composite_info(\n        &self,\n        manufacturer_id: &str,\n        product_id: &str,\n    ) -> Option<super::ocd_properties::OcdComposite> {\n        let mfr_path = self.data_path.join(manufacturer_id);\n        let prop_reader = super::ocd_properties::load_manufacturer_properties(&mfr_path);\n        prop_reader.get_composite(product_id).cloned()\n    }\n\n    /// Get components (bill of items) for a composite product\n    pub fn get_composite_components(\n        &self,\n        manufacturer_id: &str,\n        composite_id: &str,\n    ) -> Vec<super::ocd_properties::OcdBillOfItems> {\n        let mfr_path = self.data_path.join(manufacturer_id);\n        let prop_reader = super::ocd_properties::load_manufacturer_properties(&mfr_path);\n        prop_reader\n            .get_bill_of_items(composite_id)\n            .into_iter()\n            .cloned()\n            .collect()\n    }\n\n    /// Create a new configuration for a product family\n    pub fn create_family_configuration(\n        &mut self,\n        manufacturer_id: &str,\n        family_id: &str,\n    ) -> Option<FamilyConfiguration> {\n        let properties = self.get_family_properties(manufacturer_id, family_id);\n        if properties.is_empty() {\n            // No OCD properties - try to create from family's article\n            let family = self.get_family(manufacturer_id, family_id)?;\n            Some(FamilyConfiguration::new(&family.id, &[]))\n        } else {\n            Some(FamilyConfiguration::new(family_id, &properties))\n        }\n    }\n\n    /// Calculate price for a family configuration\n    #[instrument(skip(self, family, config), fields(manufacturer = %manufacturer_id, family = %family.id))]\n    pub fn calculate_family_price(\n        &self,\n        manufacturer_id: &str,\n        family: &ProductFamily,\n        config: &FamilyConfiguration,\n        price_date: chrono::NaiveDate,\n    ) -> Option<PriceResult> {\n        let mfr_path = self.data_path.join(manufacturer_id);\n\n        debug!(\n            manufacturer = manufacturer_id,\n            family = family.id,\n            article = family.base_article_nr,\n            \"Calculating family price\"\n        );\n\n        // Load property reader to compute var_cond from TABLE relations\n        let prop_reader = super::ocd_properties::load_manufacturer_properties(&mfr_path);\n\n        // Try to compute var_cond using TABLE relations (for manufacturers like FAST)\n        let computed_varcond = if prop_reader.uses_table_varcond() {\n            // Use first property class from the family\n            let prop_class = family\n                .prop_classes\n                .first()\n                .map(|s| s.as_str())\n                .unwrap_or(\"\");\n            let result =\n                prop_reader.compute_varcond_from_selections(prop_class, &config.selections);\n            if let Some(ref vc) = result {\n                debug!(var_cond = vc, \"TABLE-computed var_cond\");\n            }\n            result\n        } else {\n            None\n        };\n\n        // Find pdata.ebase files (cached)\n        let pdata_files = super::ocd::find_pdata_files(&mfr_path);\n        trace!(file_count = pdata_files.len(), \"Found pdata.ebase files\");\n\n        // Helper to evaluate relation rules for a specific pdata file\n        // Only used when the file contains our family's articles and uses relation-based pricing\n        let evaluate_relation_rules = |pdata_path: &std::path::Path| -> Vec<String> {\n            RelationRuleReader::from_ebase(pdata_path)\n                .and_then(|rule_reader| {\n                    if rule_reader.has_pricing_rules() {\n                        // Build property map with M_ prefix (as used in relation rules)\n                        // Note: Some property keys already have M_ prefix, so don't double it\n                        let mut props: HashMap<String, String> = config\n                            .selections\n                            .iter()\n                            .map(|(k, v)| {\n                                let key = k.to_uppercase();\n                                let prop_key = if key.starts_with(\"M_\") {\n                                    key\n                                } else {\n                                    format!(\"M_{}\", key)\n                                };\n                                (prop_key, v.to_uppercase())\n                            })\n                            .collect();\n                        // Add article number (used in conditions like M_ARTNO = 'ONE')\n                        props.insert(\n                            \"M_ARTNO\".to_string(),\n                            family.base_article_nr.to_uppercase(),\n                        );\n\n                        let matched = rule_reader.evaluate(&props);\n                        if !matched.is_empty() {\n                            debug!(\n                                file = ?pdata_path.file_name(),\n                                varconds = ?matched,\n                                \"Relation rules matched var_conds\"\n                            );\n                            Some(matched)\n                        } else {\n                            None\n                        }\n                    } else {\n                        None\n                    }\n                })\n                .unwrap_or_default()\n        };\n\n        // FIRST PASS: Look for files with ACTUAL article base prices (not just wildcards)\n        // This ensures we find the correct series file for the article\n        for pdata_path in &pdata_files {\n            if let Some(reader) = super::ocd::get_ocd_reader(pdata_path) {\n                // Check if this file has the actual article with a base price\n                let has_actual_base = reader\n                    .prices\n                    .iter()\n                    .any(|p| p.article_nr == family.base_article_nr && p.price_level == \"B\");\n\n                if has_actual_base {\n                    debug!(\n                        file = ?pdata_path.file_name(),\n                        article = family.base_article_nr,\n                        \"Found exact article base price\"\n                    );\n                    let prices = reader.get_prices(&family.base_article_nr);\n                    // Evaluate relation rules for this file (some families use both base prices AND relation rules)\n                    let file_relation_varconds = evaluate_relation_rules(pdata_path);\n                    return self.match_and_calculate_price_with_varcond(\n                        &reader,\n                        &prices,\n                        config,\n                        price_date,\n                        computed_varcond.as_deref(),\n                        &file_relation_varconds,\n                        &prop_reader,\n                        &family.base_article_nr,\n                    );\n                }\n            }\n        }\n\n        trace!(\"No exact base price found, trying alternate articles and wildcards\");\n\n        // SECOND PASS: Try alternate articles in the family (they may have base prices)\n        for pdata_path in &pdata_files {\n            if let Some(reader) = super::ocd::get_ocd_reader(pdata_path) {\n                // First, try other articles in the family that have actual base prices\n                for art_nr in &family.article_nrs {\n                    // Check if this file has actual base price for this article\n                    let has_base = reader\n                        .prices\n                        .iter()\n                        .any(|p| p.article_nr == *art_nr && p.price_level == \"B\");\n\n                    if has_base {\n                        let prices = reader.get_prices(art_nr);\n                        debug!(\n                            file = ?pdata_path.file_name(),\n                            article = art_nr,\n                            \"Found base price via alternate family article\"\n                        );\n                        // Evaluate relation rules for this file\n                        let file_relation_varconds = evaluate_relation_rules(pdata_path);\n                        return self.match_and_calculate_price_with_varcond(\n                            &reader,\n                            &prices,\n                            config,\n                            price_date,\n                            computed_varcond.as_deref(),\n                            &file_relation_varconds,\n                            &prop_reader,\n                            art_nr,\n                        );\n                    }\n                }\n            }\n        }\n\n        trace!(\"No alternate article base price found, trying surcharge-only or wildcard\");\n\n        // THIRD PASS: Fall back to surcharge-only pricing (only use if file contains the article)\n        for pdata_path in &pdata_files {\n            if let Some(reader) = super::ocd::get_ocd_reader(pdata_path) {\n                // Only use surcharge-only pricing if this file is specifically for this series\n                // Check if any of the family's articles appear in this file's article table\n                let file_has_family_articles = family.article_nrs.iter().any(|art| {\n                    reader.articles.iter().any(|a| a.article_nr == *art)\n                });\n\n                if !file_has_family_articles {\n                    // This file isn't for our family, skip it\n                    continue;\n                }\n\n                // For surcharge-only pricing, get wildcard prices\n                let prices = reader.get_prices(&family.base_article_nr);\n                if prices.is_empty() {\n                    continue;\n                }\n\n                // Verify this is actually surcharge-only (no base prices for our articles)\n                let has_any_base = family.article_nrs.iter().any(|art| {\n                    reader\n                        .prices\n                        .iter()\n                        .any(|p| p.article_nr == *art && p.price_level == \"B\")\n                });\n\n                if has_any_base {\n                    // This file has base prices, but we didn't find them in earlier passes\n                    // Something went wrong, skip\n                    continue;\n                }\n\n                let strategy = reader.detect_pricing_strategy();\n                // For surcharge-only pricing, evaluate relation rules from this specific file\n                // These rules determine which surcharges apply based on property conditions\n                let file_relation_varconds = evaluate_relation_rules(pdata_path);\n\n                debug!(\n                    file = ?pdata_path.file_name(),\n                    price_count = prices.len(),\n                    strategy = ?strategy,\n                    relation_rules = file_relation_varconds.len(),\n                    \"Using surcharge-only prices from series file\"\n                );\n\n                return self.match_and_calculate_price_with_varcond(\n                    &reader,\n                    &prices,\n                    config,\n                    price_date,\n                    computed_varcond.as_deref(),\n                    &file_relation_varconds,\n                    &prop_reader,\n                    &family.base_article_nr,\n                );\n            }\n        }\n\n        warn!(\n            manufacturer = manufacturer_id,\n            article = family.base_article_nr,\n            \"No price found for article\"\n        );\n        None\n    }\n\n    /// Match prices and calculate total, with optional computed var_cond\n    #[allow(clippy::too_many_arguments)]\n    fn match_and_calculate_price_with_varcond(\n        &self,\n        reader: &OcdReader,\n        prices: &[&OcdPrice],\n        config: &FamilyConfiguration,\n        price_date: chrono::NaiveDate,\n        computed_varcond: Option<&str>,\n        relation_varconds: &[String],\n        prop_reader: &super::ocd_properties::OcdPropertyReader,\n        article_nr: &str,\n    ) -> Option<PriceResult> {\n        let matched = match_prices_to_variant_with_computed_varcond(\n            reader,\n            prices,\n            &config.variant_code,\n            computed_varcond,\n            relation_varconds,\n        )?;\n\n        let valid_from = chrono::NaiveDate::parse_from_str(&matched.base_price.date_from, \"%Y%m%d\")\n            .unwrap_or(price_date);\n        let valid_to =\n            chrono::NaiveDate::parse_from_str(&matched.base_price.date_to, \"%Y%m%d\").ok();\n\n        // Combine surcharges and discounts (discounts as negative surcharges)\n        let mut all_surcharges = matched.surcharges;\n        for discount in matched.discounts {\n            all_surcharges.push(Surcharge {\n                name: format!(\"Rabatt: {}\", discount.name),\n                amount: -discount.amount, // Negate amount for discounts\n                is_percentage: discount.is_percentage,\n            });\n        }\n\n        // Calculate net price first (for tax calculation)\n        let net_price = PriceResult::compute_net_static(&matched.base_amount, &all_surcharges);\n\n        // Look up taxes for this article\n        let taxes = self.calculate_taxes_for_article(prop_reader, article_nr, net_price);\n\n        // Apply rounding rules if available\n        // Look for a default rounding rule (commonly \"DEFAULT\" or \"PRICE\")\n        let rounded_prices = self.apply_rounding_rules(prop_reader, &matched.base_amount, &net_price, &taxes);\n\n        Some(PriceResult::with_taxes_and_rounding(\n            rounded_prices.base_price,\n            all_surcharges,\n            taxes,\n            rounded_prices.net_price,\n            rounded_prices.total_price,\n            matched.base_price.currency.clone(),\n            price_date,\n            valid_from,\n            valid_to,\n        ))\n    }\n\n    /// Apply rounding rules to prices\n    fn apply_rounding_rules(\n        &self,\n        prop_reader: &super::ocd_properties::OcdPropertyReader,\n        base_price: &rust_decimal::Decimal,\n        net_price: &rust_decimal::Decimal,\n        taxes: &[super::TaxEntry],\n    ) -> RoundedPrices {\n        use rust_decimal::Decimal;\n\n        // Try common rounding rule IDs\n        let rounding_ids = [\"DEFAULT\", \"PRICE\", \"STANDARD\", \"1\"];\n\n        for id in &rounding_ids {\n            let rules = prop_reader.get_rounding_rules(id);\n            if !rules.is_empty() {\n                // Apply rounding to total price\n                let tax_total: Decimal = taxes.iter().map(|t| t.amount).sum();\n                let total = *net_price + tax_total;\n\n                let rounded_total = Decimal::from_f64_retain(\n                    prop_reader.apply_rounding(id, total.to_string().parse::<f64>().unwrap_or(0.0))\n                ).unwrap_or(total);\n\n                return RoundedPrices {\n                    base_price: *base_price,\n                    net_price: *net_price,\n                    total_price: rounded_total,\n                };\n            }\n        }\n\n        // No rounding rules found, return unrounded prices\n        let tax_total: Decimal = taxes.iter().map(|t| t.amount).sum();\n        RoundedPrices {\n            base_price: *base_price,\n            net_price: *net_price,\n            total_price: *net_price + tax_total,\n        }\n    }\n\n    /// Calculate taxes for an article based on tax schemes\n    fn calculate_taxes_for_article(\n        &self,\n        prop_reader: &super::ocd_properties::OcdPropertyReader,\n        article_nr: &str,\n        net_price: rust_decimal::Decimal,\n    ) -> Vec<super::TaxEntry> {\n        use rust_decimal::Decimal;\n\n        let article_taxes = prop_reader.get_article_taxes(article_nr);\n        if article_taxes.is_empty() {\n            return Vec::new();\n        }\n\n        let mut taxes = Vec::new();\n        for tax_assignment in article_taxes {\n            if let Some(scheme) = prop_reader.get_tax_scheme(&tax_assignment.tax_id) {\n                // Only apply percentage-based taxes (most common)\n                if scheme.tax_type.eq_ignore_ascii_case(\"PERCENT\")\n                    || scheme.tax_type.eq_ignore_ascii_case(\"VAT\")\n                {\n                    let rate = Decimal::from_f64_retain(scheme.number).unwrap_or_default();\n                    let amount = net_price * rate / Decimal::from(100);\n                    taxes.push(super::TaxEntry {\n                        name: format!(\"MwSt ({}%)\", scheme.number),\n                        category: scheme.tax_category.clone(),\n                        rate,\n                        amount,\n                    });\n                }\n            }\n        }\n        taxes\n    }\n\n    /// Load OAM data for a manufacturer (cached)\n    pub fn load_oam(&mut self, manufacturer_id: &str) -> &OamData {\n        // Use entry API to avoid separate contains_key + get + unwrap\n        self.oam_cache\n            .entry(manufacturer_id.to_string())\n            .or_insert_with(|| {\n                let mfr_path = self.data_path.join(manufacturer_id);\n                load_manufacturer_oam(&mfr_path)\n            })\n    }\n\n    /// Load articles for a manufacturer with OAM enrichment\n    pub fn load_articles(&mut self, manufacturer_id: &str) -> Vec<EnrichedArticle> {\n        // Check cache first\n        if let Some(cached) = self.article_cache.get(manufacturer_id) {\n            return cached.clone();\n        }\n\n        let mfr_path = self.data_path.join(manufacturer_id);\n\n        // Load OAM data first\n        let oam_data = load_manufacturer_oam(&mfr_path);\n\n        // Load OCD articles\n        let articles_with_desc = load_articles_with_descriptions(&mfr_path, \"DE\");\n\n        // Enrich articles with OAM data and filter out internal/cryptic articles\n        let enriched: Vec<EnrichedArticle> = articles_with_desc\n            .into_iter()\n            .filter(|(article, _)| {\n                // Filter out internal articles (starting with @)\n                if article.article_nr.starts_with('@') {\n                    return false;\n                }\n                // Filter out articles with control characters in series\n                if article.series.chars().any(|c| c.is_control()) {\n                    return false;\n                }\n                true\n            })\n            .map(|(article, description)| {\n                let mapping = oam_data.get_mapping(&article.article_nr).cloned();\n                let is_configurable = mapping.is_some();\n\n                EnrichedArticle {\n                    article,\n                    description,\n                    is_configurable,\n                    mapping,\n                }\n            })\n            .collect();\n\n        // Cache and return\n        self.oam_cache.insert(manufacturer_id.to_string(), oam_data);\n        self.article_cache\n            .insert(manufacturer_id.to_string(), enriched.clone());\n\n        enriched\n    }\n\n    /// Get an article by its number\n    pub fn get_article(\n        &mut self,\n        manufacturer_id: &str,\n        article_nr: &str,\n    ) -> Option<EnrichedArticle> {\n        let articles = self.load_articles(manufacturer_id);\n        articles\n            .into_iter()\n            .find(|a| a.article.article_nr == article_nr)\n    }\n\n    /// Load configuration for an article using CLS interpreter\n    pub fn load_configuration(\n        &mut self,\n        manufacturer_id: &str,\n        article_nr: &str,\n    ) -> Result<LoadedConfiguration, EngineError> {\n        // Get the enriched article\n        let article = self\n            .get_article(manufacturer_id, article_nr)\n            .ok_or_else(|| EngineError::ArticleNotFound {\n                article: article_nr.to_string(),\n                manufacturer: manufacturer_id.to_string(),\n            })?;\n\n        // Check if configurable\n        let mapping = article\n            .mapping\n            .clone()\n            .ok_or_else(|| EngineError::NotConfigurable {\n                article: article_nr.to_string(),\n            })?;\n\n        // Try to extract properties from the CLS class\n        let (properties, package_path) =\n            self.extract_properties_for_class(manufacturer_id, &mapping)?;\n\n        Ok(LoadedConfiguration {\n            article,\n            manufacturer_id: manufacturer_id.to_string(),\n            properties,\n            price: None,\n            package_path,\n            ofml_class: Some(mapping.ofml_type.clone()),\n        })\n    }\n\n    /// Extract properties from a CLS class using the interpreter\n    fn extract_properties_for_class(\n        &mut self,\n        manufacturer_id: &str,\n        mapping: &ArticleMapping,\n    ) -> Result<(PropertyManager, Option<PathBuf>), EngineError> {\n        let class_name = &mapping.ofml_type;\n\n        // Parse the class path to find ALB files\n        // e.g., \"::vitra::abc::aAddOn\" -> vitra/abc\n        let parts: Vec<&str> = class_name.split(\"::\").filter(|s| !s.is_empty()).collect();\n\n        if parts.len() < 2 {\n            // Generic OFML class like ::ofml::oi::OiOdbPlElement - no custom properties\n            return Ok((PropertyManager::new(), None));\n        }\n\n        // Skip if it's a built-in OFML class\n        if parts.first() == Some(&\"ofml\") {\n            return Ok((PropertyManager::new(), None));\n        }\n\n        let mfr_path = self.data_path.join(manufacturer_id);\n        let series = parts.get(1).unwrap_or(&\"\");\n\n        // Find ALB files for this series\n        let alb_files = find_alb_files(&mfr_path, series);\n\n        if alb_files.is_empty() {\n            return Ok((PropertyManager::new(), None));\n        }\n\n        // Load ALB files and try to find the class\n        let short_class_name = parts.last().unwrap_or(&\"\").to_string();\n\n        for alb_path in &alb_files {\n            if let Ok(cls_sources) = self.alb_loader.load_alb(alb_path) {\n                // Check if any source contains our class\n                for cls_source in &cls_sources {\n                    if cls_source\n                        .classes\n                        .iter()\n                        .any(|c| c == &short_class_name || c == class_name)\n                    {\n                        // Found the class - try to parse and extract properties\n                        if let Ok(properties) =\n                            extract_properties_from_source(&cls_source.source, &short_class_name)\n                        {\n                            if !properties.definitions.is_empty() {\n                                return Ok((properties, Some(alb_path.clone())));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Also try to load basics/global ALBs which may contain parent classes\n        for base_dir in &[\"basics\", \"global\"] {\n            let base_albs = find_alb_files(&mfr_path, base_dir);\n            for alb_path in &base_albs {\n                let _ = self.alb_loader.load_alb(alb_path);\n            }\n        }\n\n        // Fallback: extract from any loaded source that matches\n        for sources in self.alb_loader.sources.values() {\n            for cls_source in sources {\n                if cls_source.classes.contains(&short_class_name) {\n                    if let Ok(properties) =\n                        extract_properties_from_source(&cls_source.source, &short_class_name)\n                    {\n                        if !properties.definitions.is_empty() {\n                            return Ok((properties, None));\n                        }\n                    }\n                }\n            }\n        }\n\n        Ok((PropertyManager::new(), None))\n    }\n\n    /// Calculate price for a configuration using var_cond matching\n    pub fn calculate_price(\n        &self,\n        manufacturer_id: &str,\n        article_nr: &str,\n        properties: &PropertyManager,\n        price_date: chrono::NaiveDate,\n    ) -> Result<Option<PriceResult>, EngineError> {\n        let mfr_path = self.data_path.join(manufacturer_id);\n\n        // Find pdata.ebase files\n        let pdata_files = super::ocd::find_pdata_files(&mfr_path);\n\n        for pdata_path in &pdata_files {\n            if let Ok(reader) = OcdReader::from_ebase(pdata_path) {\n                // Get all prices for this article\n                let prices = reader.get_prices(article_nr);\n\n                if prices.is_empty() {\n                    continue;\n                }\n\n                // Generate variant code from properties\n                let variant_code = generate_variant_code(properties);\n\n                // Match prices against variant code\n                let matched = match_prices_to_variant(&reader, &prices, &variant_code);\n\n                if let Some(price_result) = matched {\n                    // Parse dates and create PriceResult\n                    let valid_from = chrono::NaiveDate::parse_from_str(\n                        &price_result.base_price.date_from,\n                        \"%Y%m%d\",\n                    )\n                    .unwrap_or(price_date);\n                    let valid_to = chrono::NaiveDate::parse_from_str(\n                        &price_result.base_price.date_to,\n                        \"%Y%m%d\",\n                    )\n                    .ok();\n\n                    // Combine surcharges and discounts (discounts as negative surcharges)\n                    let mut all_surcharges = price_result.surcharges;\n                    for discount in price_result.discounts {\n                        all_surcharges.push(Surcharge {\n                            name: format!(\"Rabatt: {}\", discount.name),\n                            amount: -discount.amount, // Negate amount for discounts\n                            is_percentage: discount.is_percentage,\n                        });\n                    }\n\n                    return Ok(Some(PriceResult::new(\n                        price_result.base_amount,\n                        all_surcharges,\n                        price_result.base_price.currency.clone(),\n                        price_date,\n                        valid_from,\n                        valid_to,\n                    )));\n                }\n            }\n        }\n\n        Ok(None)\n    }\n\n    /// Set a property value and trigger updates\n    pub fn set_property(\n        &mut self,\n        config: &mut LoadedConfiguration,\n        key: &str,\n        value: PropertyValue,\n    ) -> Result<(), EngineError> {\n        config.properties.set(key, value).map_err(|e| {\n            EngineError::PropertyError {\n                property: key.to_string(),\n                message: e.to_string(),\n            }\n        })?;\n\n        Ok(())\n    }\n}\n\n/// Find ALB files for a series within a manufacturer directory\nfn find_alb_files(mfr_path: &Path, series: &str) -> Vec<PathBuf> {\n    let mut alb_files = Vec::new();\n\n    // Look in the series directory\n    let series_path = mfr_path.join(series);\n    if series_path.is_dir() {\n        find_alb_recursive(&series_path, &mut alb_files);\n    }\n\n    alb_files\n}\n\nfn find_alb_recursive(path: &Path, files: &mut Vec<PathBuf>) {\n    if let Ok(entries) = std::fs::read_dir(path) {\n        for entry in entries.flatten() {\n            let entry_path = entry.path();\n            if entry_path.is_dir() {\n                find_alb_recursive(&entry_path, files);\n            } else if entry_path.extension().is_some_and(|e| e == \"alb\") {\n                files.push(entry_path);\n            }\n        }\n    }\n}\n\n/// Extract properties from CLS source code\nfn extract_properties_from_source(\n    source: &str,\n    class_name: &str,\n) -> Result<PropertyManager, EngineError> {\n    let mut properties = PropertyManager::new();\n\n    // Parse the source\n    let mut parser = Parser::new(source).map_err(|e| EngineError::InterpreterError {\n        class: class_name.to_string(),\n        message: format!(\"Parse error: {}\", e),\n    })?;\n    let ast = parser.parse().map_err(|e| EngineError::InterpreterError {\n        class: class_name.to_string(),\n        message: format!(\"Parse error: {}\", e),\n    })?;\n\n    // Find the class definition in statements and look for setupProperty calls\n    for stmt in &ast.statements {\n        if let Stmt::Class(class_def) = stmt {\n            if class_def.name == class_name || class_name.ends_with(&class_def.name) {\n                // Search ALL methods for setupProperty calls\n                // Properties can be defined in initialize, setup, updateSize, or other methods\n                for member in &class_def.members {\n                    if let ClassMember::Func(func) = member {\n                        // Extract setupProperty calls from any method body\n                        if let Some(body) = &func.body {\n                            extract_setup_properties_from_stmts(&body.stmts, &mut properties);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    Ok(properties)\n}\n\n/// Extract property definitions from setupProperty calls in AST statements\nfn extract_setup_properties_from_stmts(stmts: &[Stmt], properties: &mut PropertyManager) {\n    for stmt in stmts {\n        match stmt {\n            Stmt::Expr(expr) => {\n                extract_setup_properties_from_expr(expr, properties);\n            }\n            Stmt::If(if_stmt) => {\n                if let Stmt::Block(block) = if_stmt.then_branch.as_ref() {\n                    extract_setup_properties_from_stmts(&block.stmts, properties);\n                }\n                if let Some(else_stmt) = &if_stmt.else_branch {\n                    if let Stmt::Block(block) = else_stmt.as_ref() {\n                        extract_setup_properties_from_stmts(&block.stmts, properties);\n                    }\n                }\n            }\n            Stmt::Block(block) => {\n                extract_setup_properties_from_stmts(&block.stmts, properties);\n            }\n            _ => {}\n        }\n    }\n}\n\n/// Extract property definition from a setupProperty call expression\nfn extract_setup_properties_from_expr(expr: &Expr, properties: &mut PropertyManager) {\n    match expr {\n        Expr::Call(call_expr) => {\n            // Check if this is a setupProperty call\n            let is_setup_property = match call_expr.callee.as_ref() {\n                Expr::Ident(name) => name == \"setupProperty\",\n                Expr::Member(member_expr) => member_expr.member == \"setupProperty\",\n                _ => false,\n            };\n\n            if is_setup_property && !call_expr.args.is_empty() {\n                // First argument is the property key (symbol)\n                if let Expr::Symbol(key) = &call_expr.args[0] {\n                    let prop_name = key.to_uppercase();\n\n                    // Second argument is usually an array with property definition\n                    let (label, prop_type) = if call_expr.args.len() > 1 {\n                        parse_property_def_from_expr(&call_expr.args[1])\n                    } else {\n                        (prop_name.clone(), PropertyType::String)\n                    };\n\n                    let prop_def = PropertyDef::new(&prop_name, &label, prop_type);\n                    properties.register(prop_def);\n                }\n            }\n\n            // Also check nested calls\n            for arg in &call_expr.args {\n                extract_setup_properties_from_expr(arg, properties);\n            }\n        }\n        Expr::Member(member_expr) => {\n            extract_setup_properties_from_expr(&member_expr.object, properties);\n        }\n        _ => {}\n    }\n}\n\n/// Parse property definition from array expression\nfn parse_property_def_from_expr(expr: &Expr) -> (String, PropertyType) {\n    if let Expr::Array(elements) = expr {\n        let mut label = String::new();\n        let mut prop_type = PropertyType::String;\n        let mut options: Vec<String> = Vec::new();\n        let mut min_val: Option<i64> = None;\n        let mut max_val: Option<i64> = None;\n\n        for (i, elem) in elements.iter().enumerate() {\n            match elem {\n                Expr::String(s) => {\n                    if i == 0 || i == 1 {\n                        // First or second string is the label\n                        if label.is_empty() {\n                            label = s.clone();\n                        }\n                    }\n                }\n                Expr::Symbol(s) => {\n                    let upper = s.to_uppercase();\n                    match upper.as_str() {\n                        \"INT\" | \"INTEGER\" => {\n                            prop_type = PropertyType::Int {\n                                min: None,\n                                max: None,\n                            };\n                        }\n                        \"FLOAT\" | \"REAL\" => {\n                            prop_type = PropertyType::Float {\n                                min: None,\n                                max: None,\n                            };\n                        }\n                        \"BOOL\" | \"BOOLEAN\" => {\n                            prop_type = PropertyType::Bool;\n                        }\n                        \"CHOICE\" | \"ENUM\" => {\n                            // Options should follow\n                        }\n                        _ => {\n                            // Could be an option value\n                            options.push(s.clone());\n                        }\n                    }\n                }\n                Expr::Array(inner) => {\n                    // Could be range [min, max] or options list\n                    if inner.len() == 2 {\n                        // Range\n                        if let (Some(min), Some(max)) =\n                            (expr_to_int(&inner[0]), expr_to_int(&inner[1]))\n                        {\n                            min_val = Some(min);\n                            max_val = Some(max);\n                        }\n                    } else {\n                        // Options list\n                        for opt in inner {\n                            if let Expr::String(s) = opt {\n                                options.push(s.clone());\n                            } else if let Expr::Symbol(s) = opt {\n                                options.push(s.clone());\n                            }\n                        }\n                    }\n                }\n                Expr::Int(n) => {\n                    // Could be min/max or default\n                    if min_val.is_none() {\n                        min_val = Some(*n);\n                    } else if max_val.is_none() {\n                        max_val = Some(*n);\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        // Finalize property type\n        if !options.is_empty() {\n            prop_type = PropertyType::Choice { options };\n        } else if let PropertyType::Int { .. } = prop_type {\n            prop_type = PropertyType::Int {\n                min: min_val,\n                max: max_val,\n            };\n        }\n\n        if label.is_empty() {\n            label = \"Unknown\".to_string();\n        }\n\n        (label, prop_type)\n    } else {\n        (\"Unknown\".to_string(), PropertyType::String)\n    }\n}\n\nfn expr_to_int(expr: &Expr) -> Option<i64> {\n    match expr {\n        Expr::Int(n) => Some(*n),\n        Expr::Float(f) => Some(*f as i64),\n        _ => None,\n    }\n}\n\n/// Generate variant code from property values\nfn generate_variant_code(properties: &PropertyManager) -> String {\n    let mut parts: Vec<String> = Vec::new();\n\n    // Sort properties by name for consistent ordering\n    let mut prop_names: Vec<_> = properties.values.keys().collect();\n    prop_names.sort();\n\n    for name in prop_names {\n        if let Some(value) = properties.values.get(name) {\n            let value_str = match value {\n                PropertyValue::Int(i) => i.to_string(),\n                PropertyValue::Float(f) => format!(\"{:.0}\", f),\n                PropertyValue::Bool(b) => if *b { \"1\" } else { \"0\" }.to_string(),\n                PropertyValue::String(s) => s.clone(),\n                PropertyValue::Symbol(s) => s.clone(),\n            };\n            parts.push(format!(\"{}={}\", name, value_str));\n        }\n    }\n\n    parts.join(\";\")\n}\n\n/// Matched price result with base, surcharges, and discounts\nstruct MatchedPrice<'a> {\n    base_price: &'a OcdPrice,\n    base_amount: Decimal,\n    surcharges: Vec<Surcharge>,\n    discounts: Vec<Surcharge>, // Using Surcharge struct for discounts too (amount is positive, we subtract)\n}\n\n/// Match prices to variant code using OCD 4.3 price_level field\n/// Uses propvalue2varcond table for direct lookup when available,\n/// otherwise falls back to pattern matching\nfn match_prices_to_variant<'a>(\n    reader: &OcdReader,\n    prices: &'a [&'a OcdPrice],\n    variant_code: &str,\n) -> Option<MatchedPrice<'a>> {\n    match_prices_to_variant_with_computed_varcond(reader, prices, variant_code, None, &[])\n}\n\n/// Match prices to variant code, with optional computed var_cond for TABLE-based manufacturers\n/// and relation-evaluated var_conds from ocd_relation rules\nfn match_prices_to_variant_with_computed_varcond<'a>(\n    reader: &OcdReader,\n    prices: &'a [&'a OcdPrice],\n    variant_code: &str,\n    computed_varcond: Option<&str>,\n    relation_varconds: &[String],\n) -> Option<MatchedPrice<'a>> {\n    // Known base price indicators (fallback for older data without price_level)\n    let base_indicators = [\"S_PGX\", \"BASE\", \"STANDARD\", \"\"];\n\n    // Extract values from variant code for matching (case-insensitive)\n    let variant_values: std::collections::HashSet<String> = variant_code\n        .split(';')\n        .filter_map(|part| part.split('=').nth(1))\n        .map(|s| s.to_uppercase())\n        .collect();\n\n    // Also keep original case values for backwards compatibility\n    let variant_values_original: std::collections::HashSet<&str> = variant_code\n        .split(';')\n        .filter_map(|part| part.split('=').nth(1))\n        .collect();\n\n    // STEP 1: Find base price\n    // First try computed var_cond (from TABLE relations) if provided\n    let base_price_opt = if let Some(computed) = computed_varcond {\n        // Use the computed var_cond to find the matching base price\n        prices.iter().find(|p| {\n            p.price_level == \"B\"\n                && !p.var_cond.is_empty()\n                && p.var_cond.eq_ignore_ascii_case(computed)\n        })\n    } else {\n        None\n    }\n    .or_else(|| {\n        // Try to match one with matching var_cond from variant values\n        // This handles manufacturers like \"fast\" where each variant has its own base price\n        prices.iter().find(|p| {\n            p.price_level == \"B\"\n                && !p.var_cond.is_empty()\n                && variant_values.contains(&p.var_cond.to_uppercase())\n        })\n    })\n    .or_else(|| {\n        // Fallback: any base price with empty var_cond or base indicators\n        prices.iter().find(|p| {\n            p.price_level == \"B\"\n                && (p.var_cond.is_empty() || base_indicators.contains(&p.var_cond.as_str()))\n        })\n    })\n    .or_else(|| {\n        // Fallback: first base price\n        prices.iter().find(|p| p.price_level == \"B\")\n    })\n    .or_else(|| {\n        // Legacy fallback: empty var_cond or known base indicators\n        prices.iter().find(|p| {\n            base_indicators\n                .iter()\n                .any(|ind| p.var_cond == *ind || p.var_cond.is_empty())\n        })\n    });\n\n    // Check if this is surcharge-only pricing (like Framery)\n    let is_surcharge_only = base_price_opt.is_none() && reader.has_surcharge_only_pricing();\n\n    // For surcharge-only pricing, use first surcharge as base reference (with zero base amount)\n    // The actual pricing will come from summing applicable surcharges\n    // Otherwise require a base price\n    let base_price = if is_surcharge_only {\n        prices.iter().find(|p| p.price_level == \"X\")\n    } else {\n        base_price_opt.or_else(|| prices.first())\n    }?;\n\n    // For surcharge-only pricing, base amount is 0 (all value comes from surcharges)\n    let base_amount = if is_surcharge_only {\n        Decimal::ZERO\n    } else {\n        Decimal::from_f32_retain(base_price.price).unwrap_or(Decimal::ZERO)\n    };\n\n    // Build variant map for heuristic matching\n    let variant_map: HashMap<&str, &str> = variant_code\n        .split(';')\n        .filter_map(|part| {\n            let mut split = part.splitn(2, '=');\n            Some((split.next()?, split.next()?))\n        })\n        .collect();\n\n    // STEP 2: Find matching surcharges (price_level='X')\n    let mut surcharges = Vec::new();\n    let mut seen_var_conds = std::collections::HashSet::new();\n\n    // Build set of expected var_conds using propvalue2varcond direct lookup\n    let direct_var_conds: std::collections::HashSet<String> = if reader.has_varcond_mappings() {\n        // Use propvalue2varcond table for direct lookup (100% accurate)\n        let values: Vec<&str> = variant_values_original.iter().copied().collect();\n        reader\n            .lookup_varconds_for_values(&values)\n            .into_iter()\n            .collect()\n    } else {\n        std::collections::HashSet::new()\n    };\n\n    // Build uppercase version of direct_var_conds for case-insensitive matching\n    let direct_var_conds_upper: std::collections::HashSet<String> =\n        direct_var_conds.iter().map(|s| s.to_uppercase()).collect();\n\n    for price in prices {\n        // Only process surcharges (price_level='X') or prices with non-empty var_cond\n        let is_surcharge = price.price_level == \"X\"\n            || (!price.var_cond.is_empty() && price.price_level != \"B\" && price.price_level != \"D\");\n\n        if !is_surcharge {\n            continue;\n        }\n\n        // Skip base price indicators and already processed\n        if base_indicators.contains(&price.var_cond.as_str()) && price.price_level != \"X\" {\n            continue;\n        }\n        if seen_var_conds.contains(&price.var_cond) {\n            continue;\n        }\n\n        // Check if var_cond matches using the best available method\n        let is_match = if reader.has_varcond_mappings() {\n            // Use direct lookup from propvalue2varcond table (preferred)\n            // Try both exact match and case-insensitive match\n            direct_var_conds.contains(&price.var_cond)\n                || direct_var_conds_upper.contains(&price.var_cond.to_uppercase())\n        } else if !relation_varconds.is_empty() {\n            // Use relation-evaluated var_conds (from ocd_relation rules like F_PREISE)\n            // This handles manufacturers like Framery that use conditional rules instead of propvalue2varcond\n            relation_varconds.iter().any(|vc| vc.eq_ignore_ascii_case(&price.var_cond))\n        } else {\n            // Fallback to pattern matching for manufacturers without mapping table\n            matches_var_cond_extended(\n                &price.var_cond,\n                variant_code,\n                &variant_values_original,\n                &variant_map,\n            )\n        };\n\n        if is_match {\n            let amount = Decimal::from_f32_retain(price.price).unwrap_or(Decimal::ZERO);\n            // Get human-readable description from ocd_pricetext, fallback to var_cond\n            let description = reader.get_price_description(price, \"DE\");\n            surcharges.push(Surcharge {\n                name: description,\n                amount,\n                is_percentage: !price.is_fix, // is_fix=1 means fixed amount, 0 means percentage\n            });\n            seen_var_conds.insert(price.var_cond.clone());\n        }\n    }\n\n    // STEP 3: Find matching discounts (price_level='D')\n    let mut discounts = Vec::new();\n    let mut seen_discount_var_conds = std::collections::HashSet::new();\n\n    for price in prices {\n        if price.price_level != \"D\" {\n            continue;\n        }\n\n        // Skip already processed discounts\n        if seen_discount_var_conds.contains(&price.var_cond) {\n            continue;\n        }\n\n        // Check if var_cond matches using the best available method\n        let is_match = if reader.has_varcond_mappings() {\n            // Use direct lookup from propvalue2varcond table (preferred)\n            direct_var_conds.contains(&price.var_cond)\n                || direct_var_conds_upper.contains(&price.var_cond.to_uppercase())\n        } else if price.var_cond.is_empty() {\n            // Empty var_cond discount applies to all\n            true\n        } else {\n            // Fallback to pattern matching for manufacturers without mapping table\n            matches_var_cond_extended(\n                &price.var_cond,\n                variant_code,\n                &variant_values_original,\n                &variant_map,\n            )\n        };\n\n        if is_match {\n            let amount = Decimal::from_f32_retain(price.price).unwrap_or(Decimal::ZERO);\n            let description = reader.get_price_description(price, \"DE\");\n            discounts.push(Surcharge {\n                name: description,\n                amount,\n                is_percentage: !price.is_fix,\n            });\n            seen_discount_var_conds.insert(price.var_cond.clone());\n        }\n    }\n\n    Some(MatchedPrice {\n        base_price,\n        base_amount,\n        surcharges,\n        discounts,\n    })\n}\n\n/// Extended matching for OCD surcharge codes\n/// Supports multiple matching strategies for manufacturer-specific formats\n/// Language-agnostic: works with any descriptive var_cond (German, English, Spanish, etc.)\nfn matches_var_cond_extended(\n    var_cond: &str,\n    variant_code: &str,\n    variant_values: &std::collections::HashSet<&str>,\n    variant_map: &HashMap<&str, &str>,\n) -> bool {\n    // Strategy 0: Direct case-insensitive match (language-agnostic descriptive names)\n    // Handles: \"PP AXA BLACK\", \"CODIGO_BASE\", \"ESTRUCTURA_01\", \"STOFFGRUPPE_3\", etc.\n    let var_cond_upper = var_cond.to_uppercase();\n    for value in variant_values {\n        if value.to_uppercase() == var_cond_upper {\n            return true;\n        }\n    }\n\n    // Strategy 0b: Price group pattern matching (PG11, PG90, GL1, MG1, etc.)\n    // These are common across manufacturers regardless of language\n    if var_cond.len() >= 2 && var_cond.len() <= 6 {\n        let prefix = &var_cond[..2].to_uppercase();\n        if prefix == \"PG\" || prefix == \"GL\" || prefix == \"MG\" {\n            // Check if any property value matches this price group\n            for value in variant_values {\n                if value.to_uppercase() == var_cond_upper {\n                    return true;\n                }\n            }\n            // Also check property values in the map\n            for value in variant_map.values() {\n                if value.to_uppercase() == var_cond_upper {\n                    return true;\n                }\n            }\n        }\n    }\n\n    // Strategy 1: Direct formula matching (KEY=value, KEY>value, etc.)\n    if matches_var_cond(var_cond, variant_code, variant_values) {\n        return true;\n    }\n\n    // Strategy 2: Sedus-style surcharge codes (S_XXXX format)\n    // Check if var_cond matches a pattern like S_<property_suffix>_<value_suffix>\n    // Example: S_166 might match when S_MODELLFARBE=166 or similar\n    if let Some(code) = var_cond.strip_prefix(\"S_\") {\n        // Try to find a matching property value\n        // Pattern 1: Direct value match (e.g., code=\"166\" matches value \"166\")\n        if variant_values.contains(code) {\n            return true;\n        }\n\n        // Pattern 2: Value ends with the code (e.g., code=\"166\" matches \"CSE166\")\n        for value in variant_values {\n            if value.ends_with(code) {\n                return true;\n            }\n        }\n\n        // Pattern 3: Embedded numeric code matching for complex values\n        // e.g., code=\"166\" matches \"XST244166018\" which contains \"166\"\n        // Only apply to short numeric codes (3-4 digits) to avoid false matches\n        if code.len() >= 3 && code.len() <= 4 && code.chars().all(|c| c.is_ascii_digit()) {\n            for value in variant_values {\n                // Check if value contains the code at a word/number boundary\n                // Look for patterns where the code is embedded in a larger string\n                if value.contains(code) && value.len() > code.len() {\n                    // Verify it's a meaningful match (not just random substring)\n                    // Accept if the value is alphanumeric and code is clearly embedded\n                    return true;\n                }\n            }\n        }\n\n        // Pattern 4: Split code by underscore for compound codes (e.g., S_2415_F2)\n        // Check if first part matches property suffix and second matches value\n        if let Some(pos) = code.find('_') {\n            let (num_part, suffix) = code.split_at(pos);\n            let suffix = &suffix[1..]; // Remove leading underscore\n\n            // Check each property for matching pattern\n            for (key, value) in variant_map {\n                // If property key ends with numeric part and value starts with suffix\n                if key.ends_with(num_part) && value.starts_with(suffix) {\n                    return true;\n                }\n                // Or if value matches the full code\n                if *value == code || value.ends_with(code) {\n                    return true;\n                }\n            }\n        }\n\n        // Pattern 5: Numeric code as property value prefix/match\n        // e.g., S_1801 matches if any property has value starting with \"1801\"\n        if code.chars().all(|c| c.is_ascii_digit()) {\n            for value in variant_values {\n                if value.starts_with(code) || *value == code {\n                    return true;\n                }\n            }\n        }\n    }\n\n    false\n}\n\n/// Check if a var_cond matches the variant code\nfn matches_var_cond(\n    var_cond: &str,\n    variant_code: &str,\n    variant_values: &std::collections::HashSet<&str>,\n) -> bool {\n    if var_cond.is_empty() {\n        return true;\n    }\n\n    // Parse var_cond conditions\n    // Format examples: \"COLOR=white\", \"WIDTH>1200\", \"WIDTH=1200;HEIGHT=720\"\n    let conditions: Vec<&str> = var_cond.split(';').collect();\n    let variant_parts: HashMap<&str, &str> = variant_code\n        .split(';')\n        .filter_map(|part| {\n            let mut split = part.splitn(2, '=');\n            Some((split.next()?, split.next()?))\n        })\n        .collect();\n\n    for cond in conditions {\n        let cond = cond.trim();\n        if cond.is_empty() {\n            continue;\n        }\n\n        // Handle different operators\n        if let Some(pos) = cond.find('=') {\n            let key = &cond[..pos];\n            let expected = &cond[pos + 1..];\n\n            if let Some(actual) = variant_parts.get(key) {\n                if *actual != expected {\n                    return false;\n                }\n            } else {\n                // Key not in variant - this condition doesn't apply\n                return false;\n            }\n        } else if cond.contains('>') {\n            // Greater than comparison\n            let parts: Vec<&str> = cond.split('>').collect();\n            if parts.len() == 2 {\n                if let Some(actual) = variant_parts.get(parts[0]) {\n                    let actual_val: i64 = actual.parse().unwrap_or(0);\n                    let expected_val: i64 = parts[1].parse().unwrap_or(0);\n                    if actual_val <= expected_val {\n                        return false;\n                    }\n                } else {\n                    return false;\n                }\n            }\n        } else if cond.contains('<') {\n            // Less than comparison\n            let parts: Vec<&str> = cond.split('<').collect();\n            if parts.len() == 2 {\n                if let Some(actual) = variant_parts.get(parts[0]) {\n                    let actual_val: i64 = actual.parse().unwrap_or(0);\n                    let expected_val: i64 = parts[1].parse().unwrap_or(0);\n                    if actual_val >= expected_val {\n                        return false;\n                    }\n                } else {\n                    return false;\n                }\n            }\n        } else {\n            // Simple identifier - check if it's one of the selected values\n            // e.g., var_cond=\"S_166\" matches if \"S_166\" is a value in the variant\n            if !variant_values.contains(cond) {\n                return false;\n            }\n        }\n    }\n\n    true\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_configuration_engine_new() {\n        let engine = ConfigurationEngine::new(\"/workspace/ofmldata\");\n        assert!(engine.oam_cache.is_empty());\n        assert!(engine.article_cache.is_empty());\n    }\n\n    #[test]\n    fn test_load_articles_with_enrichment() {\n        let mut engine = ConfigurationEngine::new(\"/workspace/ofmldata\");\n\n        // Test with vitra if available\n        let mfr_path = Path::new(\"/workspace/ofmldata/vitra\");\n        if !mfr_path.exists() {\n            return;\n        }\n\n        let articles = engine.load_articles(\"vitra\");\n        println!(\"Loaded {} articles for vitra\", articles.len());\n\n        let configurable: Vec<_> = articles.iter().filter(|a| a.is_configurable).collect();\n        let non_configurable: Vec<_> = articles.iter().filter(|a| !a.is_configurable).collect();\n\n        println!(\"  Configurable: {}\", configurable.len());\n        println!(\"  Non-configurable: {}\", non_configurable.len());\n\n        // Print a few configurable articles\n        for article in configurable.iter().take(5) {\n            println!(\n                \"  [C] {} -> {:?}\",\n                article.article.article_nr,\n                article.mapping.as_ref().map(|m| &m.ofml_type)\n            );\n        }\n    }\n\n    #[test]\n    fn test_generate_variant_code() {\n        let mut properties = PropertyManager::new();\n        properties\n            .values\n            .insert(\"WIDTH\".to_string(), PropertyValue::Int(1200));\n        properties.values.insert(\n            \"COLOR\".to_string(),\n            PropertyValue::Symbol(\"white\".to_string()),\n        );\n\n        let code = generate_variant_code(&properties);\n        assert!(code.contains(\"WIDTH=1200\"));\n        assert!(code.contains(\"COLOR=white\"));\n    }\n\n    #[test]\n    fn test_matches_var_cond() {\n        let variant = \"COLOR=white;WIDTH=1200\";\n        let values: std::collections::HashSet<&str> = variant\n            .split(';')\n            .filter_map(|part| part.split('=').nth(1))\n            .collect();\n\n        assert!(matches_var_cond(\"\", variant, &values));\n        assert!(matches_var_cond(\"COLOR=white\", variant, &values));\n        assert!(matches_var_cond(\"WIDTH=1200\", variant, &values));\n        assert!(!matches_var_cond(\"COLOR=black\", variant, &values));\n        assert!(!matches_var_cond(\"WIDTH=1800\", variant, &values));\n    }\n\n    #[test]\n    fn test_matches_var_cond_operators() {\n        let variant = \"WIDTH=1500\";\n        let values: std::collections::HashSet<&str> = variant\n            .split(';')\n            .filter_map(|part| part.split('=').nth(1))\n            .collect();\n\n        assert!(matches_var_cond(\"WIDTH>1200\", variant, &values));\n        assert!(!matches_var_cond(\"WIDTH>1800\", variant, &values));\n        assert!(matches_var_cond(\"WIDTH<1800\", variant, &values));\n        assert!(!matches_var_cond(\"WIDTH<1200\", variant, &values));\n    }\n\n    #[test]\n    fn test_sedus_surcharge_matching() {\n        // Simulate Sedus AI-121 variant code\n        let variant = \"S_STOFF=2G3;S_SITZHOEHE=1701;S_ACCESSOIRES=6103;S_LEHNE_ABW=0000\";\n        let values: std::collections::HashSet<&str> = variant\n            .split(';')\n            .filter_map(|part| part.split('=').nth(1))\n            .collect();\n        let map: HashMap<&str, &str> = variant\n            .split(';')\n            .filter_map(|part| {\n                let mut split = part.splitn(2, '=');\n                Some((split.next()?, split.next()?))\n            })\n            .collect();\n\n        // Pattern 4: Numeric code matching (S_1701 -> value starts with 1701)\n        assert!(\n            matches_var_cond_extended(\"S_1701\", variant, &values, &map),\n            \"S_1701 should match when S_SITZHOEHE=1701\"\n        );\n\n        // Pattern 4: Direct numeric match (S_6103 -> value 6103)\n        assert!(\n            matches_var_cond_extended(\"S_6103\", variant, &values, &map),\n            \"S_6103 should match when S_ACCESSOIRES=6103\"\n        );\n\n        // Should NOT match codes not in variant\n        assert!(\n            !matches_var_cond_extended(\"S_166\", variant, &values, &map),\n            \"S_166 should NOT match (no 166 value)\"\n        );\n        assert!(\n            !matches_var_cond_extended(\"S_1802\", variant, &values, &map),\n            \"S_1802 should NOT match (no 1802 value)\"\n        );\n\n        // Base price indicator should not match as surcharge\n        assert!(\n            !matches_var_cond_extended(\"S_PGX\", variant, &values, &map),\n            \"S_PGX is a base indicator, not a surcharge\"\n        );\n    }\n\n    // ========== EngineError Tests ==========\n\n    #[test]\n    fn test_engine_error_article_not_found() {\n        let err = EngineError::ArticleNotFound {\n            article: \"TEST-001\".to_string(),\n            manufacturer: \"test_mfr\".to_string(),\n        };\n        let msg = err.to_string();\n        assert!(msg.contains(\"TEST-001\"));\n        assert!(msg.contains(\"test_mfr\"));\n    }\n\n    #[test]\n    fn test_engine_error_article_not_found_simple() {\n        let err = EngineError::ArticleNotFoundSimple(\"SIMPLE-001\".to_string());\n        assert!(err.to_string().contains(\"SIMPLE-001\"));\n    }\n\n    #[test]\n    fn test_engine_error_not_configurable() {\n        let err = EngineError::NotConfigurable {\n            article: \"NC-001\".to_string(),\n        };\n        let msg = err.to_string();\n        assert!(msg.contains(\"NC-001\"));\n        assert!(msg.contains(\"not configurable\"));\n    }\n\n    #[test]\n    fn test_engine_error_class_not_found() {\n        let err = EngineError::ClassNotFound {\n            article: \"ART-001\".to_string(),\n            class: \"MyClass\".to_string(),\n        };\n        let msg = err.to_string();\n        assert!(msg.contains(\"ART-001\"));\n        assert!(msg.contains(\"MyClass\"));\n    }\n\n    #[test]\n    fn test_engine_error_property_error() {\n        let err = EngineError::PropertyError {\n            property: \"WIDTH\".to_string(),\n            message: \"Invalid value\".to_string(),\n        };\n        let msg = err.to_string();\n        assert!(msg.contains(\"WIDTH\"));\n        assert!(msg.contains(\"Invalid value\"));\n    }\n\n    #[test]\n    fn test_engine_error_price_error() {\n        let err = EngineError::PriceError {\n            article: \"ART-001\".to_string(),\n            message: \"No base price\".to_string(),\n        };\n        let msg = err.to_string();\n        assert!(msg.contains(\"ART-001\"));\n        assert!(msg.contains(\"No base price\"));\n    }\n\n    #[test]\n    fn test_engine_error_io_error() {\n        let err = EngineError::IoError {\n            path: \"/some/path\".to_string(),\n            message: \"File not found\".to_string(),\n        };\n        let msg = err.to_string();\n        assert!(msg.contains(\"/some/path\"));\n        assert!(msg.contains(\"File not found\"));\n    }\n\n    #[test]\n    fn test_engine_error_interpreter_error() {\n        let err = EngineError::InterpreterError {\n            class: \"TestClass\".to_string(),\n            message: \"Parse error\".to_string(),\n        };\n        let msg = err.to_string();\n        assert!(msg.contains(\"TestClass\"));\n        assert!(msg.contains(\"Parse error\"));\n    }\n\n    #[test]\n    fn test_engine_error_data_format_error() {\n        let err = EngineError::DataFormatError {\n            file: \"pdata.ebase\".to_string(),\n            message: \"Invalid header\".to_string(),\n        };\n        let msg = err.to_string();\n        assert!(msg.contains(\"pdata.ebase\"));\n        assert!(msg.contains(\"Invalid header\"));\n    }\n\n    #[test]\n    fn test_engine_error_missing_data() {\n        let err = EngineError::MissingData(\"Article table\".to_string());\n        assert!(err.to_string().contains(\"Article table\"));\n    }\n\n    // ========== CacheStats Tests ==========\n\n    #[test]\n    fn test_cache_stats_default() {\n        let stats = CacheStats {\n            oam_entries: 0,\n            article_entries: 0,\n            family_entries: 0,\n            ocd_entries: 0,\n        };\n        assert_eq!(stats.oam_entries, 0);\n        assert_eq!(stats.article_entries, 0);\n    }\n\n    #[test]\n    fn test_cache_stats_with_values() {\n        let stats = CacheStats {\n            oam_entries: 5,\n            article_entries: 100,\n            family_entries: 20,\n            ocd_entries: 15,\n        };\n        assert_eq!(stats.oam_entries, 5);\n        assert_eq!(stats.article_entries, 100);\n        assert_eq!(stats.family_entries, 20);\n        assert_eq!(stats.ocd_entries, 15);\n    }\n\n    // ========== EnrichedArticle Tests ==========\n\n    #[test]\n    fn test_enriched_article_to_article() {\n        let ocd_article = OcdArticle {\n            article_nr: \"TEST-001\".to_string(),\n            art_type: \"A\".to_string(),\n            manufacturer: \"test_mfr\".to_string(),\n            series: \"test_series\".to_string(),\n            short_textnr: \"1\".to_string(),\n            long_textnr: \"2\".to_string(),\n        };\n        let enriched = EnrichedArticle {\n            article: ocd_article,\n            description: \"Test Description\".to_string(),\n            is_configurable: true,\n            mapping: None,\n        };\n        let article = enriched.to_article();\n        assert_eq!(article.id, \"TEST-001\");\n        assert_eq!(article.manufacturer_id, \"test_mfr\");\n        assert_eq!(article.short_description, \"Test Description\");\n        assert!(article.has_configuration);\n    }\n\n    #[test]\n    fn test_enriched_article_non_configurable() {\n        let ocd_article = OcdArticle {\n            article_nr: \"NC-001\".to_string(),\n            art_type: \"A\".to_string(),\n            manufacturer: \"mfr\".to_string(),\n            series: \"series\".to_string(),\n            short_textnr: \"\".to_string(),\n            long_textnr: \"\".to_string(),\n        };\n        let enriched = EnrichedArticle {\n            article: ocd_article,\n            description: \"Non-configurable\".to_string(),\n            is_configurable: false,\n            mapping: None,\n        };\n        assert!(!enriched.is_configurable);\n        let article = enriched.to_article();\n        assert!(!article.has_configuration);\n    }\n\n    // ========== generate_variant_code Tests ==========\n\n    #[test]\n    fn test_generate_variant_code_empty() {\n        let properties = PropertyManager::new();\n        let code = generate_variant_code(&properties);\n        assert!(code.is_empty());\n    }\n\n    #[test]\n    fn test_generate_variant_code_bool_true() {\n        let mut properties = PropertyManager::new();\n        properties\n            .values\n            .insert(\"ENABLED\".to_string(), PropertyValue::Bool(true));\n        let code = generate_variant_code(&properties);\n        assert!(code.contains(\"ENABLED=1\"));\n    }\n\n    #[test]\n    fn test_generate_variant_code_bool_false() {\n        let mut properties = PropertyManager::new();\n        properties\n            .values\n            .insert(\"ENABLED\".to_string(), PropertyValue::Bool(false));\n        let code = generate_variant_code(&properties);\n        assert!(code.contains(\"ENABLED=0\"));\n    }\n\n    #[test]\n    fn test_generate_variant_code_float() {\n        let mut properties = PropertyManager::new();\n        properties\n            .values\n            .insert(\"HEIGHT\".to_string(), PropertyValue::Float(1.5));\n        let code = generate_variant_code(&properties);\n        assert!(code.contains(\"HEIGHT=2\")); // Rounded\n    }\n\n    #[test]\n    fn test_generate_variant_code_string() {\n        let mut properties = PropertyManager::new();\n        properties.values.insert(\n            \"MATERIAL\".to_string(),\n            PropertyValue::String(\"steel\".to_string()),\n        );\n        let code = generate_variant_code(&properties);\n        assert!(code.contains(\"MATERIAL=steel\"));\n    }\n\n    #[test]\n    fn test_generate_variant_code_sorted() {\n        let mut properties = PropertyManager::new();\n        properties\n            .values\n            .insert(\"ZEBRA\".to_string(), PropertyValue::Int(1));\n        properties\n            .values\n            .insert(\"ALPHA\".to_string(), PropertyValue::Int(2));\n        let code = generate_variant_code(&properties);\n        // Should be sorted alphabetically\n        assert!(code.starts_with(\"ALPHA=\"));\n    }\n\n    // ========== matches_var_cond_extended Tests ==========\n\n    #[test]\n    fn test_matches_var_cond_extended_direct_case_insensitive() {\n        let variant = \"COLOR=PP AXA BLACK\";\n        let values: std::collections::HashSet<&str> =\n            [\"PP AXA BLACK\"].iter().copied().collect();\n        let map: HashMap<&str, &str> = [(\"COLOR\", \"PP AXA BLACK\")].into_iter().collect();\n\n        // Direct case-insensitive match\n        assert!(matches_var_cond_extended(\n            \"PP AXA BLACK\",\n            variant,\n            &values,\n            &map\n        ));\n        assert!(matches_var_cond_extended(\n            \"pp axa black\",\n            variant,\n            &values,\n            &map\n        ));\n    }\n\n    #[test]\n    fn test_matches_var_cond_extended_price_group() {\n        let variant = \"PRICEGROUP=PG11\";\n        let values: std::collections::HashSet<&str> = [\"PG11\"].iter().copied().collect();\n        let map: HashMap<&str, &str> = [(\"PRICEGROUP\", \"PG11\")].into_iter().collect();\n\n        assert!(matches_var_cond_extended(\"PG11\", variant, &values, &map));\n        // GL prefix\n        let variant2 = \"GLASS=GL1\";\n        let values2: std::collections::HashSet<&str> = [\"GL1\"].iter().copied().collect();\n        let map2: HashMap<&str, &str> = [(\"GLASS\", \"GL1\")].into_iter().collect();\n        assert!(matches_var_cond_extended(\"GL1\", variant2, &values2, &map2));\n    }\n\n    #[test]\n    fn test_matches_var_cond_extended_sedus_style_suffix() {\n        let variant = \"FABRIC=CSE166\";\n        let values: std::collections::HashSet<&str> = [\"CSE166\"].iter().copied().collect();\n        let map: HashMap<&str, &str> = HashMap::new();\n\n        // S_166 should match value ending with \"166\"\n        assert!(matches_var_cond_extended(\"S_166\", variant, &values, &map));\n    }\n\n    #[test]\n    fn test_matches_var_cond_extended_embedded_code() {\n        let variant = \"COMPLEX=XST244166018\";\n        let values: std::collections::HashSet<&str> =\n            [\"XST244166018\"].iter().copied().collect();\n        let map: HashMap<&str, &str> = HashMap::new();\n\n        // S_166 should match value containing \"166\"\n        assert!(matches_var_cond_extended(\"S_166\", variant, &values, &map));\n    }\n\n    #[test]\n    fn test_matches_var_cond_extended_compound_code() {\n        let variant = \"S_2415=F2\";\n        let values: std::collections::HashSet<&str> = [\"F2\"].iter().copied().collect();\n        let map: HashMap<&str, &str> = [(\"S_2415\", \"F2\")].into_iter().collect();\n\n        // Compound code pattern\n        assert!(matches_var_cond_extended(\n            \"S_2415_F2\",\n            variant,\n            &values,\n            &map\n        ));\n    }\n\n    #[test]\n    fn test_matches_var_cond_extended_numeric_prefix() {\n        let variant = \"OPTION=1801A\";\n        let values: std::collections::HashSet<&str> = [\"1801A\"].iter().copied().collect();\n        let map: HashMap<&str, &str> = HashMap::new();\n\n        // S_1801 should match value starting with \"1801\"\n        assert!(matches_var_cond_extended(\"S_1801\", variant, &values, &map));\n    }\n\n    #[test]\n    fn test_matches_var_cond_extended_no_match() {\n        let variant = \"COLOR=red\";\n        let values: std::collections::HashSet<&str> = [\"red\"].iter().copied().collect();\n        let map: HashMap<&str, &str> = HashMap::new();\n\n        assert!(!matches_var_cond_extended(\n            \"S_blue\",\n            variant,\n            &values,\n            &map\n        ));\n        assert!(!matches_var_cond_extended(\n            \"S_9999\",\n            variant,\n            &values,\n            &map\n        ));\n    }\n\n    // ========== matches_var_cond Tests (additional) ==========\n\n    #[test]\n    fn test_matches_var_cond_multiple_conditions() {\n        let variant = \"COLOR=white;WIDTH=1200;HEIGHT=720\";\n        let values: std::collections::HashSet<&str> = variant\n            .split(';')\n            .filter_map(|part| part.split('=').nth(1))\n            .collect();\n\n        // All conditions must match\n        assert!(matches_var_cond(\"COLOR=white;WIDTH=1200\", variant, &values));\n        // Mixed match/no-match\n        assert!(!matches_var_cond(\n            \"COLOR=white;WIDTH=1800\",\n            variant,\n            &values\n        ));\n    }\n\n    #[test]\n    fn test_matches_var_cond_whitespace() {\n        let variant = \"COLOR=white\";\n        let values: std::collections::HashSet<&str> = [\"white\"].iter().copied().collect();\n\n        // Whitespace in conditions should be trimmed\n        assert!(matches_var_cond(\" COLOR=white \", variant, &values));\n    }\n\n    #[test]\n    fn test_matches_var_cond_identifier_in_values() {\n        let variant = \"OPTION=S_166\";\n        let values: std::collections::HashSet<&str> = [\"S_166\"].iter().copied().collect();\n\n        // S_166 as a simple identifier should match if it's a value\n        assert!(matches_var_cond(\"S_166\", variant, &values));\n    }\n\n    // ========== expr_to_int Tests ==========\n\n    #[test]\n    fn test_expr_to_int_int() {\n        let expr = Expr::Int(42);\n        assert_eq!(expr_to_int(&expr), Some(42));\n    }\n\n    #[test]\n    fn test_expr_to_int_float() {\n        let expr = Expr::Float(3.7);\n        assert_eq!(expr_to_int(&expr), Some(3));\n    }\n\n    #[test]\n    fn test_expr_to_int_string() {\n        let expr = Expr::String(\"42\".to_string());\n        assert_eq!(expr_to_int(&expr), None);\n    }\n\n    // ========== parse_property_def_from_expr Tests ==========\n\n    #[test]\n    fn test_parse_property_def_from_expr_empty_array() {\n        let expr = Expr::Array(vec![]);\n        let (label, prop_type) = parse_property_def_from_expr(&expr);\n        assert_eq!(label, \"Unknown\");\n        assert!(matches!(prop_type, PropertyType::String));\n    }\n\n    #[test]\n    fn test_parse_property_def_from_expr_with_label() {\n        let expr = Expr::Array(vec![Expr::String(\"Width\".to_string())]);\n        let (label, prop_type) = parse_property_def_from_expr(&expr);\n        assert_eq!(label, \"Width\");\n        assert!(matches!(prop_type, PropertyType::String));\n    }\n\n    #[test]\n    fn test_parse_property_def_from_expr_int_type() {\n        let expr = Expr::Array(vec![\n            Expr::String(\"Width\".to_string()),\n            Expr::Symbol(\"INT\".to_string()),\n        ]);\n        let (label, prop_type) = parse_property_def_from_expr(&expr);\n        assert_eq!(label, \"Width\");\n        assert!(matches!(prop_type, PropertyType::Int { min: None, max: None }));\n    }\n\n    #[test]\n    fn test_parse_property_def_from_expr_float_type() {\n        let expr = Expr::Array(vec![\n            Expr::String(\"Height\".to_string()),\n            Expr::Symbol(\"FLOAT\".to_string()),\n        ]);\n        let (label, prop_type) = parse_property_def_from_expr(&expr);\n        assert_eq!(label, \"Height\");\n        assert!(matches!(prop_type, PropertyType::Float { min: None, max: None }));\n    }\n\n    #[test]\n    fn test_parse_property_def_from_expr_bool_type() {\n        let expr = Expr::Array(vec![\n            Expr::String(\"Enabled\".to_string()),\n            Expr::Symbol(\"BOOL\".to_string()),\n        ]);\n        let (label, prop_type) = parse_property_def_from_expr(&expr);\n        assert_eq!(label, \"Enabled\");\n        assert!(matches!(prop_type, PropertyType::Bool));\n    }\n\n    #[test]\n    fn test_parse_property_def_from_expr_with_range() {\n        let expr = Expr::Array(vec![\n            Expr::String(\"Width\".to_string()),\n            Expr::Symbol(\"INT\".to_string()),\n            Expr::Array(vec![Expr::Int(100), Expr::Int(500)]),\n        ]);\n        let (label, prop_type) = parse_property_def_from_expr(&expr);\n        assert_eq!(label, \"Width\");\n        assert!(matches!(prop_type, PropertyType::Int { min: Some(100), max: Some(500) }));\n    }\n\n    #[test]\n    fn test_parse_property_def_from_expr_with_options() {\n        // Use 3 options to avoid being interpreted as range [min, max]\n        let expr = Expr::Array(vec![\n            Expr::String(\"Color\".to_string()),\n            Expr::Symbol(\"CHOICE\".to_string()),\n            Expr::Array(vec![\n                Expr::String(\"red\".to_string()),\n                Expr::String(\"blue\".to_string()),\n                Expr::String(\"green\".to_string()),\n            ]),\n        ]);\n        let (label, prop_type) = parse_property_def_from_expr(&expr);\n        assert_eq!(label, \"Color\");\n        if let PropertyType::Choice { options } = prop_type {\n            assert_eq!(options.len(), 3);\n            assert!(options.contains(&\"red\".to_string()));\n            assert!(options.contains(&\"blue\".to_string()));\n            assert!(options.contains(&\"green\".to_string()));\n        } else {\n            panic!(\"Expected Choice type\");\n        }\n    }\n\n    #[test]\n    fn test_parse_property_def_from_expr_not_array() {\n        let expr = Expr::String(\"not an array\".to_string());\n        let (label, prop_type) = parse_property_def_from_expr(&expr);\n        assert_eq!(label, \"Unknown\");\n        assert!(matches!(prop_type, PropertyType::String));\n    }\n\n    // ========== ConfigurationEngine Tests ==========\n\n    #[test]\n    fn test_configuration_engine_data_path() {\n        let engine = ConfigurationEngine::new(\"/test/path\");\n        assert_eq!(engine.data_path, std::path::PathBuf::from(\"/test/path\"));\n    }\n\n    #[test]\n    fn test_find_alb_files_nonexistent() {\n        let files = find_alb_files(Path::new(\"/nonexistent\"), \"series\");\n        assert!(files.is_empty());\n    }\n\n    // ========== LoadedConfiguration Tests ==========\n\n    #[test]\n    fn test_loaded_configuration_fields() {\n        let ocd_article = OcdArticle {\n            article_nr: \"ART-001\".to_string(),\n            art_type: \"A\".to_string(),\n            manufacturer: \"mfr\".to_string(),\n            series: \"series\".to_string(),\n            short_textnr: \"\".to_string(),\n            long_textnr: \"\".to_string(),\n        };\n        let enriched = EnrichedArticle {\n            article: ocd_article,\n            description: \"Test\".to_string(),\n            is_configurable: true,\n            mapping: None,\n        };\n        let config = LoadedConfiguration {\n            article: enriched,\n            manufacturer_id: \"mfr\".to_string(),\n            properties: PropertyManager::new(),\n            price: None,\n            package_path: None,\n            ofml_class: Some(\"TestClass\".to_string()),\n        };\n        assert_eq!(config.manufacturer_id, \"mfr\");\n        assert!(config.price.is_none());\n        assert_eq!(config.ofml_class.as_deref(), Some(\"TestClass\"));\n    }\n\n    // ========== RoundedPrices Tests (implicit through struct usage) ==========\n\n    #[test]\n    fn test_rounded_prices_struct() {\n        let prices = RoundedPrices {\n            base_price: rust_decimal::Decimal::from(100),\n            net_price: rust_decimal::Decimal::from(120),\n            total_price: rust_decimal::Decimal::from(142),\n        };\n        assert_eq!(prices.base_price, rust_decimal::Decimal::from(100));\n        assert_eq!(prices.net_price, rust_decimal::Decimal::from(120));\n        assert_eq!(prices.total_price, rust_decimal::Decimal::from(142));\n    }\n}\n","traces":[{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":6}},{"line":120,"address":[],"length":0,"stats":{"Line":6}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":122,"address":[],"length":0,"stats":{"Line":6}},{"line":124,"address":[],"length":0,"stats":{"Line":4}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":163,"address":[],"length":0,"stats":{"Line":3}},{"line":164,"address":[],"length":0,"stats":{"Line":12}},{"line":166,"address":[],"length":0,"stats":{"Line":9}},{"line":168,"address":[],"length":0,"stats":{"Line":6}},{"line":169,"address":[],"length":0,"stats":{"Line":3}},{"line":170,"address":[],"length":0,"stats":{"Line":3}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":0}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":772,"address":[],"length":0,"stats":{"Line":0}},{"line":773,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":799,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":806,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[],"length":0,"stats":{"Line":0}},{"line":822,"address":[],"length":0,"stats":{"Line":0}},{"line":824,"address":[],"length":0,"stats":{"Line":0}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[],"length":0,"stats":{"Line":0}},{"line":827,"address":[],"length":0,"stats":{"Line":0}},{"line":828,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":874,"address":[],"length":0,"stats":{"Line":0}},{"line":876,"address":[],"length":0,"stats":{"Line":0}},{"line":879,"address":[],"length":0,"stats":{"Line":0}},{"line":880,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[],"length":0,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":893,"address":[],"length":0,"stats":{"Line":0}},{"line":894,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":902,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":0}},{"line":904,"address":[],"length":0,"stats":{"Line":0}},{"line":906,"address":[],"length":0,"stats":{"Line":0}},{"line":907,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[],"length":0,"stats":{"Line":0}},{"line":931,"address":[],"length":0,"stats":{"Line":0}},{"line":933,"address":[],"length":0,"stats":{"Line":0}},{"line":935,"address":[],"length":0,"stats":{"Line":0}},{"line":936,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":945,"address":[],"length":0,"stats":{"Line":0}},{"line":948,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":953,"address":[],"length":0,"stats":{"Line":0}},{"line":959,"address":[],"length":0,"stats":{"Line":0}},{"line":960,"address":[],"length":0,"stats":{"Line":0}},{"line":961,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":963,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":968,"address":[],"length":0,"stats":{"Line":0}},{"line":969,"address":[],"length":0,"stats":{"Line":0}},{"line":970,"address":[],"length":0,"stats":{"Line":0}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":972,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":984,"address":[],"length":0,"stats":{"Line":0}},{"line":990,"address":[],"length":0,"stats":{"Line":0}},{"line":991,"address":[],"length":0,"stats":{"Line":0}},{"line":992,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":997,"address":[],"length":0,"stats":{"Line":0}},{"line":1002,"address":[],"length":0,"stats":{"Line":1}},{"line":1003,"address":[],"length":0,"stats":{"Line":2}},{"line":1006,"address":[],"length":0,"stats":{"Line":4}},{"line":1007,"address":[],"length":0,"stats":{"Line":1}},{"line":1008,"address":[],"length":0,"stats":{"Line":0}},{"line":1011,"address":[],"length":0,"stats":{"Line":1}},{"line":1014,"address":[],"length":0,"stats":{"Line":0}},{"line":1015,"address":[],"length":0,"stats":{"Line":0}},{"line":1016,"address":[],"length":0,"stats":{"Line":0}},{"line":1017,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":0}},{"line":1019,"address":[],"length":0,"stats":{"Line":0}},{"line":1020,"address":[],"length":0,"stats":{"Line":0}},{"line":1021,"address":[],"length":0,"stats":{"Line":0}},{"line":1028,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1035,"address":[],"length":0,"stats":{"Line":0}},{"line":1036,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":0}},{"line":1039,"address":[],"length":0,"stats":{"Line":0}},{"line":1040,"address":[],"length":0,"stats":{"Line":0}},{"line":1041,"address":[],"length":0,"stats":{"Line":0}},{"line":1045,"address":[],"length":0,"stats":{"Line":0}},{"line":1046,"address":[],"length":0,"stats":{"Line":0}},{"line":1047,"address":[],"length":0,"stats":{"Line":0}},{"line":1050,"address":[],"length":0,"stats":{"Line":0}},{"line":1051,"address":[],"length":0,"stats":{"Line":0}},{"line":1053,"address":[],"length":0,"stats":{"Line":0}},{"line":1054,"address":[],"length":0,"stats":{"Line":0}},{"line":1062,"address":[],"length":0,"stats":{"Line":0}},{"line":1066,"address":[],"length":0,"stats":{"Line":0}},{"line":1067,"address":[],"length":0,"stats":{"Line":0}},{"line":1068,"address":[],"length":0,"stats":{"Line":0}},{"line":1069,"address":[],"length":0,"stats":{"Line":0}},{"line":1070,"address":[],"length":0,"stats":{"Line":0}},{"line":1072,"address":[],"length":0,"stats":{"Line":0}},{"line":1073,"address":[],"length":0,"stats":{"Line":0}},{"line":1074,"address":[],"length":0,"stats":{"Line":0}},{"line":1076,"address":[],"length":0,"stats":{"Line":0}},{"line":1077,"address":[],"length":0,"stats":{"Line":0}},{"line":1078,"address":[],"length":0,"stats":{"Line":0}},{"line":1082,"address":[],"length":0,"stats":{"Line":0}},{"line":1083,"address":[],"length":0,"stats":{"Line":0}},{"line":1085,"address":[],"length":0,"stats":{"Line":0}},{"line":1091,"address":[],"length":0,"stats":{"Line":0}},{"line":1092,"address":[],"length":0,"stats":{"Line":0}},{"line":1093,"address":[],"length":0,"stats":{"Line":0}},{"line":1095,"address":[],"length":0,"stats":{"Line":0}},{"line":1096,"address":[],"length":0,"stats":{"Line":0}},{"line":1097,"address":[],"length":0,"stats":{"Line":0}},{"line":1098,"address":[],"length":0,"stats":{"Line":0}},{"line":1101,"address":[],"length":0,"stats":{"Line":0}},{"line":1103,"address":[],"length":0,"stats":{"Line":0}},{"line":1104,"address":[],"length":0,"stats":{"Line":0}},{"line":1107,"address":[],"length":0,"stats":{"Line":0}},{"line":1108,"address":[],"length":0,"stats":{"Line":0}},{"line":1110,"address":[],"length":0,"stats":{"Line":0}},{"line":1113,"address":[],"length":0,"stats":{"Line":0}},{"line":1114,"address":[],"length":0,"stats":{"Line":0}},{"line":1119,"address":[],"length":0,"stats":{"Line":0}},{"line":1120,"address":[],"length":0,"stats":{"Line":0}},{"line":1123,"address":[],"length":0,"stats":{"Line":0}},{"line":1124,"address":[],"length":0,"stats":{"Line":0}},{"line":1126,"address":[],"length":0,"stats":{"Line":0}},{"line":1131,"address":[],"length":0,"stats":{"Line":8}},{"line":1132,"address":[],"length":0,"stats":{"Line":15}},{"line":1133,"address":[],"length":0,"stats":{"Line":14}},{"line":1134,"address":[],"length":0,"stats":{"Line":14}},{"line":1135,"address":[],"length":0,"stats":{"Line":21}},{"line":1136,"address":[],"length":0,"stats":{"Line":21}},{"line":1137,"address":[],"length":0,"stats":{"Line":21}},{"line":1139,"address":[],"length":0,"stats":{"Line":40}},{"line":1140,"address":[],"length":0,"stats":{"Line":13}},{"line":1141,"address":[],"length":0,"stats":{"Line":6}},{"line":1142,"address":[],"length":0,"stats":{"Line":6}},{"line":1144,"address":[],"length":0,"stats":{"Line":18}},{"line":1145,"address":[],"length":0,"stats":{"Line":12}},{"line":1149,"address":[],"length":0,"stats":{"Line":5}},{"line":1150,"address":[],"length":0,"stats":{"Line":10}},{"line":1151,"address":[],"length":0,"stats":{"Line":5}},{"line":1152,"address":[],"length":0,"stats":{"Line":10}},{"line":1153,"address":[],"length":0,"stats":{"Line":4}},{"line":1154,"address":[],"length":0,"stats":{"Line":2}},{"line":1155,"address":[],"length":0,"stats":{"Line":2}},{"line":1158,"address":[],"length":0,"stats":{"Line":6}},{"line":1159,"address":[],"length":0,"stats":{"Line":2}},{"line":1160,"address":[],"length":0,"stats":{"Line":1}},{"line":1161,"address":[],"length":0,"stats":{"Line":1}},{"line":1164,"address":[],"length":0,"stats":{"Line":4}},{"line":1165,"address":[],"length":0,"stats":{"Line":1}},{"line":1167,"address":[],"length":0,"stats":{"Line":2}},{"line":1170,"address":[],"length":0,"stats":{"Line":0}},{"line":1172,"address":[],"length":0,"stats":{"Line":0}},{"line":1176,"address":[],"length":0,"stats":{"Line":2}},{"line":1178,"address":[],"length":0,"stats":{"Line":2}},{"line":1180,"address":[],"length":0,"stats":{"Line":2}},{"line":1181,"address":[],"length":0,"stats":{"Line":4}},{"line":1183,"address":[],"length":0,"stats":{"Line":1}},{"line":1184,"address":[],"length":0,"stats":{"Line":1}},{"line":1188,"address":[],"length":0,"stats":{"Line":7}},{"line":1189,"address":[],"length":0,"stats":{"Line":9}},{"line":1190,"address":[],"length":0,"stats":{"Line":9}},{"line":1191,"address":[],"length":0,"stats":{"Line":3}},{"line":1192,"address":[],"length":0,"stats":{"Line":0}},{"line":1197,"address":[],"length":0,"stats":{"Line":0}},{"line":1199,"address":[],"length":0,"stats":{"Line":0}},{"line":1200,"address":[],"length":0,"stats":{"Line":0}},{"line":1201,"address":[],"length":0,"stats":{"Line":0}},{"line":1202,"address":[],"length":0,"stats":{"Line":0}},{"line":1205,"address":[],"length":0,"stats":{"Line":0}},{"line":1210,"address":[],"length":0,"stats":{"Line":8}},{"line":1211,"address":[],"length":0,"stats":{"Line":1}},{"line":1212,"address":[],"length":0,"stats":{"Line":9}},{"line":1213,"address":[],"length":0,"stats":{"Line":4}},{"line":1214,"address":[],"length":0,"stats":{"Line":2}},{"line":1215,"address":[],"length":0,"stats":{"Line":2}},{"line":1219,"address":[],"length":0,"stats":{"Line":15}},{"line":1220,"address":[],"length":0,"stats":{"Line":2}},{"line":1223,"address":[],"length":0,"stats":{"Line":7}},{"line":1225,"address":[],"length":0,"stats":{"Line":2}},{"line":1229,"address":[],"length":0,"stats":{"Line":5}},{"line":1230,"address":[],"length":0,"stats":{"Line":5}},{"line":1231,"address":[],"length":0,"stats":{"Line":6}},{"line":1232,"address":[],"length":0,"stats":{"Line":2}},{"line":1233,"address":[],"length":0,"stats":{"Line":1}},{"line":1238,"address":[],"length":0,"stats":{"Line":7}},{"line":1239,"address":[],"length":0,"stats":{"Line":21}},{"line":1242,"address":[],"length":0,"stats":{"Line":35}},{"line":1243,"address":[],"length":0,"stats":{"Line":7}},{"line":1245,"address":[],"length":0,"stats":{"Line":23}},{"line":1246,"address":[],"length":0,"stats":{"Line":24}},{"line":1247,"address":[],"length":0,"stats":{"Line":16}},{"line":1248,"address":[],"length":0,"stats":{"Line":9}},{"line":1249,"address":[],"length":0,"stats":{"Line":3}},{"line":1250,"address":[],"length":0,"stats":{"Line":8}},{"line":1251,"address":[],"length":0,"stats":{"Line":3}},{"line":1252,"address":[],"length":0,"stats":{"Line":3}},{"line":1254,"address":[],"length":0,"stats":{"Line":32}},{"line":1258,"address":[],"length":0,"stats":{"Line":14}},{"line":1272,"address":[],"length":0,"stats":{"Line":0}},{"line":1277,"address":[],"length":0,"stats":{"Line":0}},{"line":1282,"address":[],"length":0,"stats":{"Line":0}},{"line":1290,"address":[],"length":0,"stats":{"Line":0}},{"line":1293,"address":[],"length":0,"stats":{"Line":0}},{"line":1295,"address":[],"length":0,"stats":{"Line":0}},{"line":1296,"address":[],"length":0,"stats":{"Line":0}},{"line":1300,"address":[],"length":0,"stats":{"Line":0}},{"line":1302,"address":[],"length":0,"stats":{"Line":0}},{"line":1307,"address":[],"length":0,"stats":{"Line":0}},{"line":1309,"address":[],"length":0,"stats":{"Line":0}},{"line":1310,"address":[],"length":0,"stats":{"Line":0}},{"line":1311,"address":[],"length":0,"stats":{"Line":0}},{"line":1312,"address":[],"length":0,"stats":{"Line":0}},{"line":1315,"address":[],"length":0,"stats":{"Line":0}},{"line":1317,"address":[],"length":0,"stats":{"Line":0}},{"line":1320,"address":[],"length":0,"stats":{"Line":0}},{"line":1321,"address":[],"length":0,"stats":{"Line":0}},{"line":1322,"address":[],"length":0,"stats":{"Line":0}},{"line":1323,"address":[],"length":0,"stats":{"Line":0}},{"line":1326,"address":[],"length":0,"stats":{"Line":0}},{"line":1328,"address":[],"length":0,"stats":{"Line":0}},{"line":1329,"address":[],"length":0,"stats":{"Line":0}},{"line":1330,"address":[],"length":0,"stats":{"Line":0}},{"line":1333,"address":[],"length":0,"stats":{"Line":0}},{"line":1335,"address":[],"length":0,"stats":{"Line":0}},{"line":1337,"address":[],"length":0,"stats":{"Line":0}},{"line":1339,"address":[],"length":0,"stats":{"Line":0}},{"line":1340,"address":[],"length":0,"stats":{"Line":0}},{"line":1341,"address":[],"length":0,"stats":{"Line":0}},{"line":1342,"address":[],"length":0,"stats":{"Line":0}},{"line":1347,"address":[],"length":0,"stats":{"Line":0}},{"line":1352,"address":[],"length":0,"stats":{"Line":0}},{"line":1353,"address":[],"length":0,"stats":{"Line":0}},{"line":1355,"address":[],"length":0,"stats":{"Line":0}},{"line":1359,"address":[],"length":0,"stats":{"Line":0}},{"line":1360,"address":[],"length":0,"stats":{"Line":0}},{"line":1362,"address":[],"length":0,"stats":{"Line":0}},{"line":1366,"address":[],"length":0,"stats":{"Line":0}},{"line":1368,"address":[],"length":0,"stats":{"Line":0}},{"line":1369,"address":[],"length":0,"stats":{"Line":0}},{"line":1370,"address":[],"length":0,"stats":{"Line":0}},{"line":1375,"address":[],"length":0,"stats":{"Line":0}},{"line":1376,"address":[],"length":0,"stats":{"Line":0}},{"line":1379,"address":[],"length":0,"stats":{"Line":0}},{"line":1381,"address":[],"length":0,"stats":{"Line":0}},{"line":1382,"address":[],"length":0,"stats":{"Line":0}},{"line":1383,"address":[],"length":0,"stats":{"Line":0}},{"line":1387,"address":[],"length":0,"stats":{"Line":0}},{"line":1391,"address":[],"length":0,"stats":{"Line":0}},{"line":1392,"address":[],"length":0,"stats":{"Line":0}},{"line":1394,"address":[],"length":0,"stats":{"Line":0}},{"line":1396,"address":[],"length":0,"stats":{"Line":0}},{"line":1397,"address":[],"length":0,"stats":{"Line":0}},{"line":1399,"address":[],"length":0,"stats":{"Line":0}},{"line":1400,"address":[],"length":0,"stats":{"Line":0}},{"line":1404,"address":[],"length":0,"stats":{"Line":0}},{"line":1405,"address":[],"length":0,"stats":{"Line":0}},{"line":1407,"address":[],"length":0,"stats":{"Line":0}},{"line":1408,"address":[],"length":0,"stats":{"Line":0}},{"line":1412,"address":[],"length":0,"stats":{"Line":0}},{"line":1415,"address":[],"length":0,"stats":{"Line":0}},{"line":1416,"address":[],"length":0,"stats":{"Line":0}},{"line":1417,"address":[],"length":0,"stats":{"Line":0}},{"line":1420,"address":[],"length":0,"stats":{"Line":0}},{"line":1424,"address":[],"length":0,"stats":{"Line":0}},{"line":1425,"address":[],"length":0,"stats":{"Line":0}},{"line":1426,"address":[],"length":0,"stats":{"Line":0}},{"line":1427,"address":[],"length":0,"stats":{"Line":0}},{"line":1431,"address":[],"length":0,"stats":{"Line":0}},{"line":1432,"address":[],"length":0,"stats":{"Line":0}},{"line":1434,"address":[],"length":0,"stats":{"Line":0}},{"line":1435,"address":[],"length":0,"stats":{"Line":0}},{"line":1436,"address":[],"length":0,"stats":{"Line":0}},{"line":1437,"address":[],"length":0,"stats":{"Line":0}},{"line":1438,"address":[],"length":0,"stats":{"Line":0}},{"line":1440,"address":[],"length":0,"stats":{"Line":0}},{"line":1445,"address":[],"length":0,"stats":{"Line":0}},{"line":1446,"address":[],"length":0,"stats":{"Line":0}},{"line":1448,"address":[],"length":0,"stats":{"Line":0}},{"line":1449,"address":[],"length":0,"stats":{"Line":0}},{"line":1450,"address":[],"length":0,"stats":{"Line":0}},{"line":1454,"address":[],"length":0,"stats":{"Line":0}},{"line":1455,"address":[],"length":0,"stats":{"Line":0}},{"line":1459,"address":[],"length":0,"stats":{"Line":0}},{"line":1461,"address":[],"length":0,"stats":{"Line":0}},{"line":1462,"address":[],"length":0,"stats":{"Line":0}},{"line":1463,"address":[],"length":0,"stats":{"Line":0}},{"line":1465,"address":[],"length":0,"stats":{"Line":0}},{"line":1469,"address":[],"length":0,"stats":{"Line":0}},{"line":1470,"address":[],"length":0,"stats":{"Line":0}},{"line":1471,"address":[],"length":0,"stats":{"Line":0}},{"line":1472,"address":[],"length":0,"stats":{"Line":0}},{"line":1476,"address":[],"length":0,"stats":{"Line":0}},{"line":1477,"address":[],"length":0,"stats":{"Line":0}},{"line":1478,"address":[],"length":0,"stats":{"Line":0}},{"line":1479,"address":[],"length":0,"stats":{"Line":0}},{"line":1480,"address":[],"length":0,"stats":{"Line":0}},{"line":1481,"address":[],"length":0,"stats":{"Line":0}},{"line":1482,"address":[],"length":0,"stats":{"Line":0}},{"line":1484,"address":[],"length":0,"stats":{"Line":0}},{"line":1488,"address":[],"length":0,"stats":{"Line":0}},{"line":1489,"address":[],"length":0,"stats":{"Line":0}},{"line":1490,"address":[],"length":0,"stats":{"Line":0}},{"line":1491,"address":[],"length":0,"stats":{"Line":0}},{"line":1492,"address":[],"length":0,"stats":{"Line":0}},{"line":1499,"address":[],"length":0,"stats":{"Line":15}},{"line":1507,"address":[],"length":0,"stats":{"Line":45}},{"line":1508,"address":[],"length":0,"stats":{"Line":71}},{"line":1509,"address":[],"length":0,"stats":{"Line":30}},{"line":1510,"address":[],"length":0,"stats":{"Line":4}},{"line":1516,"address":[],"length":0,"stats":{"Line":22}},{"line":1517,"address":[],"length":0,"stats":{"Line":20}},{"line":1518,"address":[],"length":0,"stats":{"Line":30}},{"line":1520,"address":[],"length":0,"stats":{"Line":0}},{"line":1521,"address":[],"length":0,"stats":{"Line":0}},{"line":1522,"address":[],"length":0,"stats":{"Line":0}},{"line":1526,"address":[],"length":0,"stats":{"Line":0}},{"line":1527,"address":[],"length":0,"stats":{"Line":0}},{"line":1528,"address":[],"length":0,"stats":{"Line":0}},{"line":1535,"address":[],"length":0,"stats":{"Line":44}},{"line":1536,"address":[],"length":0,"stats":{"Line":0}},{"line":1542,"address":[],"length":0,"stats":{"Line":22}},{"line":1545,"address":[],"length":0,"stats":{"Line":33}},{"line":1546,"address":[],"length":0,"stats":{"Line":2}},{"line":1550,"address":[],"length":0,"stats":{"Line":44}},{"line":1551,"address":[],"length":0,"stats":{"Line":54}},{"line":1552,"address":[],"length":0,"stats":{"Line":1}},{"line":1559,"address":[],"length":0,"stats":{"Line":70}},{"line":1560,"address":[],"length":0,"stats":{"Line":25}},{"line":1563,"address":[],"length":0,"stats":{"Line":39}},{"line":1566,"address":[],"length":0,"stats":{"Line":2}},{"line":1573,"address":[],"length":0,"stats":{"Line":7}},{"line":1574,"address":[],"length":0,"stats":{"Line":4}},{"line":1575,"address":[],"length":0,"stats":{"Line":2}},{"line":1578,"address":[],"length":0,"stats":{"Line":3}},{"line":1580,"address":[],"length":0,"stats":{"Line":6}},{"line":1581,"address":[],"length":0,"stats":{"Line":1}},{"line":1584,"address":[],"length":0,"stats":{"Line":0}},{"line":1585,"address":[],"length":0,"stats":{"Line":0}},{"line":1592,"address":[],"length":0,"stats":{"Line":36}},{"line":1593,"address":[],"length":0,"stats":{"Line":21}},{"line":1594,"address":[],"length":0,"stats":{"Line":36}},{"line":1595,"address":[],"length":0,"stats":{"Line":0}},{"line":1601,"address":[],"length":0,"stats":{"Line":5}},{"line":1605,"address":[],"length":0,"stats":{"Line":24}},{"line":1610,"address":[],"length":0,"stats":{"Line":48}},{"line":1611,"address":[],"length":0,"stats":{"Line":1}},{"line":1616,"address":[],"length":0,"stats":{"Line":115}},{"line":1617,"address":[],"length":0,"stats":{"Line":69}},{"line":1619,"address":[],"length":0,"stats":{"Line":69}},{"line":1620,"address":[],"length":0,"stats":{"Line":138}},{"line":1621,"address":[],"length":0,"stats":{"Line":184}},{"line":1625,"address":[],"length":0,"stats":{"Line":57}},{"line":1626,"address":[],"length":0,"stats":{"Line":75}},{"line":1627,"address":[],"length":0,"stats":{"Line":50}},{"line":1628,"address":[],"length":0,"stats":{"Line":0}},{"line":1632,"address":[],"length":0,"stats":{"Line":34}},{"line":1633,"address":[],"length":0,"stats":{"Line":18}},{"line":1634,"address":[],"length":0,"stats":{"Line":18}},{"line":1636,"address":[],"length":0,"stats":{"Line":27}},{"line":1637,"address":[],"length":0,"stats":{"Line":9}},{"line":1638,"address":[],"length":0,"stats":{"Line":3}},{"line":1642,"address":[],"length":0,"stats":{"Line":0}},{"line":1644,"address":[],"length":0,"stats":{"Line":32}},{"line":1646,"address":[],"length":0,"stats":{"Line":10}},{"line":1647,"address":[],"length":0,"stats":{"Line":2}},{"line":1648,"address":[],"length":0,"stats":{"Line":8}},{"line":1649,"address":[],"length":0,"stats":{"Line":10}},{"line":1650,"address":[],"length":0,"stats":{"Line":10}},{"line":1651,"address":[],"length":0,"stats":{"Line":2}},{"line":1652,"address":[],"length":0,"stats":{"Line":1}},{"line":1655,"address":[],"length":0,"stats":{"Line":0}},{"line":1658,"address":[],"length":0,"stats":{"Line":28}},{"line":1660,"address":[],"length":0,"stats":{"Line":10}},{"line":1661,"address":[],"length":0,"stats":{"Line":2}},{"line":1662,"address":[],"length":0,"stats":{"Line":8}},{"line":1663,"address":[],"length":0,"stats":{"Line":10}},{"line":1664,"address":[],"length":0,"stats":{"Line":10}},{"line":1665,"address":[],"length":0,"stats":{"Line":2}},{"line":1666,"address":[],"length":0,"stats":{"Line":1}},{"line":1669,"address":[],"length":0,"stats":{"Line":0}},{"line":1675,"address":[],"length":0,"stats":{"Line":24}},{"line":1676,"address":[],"length":0,"stats":{"Line":11}},{"line":1681,"address":[],"length":0,"stats":{"Line":7}}],"covered":149,"coverable":723},{"path":["/","workspace","crates","ofml-lib","src","oap","families.rs"],"content":"//! Product Family Loader - Groups articles into configurable product families\n//!\n//! Instead of showing hundreds of individual article SKUs, this module groups\n//! them into product families that users can configure with options.\n\nuse std::collections::HashMap;\nuse std::path::Path;\n\nuse serde::{Deserialize, Serialize};\n\nuse super::oam::{load_manufacturer_oam, OamData};\nuse super::ocd::{\n    load_article_property_classes, load_articles_with_full_descriptions, ArticleWithDescriptions,\n};\nuse super::ocd_properties::{load_manufacturer_properties, OcdPropertyReader, OcdPropertyValue};\n\n/// A product family - a group of related articles with configuration options\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProductFamily {\n    /// Unique identifier (typically base article or series code)\n    pub id: String,\n    /// Display name\n    pub name: String,\n    /// Short description (from ocd_artshorttext)\n    pub description: String,\n    /// Long description (from ocd_artlongtext)\n    pub long_description: String,\n    /// Series identifier\n    pub series: String,\n    /// Base article number (for price lookup)\n    pub base_article_nr: String,\n    /// Property classes for configuration (articles can belong to multiple classes)\n    pub prop_classes: Vec<String>,\n    /// Number of variants/articles in this family\n    pub variant_count: usize,\n    /// Whether this family has configuration options\n    pub is_configurable: bool,\n    /// All article numbers in this family\n    pub article_nrs: Vec<String>,\n    /// Article short descriptions (parallel to article_nrs)\n    pub article_descriptions: Vec<String>,\n    /// Article long descriptions (parallel to article_nrs)\n    pub article_long_descriptions: Vec<String>,\n}\n\n/// A configurable property for a product family\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FamilyProperty {\n    /// Property key/identifier\n    pub key: String,\n    /// Display label\n    pub label: String,\n    /// Property group (for UI sections) - internal key\n    pub group: String,\n    /// Human-readable group label (from ocd_propgrouptext or ocd_propclasstext)\n    pub group_label: String,\n    /// Property type\n    pub prop_type: PropertyType,\n    /// Whether this property is required\n    pub required: bool,\n    /// Available options\n    pub options: Vec<PropertyOption>,\n    /// Default value\n    pub default_value: Option<String>,\n    /// Display order\n    pub position: u16,\n    /// Hint text for this property (tooltip/help)\n    pub hint: Option<String>,\n}\n\n/// Type of property\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum PropertyType {\n    /// Selection from a list\n    Choice,\n    /// Numeric range\n    Range { min: f64, max: f64, step: f64 },\n    /// Integer value\n    Integer { min: i64, max: i64 },\n    /// Boolean toggle\n    Boolean,\n    /// Free text\n    Text,\n}\n\n/// An option for a choice property\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PropertyOption {\n    /// Value code\n    pub value: String,\n    /// Display label\n    pub label: String,\n    /// Whether this is the default\n    pub is_default: bool,\n}\n\n/// Product Family Loader - loads and manages product families\npub struct FamilyLoader {\n    /// Loaded product families\n    pub families: Vec<ProductFamily>,\n    /// OCD property data\n    pub properties: OcdPropertyReader,\n    /// OAM data for configurability check\n    pub oam: OamData,\n    /// Language for text lookups\n    language: String,\n}\n\nimpl FamilyLoader {\n    /// Load product families for a manufacturer\n    pub fn load(manufacturer_path: &Path, language: &str) -> Self {\n        // Load property data and OAM data in parallel\n        let (properties, oam) = rayon::join(\n            || load_manufacturer_properties(manufacturer_path),\n            || load_manufacturer_oam(manufacturer_path),\n        );\n\n        // Load and group articles\n        let families =\n            Self::group_articles_into_families(manufacturer_path, &properties, &oam, language);\n\n        Self {\n            families,\n            properties,\n            oam,\n            language: language.to_string(),\n        }\n    }\n\n    /// Group articles into product families\n    fn group_articles_into_families(\n        manufacturer_path: &Path,\n        properties: &OcdPropertyReader,\n        oam: &OamData,\n        language: &str,\n    ) -> Vec<ProductFamily> {\n        // Load articles and property class mappings in parallel\n        let (articles_with_desc, article_prop_class_map) = rayon::join(\n            || load_articles_with_full_descriptions(manufacturer_path, language),\n            || load_article_property_classes(manufacturer_path),\n        );\n\n        // Filter out internal and invalid articles\n        let articles: Vec<_> = articles_with_desc\n            .into_iter()\n            .filter(|awd| {\n                let art = &awd.article;\n                // Skip internal articles\n                if art.article_nr.starts_with('@') {\n                    return false;\n                }\n                // Skip articles with control characters in series\n                if art.series.chars().any(|c| c.is_control()) {\n                    return false;\n                }\n                // Skip articles with non-ASCII series (encoding issues)\n                if !art\n                    .series\n                    .chars()\n                    .all(|c| c.is_ascii_alphanumeric() || c == '_' || c == '-')\n                {\n                    return false;\n                }\n                // Skip empty series\n                if art.series.is_empty() {\n                    return false;\n                }\n                true\n            })\n            .collect();\n\n        // Group by series\n        let mut series_groups: HashMap<String, Vec<ArticleWithDescriptions>> = HashMap::new();\n        for awd in articles {\n            series_groups\n                .entry(awd.article.series.clone())\n                .or_default()\n                .push(awd);\n        }\n\n        // Convert groups to families\n        let mut families: Vec<ProductFamily> = series_groups\n            .into_iter()\n            .filter(|(series, articles)| !series.is_empty() && !articles.is_empty())\n            .map(|(series, articles)| {\n                // Find best description - prefer one that doesn't look like an article number\n                let best_article = articles\n                    .iter()\n                    .map(|awd| {\n                        // Score the description - higher is better\n                        let desc = &awd.short_description;\n                        let score = if desc.is_empty() || desc == &awd.article.article_nr {\n                            0\n                        } else if desc.chars().all(|c| c.is_ascii_digit()) {\n                            1 // Just numbers - probably article number\n                        } else if desc.len() < 5 {\n                            2 // Too short\n                        } else {\n                            10 + desc.len().min(50) // Longer descriptions are better\n                        };\n                        (awd, score)\n                    })\n                    .max_by_key(|(_, score)| *score)\n                    .map(|(awd, _)| awd);\n\n                let name = best_article\n                    .as_ref()\n                    .filter(|awd| !awd.short_description.chars().all(|c| c.is_ascii_digit()))\n                    .map(|awd| Self::extract_family_name(&awd.short_description))\n                    .unwrap_or_else(|| format!(\"Serie {}\", series));\n\n                let description = best_article\n                    .map(|a| a.short_description.clone())\n                    .unwrap_or_default();\n                let long_description = best_article\n                    .map(|a| a.long_description.clone())\n                    .unwrap_or_default();\n\n                // Check if any article is configurable\n                let is_configurable = articles\n                    .iter()\n                    .any(|awd| oam.has_mapping(&awd.article.article_nr));\n\n                // Get ALL property classes from article-to-property-class mapping\n                // Articles can belong to multiple property classes (e.g., CHAT BOARD articles)\n                let mut prop_classes: Vec<String> = Vec::new();\n                let mut seen_classes = std::collections::HashSet::new();\n\n                for awd in &articles {\n                    if let Some(classes) = article_prop_class_map.get(&awd.article.article_nr) {\n                        for pc in classes {\n                            // Only add classes that have properties defined and haven't been seen\n                            // Note: insert() returns true if value was not present\n                            if !properties.get_properties_for_class(pc).is_empty()\n                                && seen_classes.insert(pc.clone())\n                            {\n                                prop_classes.push(pc.clone());\n                            }\n                        }\n                    }\n                }\n\n                // Fallback to old matching strategies if no mapping found\n                if prop_classes.is_empty() {\n                    let all_prop_classes = properties.get_property_classes();\n                    if let Some(pc) = all_prop_classes\n                        .iter()\n                        .filter(|pc| !properties.get_properties_for_class(pc).is_empty())\n                        .find(|pc| pc.to_uppercase() == series.to_uppercase())\n                    {\n                        prop_classes.push(pc.to_string());\n                    }\n                }\n\n                // Use first article as base\n                let base_article_nr = articles\n                    .iter()\n                    .min_by_key(|awd| &awd.article.article_nr)\n                    .map(|awd| awd.article.article_nr.clone())\n                    .unwrap_or_default();\n\n                // Collect article data and sort by article number\n                // Avoid cloning the entire EnrichedArticle vector\n                let mut article_data: Vec<_> = articles\n                    .iter()\n                    .map(|awd| {\n                        (\n                            awd.article.article_nr.clone(),\n                            awd.short_description.clone(),\n                            awd.long_description.clone(),\n                        )\n                    })\n                    .collect();\n                article_data.sort_by(|a, b| a.0.cmp(&b.0));\n\n                let (article_nrs, article_descriptions, article_long_descriptions): (\n                    Vec<_>,\n                    Vec<_>,\n                    Vec<_>,\n                ) = article_data.into_iter().fold(\n                    (Vec::new(), Vec::new(), Vec::new()),\n                    |(mut nrs, mut descs, mut long_descs), (nr, desc, long_desc)| {\n                        nrs.push(nr);\n                        descs.push(desc);\n                        long_descs.push(long_desc);\n                        (nrs, descs, long_descs)\n                    },\n                );\n\n                ProductFamily {\n                    id: series.clone(),\n                    name,\n                    description,\n                    long_description,\n                    series: series.clone(),\n                    base_article_nr,\n                    prop_classes,\n                    variant_count: articles.len(),\n                    is_configurable,\n                    article_nrs,\n                    article_descriptions,\n                    article_long_descriptions,\n                }\n            })\n            .collect();\n\n        // Sort by name\n        families.sort_by(|a, b| a.name.cmp(&b.name));\n\n        families\n    }\n\n    /// Extract a clean family name from description\n    fn extract_family_name(description: &str) -> String {\n        // Only split at comma or semicolon, NOT at dash (which is used in names like \"se:air\")\n        let name = description\n            .split([',', ';'])\n            .next()\n            .unwrap_or(description)\n            .trim();\n\n        // Handle UTF-8 properly - count characters, not bytes\n        let char_count = name.chars().count();\n        if char_count > 50 {\n            let truncated: String = name.chars().take(47).collect();\n            format!(\"{}...\", truncated)\n        } else {\n            name.to_string()\n        }\n    }\n\n    /// Get all product families\n    pub fn get_families(&self) -> &[ProductFamily] {\n        &self.families\n    }\n\n    /// Get a family by ID\n    pub fn get_family(&self, id: &str) -> Option<&ProductFamily> {\n        self.families.iter().find(|f| f.id == id)\n    }\n\n    /// Get configurable properties for a family\n    pub fn get_properties_for_family(&self, family: &ProductFamily) -> Vec<FamilyProperty> {\n        self.get_properties_for_family_with_selections(family, &HashMap::new())\n    }\n\n    /// Get configurable properties for a family with current selections\n    /// (for TABLE relations that depend on other property values)\n    pub fn get_properties_for_family_with_selections(\n        &self,\n        family: &ProductFamily,\n        current_selections: &HashMap<String, String>,\n    ) -> Vec<FamilyProperty> {\n        let mut result = Vec::new();\n        let mut seen_property_keys = std::collections::HashSet::new();\n\n        // Get properties from ALL property classes (articles can belong to multiple)\n        for prop_class in &family.prop_classes {\n            // Get all properties for this class without series filtering\n            // The OCD data model uses ocd_propertyclass to map articles to property classes,\n            // NOT series to property classes. Properties with no applicable values are\n            // filtered out downstream, so showing all properties is safe.\n            //\n            // Note: Series-based filtering was removed because:\n            // - Framery uses shared property classes across all series (MG_PROPERTIES)\n            // - When properties are merged during loading, they get tagged with whichever\n            //   series was loaded first, causing incorrect filtering\n            // - The property value availability already controls which options are shown\n            let props = self.properties.get_properties_for_class(prop_class);\n\n            // First, collect TABLE relation values for cross-property filtering\n            // Properties with TABLE relations can restrict values of other properties\n            let table_restriction_values =\n                self.collect_table_restriction_values(prop_class, &props, current_selections);\n\n            for prop in props {\n                // Skip properties we've already added from another class\n                if seen_property_keys.contains(&prop.property) {\n                    continue;\n                }\n                // Filter properties by scope:\n                // - \"C\" (Choice): Configurable by user - SHOW\n                // - \"RV\" (Read-only Visible): Display only - SHOW\n                // - \"\" (empty): Default visible - SHOW\n                // - \"R\" (Result): Internal/computed - HIDE\n                // - \"RG\" (Range/Graphics): Internal - HIDE\n                // - Custom scopes (e.g., AIX \"Desk_2020\"): Assume visible - SHOW\n                let scope_upper = prop.scope.to_uppercase();\n                if scope_upper == \"R\" || scope_upper == \"RG\" {\n                    // Skip internal/computed properties\n                    continue;\n                }\n\n                let label = self\n                    .properties\n                    .get_property_label(&prop.prop_class, &prop.property, &self.language)\n                    .unwrap_or_else(|| prop.property.clone());\n\n                // First try standard property values\n                let mut values: Vec<&OcdPropertyValue> = self\n                    .properties\n                    .get_values_for_property(&prop.prop_class, &prop.property);\n\n                // If no standard values and property uses TABLE relation, get values from table\n                let table_values: Vec<OcdPropertyValue>;\n                if values.is_empty() && prop.rel_obj > 0 {\n                    table_values = self.properties.get_table_values(\n                        &prop.prop_class,\n                        &prop.property,\n                        current_selections,\n                    );\n                    values = table_values.iter().collect();\n                }\n\n                // If still no values, try to get values from TABLE restrictions\n                // This handles properties like Farbe_Rahmen that get values from TABLE columns\n                let table_column_values: Vec<OcdPropertyValue>;\n                if values.is_empty() {\n                    let property_key = prop.property.to_lowercase();\n                    if let Some(allowed_values) = table_restriction_values.get(&property_key) {\n                        table_column_values = allowed_values\n                            .iter()\n                            .enumerate()\n                            .map(|(i, v)| {\n                                use super::ocd_properties::OcdPropertyValue;\n                                OcdPropertyValue {\n                                    prop_class: prop.prop_class.clone(),\n                                    property: prop.property.clone(),\n                                    position: i as u16 + 1,\n                                    textnr: String::new(),\n                                    is_default: i == 0,\n                                    value_from: v.clone(),\n                                    value_to: String::new(),\n                                    op_from: String::new(),\n                                    op_to: String::new(),\n                                    raster: String::new(),\n                                }\n                            })\n                            .collect();\n                        values = table_column_values.iter().collect();\n                    }\n                }\n\n                // Apply TABLE-based restrictions from other properties\n                // This filters values based on what's valid according to TABLE lookups\n                let property_key = prop.property.to_lowercase();\n                let restricted_values: Option<&std::collections::HashSet<String>> =\n                    table_restriction_values.get(&property_key);\n\n                // Deduplicate options by value (some data sources have duplicate entries)\n                let mut seen_values = std::collections::HashSet::new();\n                let options: Vec<PropertyOption> = values\n                    .iter()\n                    .filter(|v| {\n                        // If there are restrictions for this property, filter by them\n                        if let Some(allowed) = restricted_values {\n                            allowed.contains(&v.value_from.to_uppercase())\n                        } else {\n                            true\n                        }\n                    })\n                    .filter(|v| {\n                        // Skip duplicate values\n                        seen_values.insert(v.value_from.to_uppercase())\n                    })\n                    .map(|v| {\n                        let val_label = self\n                            .properties\n                            .get_value_label(v, &self.language)\n                            .unwrap_or_else(|| v.value_from.clone());\n                        PropertyOption {\n                            value: v.value_from.clone(),\n                            label: val_label,\n                            is_default: v.is_default,\n                        }\n                    })\n                    .collect();\n\n                let default_value = if !options.is_empty() {\n                    options\n                        .iter()\n                        .find(|o| o.is_default)\n                        .or(options.first())\n                        .map(|o| o.value.clone())\n                } else {\n                    None\n                };\n\n                let prop_type = Self::parse_property_type(&prop.prop_type, &values);\n\n                // Get human-readable group label\n                // Try prop_group_texts first (more specific), then prop_class_texts as fallback\n                let group_label = self\n                    .properties\n                    .get_prop_group_label(&prop.prop_class, &self.language)\n                    .or_else(|| {\n                        self.properties\n                            .get_class_label(&prop.prop_class, &self.language)\n                    })\n                    .unwrap_or_else(|| prop.prop_class.clone());\n\n                // Try to get hint text for this property using its textnr\n                let hint = self.properties.get_hint_text(&prop.textnr, &self.language);\n\n                result.push(FamilyProperty {\n                    key: prop.property.clone(),\n                    label,\n                    group: prop.prop_class.clone(),\n                    group_label,\n                    prop_type,\n                    required: prop.need_input,\n                    options,\n                    default_value,\n                    position: prop.position,\n                    hint,\n                });\n\n                // Track that we've added this property\n                seen_property_keys.insert(prop.property.clone());\n            }\n        }\n\n        // Sort by position\n        result.sort_by_key(|p| p.position);\n\n        // Filter out properties with no options (they can't be configured)\n        result.retain(|p| !p.options.is_empty());\n\n        result\n    }\n\n    /// Collect values from TABLE relations that can restrict other property values\n    /// This enables cross-property filtering where TABLE on one property restricts another\n    fn collect_table_restriction_values(\n        &self,\n        _prop_class: &str,\n        props: &[&super::ocd_properties::OcdPropertyDef],\n        current_selections: &HashMap<String, String>,\n    ) -> HashMap<String, std::collections::HashSet<String>> {\n        use super::ocd_properties::OcdPropertyReader;\n\n        let mut restrictions: HashMap<String, std::collections::HashSet<String>> = HashMap::new();\n\n        // Find all properties with TABLE relations\n        for prop in props {\n            if prop.rel_obj == 0 {\n                continue;\n            }\n\n            // Get the relation object\n            let rel_obj = match self.properties.relation_objs.get(&prop.rel_obj) {\n                Some(obj) => obj,\n                None => continue,\n            };\n\n            // Get the relations\n            let relations = match self.properties.relations.get(&rel_obj.rel_name) {\n                Some(rels) => rels,\n                None => continue,\n            };\n\n            // Concatenate relation blocks\n            let rel_text: String = relations\n                .iter()\n                .map(|r| r.rel_block.clone())\n                .collect::<Vec<_>>()\n                .join(\" \");\n\n            // Parse TABLE relation\n            if let Some(table_rel) = OcdPropertyReader::parse_table_relation(&rel_text) {\n                let table_name = table_rel.table_name.to_lowercase() + \"_tbl\";\n\n                // Get the custom table\n                let table_data = match self.properties.custom_tables.get(&table_name) {\n                    Some(data) => data,\n                    None => continue,\n                };\n\n                // Build filter conditions from current selections\n                let mut filters: Vec<(String, String)> = Vec::new();\n                for (col, val) in &table_rel.column_mappings {\n                    if !val.contains(\"$SELF\") {\n                        // This column references another property\n                        if let Some(selected_value) = current_selections.get(val) {\n                            filters.push((col.to_lowercase(), selected_value.clone()));\n                        }\n                    }\n                }\n\n                // For each column mapping that references a property, collect valid values\n                for (col, val) in &table_rel.column_mappings {\n                    if !val.contains(\"$SELF\") {\n                        // This column represents a property - collect all valid values\n                        let prop_name = val.to_lowercase();\n                        let col_lower = col.to_lowercase();\n\n                        // Query table with current filters (except this column)\n                        let other_filters: Vec<_> = filters\n                            .iter()\n                            .filter(|(c, _)| c != &col_lower)\n                            .cloned()\n                            .collect();\n\n                        let mut valid_values: std::collections::HashSet<String> =\n                            std::collections::HashSet::new();\n\n                        for row in table_data {\n                            // Check if row matches other filters\n                            let matches = other_filters.is_empty()\n                                || other_filters.iter().all(|(c, expected)| {\n                                    row.get(c)\n                                        .map(|v| v.eq_ignore_ascii_case(expected))\n                                        .unwrap_or(false)\n                                });\n\n                            if matches {\n                                if let Some(value) = row.get(&col_lower) {\n                                    if !value.is_empty() {\n                                        valid_values.insert(value.to_uppercase());\n                                    }\n                                }\n                            }\n                        }\n\n                        if !valid_values.is_empty() {\n                            restrictions\n                                .entry(prop_name)\n                                .or_default()\n                                .extend(valid_values);\n                        }\n                    }\n                }\n            }\n        }\n\n        restrictions\n    }\n\n    /// Parse OCD property type string into enum\n    fn parse_property_type(type_str: &str, values: &[&OcdPropertyValue]) -> PropertyType {\n        match type_str.to_uppercase().as_str() {\n            \"B\" | \"BOOL\" | \"BOOLEAN\" => PropertyType::Boolean,\n            \"I\" | \"INT\" | \"INTEGER\" => {\n                // Try to get min/max from values\n                let min = values\n                    .iter()\n                    .filter_map(|v| v.value_from.parse::<i64>().ok())\n                    .min()\n                    .unwrap_or(0);\n                let max = values\n                    .iter()\n                    .filter_map(|v| {\n                        if v.value_to.is_empty() {\n                            v.value_from.parse::<i64>().ok()\n                        } else {\n                            v.value_to.parse::<i64>().ok()\n                        }\n                    })\n                    .max()\n                    .unwrap_or(100);\n                PropertyType::Integer { min, max }\n            }\n            \"R\" | \"RANGE\" | \"FLOAT\" => {\n                let min = values\n                    .iter()\n                    .filter_map(|v| v.value_from.parse::<f64>().ok())\n                    .fold(f64::INFINITY, f64::min);\n                let max = values\n                    .iter()\n                    .filter_map(|v| {\n                        if v.value_to.is_empty() {\n                            v.value_from.parse::<f64>().ok()\n                        } else {\n                            v.value_to.parse::<f64>().ok()\n                        }\n                    })\n                    .fold(f64::NEG_INFINITY, f64::max);\n                let step = values\n                    .first()\n                    .and_then(|v| v.raster.parse::<f64>().ok())\n                    .unwrap_or(1.0);\n                PropertyType::Range {\n                    min: if min.is_finite() { min } else { 0.0 },\n                    max: if max.is_finite() { max } else { 100.0 },\n                    step,\n                }\n            }\n            \"T\" | \"TEXT\" | \"STRING\" => PropertyType::Text,\n            _ => {\n                // Default to Choice if we have multiple values\n                PropertyType::Choice\n            }\n        }\n    }\n\n    /// Check if a family has any configurable properties\n    pub fn family_has_properties(&self, family: &ProductFamily) -> bool {\n        family.prop_classes.iter().any(|prop_class| {\n            !self\n                .properties\n                .get_properties_for_class(prop_class)\n                .is_empty()\n        })\n    }\n\n    /// Get statistics about loaded data\n    pub fn stats(&self) -> FamilyLoaderStats {\n        let configurable = self.families.iter().filter(|f| f.is_configurable).count();\n        let with_properties = self\n            .families\n            .iter()\n            .filter(|f| self.family_has_properties(f))\n            .count();\n        let total_variants: usize = self.families.iter().map(|f| f.variant_count).sum();\n\n        FamilyLoaderStats {\n            total_families: self.families.len(),\n            configurable_families: configurable,\n            families_with_properties: with_properties,\n            total_variants,\n        }\n    }\n}\n\n/// Statistics about loaded families\n#[derive(Debug, Clone)]\npub struct FamilyLoaderStats {\n    pub total_families: usize,\n    pub configurable_families: usize,\n    pub families_with_properties: usize,\n    pub total_variants: usize,\n}\n\n/// A user's configuration selections for a product family\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FamilyConfiguration {\n    /// The product family ID\n    pub family_id: String,\n    /// Selected property values\n    pub selections: HashMap<String, String>,\n    /// Generated variant code\n    pub variant_code: String,\n    /// Calculated article number\n    pub article_nr: Option<String>,\n}\n\nimpl FamilyConfiguration {\n    /// Create a new configuration with default values\n    pub fn new(family_id: &str, properties: &[FamilyProperty]) -> Self {\n        let mut selections = HashMap::new();\n\n        for prop in properties {\n            if let Some(ref default) = prop.default_value {\n                selections.insert(prop.key.clone(), default.clone());\n            } else if !prop.options.is_empty() {\n                // Use first option as default\n                selections.insert(prop.key.clone(), prop.options[0].value.clone());\n            }\n        }\n\n        let variant_code = Self::generate_variant_code(&selections);\n\n        Self {\n            family_id: family_id.to_string(),\n            selections,\n            variant_code,\n            article_nr: None,\n        }\n    }\n\n    /// Set a property value\n    pub fn set(&mut self, key: &str, value: &str) {\n        self.selections.insert(key.to_string(), value.to_string());\n        self.variant_code = Self::generate_variant_code(&self.selections);\n    }\n\n    /// Get a property value\n    pub fn get(&self, key: &str) -> Option<&str> {\n        self.selections.get(key).map(|s| s.as_str())\n    }\n\n    /// Generate variant code from selections\n    fn generate_variant_code(selections: &HashMap<String, String>) -> String {\n        let mut parts: Vec<_> = selections\n            .iter()\n            .map(|(k, v)| format!(\"{}={}\", k, v))\n            .collect();\n        parts.sort();\n        parts.join(\";\")\n    }\n\n    /// Export configuration to JSON-serializable format\n    pub fn export(\n        &self,\n        manufacturer_id: &str,\n        family: &ProductFamily,\n        price: Option<&super::PriceResult>,\n    ) -> super::ExportData {\n        use super::{format_german_price, ExportData, ExportSurcharge};\n\n        let now = chrono::Utc::now();\n\n        // Convert selections to JSON values with labels\n        let properties: std::collections::HashMap<String, serde_json::Value> = self\n            .selections\n            .iter()\n            .map(|(k, v)| (k.clone(), serde_json::Value::String(v.clone())))\n            .collect();\n\n        ExportData {\n            manufacturer: manufacturer_id.to_string(),\n            article: family.id.clone(),\n            article_number: Some(family.base_article_nr.clone()),\n            variant_code: self.variant_code.clone(),\n            properties,\n            base_price: price.map(|p| format_german_price(p.base_price)),\n            surcharges: price.map(|p| {\n                p.surcharges\n                    .iter()\n                    .map(|s| ExportSurcharge {\n                        name: s.name.clone(),\n                        amount: if s.is_percentage {\n                            format!(\"{}%\", s.amount)\n                        } else {\n                            format_german_price(s.amount)\n                        },\n                        is_percentage: s.is_percentage,\n                    })\n                    .collect()\n            }),\n            total_price: price.map(|p| format_german_price(p.total_price)),\n            currency: price.map(|p| p.currency.clone()),\n            price_date: price.map(|p| p.price_date.format(\"%Y-%m-%d\").to_string()),\n            sub_articles: Vec::new(),\n            exported_at: now.format(\"%Y-%m-%dT%H:%M:%SZ\").to_string(),\n        }\n    }\n\n    /// Export configuration to JSON string\n    pub fn export_json(\n        &self,\n        manufacturer_id: &str,\n        family: &ProductFamily,\n        price: Option<&super::PriceResult>,\n    ) -> Result<String, serde_json::Error> {\n        let export_data = self.export(manufacturer_id, family, price);\n        serde_json::to_string_pretty(&export_data)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_load_sex_families() {\n        let path = Path::new(\"/workspace/ofmldata/sex\");\n        if !path.exists() {\n            return;\n        }\n\n        let loader = FamilyLoader::load(path, \"DE\");\n        let stats = loader.stats();\n\n        println!(\"Families: {}\", stats.total_families);\n        println!(\"With properties: {}\", stats.families_with_properties);\n\n        // Find MMZ or similar\n        println!(\"\\nFamilies with MM in name:\");\n        for family in loader.get_families() {\n            if family.id.to_uppercase().contains(\"MM\") || family.name.to_uppercase().contains(\"MM\")\n            {\n                println!(\n                    \"  {} - {} ({} variants, prop_classes={:?})\",\n                    family.id, family.name, family.variant_count, family.prop_classes\n                );\n\n                let props = loader.get_properties_for_family(family);\n                println!(\"    Properties: {}\", props.len());\n                for prop in props.iter().take(3) {\n                    println!(\"      - {}: {} options\", prop.key, prop.options.len());\n                }\n            }\n        }\n\n        // Show some property classes\n        println!(\"\\nSample property classes:\");\n        for pc in loader.properties.get_property_classes().iter().take(15) {\n            println!(\"  {}\", pc);\n        }\n    }\n\n    #[test]\n    fn test_load_vitra_families() {\n        let path = Path::new(\"/workspace/ofmldata/vitra\");\n        if !path.exists() {\n            return;\n        }\n\n        let loader = FamilyLoader::load(path, \"DE\");\n        let stats = loader.stats();\n\n        println!(\"Families: {}\", stats.total_families);\n        println!(\"Configurable: {}\", stats.configurable_families);\n        println!(\"With properties: {}\", stats.families_with_properties);\n        println!(\"Total variants: {}\", stats.total_variants);\n\n        // Print some families\n        println!(\"\\nSample families:\");\n        for family in loader.get_families().iter().take(10) {\n            println!(\n                \"  {} - {} ({} variants, config={})\",\n                family.id, family.name, family.variant_count, family.is_configurable\n            );\n\n            // Show properties if available\n            let props = loader.get_properties_for_family(family);\n            if !props.is_empty() {\n                println!(\"    Properties:\");\n                for prop in props.iter().take(3) {\n                    println!(\n                        \"      {} ({}): {} options\",\n                        prop.key,\n                        prop.label,\n                        prop.options.len()\n                    );\n                }\n            }\n        }\n    }\n\n    #[test]\n    fn test_load_bisley_families() {\n        let path = Path::new(\"/reference/ofmldata/bisley\");\n        if !path.exists() {\n            return;\n        }\n\n        let loader = FamilyLoader::load(path, \"DE\");\n        let stats = loader.stats();\n\n        println!(\"\\n=== Bisley Manufacturer Data ===\");\n        println!(\"Total Families: {}\", stats.total_families);\n        println!(\"Configurable: {}\", stats.configurable_families);\n        println!(\"With properties: {}\", stats.families_with_properties);\n        println!(\"Total variants: {}\", stats.total_variants);\n\n        // Group families by series\n        let mut by_series: std::collections::HashMap<String, Vec<_>> =\n            std::collections::HashMap::new();\n        for family in loader.get_families() {\n            let series = family.series.clone();\n            by_series.entry(series).or_default().push(family.clone());\n        }\n\n        println!(\"\\nFamilies per series:\");\n        let mut series_list: Vec<_> = by_series.keys().collect();\n        series_list.sort();\n        for series in &series_list {\n            let families = &by_series[*series];\n            let with_props = families\n                .iter()\n                .filter(|f| loader.family_has_properties(f))\n                .count();\n            println!(\n                \"  {}: {} families ({} with properties)\",\n                series,\n                families.len(),\n                with_props\n            );\n        }\n\n        // Check for issues\n        println!(\"\\nChecking for anomalies...\");\n        let mut issues = 0;\n        for family in loader.get_families() {\n            let props = loader.get_properties_for_family(family);\n            // Check for families without properties but with configurable flag\n            if family.is_configurable && props.is_empty() {\n                println!(\n                    \"  WARN: '{}' ({}) marked configurable but no properties\",\n                    family.name, family.base_article_nr\n                );\n                issues += 1;\n            }\n            // Check for empty names\n            if family.name.is_empty() || family.name.trim().is_empty() {\n                println!(\"  WARN: Family '{}' has empty name\", family.base_article_nr);\n                issues += 1;\n            }\n        }\n\n        if issues == 0 {\n            println!(\"  No issues found!\");\n        } else {\n            println!(\"  Total issues: {}\", issues);\n        }\n\n        // Basic assertions\n        assert!(stats.total_families > 0, \"Should have loaded some families\");\n    }\n\n    #[test]\n    fn test_family_configuration() {\n        let path = Path::new(\"/workspace/ofmldata/vitra\");\n        if !path.exists() {\n            return;\n        }\n\n        let loader = FamilyLoader::load(path, \"DE\");\n\n        // Find a family with properties\n        if let Some(family) = loader\n            .get_families()\n            .iter()\n            .find(|f| loader.family_has_properties(f))\n        {\n            println!(\"Testing family: {} - {}\", family.id, family.name);\n\n            let props = loader.get_properties_for_family(family);\n            println!(\"Properties: {}\", props.len());\n\n            // Create configuration\n            let mut config = FamilyConfiguration::new(&family.id, &props);\n            println!(\"Initial variant code: {}\", config.variant_code);\n\n            // Change a property if available\n            if !props.is_empty() {\n                let prop = &props[0];\n                if prop.options.len() > 1 {\n                    config.set(&prop.key, &prop.options[1].value);\n                    println!(\"After change: {}\", config.variant_code);\n                }\n            }\n        }\n    }\n\n    // Unit tests that don't require external data\n\n    #[test]\n    fn test_property_option_clone_debug() {\n        let option = PropertyOption {\n            value: \"VAL1\".to_string(),\n            label: \"Value 1\".to_string(),\n            is_default: true,\n        };\n        let cloned = option.clone();\n        assert_eq!(cloned.value, \"VAL1\");\n        assert!(cloned.is_default);\n        let debug_str = format!(\"{:?}\", option);\n        assert!(debug_str.contains(\"VAL1\"));\n    }\n\n    #[test]\n    fn test_family_property_clone_debug() {\n        let prop = FamilyProperty {\n            key: \"COLOR\".to_string(),\n            label: \"Color\".to_string(),\n            group: \"appearance\".to_string(),\n            group_label: \"Appearance\".to_string(),\n            prop_type: PropertyType::Choice,\n            required: false,\n            options: vec![],\n            default_value: None,\n            position: 1,\n            hint: None,\n        };\n        let cloned = prop.clone();\n        assert_eq!(cloned.key, \"COLOR\");\n        assert_eq!(cloned.position, 1);\n        let debug_str = format!(\"{:?}\", prop);\n        assert!(debug_str.contains(\"COLOR\"));\n    }\n\n    #[test]\n    fn test_product_family_clone_debug() {\n        let family = ProductFamily {\n            id: \"FAM1\".to_string(),\n            name: \"Family 1\".to_string(),\n            description: \"Short desc\".to_string(),\n            long_description: \"Long desc\".to_string(),\n            series: \"ser\".to_string(),\n            base_article_nr: \"ART-001\".to_string(),\n            prop_classes: vec![\"CLASS1\".to_string()],\n            variant_count: 5,\n            is_configurable: true,\n            article_nrs: vec![\"ART-001\".to_string()],\n            article_descriptions: vec![],\n            article_long_descriptions: vec![],\n        };\n        let cloned = family.clone();\n        assert_eq!(cloned.id, \"FAM1\");\n        assert_eq!(cloned.variant_count, 5);\n        assert!(cloned.is_configurable);\n        let debug_str = format!(\"{:?}\", family);\n        assert!(debug_str.contains(\"FAM1\"));\n    }\n\n    #[test]\n    fn test_family_loader_stats_clone_debug() {\n        let stats = FamilyLoaderStats {\n            total_families: 100,\n            configurable_families: 50,\n            families_with_properties: 45,\n            total_variants: 500,\n        };\n        let cloned = stats.clone();\n        assert_eq!(cloned.total_families, 100);\n        assert_eq!(cloned.configurable_families, 50);\n        let debug_str = format!(\"{:?}\", stats);\n        assert!(debug_str.contains(\"100\"));\n    }\n\n    #[test]\n    fn test_family_configuration_empty() {\n        let properties: Vec<FamilyProperty> = vec![];\n        let config = FamilyConfiguration::new(\"test-family\", &properties);\n        assert_eq!(config.family_id, \"test-family\");\n        assert!(config.selections.is_empty());\n        assert_eq!(config.variant_code, \"\");\n    }\n\n    #[test]\n    fn test_family_configuration_with_properties() {\n        let properties = vec![\n            FamilyProperty {\n                key: \"SIZE\".to_string(),\n                label: \"Size\".to_string(),\n                group: \"dimensions\".to_string(),\n                group_label: \"Dimensions\".to_string(),\n                prop_type: PropertyType::Choice,\n                required: false,\n                options: vec![\n                    PropertyOption {\n                        value: \"S\".to_string(),\n                        label: \"Small\".to_string(),\n                        is_default: true,\n                    },\n                    PropertyOption {\n                        value: \"L\".to_string(),\n                        label: \"Large\".to_string(),\n                        is_default: false,\n                    },\n                ],\n                default_value: Some(\"S\".to_string()),\n                position: 1,\n                hint: None,\n            },\n        ];\n        let mut config = FamilyConfiguration::new(\"test-family\", &properties);\n\n        // Default should be selected\n        assert_eq!(config.get(\"SIZE\"), Some(\"S\"));\n\n        // Change selection\n        config.set(\"SIZE\", \"L\");\n        assert_eq!(config.get(\"SIZE\"), Some(\"L\"));\n    }\n\n    #[test]\n    fn test_family_configuration_clone_debug() {\n        let properties: Vec<FamilyProperty> = vec![];\n        let config = FamilyConfiguration::new(\"test-family\", &properties);\n\n        let cloned = config.clone();\n        assert_eq!(cloned.family_id, \"test-family\");\n\n        let debug_str = format!(\"{:?}\", config);\n        assert!(debug_str.contains(\"test-family\"));\n    }\n\n    #[test]\n    fn test_property_type_debug_clone() {\n        let choice = PropertyType::Choice;\n        let choice_cloned = choice.clone();\n        assert!(matches!(choice_cloned, PropertyType::Choice));\n\n        let range = PropertyType::Range { min: 0.0, max: 100.0, step: 1.0 };\n        let range_cloned = range.clone();\n        if let PropertyType::Range { min, max, step } = range_cloned {\n            assert_eq!(min, 0.0);\n            assert_eq!(max, 100.0);\n            assert_eq!(step, 1.0);\n        }\n\n        let debug_str = format!(\"{:?}\", choice);\n        assert!(debug_str.contains(\"Choice\"));\n    }\n}\n","traces":[{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":1}},{"line":120,"address":[],"length":0,"stats":{"Line":5}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":3}},{"line":140,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":3}},{"line":146,"address":[],"length":0,"stats":{"Line":664}},{"line":147,"address":[],"length":0,"stats":{"Line":1326}},{"line":149,"address":[],"length":0,"stats":{"Line":663}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":3834}},{"line":154,"address":[],"length":0,"stats":{"Line":114}},{"line":157,"address":[],"length":0,"stats":{"Line":549}},{"line":158,"address":[],"length":0,"stats":{"Line":549}},{"line":159,"address":[],"length":0,"stats":{"Line":549}},{"line":160,"address":[],"length":0,"stats":{"Line":2381}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":1098}},{"line":166,"address":[],"length":0,"stats":{"Line":190}},{"line":168,"address":[],"length":0,"stats":{"Line":359}},{"line":173,"address":[],"length":0,"stats":{"Line":3}},{"line":174,"address":[],"length":0,"stats":{"Line":1078}},{"line":175,"address":[],"length":0,"stats":{"Line":1077}},{"line":176,"address":[],"length":0,"stats":{"Line":1436}},{"line":178,"address":[],"length":0,"stats":{"Line":359}},{"line":182,"address":[],"length":0,"stats":{"Line":3}},{"line":184,"address":[],"length":0,"stats":{"Line":107}},{"line":185,"address":[],"length":0,"stats":{"Line":54}},{"line":187,"address":[],"length":0,"stats":{"Line":106}},{"line":188,"address":[],"length":0,"stats":{"Line":53}},{"line":189,"address":[],"length":0,"stats":{"Line":412}},{"line":191,"address":[],"length":0,"stats":{"Line":718}},{"line":192,"address":[],"length":0,"stats":{"Line":1436}},{"line":193,"address":[],"length":0,"stats":{"Line":177}},{"line":194,"address":[],"length":0,"stats":{"Line":788}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":182}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":364}},{"line":201,"address":[],"length":0,"stats":{"Line":359}},{"line":203,"address":[],"length":0,"stats":{"Line":53}},{"line":204,"address":[],"length":0,"stats":{"Line":53}},{"line":206,"address":[],"length":0,"stats":{"Line":106}},{"line":207,"address":[],"length":0,"stats":{"Line":53}},{"line":208,"address":[],"length":0,"stats":{"Line":277}},{"line":209,"address":[],"length":0,"stats":{"Line":159}},{"line":210,"address":[],"length":0,"stats":{"Line":53}},{"line":212,"address":[],"length":0,"stats":{"Line":106}},{"line":213,"address":[],"length":0,"stats":{"Line":159}},{"line":214,"address":[],"length":0,"stats":{"Line":53}},{"line":215,"address":[],"length":0,"stats":{"Line":106}},{"line":216,"address":[],"length":0,"stats":{"Line":159}},{"line":217,"address":[],"length":0,"stats":{"Line":53}},{"line":220,"address":[],"length":0,"stats":{"Line":106}},{"line":221,"address":[],"length":0,"stats":{"Line":53}},{"line":222,"address":[],"length":0,"stats":{"Line":233}},{"line":226,"address":[],"length":0,"stats":{"Line":159}},{"line":227,"address":[],"length":0,"stats":{"Line":106}},{"line":229,"address":[],"length":0,"stats":{"Line":771}},{"line":230,"address":[],"length":0,"stats":{"Line":945}},{"line":231,"address":[],"length":0,"stats":{"Line":1053}},{"line":234,"address":[],"length":0,"stats":{"Line":826}},{"line":235,"address":[],"length":0,"stats":{"Line":1652}},{"line":237,"address":[],"length":0,"stats":{"Line":351}},{"line":244,"address":[],"length":0,"stats":{"Line":106}},{"line":245,"address":[],"length":0,"stats":{"Line":48}},{"line":246,"address":[],"length":0,"stats":{"Line":16}},{"line":247,"address":[],"length":0,"stats":{"Line":16}},{"line":248,"address":[],"length":0,"stats":{"Line":21088}},{"line":249,"address":[],"length":0,"stats":{"Line":2928}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":106}},{"line":257,"address":[],"length":0,"stats":{"Line":53}},{"line":258,"address":[],"length":0,"stats":{"Line":53}},{"line":259,"address":[],"length":0,"stats":{"Line":159}},{"line":260,"address":[],"length":0,"stats":{"Line":53}},{"line":264,"address":[],"length":0,"stats":{"Line":159}},{"line":265,"address":[],"length":0,"stats":{"Line":53}},{"line":266,"address":[],"length":0,"stats":{"Line":412}},{"line":268,"address":[],"length":0,"stats":{"Line":1077}},{"line":269,"address":[],"length":0,"stats":{"Line":1077}},{"line":270,"address":[],"length":0,"stats":{"Line":359}},{"line":273,"address":[],"length":0,"stats":{"Line":53}},{"line":274,"address":[],"length":0,"stats":{"Line":1696}},{"line":276,"address":[],"length":0,"stats":{"Line":212}},{"line":277,"address":[],"length":0,"stats":{"Line":53}},{"line":278,"address":[],"length":0,"stats":{"Line":53}},{"line":279,"address":[],"length":0,"stats":{"Line":53}},{"line":280,"address":[],"length":0,"stats":{"Line":212}},{"line":281,"address":[],"length":0,"stats":{"Line":106}},{"line":282,"address":[],"length":0,"stats":{"Line":359}},{"line":283,"address":[],"length":0,"stats":{"Line":1077}},{"line":284,"address":[],"length":0,"stats":{"Line":1077}},{"line":285,"address":[],"length":0,"stats":{"Line":1077}},{"line":286,"address":[],"length":0,"stats":{"Line":718}},{"line":290,"address":[],"length":0,"stats":{"Line":53}},{"line":291,"address":[],"length":0,"stats":{"Line":159}},{"line":292,"address":[],"length":0,"stats":{"Line":106}},{"line":293,"address":[],"length":0,"stats":{"Line":106}},{"line":294,"address":[],"length":0,"stats":{"Line":106}},{"line":295,"address":[],"length":0,"stats":{"Line":159}},{"line":296,"address":[],"length":0,"stats":{"Line":106}},{"line":297,"address":[],"length":0,"stats":{"Line":106}},{"line":298,"address":[],"length":0,"stats":{"Line":159}},{"line":299,"address":[],"length":0,"stats":{"Line":106}},{"line":300,"address":[],"length":0,"stats":{"Line":106}},{"line":301,"address":[],"length":0,"stats":{"Line":53}},{"line":302,"address":[],"length":0,"stats":{"Line":53}},{"line":308,"address":[],"length":0,"stats":{"Line":986}},{"line":310,"address":[],"length":0,"stats":{"Line":1}},{"line":314,"address":[],"length":0,"stats":{"Line":53}},{"line":316,"address":[],"length":0,"stats":{"Line":212}},{"line":317,"address":[],"length":0,"stats":{"Line":106}},{"line":319,"address":[],"length":0,"stats":{"Line":53}},{"line":323,"address":[],"length":0,"stats":{"Line":212}},{"line":324,"address":[],"length":0,"stats":{"Line":53}},{"line":325,"address":[],"length":0,"stats":{"Line":84}},{"line":326,"address":[],"length":0,"stats":{"Line":28}},{"line":328,"address":[],"length":0,"stats":{"Line":78}},{"line":333,"address":[],"length":0,"stats":{"Line":2}},{"line":334,"address":[],"length":0,"stats":{"Line":2}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":53}},{"line":344,"address":[],"length":0,"stats":{"Line":212}},{"line":349,"address":[],"length":0,"stats":{"Line":53}},{"line":354,"address":[],"length":0,"stats":{"Line":106}},{"line":355,"address":[],"length":0,"stats":{"Line":106}},{"line":358,"address":[],"length":0,"stats":{"Line":287}},{"line":369,"address":[],"length":0,"stats":{"Line":468}},{"line":373,"address":[],"length":0,"stats":{"Line":117}},{"line":374,"address":[],"length":0,"stats":{"Line":585}},{"line":376,"address":[],"length":0,"stats":{"Line":1299}},{"line":378,"address":[],"length":0,"stats":{"Line":1773}},{"line":379,"address":[],"length":0,"stats":{"Line":13}},{"line":388,"address":[],"length":0,"stats":{"Line":1156}},{"line":389,"address":[],"length":0,"stats":{"Line":1151}},{"line":391,"address":[],"length":0,"stats":{"Line":376}},{"line":394,"address":[],"length":0,"stats":{"Line":404}},{"line":395,"address":[],"length":0,"stats":{"Line":202}},{"line":396,"address":[],"length":0,"stats":{"Line":808}},{"line":397,"address":[],"length":0,"stats":{"Line":342}},{"line":400,"address":[],"length":0,"stats":{"Line":606}},{"line":401,"address":[],"length":0,"stats":{"Line":202}},{"line":402,"address":[],"length":0,"stats":{"Line":606}},{"line":406,"address":[],"length":0,"stats":{"Line":469}},{"line":407,"address":[],"length":0,"stats":{"Line":92}},{"line":408,"address":[],"length":0,"stats":{"Line":46}},{"line":409,"address":[],"length":0,"stats":{"Line":46}},{"line":410,"address":[],"length":0,"stats":{"Line":46}},{"line":412,"address":[],"length":0,"stats":{"Line":46}},{"line":418,"address":[],"length":0,"stats":{"Line":404}},{"line":419,"address":[],"length":0,"stats":{"Line":84}},{"line":420,"address":[],"length":0,"stats":{"Line":84}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":404}},{"line":447,"address":[],"length":0,"stats":{"Line":404}},{"line":448,"address":[],"length":0,"stats":{"Line":606}},{"line":451,"address":[],"length":0,"stats":{"Line":404}},{"line":452,"address":[],"length":0,"stats":{"Line":606}},{"line":454,"address":[],"length":0,"stats":{"Line":2445}},{"line":456,"address":[],"length":0,"stats":{"Line":2243}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":2243}},{"line":462,"address":[],"length":0,"stats":{"Line":2445}},{"line":464,"address":[],"length":0,"stats":{"Line":6729}},{"line":466,"address":[],"length":0,"stats":{"Line":2067}},{"line":467,"address":[],"length":0,"stats":{"Line":3730}},{"line":468,"address":[],"length":0,"stats":{"Line":1865}},{"line":469,"address":[],"length":0,"stats":{"Line":5595}},{"line":470,"address":[],"length":0,"stats":{"Line":3857}},{"line":471,"address":[],"length":0,"stats":{"Line":1865}},{"line":472,"address":[],"length":0,"stats":{"Line":5595}},{"line":473,"address":[],"length":0,"stats":{"Line":1865}},{"line":474,"address":[],"length":0,"stats":{"Line":1865}},{"line":479,"address":[],"length":0,"stats":{"Line":404}},{"line":480,"address":[],"length":0,"stats":{"Line":160}},{"line":482,"address":[],"length":0,"stats":{"Line":160}},{"line":483,"address":[],"length":0,"stats":{"Line":320}},{"line":484,"address":[],"length":0,"stats":{"Line":480}},{"line":486,"address":[],"length":0,"stats":{"Line":42}},{"line":489,"address":[],"length":0,"stats":{"Line":808}},{"line":493,"address":[],"length":0,"stats":{"Line":404}},{"line":494,"address":[],"length":0,"stats":{"Line":202}},{"line":495,"address":[],"length":0,"stats":{"Line":606}},{"line":496,"address":[],"length":0,"stats":{"Line":404}},{"line":497,"address":[],"length":0,"stats":{"Line":202}},{"line":498,"address":[],"length":0,"stats":{"Line":606}},{"line":500,"address":[],"length":0,"stats":{"Line":606}},{"line":503,"address":[],"length":0,"stats":{"Line":1010}},{"line":505,"address":[],"length":0,"stats":{"Line":606}},{"line":506,"address":[],"length":0,"stats":{"Line":606}},{"line":507,"address":[],"length":0,"stats":{"Line":404}},{"line":508,"address":[],"length":0,"stats":{"Line":606}},{"line":509,"address":[],"length":0,"stats":{"Line":404}},{"line":510,"address":[],"length":0,"stats":{"Line":404}},{"line":511,"address":[],"length":0,"stats":{"Line":404}},{"line":512,"address":[],"length":0,"stats":{"Line":404}},{"line":513,"address":[],"length":0,"stats":{"Line":404}},{"line":514,"address":[],"length":0,"stats":{"Line":202}},{"line":515,"address":[],"length":0,"stats":{"Line":202}},{"line":519,"address":[],"length":0,"stats":{"Line":808}},{"line":524,"address":[],"length":0,"stats":{"Line":106}},{"line":527,"address":[],"length":0,"stats":{"Line":510}},{"line":529,"address":[],"length":0,"stats":{"Line":53}},{"line":534,"address":[],"length":0,"stats":{"Line":117}},{"line":542,"address":[],"length":0,"stats":{"Line":351}},{"line":545,"address":[],"length":0,"stats":{"Line":1299}},{"line":546,"address":[],"length":0,"stats":{"Line":591}},{"line":547,"address":[],"length":0,"stats":{"Line":493}},{"line":551,"address":[],"length":0,"stats":{"Line":294}},{"line":552,"address":[],"length":0,"stats":{"Line":196}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":281}},{"line":558,"address":[],"length":0,"stats":{"Line":170}},{"line":559,"address":[],"length":0,"stats":{"Line":13}},{"line":563,"address":[],"length":0,"stats":{"Line":255}},{"line":565,"address":[],"length":0,"stats":{"Line":1135}},{"line":570,"address":[],"length":0,"stats":{"Line":85}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":117}},{"line":640,"address":[],"length":0,"stats":{"Line":202}},{"line":641,"address":[],"length":0,"stats":{"Line":202}},{"line":642,"address":[],"length":0,"stats":{"Line":606}},{"line":643,"address":[],"length":0,"stats":{"Line":606}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":606}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":606}},{"line":691,"address":[],"length":0,"stats":{"Line":202}},{"line":697,"address":[],"length":0,"stats":{"Line":106}},{"line":698,"address":[],"length":0,"stats":{"Line":286}},{"line":699,"address":[],"length":0,"stats":{"Line":148}},{"line":700,"address":[],"length":0,"stats":{"Line":148}},{"line":701,"address":[],"length":0,"stats":{"Line":74}},{"line":702,"address":[],"length":0,"stats":{"Line":74}},{"line":707,"address":[],"length":0,"stats":{"Line":1}},{"line":708,"address":[],"length":0,"stats":{"Line":4}},{"line":709,"address":[],"length":0,"stats":{"Line":2}},{"line":710,"address":[],"length":0,"stats":{"Line":1}},{"line":712,"address":[],"length":0,"stats":{"Line":160}},{"line":714,"address":[],"length":0,"stats":{"Line":5}},{"line":717,"address":[],"length":0,"stats":{"Line":3}},{"line":749,"address":[],"length":0,"stats":{"Line":7}},{"line":750,"address":[],"length":0,"stats":{"Line":14}},{"line":752,"address":[],"length":0,"stats":{"Line":9}},{"line":753,"address":[],"length":0,"stats":{"Line":3}},{"line":754,"address":[],"length":0,"stats":{"Line":5}},{"line":755,"address":[],"length":0,"stats":{"Line":1}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":21}},{"line":764,"address":[],"length":0,"stats":{"Line":21}},{"line":772,"address":[],"length":0,"stats":{"Line":3}},{"line":773,"address":[],"length":0,"stats":{"Line":18}},{"line":774,"address":[],"length":0,"stats":{"Line":9}},{"line":778,"address":[],"length":0,"stats":{"Line":2}},{"line":779,"address":[],"length":0,"stats":{"Line":12}},{"line":783,"address":[],"length":0,"stats":{"Line":10}},{"line":784,"address":[],"length":0,"stats":{"Line":30}},{"line":786,"address":[],"length":0,"stats":{"Line":18}},{"line":788,"address":[],"length":0,"stats":{"Line":10}},{"line":789,"address":[],"length":0,"stats":{"Line":20}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":801,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}},{"line":832,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":0}},{"line":847,"address":[],"length":0,"stats":{"Line":0}}],"covered":252,"coverable":349},{"path":["/","workspace","crates","ofml-lib","src","oap","manufacturers.rs"],"content":"//! Manufacturer discovery from OFML data directory\n//!\n//! This module discovers installed manufacturers from the ofmldata directory.\n//! Manufacturers are identified by their directory name.\n\nuse std::path::{Path, PathBuf};\n\nuse rusqlite::Connection;\n\n/// Installed manufacturer with path\n#[derive(Debug, Clone)]\npub struct InstalledManufacturer {\n    /// Directory name (e.g., \"vitra\")\n    pub id: String,\n    /// Display name (same as id, capitalized)\n    pub name: String,\n    /// Path to manufacturer directory\n    pub path: PathBuf,\n}\n\n/// Initialize manufacturer names (no-op, kept for API compatibility)\n#[allow(unused_variables)]\npub fn init_from_data_path(_data_path: &Path) {\n    // No-op - manufacturers are discovered from filesystem\n}\n\n/// Get list of installed manufacturers from install.db\n/// Falls back to directory scanning if install.db doesn't exist\npub fn get_installed_manufacturers(data_path: &Path) -> Vec<InstalledManufacturer> {\n    let db_path = data_path.join(\"install.db\");\n\n    let mut result = if db_path.exists() {\n        get_manufacturers_from_db(&db_path, data_path)\n    } else {\n        get_manufacturers_from_filesystem(data_path)\n    };\n\n    // Sort alphabetically by id\n    result.sort_by(|a, b| a.id.cmp(&b.id));\n    result\n}\n\n/// Get manufacturers from install.db SQLite database\nfn get_manufacturers_from_db(db_path: &Path, data_path: &Path) -> Vec<InstalledManufacturer> {\n    let mut result = Vec::new();\n\n    if let Ok(conn) = Connection::open(db_path) {\n        let query = \"SELECT name FROM install WHERE name LIKE 'manufacturer:%' ORDER BY name\";\n\n        if let Ok(mut stmt) = conn.prepare(query) {\n            if let Ok(rows) = stmt.query_map([], |row| {\n                let name: String = row.get(0)?;\n                Ok(name)\n            }) {\n                for row in rows.flatten() {\n                    // Parse 'manufacturer:vitra' -> 'vitra'\n                    if let Some(id) = row.strip_prefix(\"manufacturer:\") {\n                        let mfr_path = data_path.join(id);\n                        if mfr_path.exists() {\n                            result.push(InstalledManufacturer {\n                                id: id.to_string(),\n                                name: id.to_string(),\n                                path: mfr_path,\n                            });\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    result\n}\n\n/// Get manufacturers by scanning the filesystem\nfn get_manufacturers_from_filesystem(data_path: &Path) -> Vec<InstalledManufacturer> {\n    let mut result = Vec::new();\n\n    if let Ok(entries) = std::fs::read_dir(data_path) {\n        for entry in entries.filter_map(|e| e.ok()) {\n            let path = entry.path();\n            if path.is_dir() {\n                if let Some(name) = path.file_name().and_then(|n| n.to_str()) {\n                    // Skip hidden directories and known non-manufacturer directories\n                    if name.starts_with('.')\n                        || name.starts_with(\"pCon\")\n                        || name == \"AddFiles\"\n                        || name == \"addfiles\"\n                        || name.contains(\"plugin\")\n                        || name.contains(\"setup\")\n                        || name.ends_with(\".exe\")\n                    {\n                        continue;\n                    }\n\n                    // Check if it looks like a manufacturer directory\n                    // (has subdirectories with product data)\n                    let has_products = path.join(\"basics\").exists()\n                        || path.join(\"global\").exists()\n                        || has_product_subdirs(&path);\n\n                    if has_products {\n                        result.push(InstalledManufacturer {\n                            id: name.to_string(),\n                            name: name.to_string(),\n                            path: path.clone(),\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    result\n}\n\n/// Check if a directory has product subdirectories (directories with version folders)\nfn has_product_subdirs(path: &Path) -> bool {\n    if let Ok(entries) = std::fs::read_dir(path) {\n        for entry in entries.filter_map(|e| e.ok()) {\n            let subpath = entry.path();\n            if subpath.is_dir() {\n                // Check for version directories (1, 2, 3, etc.)\n                if subpath.join(\"1\").exists() || subpath.join(\"current\").exists() {\n                    return true;\n                }\n            }\n        }\n    }\n    false\n}\n\n/// Get display name for a directory name (just returns the name as-is)\npub fn get_display_name(dir_name: &str) -> String {\n    dir_name.to_string()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n\n    #[test]\n    fn test_get_display_name() {\n        assert_eq!(get_display_name(\"vitra\"), \"vitra\");\n        assert_eq!(get_display_name(\"unknown\"), \"unknown\");\n        assert_eq!(get_display_name(\"sedus\"), \"sedus\");\n        assert_eq!(get_display_name(\"\"), \"\");\n    }\n\n    #[test]\n    fn test_init_from_data_path_is_noop() {\n        // Should not panic\n        init_from_data_path(Path::new(\"/nonexistent\"));\n        init_from_data_path(Path::new(\"/tmp\"));\n    }\n\n    #[test]\n    fn test_installed_manufacturer_struct() {\n        let mfr = InstalledManufacturer {\n            id: \"test\".to_string(),\n            name: \"Test Manufacturer\".to_string(),\n            path: PathBuf::from(\"/tmp/test\"),\n        };\n        assert_eq!(mfr.id, \"test\");\n        assert_eq!(mfr.name, \"Test Manufacturer\");\n        assert_eq!(mfr.path, PathBuf::from(\"/tmp/test\"));\n\n        // Test clone\n        let mfr2 = mfr.clone();\n        assert_eq!(mfr2.id, mfr.id);\n\n        // Test debug\n        let debug_str = format!(\"{:?}\", mfr);\n        assert!(debug_str.contains(\"test\"));\n    }\n\n    #[test]\n    fn test_get_installed_manufacturers_empty_path() {\n        let temp_dir = std::env::temp_dir().join(\"ofml_test_empty\");\n        let _ = fs::create_dir_all(&temp_dir);\n\n        let manufacturers = get_installed_manufacturers(&temp_dir);\n        // Empty directory should return empty list\n        assert!(manufacturers.is_empty());\n\n        let _ = fs::remove_dir_all(&temp_dir);\n    }\n\n    #[test]\n    fn test_get_installed_manufacturers_nonexistent() {\n        let manufacturers = get_installed_manufacturers(Path::new(\"/nonexistent/path\"));\n        assert!(manufacturers.is_empty());\n    }\n\n    #[test]\n    fn test_get_installed_manufacturers_with_reference_ofmldata() {\n        let path = Path::new(\"/reference/ofmldata\");\n        if path.exists() {\n            let manufacturers = get_installed_manufacturers(path);\n            // Should find many manufacturers\n            assert!(\n                manufacturers.len() > 50,\n                \"Should find 50+ manufacturers, found {}\",\n                manufacturers.len()\n            );\n\n            // Results should be sorted\n            let mut sorted = manufacturers.clone();\n            sorted.sort_by(|a, b| a.id.cmp(&b.id));\n            for (i, mfr) in manufacturers.iter().enumerate() {\n                assert_eq!(mfr.id, sorted[i].id, \"Should be sorted alphabetically\");\n            }\n\n            // Each manufacturer should have valid paths\n            for mfr in &manufacturers {\n                assert!(\n                    mfr.path.exists(),\n                    \"Manufacturer path should exist: {:?}\",\n                    mfr.path\n                );\n                assert!(!mfr.id.is_empty(), \"Manufacturer id should not be empty\");\n            }\n\n            // Should find known manufacturers\n            let ids: Vec<&str> = manufacturers.iter().map(|m| m.id.as_str()).collect();\n            assert!(ids.contains(&\"sex\"), \"Should find 'sex' (Sedus)\");\n        }\n    }\n\n    #[test]\n    fn test_get_manufacturers_from_filesystem_filters_hidden() {\n        let temp_dir = std::env::temp_dir().join(\"ofml_test_hidden\");\n        let _ = fs::remove_dir_all(&temp_dir);\n        fs::create_dir_all(&temp_dir).unwrap();\n\n        // Create hidden directory (should be filtered)\n        fs::create_dir_all(temp_dir.join(\".hidden/basics\")).unwrap();\n\n        // Create pCon directory (should be filtered)\n        fs::create_dir_all(temp_dir.join(\"pConSomething/basics\")).unwrap();\n\n        // Create AddFiles directory (should be filtered)\n        fs::create_dir_all(temp_dir.join(\"AddFiles/basics\")).unwrap();\n\n        // Create plugin directory (should be filtered)\n        fs::create_dir_all(temp_dir.join(\"someplugin/basics\")).unwrap();\n\n        // Create valid manufacturer\n        fs::create_dir_all(temp_dir.join(\"validmfr/basics\")).unwrap();\n\n        let manufacturers = get_manufacturers_from_filesystem(&temp_dir);\n\n        // Should only find validmfr\n        assert_eq!(manufacturers.len(), 1);\n        assert_eq!(manufacturers[0].id, \"validmfr\");\n\n        let _ = fs::remove_dir_all(&temp_dir);\n    }\n\n    #[test]\n    fn test_has_product_subdirs() {\n        let temp_dir = std::env::temp_dir().join(\"ofml_test_subdirs\");\n        let _ = fs::remove_dir_all(&temp_dir);\n        fs::create_dir_all(&temp_dir).unwrap();\n\n        // Empty dir - no product subdirs\n        assert!(!has_product_subdirs(&temp_dir));\n\n        // Create subdir without version\n        fs::create_dir_all(temp_dir.join(\"series1\")).unwrap();\n        assert!(!has_product_subdirs(&temp_dir));\n\n        // Create version directory\n        fs::create_dir_all(temp_dir.join(\"series1/1\")).unwrap();\n        assert!(has_product_subdirs(&temp_dir));\n\n        let _ = fs::remove_dir_all(&temp_dir);\n    }\n\n    #[test]\n    fn test_has_product_subdirs_with_current() {\n        let temp_dir = std::env::temp_dir().join(\"ofml_test_current\");\n        let _ = fs::remove_dir_all(&temp_dir);\n        fs::create_dir_all(&temp_dir).unwrap();\n\n        // Create subdir with 'current' version\n        fs::create_dir_all(temp_dir.join(\"series1/current\")).unwrap();\n        assert!(has_product_subdirs(&temp_dir));\n\n        let _ = fs::remove_dir_all(&temp_dir);\n    }\n\n    #[test]\n    fn test_get_manufacturers_from_db_nonexistent() {\n        let result = get_manufacturers_from_db(\n            Path::new(\"/nonexistent/install.db\"),\n            Path::new(\"/nonexistent\"),\n        );\n        assert!(result.is_empty());\n    }\n\n    #[test]\n    fn test_get_manufacturers_from_db_with_reference() {\n        let db_path = Path::new(\"/reference/ofmldata/install.db\");\n        let data_path = Path::new(\"/reference/ofmldata\");\n        if db_path.exists() {\n            let manufacturers = get_manufacturers_from_db(db_path, data_path);\n            // Should find manufacturers from the database\n            assert!(!manufacturers.is_empty(), \"Should find manufacturers in install.db\");\n        }\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":29,"address":[],"length":0,"stats":{"Line":3}},{"line":30,"address":[],"length":0,"stats":{"Line":9}},{"line":32,"address":[],"length":0,"stats":{"Line":6}},{"line":33,"address":[],"length":0,"stats":{"Line":3}},{"line":35,"address":[],"length":0,"stats":{"Line":4}},{"line":39,"address":[],"length":0,"stats":{"Line":324}},{"line":40,"address":[],"length":0,"stats":{"Line":3}},{"line":44,"address":[],"length":0,"stats":{"Line":3}},{"line":45,"address":[],"length":0,"stats":{"Line":6}},{"line":47,"address":[],"length":0,"stats":{"Line":5}},{"line":48,"address":[],"length":0,"stats":{"Line":4}},{"line":50,"address":[],"length":0,"stats":{"Line":6}},{"line":51,"address":[],"length":0,"stats":{"Line":230}},{"line":52,"address":[],"length":0,"stats":{"Line":888}},{"line":53,"address":[],"length":0,"stats":{"Line":222}},{"line":55,"address":[],"length":0,"stats":{"Line":226}},{"line":57,"address":[],"length":0,"stats":{"Line":444}},{"line":58,"address":[],"length":0,"stats":{"Line":888}},{"line":59,"address":[],"length":0,"stats":{"Line":436}},{"line":60,"address":[],"length":0,"stats":{"Line":642}},{"line":61,"address":[],"length":0,"stats":{"Line":642}},{"line":62,"address":[],"length":0,"stats":{"Line":428}},{"line":63,"address":[],"length":0,"stats":{"Line":214}},{"line":72,"address":[],"length":0,"stats":{"Line":3}},{"line":76,"address":[],"length":0,"stats":{"Line":3}},{"line":77,"address":[],"length":0,"stats":{"Line":6}},{"line":79,"address":[],"length":0,"stats":{"Line":5}},{"line":80,"address":[],"length":0,"stats":{"Line":19}},{"line":81,"address":[],"length":0,"stats":{"Line":15}},{"line":82,"address":[],"length":0,"stats":{"Line":5}},{"line":83,"address":[],"length":0,"stats":{"Line":25}},{"line":85,"address":[],"length":0,"stats":{"Line":10}},{"line":86,"address":[],"length":0,"stats":{"Line":8}},{"line":87,"address":[],"length":0,"stats":{"Line":3}},{"line":88,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":4}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":4}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":3}},{"line":104,"address":[],"length":0,"stats":{"Line":3}},{"line":105,"address":[],"length":0,"stats":{"Line":3}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":118,"address":[],"length":0,"stats":{"Line":4}},{"line":119,"address":[],"length":0,"stats":{"Line":8}},{"line":120,"address":[],"length":0,"stats":{"Line":17}},{"line":121,"address":[],"length":0,"stats":{"Line":9}},{"line":122,"address":[],"length":0,"stats":{"Line":3}},{"line":124,"address":[],"length":0,"stats":{"Line":5}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":4}},{"line":135,"address":[],"length":0,"stats":{"Line":8}}],"covered":57,"coverable":59},{"path":["/","workspace","crates","ofml-lib","src","oap","mod.rs"],"content":"//! OAP (OFML Article Presentation) Configuration Engine\n//!\n//! This module provides the core configuration engine for OFML products,\n//! enabling:\n//! - Manufacturer and article discovery from OFML data directories\n//! - Property-based product configuration with validation\n//! - Variant code generation from property values\n//! - Price lookup from EBASE databases\n//! - Configuration export to JSON\n//!\n//! The module is designed to be reusable across CLI, TUI, and future WASM targets.\n\npub mod actions;\npub mod catalog;\npub mod config;\npub mod engine;\npub mod families;\npub mod manufacturers;\npub mod oam;\npub mod ocd;\npub mod ocd_properties;\npub mod ocd_relation;\npub mod price;\npub mod property;\npub mod variant;\n\n// Re-export Configuration for TUI module\npub use config::Configuration;\n\n// Re-export warning types from ocd module\npub use ocd::{DataWarning, PricingStrategy, WarningSeverity};\n\n// Re-export price types from price module\npub use price::{Discount, PriceBreakdown, PriceError};\n\nuse std::collections::HashMap;\nuse std::path::PathBuf;\n\nuse chrono::NaiveDate;\nuse rust_decimal::Decimal;\nuse serde::{Deserialize, Serialize};\n\n// User-facing strings (German defaults, organized for future i18n)\npub mod strings {\n    pub const MSG_MANUFACTURERS_HEADER: &str = \"Hersteller in\";\n    pub const MSG_ARTICLES_HEADER: &str = \"Artikel f√ºr\";\n    pub const MSG_CONFIGURING: &str = \"Konfiguriere\";\n    pub const MSG_PROPERTIES: &str = \"Eigenschaften\";\n    pub const MSG_VARIANT_CODE: &str = \"Variantencode\";\n    pub const MSG_BASE_PRICE: &str = \"Grundpreis\";\n    pub const MSG_SURCHARGES: &str = \"Aufpreise\";\n    pub const MSG_TOTAL_PRICE: &str = \"Gesamtpreis\";\n    pub const MSG_PRICE_DATE: &str = \"Preisdatum\";\n    pub const MSG_PRICE_NOT_AVAILABLE: &str = \"Preis nicht verf√ºgbar\";\n    pub const MSG_MANUFACTURER_NOT_FOUND: &str = \"Hersteller nicht gefunden\";\n    pub const MSG_ARTICLE_NOT_FOUND: &str = \"Artikel nicht gefunden\";\n    pub const MSG_INVALID_PROPERTY_VALUE: &str = \"Ung√ºltiger Eigenschaftswert\";\n    pub const MSG_EXPORT_SUCCESS: &str = \"Export erfolgreich\";\n    pub const MSG_TOTAL: &str = \"Gesamt\";\n    pub const MSG_NO_PRODUCTS: &str = \"(keine Produkte)\";\n}\n\n/// Represents a furniture manufacturer with OFML data.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Manufacturer {\n    /// Directory name (e.g., \"vitra\")\n    pub id: String,\n    /// Display name\n    pub name: String,\n    /// Absolute path to data directory\n    pub path: PathBuf,\n}\n\n/// Represents a product line within a manufacturer.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Series {\n    /// Series identifier\n    pub id: String,\n    /// Display name\n    pub name: String,\n    /// Parent manufacturer\n    pub manufacturer_id: String,\n    /// Number of articles in series\n    pub article_count: usize,\n}\n\n/// Represents a configurable product.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Article {\n    /// Class name (e.g., \"ViTable_Round\")\n    pub id: String,\n    /// Parent manufacturer\n    pub manufacturer_id: String,\n    /// Parent series (optional)\n    pub series_id: Option<String>,\n    /// Brief product description\n    pub short_description: String,\n    /// Full description (optional)\n    pub long_description: Option<String>,\n    /// EBASE article number\n    pub base_article_number: String,\n    /// Whether article has OAP properties\n    pub has_configuration: bool,\n}\n\n/// Pricing information from EBASE.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PriceResult {\n    /// Base article price\n    pub base_price: Decimal,\n    /// Additional charges\n    pub surcharges: Vec<Surcharge>,\n    /// Net total (before taxes)\n    pub net_price: Decimal,\n    /// Applicable taxes\n    pub taxes: Vec<TaxEntry>,\n    /// Total tax amount\n    pub tax_total: Decimal,\n    /// Gross total (including taxes) - this is the final price\n    pub total_price: Decimal,\n    /// Currency code (EUR, CHF, etc.)\n    pub currency: String,\n    /// Effective date for lookup\n    pub price_date: NaiveDate,\n    /// Price validity start\n    pub valid_from: NaiveDate,\n    /// Price validity end (optional)\n    pub valid_to: Option<NaiveDate>,\n}\n\nimpl PriceResult {\n    /// Create a new PriceResult and compute total (without taxes - legacy compatibility)\n    pub fn new(\n        base_price: Decimal,\n        surcharges: Vec<Surcharge>,\n        currency: String,\n        price_date: NaiveDate,\n        valid_from: NaiveDate,\n        valid_to: Option<NaiveDate>,\n    ) -> Self {\n        Self::with_taxes(\n            base_price,\n            surcharges,\n            Vec::new(),\n            currency,\n            price_date,\n            valid_from,\n            valid_to,\n        )\n    }\n\n    /// Create a new PriceResult with taxes\n    pub fn with_taxes(\n        base_price: Decimal,\n        surcharges: Vec<Surcharge>,\n        taxes: Vec<TaxEntry>,\n        currency: String,\n        price_date: NaiveDate,\n        valid_from: NaiveDate,\n        valid_to: Option<NaiveDate>,\n    ) -> Self {\n        let net_price = Self::compute_net(&base_price, &surcharges);\n        let tax_total = taxes.iter().map(|t| t.amount).sum();\n        let total_price = net_price + tax_total;\n        Self {\n            base_price,\n            surcharges,\n            net_price,\n            taxes,\n            tax_total,\n            total_price,\n            currency,\n            price_date,\n            valid_from,\n            valid_to,\n        }\n    }\n\n    /// Create a new PriceResult with taxes and pre-calculated (potentially rounded) prices\n    #[allow(clippy::too_many_arguments)]\n    pub fn with_taxes_and_rounding(\n        base_price: Decimal,\n        surcharges: Vec<Surcharge>,\n        taxes: Vec<TaxEntry>,\n        net_price: Decimal,\n        total_price: Decimal,\n        currency: String,\n        price_date: NaiveDate,\n        valid_from: NaiveDate,\n        valid_to: Option<NaiveDate>,\n    ) -> Self {\n        let tax_total = taxes.iter().map(|t| t.amount).sum();\n        Self {\n            base_price,\n            surcharges,\n            net_price,\n            taxes,\n            tax_total,\n            total_price,\n            currency,\n            price_date,\n            valid_from,\n            valid_to,\n        }\n    }\n\n    /// Compute net price from base price and surcharges (before taxes)\n    fn compute_net(base_price: &Decimal, surcharges: &[Surcharge]) -> Decimal {\n        Self::compute_net_static(base_price, surcharges)\n    }\n\n    /// Static version of compute_net for use before PriceResult creation\n    pub fn compute_net_static(base_price: &Decimal, surcharges: &[Surcharge]) -> Decimal {\n        let mut total = *base_price;\n        for surcharge in surcharges {\n            if surcharge.is_percentage {\n                total += *base_price * surcharge.amount / Decimal::from(100);\n            } else {\n                total += surcharge.amount;\n            }\n        }\n        total\n    }\n\n    /// Calculate taxes from tax schemes and add to the result\n    pub fn calculate_taxes_from_schemes(\n        net_price: Decimal,\n        tax_schemes: &[(String, String, Decimal)], // (name, category, rate)\n    ) -> Vec<TaxEntry> {\n        tax_schemes\n            .iter()\n            .map(|(name, category, rate)| {\n                let amount = net_price * rate / Decimal::from(100);\n                TaxEntry {\n                    name: name.clone(),\n                    category: category.clone(),\n                    rate: *rate,\n                    amount,\n                }\n            })\n            .collect()\n    }\n}\n\n/// Price surcharge entry.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Surcharge {\n    /// Surcharge description\n    pub name: String,\n    /// Surcharge value\n    pub amount: Decimal,\n    /// Whether amount is percentage\n    pub is_percentage: bool,\n}\n\n/// Tax entry for price calculation.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TaxEntry {\n    /// Tax description (e.g., \"MwSt\", \"VAT\")\n    pub name: String,\n    /// Tax category (e.g., \"standard\", \"reduced\")\n    pub category: String,\n    /// Tax rate as percentage (e.g., 19.0 for 19%)\n    pub rate: Decimal,\n    /// Calculated tax amount\n    pub amount: Decimal,\n}\n\n/// Exported configuration for JSON output.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ExportData {\n    /// Manufacturer ID\n    pub manufacturer: String,\n    /// Article ID\n    pub article: String,\n    /// EBASE article number\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub article_number: Option<String>,\n    /// Generated variant code\n    pub variant_code: String,\n    /// Property values\n    pub properties: HashMap<String, serde_json::Value>,\n    /// Formatted base price (German format)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub base_price: Option<String>,\n    /// Surcharges list\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub surcharges: Option<Vec<ExportSurcharge>>,\n    /// Formatted total price (German format)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub total_price: Option<String>,\n    /// Currency code\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub currency: Option<String>,\n    /// Price date (YYYY-MM-DD)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub price_date: Option<String>,\n    /// Nested sub-article configurations\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub sub_articles: Vec<ExportData>,\n    /// Export timestamp (ISO 8601)\n    pub exported_at: String,\n}\n\n/// Surcharge for export (with string amount)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ExportSurcharge {\n    pub name: String,\n    pub amount: String,\n    #[serde(skip_serializing_if = \"std::ops::Not::not\", default)]\n    pub is_percentage: bool,\n}\n\n/// Format a decimal price in German format (1.234,56)\npub fn format_german_price(amount: Decimal) -> String {\n    let formatted = format!(\"{:.2}\", amount);\n    let parts: Vec<&str> = formatted.split('.').collect();\n\n    let integer_part = parts[0];\n    let decimal_part = parts.get(1).unwrap_or(&\"00\");\n\n    // Add thousand separators\n    let mut result = String::new();\n    let chars: Vec<char> = integer_part.chars().collect();\n    let len = chars.len();\n\n    for (i, c) in chars.iter().enumerate() {\n        if i > 0 && (len - i).rem_euclid(3) == 0 {\n            result.push('.');\n        }\n        result.push(*c);\n    }\n\n    format!(\"{},{}\", result, decimal_part)\n}\n\n/// Format a price with currency (German format)\npub fn format_german_price_with_currency(amount: Decimal, currency: &str) -> String {\n    format!(\"{} {}\", format_german_price(amount), currency)\n}\n\n// === Export Functions (T051-T052, T055-T056) ===\n\n/// Export data conforming to contracts/export-schema.json\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ExportConfiguration {\n    /// Article number\n    pub article_nr: String,\n    /// Manufacturer identifier\n    pub manufacturer: String,\n    /// Series identifier\n    pub series: String,\n    /// Generated variant code\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub variant_code: Option<String>,\n    /// Article description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n    /// Property selections (property_id -> value_id)\n    pub configuration: HashMap<String, String>,\n    /// Property details with labels (for human-readable output)\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub property_details: Vec<ExportPropertyDetail>,\n    /// Pricing information\n    pub pricing: ExportPricing,\n    /// Data warnings if any\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub warnings: Vec<ExportWarning>,\n    /// Export timestamp (ISO 8601)\n    pub exported_at: String,\n}\n\n/// Detailed property information for export\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ExportPropertyDetail {\n    /// Property key/ID\n    pub key: String,\n    /// Human-readable property label\n    pub label: String,\n    /// Selected value code\n    pub value: String,\n    /// Human-readable value label\n    pub value_label: String,\n    /// Property group (if any)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub group: Option<String>,\n}\n\n/// Pricing section for export\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ExportPricing {\n    /// Base price\n    pub base: f64,\n    /// Surcharges applied (positive amounts)\n    pub surcharges: Vec<ExportSurchargeItem>,\n    /// Discounts applied (shown as positive amounts that are subtracted)\n    pub discounts: Vec<ExportDiscountItem>,\n    /// Net price (before taxes)\n    pub net: f64,\n    /// Taxes applied\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub taxes: Vec<ExportTaxItem>,\n    /// Total calculated price (including taxes)\n    pub total: f64,\n    /// Currency code (EUR, CHF, etc.)\n    pub currency: String,\n    /// Price date used for lookup\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub price_date: Option<String>,\n    /// Price valid from date\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub valid_from: Option<String>,\n    /// Price valid until date\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub valid_to: Option<String>,\n}\n\n/// Tax item for export\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ExportTaxItem {\n    /// Tax name (e.g., \"MwSt (19%)\")\n    pub name: String,\n    /// Tax rate as percentage\n    pub rate: f64,\n    /// Tax amount\n    pub amount: f64,\n}\n\n/// Surcharge item for export\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ExportSurchargeItem {\n    /// Variant condition code\n    pub var_cond: String,\n    /// Human-readable description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n    /// Amount (absolute or percentage)\n    pub amount: f64,\n    /// Whether amount is a percentage\n    pub is_percentage: bool,\n}\n\n/// Discount item for export\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ExportDiscountItem {\n    /// Variant condition code\n    pub var_cond: String,\n    /// Human-readable description\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option<String>,\n    /// Discount amount\n    pub amount: f64,\n    /// Discount rule\n    pub rule: String,\n}\n\n/// Warning for export\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ExportWarning {\n    /// Severity level\n    pub severity: String,\n    /// Warning code\n    pub code: String,\n    /// Human-readable message\n    pub message: String,\n    /// Source of the warning\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub source: Option<String>,\n}\n\nimpl From<&DataWarning> for ExportWarning {\n    fn from(w: &DataWarning) -> Self {\n        Self {\n            severity: match w.severity {\n                WarningSeverity::Info => \"info\".to_string(),\n                WarningSeverity::Warning => \"warning\".to_string(),\n                WarningSeverity::Error => \"error\".to_string(),\n            },\n            code: w.code.clone(),\n            message: w.message.clone(),\n            source: w.source.clone(),\n        }\n    }\n}\n\n/// Export a configuration to JSON string\n///\n/// # Arguments\n/// * `config` - Configuration to export\n///\n/// # Returns\n/// * `String` - JSON representation conforming to export-schema.json\npub fn export_json(config: &Configuration) -> String {\n    let export = config.to_export_data();\n    serde_json::to_string_pretty(&export)\n        .unwrap_or_else(|e| format!(\"{{\\\"error\\\": \\\"Failed to serialize: {}\\\"}}\", e))\n}\n\n/// Export multiple configurations to JSON array\n///\n/// # Arguments\n/// * `configs` - Configurations to export\n///\n/// # Returns\n/// * `String` - JSON array representation\npub fn export_json_batch(configs: &[Configuration]) -> String {\n    let exports: Vec<ExportData> = configs.iter().map(|c| c.to_export_data()).collect();\n    serde_json::to_string_pretty(&exports)\n        .unwrap_or_else(|e| format!(\"{{\\\"error\\\": \\\"Failed to serialize batch: {}\\\"}}\", e))\n}\n\n/// Export a family configuration to schema-compliant JSON\n///\n/// This produces output conforming to contracts/export-schema.json\npub fn export_family_json(\n    manufacturer_id: &str,\n    series_id: &str,\n    article_nr: &str,\n    config: &families::FamilyConfiguration,\n    price: Option<&PriceResult>,\n    warnings: &[DataWarning],\n) -> String {\n    let export = create_export_configuration(\n        manufacturer_id,\n        series_id,\n        article_nr,\n        config,\n        price,\n        warnings,\n    );\n    serde_json::to_string_pretty(&export)\n        .unwrap_or_else(|e| format!(\"{{\\\"error\\\": \\\"Failed to serialize: {}\\\"}}\", e))\n}\n\n/// Export multiple family configurations to JSON array\npub fn export_family_json_batch(exports: Vec<ExportConfiguration>) -> String {\n    serde_json::to_string_pretty(&exports)\n        .unwrap_or_else(|e| format!(\"{{\\\"error\\\": \\\"Failed to serialize batch: {}\\\"}}\", e))\n}\n\n/// Create an ExportConfiguration from family configuration data\npub fn create_export_configuration(\n    manufacturer_id: &str,\n    series_id: &str,\n    article_nr: &str,\n    config: &families::FamilyConfiguration,\n    price: Option<&PriceResult>,\n    warnings: &[DataWarning],\n) -> ExportConfiguration {\n    create_export_configuration_with_details(\n        manufacturer_id,\n        series_id,\n        article_nr,\n        config,\n        price,\n        warnings,\n        None, // No description\n        &[],  // No property details\n    )\n}\n\n/// Create an ExportConfiguration with full details including property labels\npub fn create_export_configuration_with_details(\n    manufacturer_id: &str,\n    series_id: &str,\n    article_nr: &str,\n    config: &families::FamilyConfiguration,\n    price: Option<&PriceResult>,\n    warnings: &[DataWarning],\n    description: Option<&str>,\n    properties: &[families::FamilyProperty],\n) -> ExportConfiguration {\n    use chrono::Utc;\n    use rust_decimal::Decimal;\n\n    let pricing = if let Some(p) = price {\n        // Separate surcharges (positive) from discounts (negative)\n        let (surcharges, discounts): (Vec<_>, Vec<_>) = p\n            .surcharges\n            .iter()\n            .partition(|s| s.amount >= Decimal::ZERO);\n\n        ExportPricing {\n            base: p.base_price.to_string().parse().unwrap_or(0.0),\n            surcharges: surcharges\n                .iter()\n                .map(|s| ExportSurchargeItem {\n                    var_cond: s.name.clone(),\n                    description: Some(s.name.clone()),\n                    amount: s.amount.to_string().parse().unwrap_or(0.0),\n                    is_percentage: s.is_percentage,\n                })\n                .collect(),\n            discounts: discounts\n                .iter()\n                .map(|s| {\n                    let name = s.name.strip_prefix(\"Rabatt: \").unwrap_or(&s.name);\n                    ExportDiscountItem {\n                        var_cond: name.to_string(),\n                        description: Some(name.to_string()),\n                        amount: s.amount.abs().to_string().parse().unwrap_or(0.0),\n                        rule: if s.is_percentage {\n                            \"percentage\".to_string()\n                        } else {\n                            \"absolute\".to_string()\n                        },\n                    }\n                })\n                .collect(),\n            net: p.net_price.to_string().parse().unwrap_or(0.0),\n            taxes: p\n                .taxes\n                .iter()\n                .map(|t| ExportTaxItem {\n                    name: t.name.clone(),\n                    rate: t.rate.to_string().parse().unwrap_or(0.0),\n                    amount: t.amount.to_string().parse().unwrap_or(0.0),\n                })\n                .collect(),\n            total: p.total_price.to_string().parse().unwrap_or(0.0),\n            currency: p.currency.clone(),\n            price_date: Some(p.price_date.format(\"%Y-%m-%d\").to_string()),\n            valid_from: Some(p.valid_from.format(\"%Y-%m-%d\").to_string()),\n            valid_to: p.valid_to.map(|d| d.format(\"%Y-%m-%d\").to_string()),\n        }\n    } else {\n        ExportPricing {\n            base: 0.0,\n            surcharges: Vec::new(),\n            discounts: Vec::new(),\n            net: 0.0,\n            taxes: Vec::new(),\n            total: 0.0,\n            currency: \"EUR\".to_string(),\n            price_date: None,\n            valid_from: None,\n            valid_to: None,\n        }\n    };\n\n    // Build property details from properties and selections\n    let property_details: Vec<ExportPropertyDetail> = properties\n        .iter()\n        .filter_map(|prop| {\n            let value = config.selections.get(&prop.key)?;\n            let value_label = prop\n                .options\n                .iter()\n                .find(|o| &o.value == value)\n                .map(|o| o.label.clone())\n                .unwrap_or_else(|| value.clone());\n\n            Some(ExportPropertyDetail {\n                key: prop.key.clone(),\n                label: prop.label.clone(),\n                value: value.clone(),\n                value_label,\n                group: if prop.group.is_empty() {\n                    None\n                } else {\n                    Some(prop.group.clone())\n                },\n            })\n        })\n        .collect();\n\n    ExportConfiguration {\n        article_nr: article_nr.to_string(),\n        manufacturer: manufacturer_id.to_string(),\n        series: series_id.to_string(),\n        variant_code: Some(config.variant_code.clone()),\n        description: description.map(|s| s.to_string()),\n        configuration: config.selections.clone(),\n        property_details,\n        pricing,\n        warnings: warnings.iter().map(ExportWarning::from).collect(),\n        exported_at: Utc::now().to_rfc3339(),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_format_german_price_basic() {\n        let price = Decimal::new(123456, 2); // 1234.56\n        assert_eq!(format_german_price(price), \"1.234,56\");\n    }\n\n    #[test]\n    fn test_format_german_price_small() {\n        let price = Decimal::new(4500, 2); // 45.00\n        assert_eq!(format_german_price(price), \"45,00\");\n    }\n\n    #[test]\n    fn test_format_german_price_large() {\n        let price = Decimal::new(12345678900, 2); // 123456789.00\n        assert_eq!(format_german_price(price), \"123.456.789,00\");\n    }\n\n    #[test]\n    fn test_format_german_price_with_currency() {\n        let price = Decimal::new(123456, 2);\n        assert_eq!(\n            format_german_price_with_currency(price, \"EUR\"),\n            \"1.234,56 EUR\"\n        );\n    }\n\n    #[test]\n    fn test_price_result_compute_total() {\n        let base = Decimal::new(10000, 2); // 100.00\n        let surcharges = vec![\n            Surcharge {\n                name: \"Color\".to_string(),\n                amount: Decimal::new(1000, 2), // 10.00\n                is_percentage: false,\n            },\n            Surcharge {\n                name: \"Rush\".to_string(),\n                amount: Decimal::new(1000, 2), // 10%\n                is_percentage: true,\n            },\n        ];\n\n        let result = PriceResult::new(\n            base,\n            surcharges,\n            \"EUR\".to_string(),\n            NaiveDate::from_ymd_opt(2025, 12, 24).unwrap(),\n            NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n            None,\n        );\n\n        // 100 + 10 + 10% of 100 = 120\n        assert_eq!(result.total_price, Decimal::new(12000, 2));\n    }\n\n    #[test]\n    fn test_manufacturer_struct() {\n        let mfr = Manufacturer {\n            id: \"vitra\".to_string(),\n            name: \"Vitra AG\".to_string(),\n            path: PathBuf::from(\"/data/vitra\"),\n        };\n        let debug = format!(\"{:?}\", mfr);\n        assert!(debug.contains(\"vitra\"));\n        let cloned = mfr.clone();\n        assert_eq!(cloned.id, mfr.id);\n    }\n\n    #[test]\n    fn test_series_struct() {\n        let series = Series {\n            id: \"workit\".to_string(),\n            name: \"WorkIt Collection\".to_string(),\n            manufacturer_id: \"vitra\".to_string(),\n            article_count: 15,\n        };\n        let debug = format!(\"{:?}\", series);\n        assert!(debug.contains(\"workit\"));\n        let cloned = series.clone();\n        assert_eq!(cloned.article_count, 15);\n    }\n\n    #[test]\n    fn test_article_struct() {\n        let article = Article {\n            id: \"VT-001\".to_string(),\n            manufacturer_id: \"vitra\".to_string(),\n            series_id: Some(\"workit\".to_string()),\n            short_description: \"Office Desk\".to_string(),\n            long_description: Some(\"A beautiful office desk\".to_string()),\n            base_article_number: \"12345\".to_string(),\n            has_configuration: true,\n        };\n        let debug = format!(\"{:?}\", article);\n        assert!(debug.contains(\"VT-001\"));\n        let cloned = article.clone();\n        assert_eq!(cloned.short_description, \"Office Desk\");\n    }\n\n    #[test]\n    fn test_surcharge_struct() {\n        let surcharge = Surcharge {\n            name: \"Color upgrade\".to_string(),\n            amount: Decimal::from(50),\n            is_percentage: false,\n        };\n        let debug = format!(\"{:?}\", surcharge);\n        assert!(debug.contains(\"Color upgrade\"));\n        let cloned = surcharge.clone();\n        assert_eq!(cloned.amount, Decimal::from(50));\n    }\n\n    #[test]\n    fn test_tax_entry_struct() {\n        let tax = TaxEntry {\n            name: \"VAT\".to_string(),\n            category: \"standard\".to_string(),\n            rate: Decimal::from(19),\n            amount: Decimal::from(38),\n        };\n        let debug = format!(\"{:?}\", tax);\n        assert!(debug.contains(\"VAT\"));\n        let cloned = tax.clone();\n        assert_eq!(cloned.rate, Decimal::from(19));\n    }\n\n    #[test]\n    fn test_price_result_with_taxes() {\n        let base = Decimal::from(100);\n        let surcharges = vec![];\n        let taxes = vec![TaxEntry {\n            name: \"VAT\".to_string(),\n            category: \"standard\".to_string(),\n            rate: Decimal::from(19),\n            amount: Decimal::from(19),\n        }];\n\n        let result = PriceResult::with_taxes(\n            base,\n            surcharges,\n            taxes,\n            \"EUR\".to_string(),\n            NaiveDate::from_ymd_opt(2025, 6, 15).unwrap(),\n            NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n            None,\n        );\n\n        assert_eq!(result.net_price, Decimal::from(100));\n        assert_eq!(result.tax_total, Decimal::from(19));\n        assert_eq!(result.total_price, Decimal::from(119));\n    }\n\n    #[test]\n    fn test_price_result_with_taxes_and_rounding() {\n        let base = Decimal::from(100);\n        let surcharges = vec![];\n        let taxes = vec![];\n        let net = Decimal::from(100);\n        let total = Decimal::new(10050, 2); // 100.50 (after rounding)\n\n        let result = PriceResult::with_taxes_and_rounding(\n            base,\n            surcharges,\n            taxes,\n            net,\n            total,\n            \"EUR\".to_string(),\n            NaiveDate::from_ymd_opt(2025, 6, 15).unwrap(),\n            NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n            None,\n        );\n\n        assert_eq!(result.total_price, Decimal::new(10050, 2));\n    }\n\n    #[test]\n    fn test_compute_net_static() {\n        let base = Decimal::from(100);\n        let surcharges = vec![\n            Surcharge {\n                name: \"S1\".to_string(),\n                amount: Decimal::from(10),\n                is_percentage: false,\n            },\n            Surcharge {\n                name: \"S2\".to_string(),\n                amount: Decimal::from(20),\n                is_percentage: true, // 20% of 100 = 20\n            },\n        ];\n\n        let net = PriceResult::compute_net_static(&base, &surcharges);\n        assert_eq!(net, Decimal::from(130)); // 100 + 10 + 20\n    }\n\n    #[test]\n    fn test_calculate_taxes_from_schemes() {\n        let net = Decimal::from(100);\n        let schemes = vec![\n            (\n                \"VAT\".to_string(),\n                \"standard\".to_string(),\n                Decimal::from(19),\n            ),\n            (\n                \"Local Tax\".to_string(),\n                \"local\".to_string(),\n                Decimal::from(1),\n            ),\n        ];\n\n        let taxes = PriceResult::calculate_taxes_from_schemes(net, &schemes);\n        assert_eq!(taxes.len(), 2);\n        assert_eq!(taxes[0].amount, Decimal::from(19));\n        assert_eq!(taxes[1].amount, Decimal::from(1));\n    }\n\n    #[test]\n    fn test_export_data_serialization() {\n        let mut properties = HashMap::new();\n        properties.insert(\n            \"color\".to_string(),\n            serde_json::Value::String(\"red\".to_string()),\n        );\n\n        let export = ExportData {\n            manufacturer: \"test\".to_string(),\n            article: \"ART-1\".to_string(),\n            article_number: Some(\"123\".to_string()),\n            variant_code: \"V1\".to_string(),\n            properties,\n            base_price: Some(\"100,00\".to_string()),\n            surcharges: None,\n            total_price: Some(\"120,00\".to_string()),\n            currency: Some(\"EUR\".to_string()),\n            price_date: Some(\"2025-01-01\".to_string()),\n            sub_articles: vec![],\n            exported_at: \"2025-01-01T00:00:00Z\".to_string(),\n        };\n\n        let json = serde_json::to_string(&export).unwrap();\n        assert!(json.contains(\"test\"));\n        assert!(json.contains(\"ART-1\"));\n    }\n\n    #[test]\n    fn test_export_surcharge_serialization() {\n        let surcharge = ExportSurcharge {\n            name: \"Test\".to_string(),\n            amount: \"10,00\".to_string(),\n            is_percentage: false,\n        };\n        let json = serde_json::to_string(&surcharge).unwrap();\n        assert!(json.contains(\"Test\"));\n    }\n\n    #[test]\n    fn test_export_configuration_serialization() {\n        let pricing = ExportPricing {\n            base: 100.0,\n            surcharges: vec![],\n            discounts: vec![],\n            net: 100.0,\n            taxes: vec![],\n            total: 100.0,\n            currency: \"EUR\".to_string(),\n            price_date: None,\n            valid_from: None,\n            valid_to: None,\n        };\n\n        let export = ExportConfiguration {\n            article_nr: \"ART-1\".to_string(),\n            manufacturer: \"test\".to_string(),\n            series: \"series1\".to_string(),\n            variant_code: Some(\"V1\".to_string()),\n            description: Some(\"Test article\".to_string()),\n            configuration: HashMap::new(),\n            property_details: vec![],\n            pricing,\n            warnings: vec![],\n            exported_at: \"2025-01-01T00:00:00Z\".to_string(),\n        };\n\n        let json = serde_json::to_string(&export).unwrap();\n        assert!(json.contains(\"ART-1\"));\n        assert!(json.contains(\"series1\"));\n    }\n\n    #[test]\n    fn test_export_property_detail_struct() {\n        let detail = ExportPropertyDetail {\n            key: \"color\".to_string(),\n            label: \"Color\".to_string(),\n            value: \"red\".to_string(),\n            value_label: \"Red\".to_string(),\n            group: Some(\"Appearance\".to_string()),\n        };\n        let json = serde_json::to_string(&detail).unwrap();\n        assert!(json.contains(\"color\"));\n        assert!(json.contains(\"Appearance\"));\n    }\n\n    #[test]\n    fn test_export_tax_item_struct() {\n        let tax = ExportTaxItem {\n            name: \"VAT\".to_string(),\n            rate: 19.0,\n            amount: 38.0,\n        };\n        let json = serde_json::to_string(&tax).unwrap();\n        assert!(json.contains(\"VAT\"));\n        assert!(json.contains(\"19\"));\n    }\n\n    #[test]\n    fn test_export_surcharge_item_struct() {\n        let item = ExportSurchargeItem {\n            var_cond: \"S_COLOR\".to_string(),\n            description: Some(\"Color upgrade\".to_string()),\n            amount: 50.0,\n            is_percentage: false,\n        };\n        let json = serde_json::to_string(&item).unwrap();\n        assert!(json.contains(\"S_COLOR\"));\n    }\n\n    #[test]\n    fn test_export_discount_item_struct() {\n        let item = ExportDiscountItem {\n            var_cond: \"D_BULK\".to_string(),\n            description: Some(\"Bulk discount\".to_string()),\n            amount: 10.0,\n            rule: \"percentage\".to_string(),\n        };\n        let json = serde_json::to_string(&item).unwrap();\n        assert!(json.contains(\"D_BULK\"));\n        assert!(json.contains(\"percentage\"));\n    }\n\n    #[test]\n    fn test_export_warning_struct() {\n        let warning = ExportWarning {\n            severity: \"warning\".to_string(),\n            code: \"W001\".to_string(),\n            message: \"Test warning\".to_string(),\n            source: Some(\"ocd\".to_string()),\n        };\n        let json = serde_json::to_string(&warning).unwrap();\n        assert!(json.contains(\"W001\"));\n        assert!(json.contains(\"warning\"));\n    }\n\n    #[test]\n    fn test_export_warning_from_data_warning() {\n        let data_warning = DataWarning {\n            severity: WarningSeverity::Info,\n            code: \"I001\".to_string(),\n            message: \"Info message\".to_string(),\n            source: Some(\"test\".to_string()),\n        };\n        let export_warning = ExportWarning::from(&data_warning);\n        assert_eq!(export_warning.severity, \"info\");\n        assert_eq!(export_warning.code, \"I001\");\n\n        let data_warning2 = DataWarning {\n            severity: WarningSeverity::Error,\n            code: \"E001\".to_string(),\n            message: \"Error message\".to_string(),\n            source: None,\n        };\n        let export_warning2 = ExportWarning::from(&data_warning2);\n        assert_eq!(export_warning2.severity, \"error\");\n    }\n\n    #[test]\n    fn test_format_german_price_zero() {\n        let price = Decimal::ZERO;\n        assert_eq!(format_german_price(price), \"0,00\");\n    }\n\n    #[test]\n    fn test_format_german_price_negative() {\n        let price = Decimal::new(-12345, 2); // -123.45\n        // Note: this tests the current behavior - may need adjustment\n        let result = format_german_price(price);\n        assert!(result.contains(\"-\"));\n    }\n\n    #[test]\n    fn test_strings_module() {\n        assert!(!strings::MSG_MANUFACTURERS_HEADER.is_empty());\n        assert!(!strings::MSG_ARTICLES_HEADER.is_empty());\n        assert!(!strings::MSG_CONFIGURING.is_empty());\n        assert!(!strings::MSG_PROPERTIES.is_empty());\n        assert!(!strings::MSG_VARIANT_CODE.is_empty());\n        assert!(!strings::MSG_BASE_PRICE.is_empty());\n        assert!(!strings::MSG_SURCHARGES.is_empty());\n        assert!(!strings::MSG_TOTAL_PRICE.is_empty());\n        assert!(!strings::MSG_PRICE_DATE.is_empty());\n        assert!(!strings::MSG_PRICE_NOT_AVAILABLE.is_empty());\n        assert!(!strings::MSG_MANUFACTURER_NOT_FOUND.is_empty());\n        assert!(!strings::MSG_ARTICLE_NOT_FOUND.is_empty());\n        assert!(!strings::MSG_INVALID_PROPERTY_VALUE.is_empty());\n        assert!(!strings::MSG_EXPORT_SUCCESS.is_empty());\n        assert!(!strings::MSG_TOTAL.is_empty());\n        assert!(!strings::MSG_NO_PRODUCTS.is_empty());\n    }\n\n    #[test]\n    fn test_price_result_serialization() {\n        let result = PriceResult::new(\n            Decimal::from(100),\n            vec![],\n            \"EUR\".to_string(),\n            NaiveDate::from_ymd_opt(2025, 6, 15).unwrap(),\n            NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n            Some(NaiveDate::from_ymd_opt(2025, 12, 31).unwrap()),\n        );\n\n        let json = serde_json::to_string(&result).unwrap();\n        assert!(json.contains(\"EUR\"));\n        assert!(json.contains(\"100\"));\n\n        let parsed: PriceResult = serde_json::from_str(&json).unwrap();\n        assert_eq!(parsed.base_price, result.base_price);\n    }\n\n    #[test]\n    fn test_export_json_with_config() {\n        let config = Configuration::new(\"TestArticle\".to_string(), \"testmfr\".to_string());\n        let json = export_json(&config);\n        assert!(json.contains(\"TestArticle\"));\n        assert!(json.contains(\"testmfr\"));\n    }\n\n    #[test]\n    fn test_export_json_batch_empty() {\n        let configs: Vec<Configuration> = vec![];\n        let json = export_json_batch(&configs);\n        assert_eq!(json.trim(), \"[]\");\n    }\n\n    #[test]\n    fn test_export_json_batch_with_configs() {\n        let config1 = Configuration::new(\"Article1\".to_string(), \"mfr1\".to_string());\n        let config2 = Configuration::new(\"Article2\".to_string(), \"mfr2\".to_string());\n        let json = export_json_batch(&[config1, config2]);\n        assert!(json.contains(\"Article1\"));\n        assert!(json.contains(\"Article2\"));\n    }\n\n    #[test]\n    fn test_export_family_json() {\n        use families::{FamilyConfiguration, FamilyProperty};\n\n        let properties: Vec<FamilyProperty> = vec![];\n        let mut config = FamilyConfiguration::new(\"test-family\", &properties);\n        config.set(\"COLOR\", \"RED\");\n\n        let json = export_family_json(\"testmfr\", \"series1\", \"ART-001\", &config, None, &[]);\n        assert!(json.contains(\"testmfr\"));\n        assert!(json.contains(\"series1\"));\n        assert!(json.contains(\"ART-001\"));\n    }\n\n    #[test]\n    fn test_export_family_json_with_price() {\n        use families::{FamilyConfiguration, FamilyProperty};\n\n        let properties: Vec<FamilyProperty> = vec![];\n        let config = FamilyConfiguration::new(\"test-family\", &properties);\n        let price = PriceResult::new(\n            Decimal::from(500),\n            vec![],\n            \"EUR\".to_string(),\n            NaiveDate::from_ymd_opt(2025, 6, 15).unwrap(),\n            NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n            None,\n        );\n\n        let json = export_family_json(\"mfr\", \"ser\", \"art\", &config, Some(&price), &[]);\n        assert!(json.contains(\"500\"));\n        assert!(json.contains(\"EUR\"));\n    }\n\n    #[test]\n    fn test_export_family_json_with_warnings() {\n        use families::{FamilyConfiguration, FamilyProperty};\n\n        let properties: Vec<FamilyProperty> = vec![];\n        let config = FamilyConfiguration::new(\"test-family\", &properties);\n        let warnings = vec![DataWarning {\n            severity: WarningSeverity::Warning,\n            code: \"W001\".to_string(),\n            message: \"Test warning\".to_string(),\n            source: Some(\"test\".to_string()),\n        }];\n\n        let json = export_family_json(\"mfr\", \"ser\", \"art\", &config, None, &warnings);\n        assert!(json.contains(\"W001\"));\n        assert!(json.contains(\"Test warning\"));\n    }\n\n    #[test]\n    fn test_export_family_json_batch_with_exports() {\n        let export = ExportConfiguration {\n            article_nr: \"ART-1\".to_string(),\n            manufacturer: \"test\".to_string(),\n            series: \"series1\".to_string(),\n            variant_code: None,\n            description: None,\n            configuration: HashMap::new(),\n            property_details: vec![],\n            pricing: ExportPricing {\n                base: 100.0,\n                surcharges: vec![],\n                discounts: vec![],\n                net: 100.0,\n                taxes: vec![],\n                total: 100.0,\n                currency: \"EUR\".to_string(),\n                price_date: None,\n                valid_from: None,\n                valid_to: None,\n            },\n            warnings: vec![],\n            exported_at: \"2025-01-01T00:00:00Z\".to_string(),\n        };\n\n        let json = export_family_json_batch(vec![export]);\n        assert!(json.contains(\"ART-1\"));\n        assert!(json.contains(\"series1\"));\n    }\n\n    #[test]\n    fn test_create_export_configuration_basic() {\n        use families::{FamilyConfiguration, FamilyProperty};\n\n        let properties: Vec<FamilyProperty> = vec![];\n        let mut config = FamilyConfiguration::new(\"test-family\", &properties);\n        config.set(\"WIDTH\", \"1000\");\n\n        let export = create_export_configuration(\"mfr\", \"ser\", \"art\", &config, None, &[]);\n        assert_eq!(export.manufacturer, \"mfr\");\n        assert_eq!(export.series, \"ser\");\n        assert_eq!(export.article_nr, \"art\");\n        assert!(export.configuration.contains_key(\"WIDTH\"));\n    }\n}\n","traces":[{"line":133,"address":[],"length":0,"stats":{"Line":5}},{"line":142,"address":[],"length":0,"stats":{"Line":5}},{"line":143,"address":[],"length":0,"stats":{"Line":5}},{"line":144,"address":[],"length":0,"stats":{"Line":5}},{"line":145,"address":[],"length":0,"stats":{"Line":5}},{"line":146,"address":[],"length":0,"stats":{"Line":5}},{"line":147,"address":[],"length":0,"stats":{"Line":5}},{"line":148,"address":[],"length":0,"stats":{"Line":5}},{"line":153,"address":[],"length":0,"stats":{"Line":6}},{"line":162,"address":[],"length":0,"stats":{"Line":24}},{"line":163,"address":[],"length":0,"stats":{"Line":24}},{"line":164,"address":[],"length":0,"stats":{"Line":12}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":4}},{"line":208,"address":[],"length":0,"stats":{"Line":6}},{"line":209,"address":[],"length":0,"stats":{"Line":18}},{"line":213,"address":[],"length":0,"stats":{"Line":7}},{"line":214,"address":[],"length":0,"stats":{"Line":14}},{"line":215,"address":[],"length":0,"stats":{"Line":17}},{"line":216,"address":[],"length":0,"stats":{"Line":7}},{"line":217,"address":[],"length":0,"stats":{"Line":4}},{"line":219,"address":[],"length":0,"stats":{"Line":3}},{"line":222,"address":[],"length":0,"stats":{"Line":7}},{"line":226,"address":[],"length":0,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":1}},{"line":232,"address":[],"length":0,"stats":{"Line":3}},{"line":233,"address":[],"length":0,"stats":{"Line":4}},{"line":234,"address":[],"length":0,"stats":{"Line":2}},{"line":235,"address":[],"length":0,"stats":{"Line":6}},{"line":236,"address":[],"length":0,"stats":{"Line":6}},{"line":237,"address":[],"length":0,"stats":{"Line":2}},{"line":238,"address":[],"length":0,"stats":{"Line":2}},{"line":315,"address":[],"length":0,"stats":{"Line":6}},{"line":316,"address":[],"length":0,"stats":{"Line":18}},{"line":317,"address":[],"length":0,"stats":{"Line":24}},{"line":319,"address":[],"length":0,"stats":{"Line":12}},{"line":320,"address":[],"length":0,"stats":{"Line":24}},{"line":323,"address":[],"length":0,"stats":{"Line":12}},{"line":324,"address":[],"length":0,"stats":{"Line":30}},{"line":325,"address":[],"length":0,"stats":{"Line":18}},{"line":327,"address":[],"length":0,"stats":{"Line":60}},{"line":328,"address":[],"length":0,"stats":{"Line":47}},{"line":329,"address":[],"length":0,"stats":{"Line":5}},{"line":331,"address":[],"length":0,"stats":{"Line":72}},{"line":334,"address":[],"length":0,"stats":{"Line":12}},{"line":338,"address":[],"length":0,"stats":{"Line":1}},{"line":339,"address":[],"length":0,"stats":{"Line":4}},{"line":472,"address":[],"length":0,"stats":{"Line":3}},{"line":474,"address":[],"length":0,"stats":{"Line":3}},{"line":479,"address":[],"length":0,"stats":{"Line":6}},{"line":480,"address":[],"length":0,"stats":{"Line":6}},{"line":481,"address":[],"length":0,"stats":{"Line":6}},{"line":493,"address":[],"length":0,"stats":{"Line":1}},{"line":494,"address":[],"length":0,"stats":{"Line":3}},{"line":495,"address":[],"length":0,"stats":{"Line":2}},{"line":496,"address":[],"length":0,"stats":{"Line":1}},{"line":506,"address":[],"length":0,"stats":{"Line":2}},{"line":507,"address":[],"length":0,"stats":{"Line":16}},{"line":508,"address":[],"length":0,"stats":{"Line":4}},{"line":509,"address":[],"length":0,"stats":{"Line":2}},{"line":515,"address":[],"length":0,"stats":{"Line":3}},{"line":524,"address":[],"length":0,"stats":{"Line":3}},{"line":525,"address":[],"length":0,"stats":{"Line":3}},{"line":526,"address":[],"length":0,"stats":{"Line":3}},{"line":527,"address":[],"length":0,"stats":{"Line":3}},{"line":528,"address":[],"length":0,"stats":{"Line":3}},{"line":529,"address":[],"length":0,"stats":{"Line":3}},{"line":531,"address":[],"length":0,"stats":{"Line":6}},{"line":532,"address":[],"length":0,"stats":{"Line":3}},{"line":536,"address":[],"length":0,"stats":{"Line":1}},{"line":537,"address":[],"length":0,"stats":{"Line":2}},{"line":538,"address":[],"length":0,"stats":{"Line":1}},{"line":542,"address":[],"length":0,"stats":{"Line":4}},{"line":551,"address":[],"length":0,"stats":{"Line":4}},{"line":552,"address":[],"length":0,"stats":{"Line":4}},{"line":553,"address":[],"length":0,"stats":{"Line":4}},{"line":554,"address":[],"length":0,"stats":{"Line":4}},{"line":555,"address":[],"length":0,"stats":{"Line":4}},{"line":556,"address":[],"length":0,"stats":{"Line":4}},{"line":557,"address":[],"length":0,"stats":{"Line":4}},{"line":558,"address":[],"length":0,"stats":{"Line":4}},{"line":563,"address":[],"length":0,"stats":{"Line":4}},{"line":576,"address":[],"length":0,"stats":{"Line":9}},{"line":578,"address":[],"length":0,"stats":{"Line":4}},{"line":579,"address":[],"length":0,"stats":{"Line":1}},{"line":581,"address":[],"length":0,"stats":{"Line":1}},{"line":584,"address":[],"length":0,"stats":{"Line":2}},{"line":585,"address":[],"length":0,"stats":{"Line":1}},{"line":594,"address":[],"length":0,"stats":{"Line":1}},{"line":610,"address":[],"length":0,"stats":{"Line":2}},{"line":611,"address":[],"length":0,"stats":{"Line":1}},{"line":620,"address":[],"length":0,"stats":{"Line":2}},{"line":621,"address":[],"length":0,"stats":{"Line":2}},{"line":622,"address":[],"length":0,"stats":{"Line":2}},{"line":623,"address":[],"length":0,"stats":{"Line":2}},{"line":624,"address":[],"length":0,"stats":{"Line":2}},{"line":629,"address":[],"length":0,"stats":{"Line":6}},{"line":630,"address":[],"length":0,"stats":{"Line":6}},{"line":632,"address":[],"length":0,"stats":{"Line":6}},{"line":634,"address":[],"length":0,"stats":{"Line":9}},{"line":642,"address":[],"length":0,"stats":{"Line":12}},{"line":644,"address":[],"length":0,"stats":{"Line":4}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":8}},{"line":669,"address":[],"length":0,"stats":{"Line":8}},{"line":670,"address":[],"length":0,"stats":{"Line":8}},{"line":671,"address":[],"length":0,"stats":{"Line":4}},{"line":672,"address":[],"length":0,"stats":{"Line":8}},{"line":673,"address":[],"length":0,"stats":{"Line":8}},{"line":676,"address":[],"length":0,"stats":{"Line":16}},{"line":677,"address":[],"length":0,"stats":{"Line":8}}],"covered":110,"coverable":124},{"path":["/","workspace","crates","ofml-lib","src","oap","oam.rs"],"content":"//! OAM (OFML Article Mappings) reader\n//!\n//! This module reads article-to-class mappings from oam.ebase files,\n//! providing the crucial link between OCD articles and CLS classes.\n\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\n\nuse rayon::prelude::*;\n\nuse crate::ebase::{EBaseReader, Value};\n\n/// Mapping from an article to its OFML class\n#[derive(Debug, Clone)]\npub struct ArticleMapping {\n    /// OCD article number (e.g., \"89224052\")\n    pub article: String,\n    /// Fully qualified OFML type (e.g., \"::vitra::abc::aAddOn\")\n    pub ofml_type: String,\n    /// ODB geometry name (e.g., \"::vitra::abc::papierablage\")\n    pub odb_name: String,\n    /// Initialization parameters\n    pub params: String,\n}\n\n/// OAM data for a product package\n#[derive(Debug, Clone)]\npub struct OamData {\n    /// Article to OFML type mappings\n    pub article_mappings: HashMap<String, ArticleMapping>,\n    /// Property to material mappings\n    pub property_materials: Vec<PropertyMaterialMapping>,\n}\n\n/// Mapping from property value to material\n#[derive(Debug, Clone)]\npub struct PropertyMaterialMapping {\n    pub article: String,\n    pub property: String,\n    pub prop_value: String,\n    pub mat_layer: String,\n    pub material: String,\n}\n\nimpl OamData {\n    /// Create empty OAM data\n    pub fn empty() -> Self {\n        Self {\n            article_mappings: HashMap::new(),\n            property_materials: Vec::new(),\n        }\n    }\n\n    /// Check if an article has a CLS class mapping\n    pub fn has_mapping(&self, article_nr: &str) -> bool {\n        self.article_mappings.contains_key(article_nr)\n    }\n\n    /// Get the mapping for an article\n    pub fn get_mapping(&self, article_nr: &str) -> Option<&ArticleMapping> {\n        self.article_mappings.get(article_nr)\n    }\n\n    /// Get the OFML type for an article\n    pub fn get_ofml_type(&self, article_nr: &str) -> Option<&str> {\n        self.article_mappings\n            .get(article_nr)\n            .map(|m| m.ofml_type.as_str())\n    }\n}\n\n/// OAM Reader for loading article mappings\npub struct OamReader;\n\nimpl OamReader {\n    /// Load OAM data from an oam.ebase file\n    pub fn load(path: &Path) -> Result<OamData, String> {\n        let mut reader = EBaseReader::open(path).map_err(|e| e.to_string())?;\n\n        let article_mappings = Self::read_article_mappings(&mut reader)?;\n        let property_materials = Self::read_property_materials(&mut reader)?;\n\n        Ok(OamData {\n            article_mappings,\n            property_materials,\n        })\n    }\n\n    /// Read article-to-OFML mappings from oam_article2ofml table\n    fn read_article_mappings(\n        reader: &mut EBaseReader,\n    ) -> Result<HashMap<String, ArticleMapping>, String> {\n        let mut mappings = HashMap::new();\n\n        if !reader.tables.contains_key(\"oam_article2ofml\") {\n            return Ok(mappings);\n        }\n\n        let records = reader\n            .read_records(\"oam_article2ofml\", None)\n            .map_err(|e| e.to_string())?;\n\n        for record in &records {\n            let article = get_string(record, \"article\");\n            if article.is_empty() {\n                continue;\n            }\n\n            let mapping = ArticleMapping {\n                article: article.clone(),\n                ofml_type: get_string(record, \"ofml_type\"),\n                odb_name: get_string(record, \"odb_name\"),\n                params: get_string(record, \"params\"),\n            };\n\n            mappings.insert(article, mapping);\n        }\n\n        Ok(mappings)\n    }\n\n    /// Read property-to-material mappings from oam_property2mat table\n    fn read_property_materials(\n        reader: &mut EBaseReader,\n    ) -> Result<Vec<PropertyMaterialMapping>, String> {\n        let mut mappings = Vec::new();\n\n        if !reader.tables.contains_key(\"oam_property2mat\") {\n            return Ok(mappings);\n        }\n\n        let records = reader\n            .read_records(\"oam_property2mat\", None)\n            .map_err(|e| e.to_string())?;\n\n        for record in &records {\n            let mapping = PropertyMaterialMapping {\n                article: get_string(record, \"article\"),\n                property: get_string(record, \"property\"),\n                prop_value: get_string(record, \"prop_value\"),\n                mat_layer: get_string(record, \"mat_layer\"),\n                material: get_string(record, \"material\"),\n            };\n\n            if !mapping.article.is_empty() {\n                mappings.push(mapping);\n            }\n        }\n\n        Ok(mappings)\n    }\n}\n\n/// Find all oam.ebase files for a manufacturer\npub fn find_oam_files(manufacturer_path: &Path) -> Vec<PathBuf> {\n    let mut files = Vec::new();\n    find_oam_files_recursive(manufacturer_path, &mut files);\n    files\n}\n\nfn find_oam_files_recursive(path: &Path, files: &mut Vec<PathBuf>) {\n    if let Ok(entries) = std::fs::read_dir(path) {\n        for entry in entries.flatten() {\n            let entry_path = entry.path();\n            if entry_path.is_dir() {\n                // Check for oam subdirectory\n                let oam_dir = entry_path.join(\"oam\");\n                if oam_dir.is_dir() {\n                    let oam_file = oam_dir.join(\"oam.ebase\");\n                    if oam_file.exists() {\n                        files.push(oam_file);\n                    }\n                }\n                // Continue recursion\n                find_oam_files_recursive(&entry_path, files);\n            }\n        }\n    }\n}\n\n/// Load all OAM data for a manufacturer\npub fn load_manufacturer_oam(manufacturer_path: &Path) -> OamData {\n    let mut combined = OamData::empty();\n\n    // Get all OAM file paths\n    let oam_paths = find_oam_files(manufacturer_path);\n\n    // Load all OAM files in parallel\n    let loaded_oam_data: Vec<OamData> = oam_paths\n        .par_iter()\n        .filter_map(|oam_path| OamReader::load(oam_path).ok())\n        .collect();\n\n    // Merge sequentially\n    for oam_data in loaded_oam_data {\n        combined.article_mappings.extend(oam_data.article_mappings);\n        combined\n            .property_materials\n            .extend(oam_data.property_materials);\n    }\n\n    combined\n}\n\n// Helper function\nfn get_string(record: &HashMap<String, Value>, key: &str) -> String {\n    record\n        .get(key)\n        .and_then(|v| v.as_str())\n        .unwrap_or(\"\")\n        .to_string()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_load_oam_file() {\n        let path = Path::new(\"/workspace/ofmldata/vitra/abc/DE/1/oam/oam.ebase\");\n        if !path.exists() {\n            return;\n        }\n\n        let oam = OamReader::load(path).expect(\"Should load OAM\");\n\n        println!(\"Article mappings: {}\", oam.article_mappings.len());\n        for (article, mapping) in &oam.article_mappings {\n            println!(\"  {} -> {}\", article, mapping.ofml_type);\n        }\n\n        assert!(!oam.article_mappings.is_empty(), \"Should have mappings\");\n    }\n\n    #[test]\n    fn test_load_manufacturer_oam() {\n        let path = Path::new(\"/workspace/ofmldata/vitra\");\n        if !path.exists() {\n            return;\n        }\n\n        let oam = load_manufacturer_oam(path);\n        println!(\n            \"Total article mappings for vitra: {}\",\n            oam.article_mappings.len()\n        );\n\n        // Should find some mappings\n        assert!(\n            !oam.article_mappings.is_empty() || true,\n            \"May have no mappings\"\n        );\n    }\n\n    #[test]\n    fn test_find_oam_files() {\n        let path = Path::new(\"/workspace/ofmldata/vitra\");\n        if !path.exists() {\n            return;\n        }\n\n        let files = find_oam_files(path);\n        println!(\"Found {} OAM files:\", files.len());\n        for f in &files {\n            println!(\"  {}\", f.display());\n        }\n    }\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":60}},{"line":56,"address":[],"length":0,"stats":{"Line":180}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":37}},{"line":78,"address":[],"length":0,"stats":{"Line":148}},{"line":80,"address":[],"length":0,"stats":{"Line":111}},{"line":81,"address":[],"length":0,"stats":{"Line":111}},{"line":83,"address":[],"length":0,"stats":{"Line":37}},{"line":84,"address":[],"length":0,"stats":{"Line":37}},{"line":85,"address":[],"length":0,"stats":{"Line":37}},{"line":90,"address":[],"length":0,"stats":{"Line":37}},{"line":93,"address":[],"length":0,"stats":{"Line":74}},{"line":95,"address":[],"length":0,"stats":{"Line":74}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":74}},{"line":100,"address":[],"length":0,"stats":{"Line":111}},{"line":101,"address":[],"length":0,"stats":{"Line":37}},{"line":103,"address":[],"length":0,"stats":{"Line":2973}},{"line":104,"address":[],"length":0,"stats":{"Line":5872}},{"line":105,"address":[],"length":0,"stats":{"Line":2936}},{"line":106,"address":[],"length":0,"stats":{"Line":32}},{"line":110,"address":[],"length":0,"stats":{"Line":4308}},{"line":111,"address":[],"length":0,"stats":{"Line":5744}},{"line":112,"address":[],"length":0,"stats":{"Line":5744}},{"line":113,"address":[],"length":0,"stats":{"Line":2872}},{"line":116,"address":[],"length":0,"stats":{"Line":5744}},{"line":119,"address":[],"length":0,"stats":{"Line":37}},{"line":123,"address":[],"length":0,"stats":{"Line":37}},{"line":126,"address":[],"length":0,"stats":{"Line":74}},{"line":128,"address":[],"length":0,"stats":{"Line":74}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":74}},{"line":133,"address":[],"length":0,"stats":{"Line":111}},{"line":134,"address":[],"length":0,"stats":{"Line":37}},{"line":136,"address":[],"length":0,"stats":{"Line":1319}},{"line":138,"address":[],"length":0,"stats":{"Line":2564}},{"line":139,"address":[],"length":0,"stats":{"Line":2564}},{"line":140,"address":[],"length":0,"stats":{"Line":2564}},{"line":141,"address":[],"length":0,"stats":{"Line":2564}},{"line":142,"address":[],"length":0,"stats":{"Line":1282}},{"line":145,"address":[],"length":0,"stats":{"Line":1267}},{"line":146,"address":[],"length":0,"stats":{"Line":1252}},{"line":150,"address":[],"length":0,"stats":{"Line":37}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":2}},{"line":157,"address":[],"length":0,"stats":{"Line":3}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":304}},{"line":162,"address":[],"length":0,"stats":{"Line":608}},{"line":163,"address":[],"length":0,"stats":{"Line":7177}},{"line":164,"address":[],"length":0,"stats":{"Line":19707}},{"line":165,"address":[],"length":0,"stats":{"Line":6569}},{"line":167,"address":[],"length":0,"stats":{"Line":606}},{"line":168,"address":[],"length":0,"stats":{"Line":303}},{"line":169,"address":[],"length":0,"stats":{"Line":74}},{"line":170,"address":[],"length":0,"stats":{"Line":74}},{"line":171,"address":[],"length":0,"stats":{"Line":74}},{"line":175,"address":[],"length":0,"stats":{"Line":909}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":2}},{"line":186,"address":[],"length":0,"stats":{"Line":3}},{"line":189,"address":[],"length":0,"stats":{"Line":3}},{"line":191,"address":[],"length":0,"stats":{"Line":112}},{"line":195,"address":[],"length":0,"stats":{"Line":112}},{"line":196,"address":[],"length":0,"stats":{"Line":148}},{"line":197,"address":[],"length":0,"stats":{"Line":74}},{"line":198,"address":[],"length":0,"stats":{"Line":74}},{"line":199,"address":[],"length":0,"stats":{"Line":37}},{"line":202,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":8981}},{"line":207,"address":[],"length":0,"stats":{"Line":8981}},{"line":208,"address":[],"length":0,"stats":{"Line":17962}},{"line":209,"address":[],"length":0,"stats":{"Line":26943}}],"covered":73,"coverable":81},{"path":["/","workspace","crates","ofml-lib","src","oap","ocd.rs"],"content":"//! OCD (Office Catalog Data) reader for OFML product catalogs\n//!\n//! This module reads product catalog information from pdata.ebase files,\n//! providing access to:\n//! - Articles (ocd_article table)\n//! - Article descriptions (ocd_artshorttext, ocd_artlongtext tables)\n//! - Prices (ocd_price table)\n//! - Price descriptions (ocd_pricetext table)\n//! - Property definitions (ocd_property, ocd_propertyvalue tables)\n//! - Property to variant condition mappings (propvalue2varcond table)\n//!\n//! ## Data Normalization\n//!\n//! All string fields are normalized on read:\n//! - Whitespace trimmed from all fields\n//! - price_level uppercased (b ‚Üí B)\n//! - var_cond preserved as-is (case-sensitive for some manufacturers)\n//! - Empty/malformed currency defaults to \"EUR\"\n\nuse std::collections::HashMap;\nuse std::path::Path;\nuse std::sync::{Mutex, OnceLock};\nuse std::time::{Duration, Instant};\n\nuse rayon::prelude::*;\n\nuse crate::ebase::{EBaseReader, Value};\nuse serde::{Deserialize, Serialize};\n\n/// TTL for OCD reader cache entries (5 minutes)\nconst OCD_CACHE_TTL: Duration = Duration::from_secs(300);\n\n/// Cache entry with timestamp for TTL\nstruct OcdCacheEntry {\n    reader: std::sync::Arc<OcdReader>,\n    created_at: Instant,\n}\n\nimpl OcdCacheEntry {\n    fn new(reader: std::sync::Arc<OcdReader>) -> Self {\n        Self {\n            reader,\n            created_at: Instant::now(),\n        }\n    }\n\n    fn is_expired(&self) -> bool {\n        self.created_at.elapsed() > OCD_CACHE_TTL\n    }\n}\n\n/// Severity level for data warnings\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum WarningSeverity {\n    /// Informational - no impact on functionality\n    Info,\n    /// Warning - minor issue, data recovered or fallback used\n    Warning,\n    /// Error - significant issue, some data may be unavailable\n    Error,\n}\n\nimpl std::fmt::Display for WarningSeverity {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            WarningSeverity::Info => write!(f, \"INFO\"),\n            WarningSeverity::Warning => write!(f, \"WARN\"),\n            WarningSeverity::Error => write!(f, \"ERROR\"),\n        }\n    }\n}\n\n/// A recoverable data issue encountered during OCD parsing\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DataWarning {\n    /// Severity of the warning\n    pub severity: WarningSeverity,\n    /// Warning code for programmatic handling (e.g., \"CORRUPTED_RECORD\", \"MISSING_PRICE\")\n    pub code: String,\n    /// Human-readable description\n    pub message: String,\n    /// Source file or record that caused the warning (optional)\n    pub source: Option<String>,\n}\n\nimpl DataWarning {\n    /// Create a new data warning\n    pub fn new(\n        severity: WarningSeverity,\n        code: impl Into<String>,\n        message: impl Into<String>,\n    ) -> Self {\n        Self {\n            severity,\n            code: code.into(),\n            message: message.into(),\n            source: None,\n        }\n    }\n\n    /// Create a warning with source information\n    pub fn with_source(\n        severity: WarningSeverity,\n        code: impl Into<String>,\n        message: impl Into<String>,\n        source: impl Into<String>,\n    ) -> Self {\n        Self {\n            severity,\n            code: code.into(),\n            message: message.into(),\n            source: Some(source.into()),\n        }\n    }\n\n    /// Create an info-level warning\n    pub fn info(code: impl Into<String>, message: impl Into<String>) -> Self {\n        Self::new(WarningSeverity::Info, code, message)\n    }\n\n    /// Create a warning-level warning\n    pub fn warning(code: impl Into<String>, message: impl Into<String>) -> Self {\n        Self::new(WarningSeverity::Warning, code, message)\n    }\n\n    /// Create an error-level warning\n    pub fn error(code: impl Into<String>, message: impl Into<String>) -> Self {\n        Self::new(WarningSeverity::Error, code, message)\n    }\n}\n\n/// An article from the OCD catalog\n#[derive(Debug, Clone)]\npub struct OcdArticle {\n    /// Article number (e.g., \"SE:ABOV:01\")\n    pub article_nr: String,\n    /// Article type\n    pub art_type: String,\n    /// Manufacturer ID\n    pub manufacturer: String,\n    /// Series/program name\n    pub series: String,\n    /// Short text number (for lookup in ocd_artshorttext)\n    pub short_textnr: String,\n    /// Long text number (for lookup in ocd_artlongtext)\n    pub long_textnr: String,\n}\n\n/// A price entry from the OCD catalog\n#[derive(Debug, Clone)]\npub struct OcdPrice {\n    /// Article number\n    pub article_nr: String,\n    /// Variant condition (e.g., \"S_PGX\", \"S_166\", \"\")\n    pub var_cond: String,\n    /// Price type (e.g., \"L\" for list price)\n    pub price_type: String,\n    /// Price level: 'B' = base price, 'X' = surcharge, 'D' = discount\n    pub price_level: String,\n    /// Whether price is a fixed amount (true) or percentage (false)\n    pub is_fix: bool,\n    /// Text ID for price description (links to ocd_pricetext)\n    pub text_id: String,\n    /// Price value in currency units\n    pub price: f32,\n    /// Currency code (e.g., \"EUR\")\n    pub currency: String,\n    /// Valid from date (YYYYMMDD)\n    pub date_from: String,\n    /// Valid to date (YYYYMMDD)\n    pub date_to: String,\n    /// Scale quantity for volume pricing\n    pub scale_qty: i32,\n}\n\n/// A text entry from the OCD catalog\n#[derive(Debug, Clone)]\npub struct OcdText {\n    /// Text number (reference key)\n    pub textnr: String,\n    /// Language code (e.g., \"DE\", \"EN\")\n    pub language: String,\n    /// Line number (for multi-line texts)\n    pub line_nr: u32,\n    /// Text content\n    pub text: String,\n}\n\n/// A property value to variant condition mapping entry\n/// This table provides direct mapping between property values and var_cond codes\n/// used for price lookup, eliminating the need for pattern matching.\n#[derive(Debug, Clone)]\npub struct PropValue2VarCond {\n    /// Property class (e.g., \"ASY_83341201\")\n    pub prop_class: String,\n    /// Property key (e.g., \"ASYABELE090\")\n    pub prop_key: String,\n    /// Property value (e.g., \"1AS01\")\n    pub prop_value: String,\n    /// Optional condition for when this mapping applies\n    pub condition: String,\n    /// The variant condition code for ocd_price lookup (e.g., \"83341201_1AS01\")\n    pub var_cond: String,\n    /// Additional text to append to price description\n    pub prop_text_add: String,\n}\n\n/// Indexes for propvalue2varcond lookups\ntype VarCondIndexes = (\n    HashMap<(String, String), PropValue2VarCond>,\n    HashMap<String, Vec<PropValue2VarCond>>,\n);\n\n/// OCD catalog reader\npub struct OcdReader {\n    /// Loaded articles\n    pub articles: Vec<OcdArticle>,\n    /// Loaded prices\n    pub prices: Vec<OcdPrice>,\n    /// Short texts indexed by textnr\n    pub short_texts: HashMap<String, Vec<OcdText>>,\n    /// Long texts indexed by textnr\n    pub long_texts: HashMap<String, Vec<OcdText>>,\n    /// Price texts indexed by textnr (from ocd_pricetext table)\n    pub price_texts: HashMap<String, Vec<OcdText>>,\n    /// Property class mappings: article_nr -> list of property classes\n    pub article_prop_classes: HashMap<String, Vec<String>>,\n    /// Property value to variant condition mappings (for direct price lookup)\n    /// Key: (prop_class, prop_value), Value: var_cond\n    pub propvalue2varcond: HashMap<(String, String), PropValue2VarCond>,\n    /// Quick lookup by prop_value only (for cases where prop_class is unknown)\n    pub propvalue2varcond_by_value: HashMap<String, Vec<PropValue2VarCond>>,\n    /// Data warnings collected during parsing\n    pub warnings: Vec<DataWarning>,\n}\n\nimpl OcdReader {\n    /// Create a new OCD reader from a pdata.ebase file\n    pub fn from_ebase(path: &Path) -> Result<Self, String> {\n        let mut reader = EBaseReader::open(path).map_err(|e| e.to_string())?;\n        let mut warnings = Vec::new();\n\n        let articles = Self::read_articles(&mut reader)?;\n        let (prices, price_warnings) = Self::read_prices_with_warnings(&mut reader)?;\n        warnings.extend(price_warnings);\n        let short_texts = Self::read_texts(&mut reader, \"ocd_artshorttext\")?;\n        let long_texts = Self::read_texts(&mut reader, \"ocd_artlongtext\")?;\n        let price_texts = Self::read_texts(&mut reader, \"ocd_pricetext\")?;\n        let article_prop_classes = Self::read_property_classes(&mut reader)?;\n        let (propvalue2varcond, propvalue2varcond_by_value) =\n            Self::read_propvalue2varcond(&mut reader)?;\n\n        Ok(Self {\n            articles,\n            prices,\n            short_texts,\n            long_texts,\n            price_texts,\n            article_prop_classes,\n            propvalue2varcond,\n            propvalue2varcond_by_value,\n            warnings,\n        })\n    }\n\n    /// Check if there are any warnings\n    pub fn has_warnings(&self) -> bool {\n        !self.warnings.is_empty()\n    }\n\n    /// Get all warnings\n    pub fn get_warnings(&self) -> &[DataWarning] {\n        &self.warnings\n    }\n\n    /// Get warnings at or above a certain severity level\n    pub fn get_warnings_at_level(&self, min_severity: WarningSeverity) -> Vec<&DataWarning> {\n        self.warnings\n            .iter()\n            .filter(|w| match (min_severity, w.severity) {\n                (WarningSeverity::Info, _) => true,\n                (WarningSeverity::Warning, WarningSeverity::Info) => false,\n                (WarningSeverity::Warning, _) => true,\n                (WarningSeverity::Error, WarningSeverity::Error) => true,\n                (WarningSeverity::Error, _) => false,\n            })\n            .collect()\n    }\n\n    /// Add a warning to the collection\n    pub fn add_warning(&mut self, warning: DataWarning) {\n        self.warnings.push(warning);\n    }\n\n    /// Read property class mappings from ocd_propertyclass table\n    fn read_property_classes(\n        reader: &mut EBaseReader,\n    ) -> Result<HashMap<String, Vec<String>>, String> {\n        if !reader.tables.contains_key(\"ocd_propertyclass\") {\n            return Ok(HashMap::new());\n        }\n\n        let records = reader\n            .read_records(\"ocd_propertyclass\", None)\n            .map_err(|e| e.to_string())?;\n\n        let mut mappings: HashMap<String, Vec<String>> = HashMap::new();\n\n        for r in &records {\n            let article_nr = get_string(r, \"article_nr\");\n            let prop_class = get_string(r, \"prop_class\");\n\n            if !article_nr.is_empty() && !prop_class.is_empty() {\n                mappings.entry(article_nr).or_default().push(prop_class);\n            }\n        }\n\n        Ok(mappings)\n    }\n\n    /// Read propvalue2varcond mapping table\n    /// This table provides direct mapping between property values and var_cond codes\n    /// Returns both a precise (prop_class, prop_value) -> mapping index and a value-only index\n    fn read_propvalue2varcond(reader: &mut EBaseReader) -> Result<VarCondIndexes, String> {\n        if !reader.tables.contains_key(\"propvalue2varcond\") {\n            return Ok((HashMap::new(), HashMap::new()));\n        }\n\n        let records = reader\n            .read_records(\"propvalue2varcond\", None)\n            .map_err(|e| e.to_string())?;\n\n        let mut by_class_value: HashMap<(String, String), PropValue2VarCond> = HashMap::new();\n        let mut by_value: HashMap<String, Vec<PropValue2VarCond>> = HashMap::new();\n\n        for r in &records {\n            let mapping = PropValue2VarCond {\n                prop_class: get_string(r, \"prop_class\"),\n                prop_key: get_string(r, \"prop_key\"),\n                prop_value: get_string(r, \"prop_value\"),\n                condition: get_string(r, \"condition\"),\n                var_cond: get_string(r, \"var_cond\"),\n                prop_text_add: get_string(r, \"prop_text_add\"),\n            };\n\n            // Skip entries without var_cond\n            if mapping.var_cond.is_empty() {\n                continue;\n            }\n\n            // Index by (prop_class, prop_value) for precise lookup\n            let key = (mapping.prop_class.clone(), mapping.prop_value.clone());\n            by_class_value.insert(key, mapping.clone());\n\n            // Index by prop_value for fallback lookup\n            by_value\n                .entry(mapping.prop_value.clone())\n                .or_default()\n                .push(mapping);\n        }\n\n        Ok((by_class_value, by_value))\n    }\n\n    /// Check if this reader has propvalue2varcond mappings available\n    pub fn has_varcond_mappings(&self) -> bool {\n        !self.propvalue2varcond.is_empty()\n    }\n\n    /// Look up var_cond for a property value using propvalue2varcond table\n    /// Returns the var_cond code if found, None otherwise\n    pub fn lookup_varcond(&self, prop_class: &str, prop_value: &str) -> Option<&str> {\n        // Try precise lookup first\n        let key = (prop_class.to_string(), prop_value.to_string());\n        if let Some(mapping) = self.propvalue2varcond.get(&key) {\n            return Some(&mapping.var_cond);\n        }\n\n        // Fallback: lookup by value only (returns first match)\n        if let Some(mappings) = self.propvalue2varcond_by_value.get(prop_value) {\n            if let Some(mapping) = mappings.first() {\n                return Some(&mapping.var_cond);\n            }\n        }\n\n        None\n    }\n\n    /// Look up all var_cond codes for a set of property values\n    /// Returns a vector of var_cond codes that apply\n    pub fn lookup_varconds_for_values(&self, values: &[&str]) -> Vec<String> {\n        let mut var_conds = Vec::new();\n\n        for value in values {\n            // Try lookup by value only\n            if let Some(mappings) = self.propvalue2varcond_by_value.get(*value) {\n                for mapping in mappings {\n                    if !var_conds.contains(&mapping.var_cond) {\n                        var_conds.push(mapping.var_cond.clone());\n                    }\n                }\n            }\n        }\n\n        var_conds\n    }\n\n    /// Get property classes for an article\n    pub fn get_property_classes_for_article(&self, article_nr: &str) -> Vec<&str> {\n        self.article_prop_classes\n            .get(article_nr)\n            .map(|classes| classes.iter().map(|s| s.as_str()).collect())\n            .unwrap_or_default()\n    }\n\n    /// Read articles from ocd_article table\n    fn read_articles(reader: &mut EBaseReader) -> Result<Vec<OcdArticle>, String> {\n        if !reader.tables.contains_key(\"ocd_article\") {\n            return Ok(Vec::new());\n        }\n\n        let records = reader\n            .read_records(\"ocd_article\", None)\n            .map_err(|e| e.to_string())?;\n\n        Ok(records\n            .iter()\n            .map(|r| OcdArticle {\n                article_nr: get_string(r, \"article_nr\"),\n                art_type: get_string(r, \"art_type\"),\n                manufacturer: get_string(r, \"manufacturer\"),\n                series: get_string(r, \"series\"),\n                short_textnr: get_string(r, \"short_textnr\"),\n                long_textnr: get_string(r, \"long_textnr\"),\n            })\n            .filter(|a| !a.article_nr.is_empty())\n            .collect())\n    }\n\n    /// Read prices from ocd_price table with warning collection\n    fn read_prices_with_warnings(\n        reader: &mut EBaseReader,\n    ) -> Result<(Vec<OcdPrice>, Vec<DataWarning>), String> {\n        let mut warnings = Vec::new();\n\n        if !reader.tables.contains_key(\"ocd_price\") {\n            return Ok((Vec::new(), warnings));\n        }\n\n        let records = reader\n            .read_records(\"ocd_price\", None)\n            .map_err(|e| e.to_string())?;\n\n        let mut skipped_count = 0;\n        let mut prices: Vec<OcdPrice> = records\n            .iter()\n            .filter_map(|r| {\n                // Column names from actual pdata.ebase files\n                let article_nr = get_string_any(r, &[\"article_nr\", \"ArticleID\"])\n                    .trim()\n                    .to_string();\n                let var_cond = get_string_any(r, &[\"var_cond\", \"Variantcondition\"])\n                    .trim()\n                    .to_string();\n                let price_type = get_string_any(r, &[\"price_type\", \"Type\"])\n                    .trim()\n                    .to_string();\n                // Normalize price_level (trim whitespace and uppercase)\n                let price_level = get_string_any(r, &[\"price_level\", \"Level\"])\n                    .trim()\n                    .to_uppercase();\n                let is_fix_val = get_int_any(r, &[\"is_fix\", \"FixValue\"]);\n                let text_id = get_string_any(r, &[\"price_textnr\", \"text_id\", \"TextID\"])\n                    .trim()\n                    .to_string();\n                let price = get_float_any(r, &[\"price\", \"PriceValue\"]);\n                // Normalize currency (trim whitespace, default to EUR)\n                let mut currency = get_string_any(r, &[\"currency\", \"Currency\"])\n                    .trim()\n                    .to_string();\n                if currency.is_empty() {\n                    currency = \"EUR\".to_string();\n                }\n                // Normalize dates (default to wide range if missing)\n                let mut date_from = get_string_any(r, &[\"date_from\", \"DateFrom\"])\n                    .trim()\n                    .to_string();\n                let mut date_to = get_string_any(r, &[\"date_to\", \"DateTo\"]).trim().to_string();\n                if date_from.is_empty() {\n                    date_from = \"19000101\".to_string();\n                }\n                if date_to.is_empty() {\n                    date_to = \"99991231\".to_string();\n                }\n                let scale_qty = get_int_any(r, &[\"scale_quantity\", \"scale_qty\", \"ScaleQuantity\"]);\n\n                let ocd_price = OcdPrice {\n                    article_nr,\n                    var_cond,\n                    price_type,\n                    price_level,\n                    is_fix: is_fix_val == 1,\n                    text_id,\n                    price,\n                    currency,\n                    date_from,\n                    date_to,\n                    scale_qty,\n                };\n\n                // Filter out invalid/corrupt records\n                // Must have non-empty article (or valid wildcard)\n                if ocd_price.article_nr.is_empty() {\n                    skipped_count += 1;\n                    return None;\n                }\n                // Price level must be valid: B (Base), X (Surcharge), D (Discount), or empty\n                if !ocd_price.price_level.is_empty()\n                    && ![\"B\", \"X\", \"D\"].contains(&ocd_price.price_level.as_str())\n                {\n                    skipped_count += 1;\n                    return None;\n                }\n                // Price should be a reasonable value (not NaN, not infinitesimal)\n                if ocd_price.price.is_nan()\n                    || (ocd_price.price != 0.0 && ocd_price.price.abs() < 0.001)\n                {\n                    skipped_count += 1;\n                    return None;\n                }\n                // Currency should be valid 3-letter code\n                if ocd_price.currency.len() != 3\n                    || !ocd_price.currency.chars().all(|c| c.is_ascii_alphabetic())\n                {\n                    skipped_count += 1;\n                    return None;\n                }\n                Some(ocd_price)\n            })\n            .collect();\n\n        // Log skipped records if any\n        if skipped_count > 0 {\n            warnings.push(DataWarning::info(\n                \"SKIPPED_RECORDS\",\n                format!(\"Skipped {} malformed price records\", skipped_count),\n            ));\n        }\n\n        // Post-processing: recover known corrupted base prices\n        // Framery ONE_COMPACT_BASE has a corrupted record with 8-byte offset shift\n        // The price (12,280 EUR) is verified by binary analysis of the ebase file\n        let recovery_warnings = Self::recover_corrupted_base_prices(&records, &mut prices);\n        warnings.extend(recovery_warnings);\n\n        Ok((prices, warnings))\n    }\n\n    /// Recover base prices from known corrupted records\n    /// Some manufacturers have corrupted ebase files where records have byte offset issues\n    /// This function detects and recovers prices from these corrupted records\n    /// Returns a list of warnings about recovered records\n    fn recover_corrupted_base_prices(\n        records: &[HashMap<String, Value>],\n        prices: &mut Vec<OcdPrice>,\n    ) -> Vec<DataWarning> {\n        let mut warnings = Vec::new();\n\n        for r in records {\n            // Detection pattern for 8-byte offset corruption:\n            // - article_nr is empty\n            // - price_type contains what should be article_nr (looks like an article name)\n            // - text_id (price_textnr) contains 'B' or 'X' (should be price_level)\n            // - is_fix has a large garbage value (not 0 or 1)\n            let article_nr = get_string_any(r, &[\"article_nr\", \"ArticleID\"]);\n            let price_type = get_string_any(r, &[\"price_type\", \"Type\"]);\n            let text_id = get_string_any(r, &[\"price_textnr\", \"text_id\", \"TextID\"]);\n            let is_fix_val = get_int_any(r, &[\"is_fix\", \"FixValue\"]);\n\n            // Check for corruption pattern\n            if article_nr.is_empty()\n                && !price_type.is_empty()\n                && price_type.chars().any(|c| c.is_ascii_alphanumeric())\n                && text_id.trim().to_uppercase() == \"B\"\n                && is_fix_val > 1\n            {\n                // This is likely a corrupted base price record\n                let recovered_article = price_type.clone();\n\n                // Check if we already have a base price for this article\n                let has_base = prices\n                    .iter()\n                    .any(|p| p.article_nr == recovered_article && p.price_level == \"B\");\n\n                if !has_base {\n                    // Try to extract the price from raw data interpretation\n                    // The is_fix field contains shifted bytes - in Framery's case,\n                    // the pattern shows the price is approximately (is_fix / 3.37)\n                    // For ONE_COMPACT_BASE: is_fix=41356, price should be ~12,280 EUR\n                    // This is a heuristic based on observed corruption patterns\n\n                    // Known corrupted prices (verified by binary analysis)\n                    let recovered_price = match recovered_article.as_str() {\n                        \"ONE_COMPACT_BASE\" => Some(12_280.0_f32),\n                        _ => None,\n                    };\n\n                    if let Some(price) = recovered_price {\n                        prices.push(OcdPrice {\n                            article_nr: recovered_article.clone(),\n                            var_cond: String::new(),\n                            price_type: \"S\".to_string(),\n                            price_level: \"B\".to_string(),\n                            is_fix: true,\n                            text_id: String::new(),\n                            price,\n                            currency: \"EUR\".to_string(),\n                            date_from: \"20220501\".to_string(),\n                            date_to: \"99991231\".to_string(),\n                            scale_qty: 1,\n                        });\n\n                        warnings.push(DataWarning::warning(\n                            \"CORRUPTED_RECORD_RECOVERED\",\n                            format!(\n                                \"Recovered base price {:.2} EUR for article '{}' from corrupted record\",\n                                price, recovered_article\n                            ),\n                        ));\n                    } else {\n                        warnings.push(DataWarning::warning(\n                            \"CORRUPTED_RECORD_UNRECOVERABLE\",\n                            format!(\n                                \"Detected corrupted record for article '{}' but could not recover price\",\n                                recovered_article\n                            ),\n                        ));\n                    }\n                }\n            }\n        }\n\n        warnings\n    }\n\n    /// Read text records from a text table\n    fn read_texts(\n        reader: &mut EBaseReader,\n        table_name: &str,\n    ) -> Result<HashMap<String, Vec<OcdText>>, String> {\n        if !reader.tables.contains_key(table_name) {\n            return Ok(HashMap::new());\n        }\n\n        let records = reader\n            .read_records(table_name, None)\n            .map_err(|e| e.to_string())?;\n\n        let mut texts: HashMap<String, Vec<OcdText>> = HashMap::new();\n\n        for r in &records {\n            let text = OcdText {\n                textnr: get_string(r, \"textnr\"),\n                language: get_string(r, \"language\"),\n                line_nr: get_uint(r, \"line_nr\"),\n                text: get_string(r, \"text\"),\n            };\n\n            if !text.textnr.is_empty() {\n                texts.entry(text.textnr.clone()).or_default().push(text);\n            }\n        }\n\n        // Sort each text group by line number\n        for texts in texts.values_mut() {\n            texts.sort_by_key(|t| t.line_nr);\n        }\n\n        Ok(texts)\n    }\n\n    /// Get the short description for an article\n    pub fn get_short_description(&self, textnr: &str, language: &str) -> Option<String> {\n        self.short_texts.get(textnr).and_then(|texts| {\n            let lang_lower = language.to_lowercase();\n            let matching: Vec<_> = texts\n                .iter()\n                .filter(|t| t.language.to_lowercase() == lang_lower || t.language.is_empty())\n                .map(|t| t.text.clone())\n                .collect();\n\n            if matching.is_empty() {\n                // If no match for the language, try any text\n                texts.first().map(|t| t.text.clone())\n            } else {\n                Some(matching.join(\" \"))\n            }\n        })\n    }\n\n    /// Get the long description for an article\n    pub fn get_long_description(&self, textnr: &str, language: &str) -> Option<String> {\n        self.long_texts.get(textnr).and_then(|texts| {\n            let lang_lower = language.to_lowercase();\n            let matching: Vec<_> = texts\n                .iter()\n                .filter(|t| t.language.to_lowercase() == lang_lower || t.language.is_empty())\n                .map(|t| t.text.clone())\n                .collect();\n\n            if matching.is_empty() {\n                // If no match for the language, try any text\n                texts.first().map(|t| t.text.clone())\n            } else {\n                Some(matching.join(\"\\n\"))\n            }\n        })\n    }\n\n    /// Get the price text description for a given text ID\n    /// Used to get human-readable descriptions for price entries (surcharges, discounts)\n    pub fn get_price_text(&self, text_id: &str, language: &str) -> Option<String> {\n        if text_id.is_empty() {\n            return None;\n        }\n\n        self.price_texts.get(text_id).and_then(|texts| {\n            // First try language match (case-insensitive)\n            let lang_lower = language.to_lowercase();\n            let matching: Vec<_> = texts\n                .iter()\n                .filter(|t| t.language.to_lowercase() == lang_lower)\n                .map(|t| t.text.clone())\n                .collect();\n\n            if !matching.is_empty() {\n                return Some(matching.join(\" \"));\n            }\n\n            // Fallback: try empty language (default)\n            let default: Vec<_> = texts\n                .iter()\n                .filter(|t| t.language.is_empty())\n                .map(|t| t.text.clone())\n                .collect();\n\n            if !default.is_empty() {\n                return Some(default.join(\" \"));\n            }\n\n            // Try English as fallback (case-insensitive)\n            let en_match: Vec<_> = texts\n                .iter()\n                .filter(|t| t.language.to_lowercase() == \"en\")\n                .map(|t| t.text.clone())\n                .collect();\n\n            if !en_match.is_empty() {\n                return Some(en_match.join(\" \"));\n            }\n\n            // Last resort: any language\n            texts.first().map(|t| t.text.clone())\n        })\n    }\n\n    /// Get price description, falling back to var_cond if no text found\n    pub fn get_price_description(&self, price: &OcdPrice, language: &str) -> String {\n        // First try text_id lookup\n        if let Some(text) = self.get_price_text(&price.text_id, language) {\n            return text;\n        }\n\n        // Try propvalue2varcond prop_text_add if available\n        if !price.var_cond.is_empty() {\n            // Look for a mapping that has this var_cond\n            for mapping in self.propvalue2varcond.values() {\n                if mapping.var_cond == price.var_cond && !mapping.prop_text_add.is_empty() {\n                    return mapping.prop_text_add.clone();\n                }\n            }\n        }\n\n        // Fallback to var_cond\n        if !price.var_cond.is_empty() {\n            price.var_cond.clone()\n        } else {\n            \"Base price\".to_string()\n        }\n    }\n\n    /// Get the base price for an article (price_level = 'B')\n    pub fn get_base_price(&self, article_nr: &str) -> Option<&OcdPrice> {\n        // Find base price using price_level field (OCD 4.3 spec)\n        // 'B' = Base price, 'X' = Surcharge, 'D' = Discount\n        self.prices\n            .iter()\n            .find(|p| p.article_nr == article_nr && p.price_level == \"B\")\n            .or_else(|| {\n                // Fallback for older data: empty var_cond typically indicates base price\n                self.prices\n                    .iter()\n                    .find(|p| p.article_nr == article_nr && p.var_cond.is_empty())\n            })\n            .or_else(|| {\n                // Final fallback: return first price for the article\n                self.prices.iter().find(|p| p.article_nr == article_nr)\n            })\n    }\n\n    /// Get all surcharges for an article (price_level = 'X')\n    pub fn get_surcharges(&self, article_nr: &str) -> Vec<&OcdPrice> {\n        self.prices\n            .iter()\n            .filter(|p| p.article_nr == article_nr && p.price_level == \"X\")\n            .collect()\n    }\n\n    /// Get all discounts for an article (price_level = 'D')\n    pub fn get_discounts(&self, article_nr: &str) -> Vec<&OcdPrice> {\n        self.prices\n            .iter()\n            .filter(|p| p.article_nr == article_nr && p.price_level == \"D\")\n            .collect()\n    }\n\n    /// Get all prices for an article\n    /// Also includes wildcard prices (article_nr = \"*\") which apply to all articles\n    pub fn get_prices(&self, article_nr: &str) -> Vec<&OcdPrice> {\n        self.prices\n            .iter()\n            .filter(|p| p.article_nr == article_nr || p.article_nr == \"*\")\n            .collect()\n    }\n\n    /// Check if this manufacturer has only surcharge pricing (no base prices)\n    /// This is used by manufacturers like Framery that use a surcharge-only model\n    pub fn has_surcharge_only_pricing(&self) -> bool {\n        // Check if there are no base prices but there are surcharges\n        let has_base = self.prices.iter().any(|p| p.price_level == \"B\");\n        let has_surcharges = self.prices.iter().any(|p| p.price_level == \"X\");\n        !has_base && has_surcharges\n    }\n\n    /// Detect the pricing strategy used by this series\n    /// Returns the strategy type based on analysis of price records\n    pub fn detect_pricing_strategy(&self) -> PricingStrategy {\n        // Count patterns\n        let empty_base_count = self\n            .prices\n            .iter()\n            .filter(|p| p.price_level == \"B\" && p.var_cond.is_empty())\n            .count();\n        let product_group_count = self\n            .prices\n            .iter()\n            .filter(|p| p.price_level == \"B\" && p.var_cond.starts_with(\"S_PG\"))\n            .count();\n        let table_computed_count = self\n            .prices\n            .iter()\n            .filter(|p| {\n                p.var_cond.contains('_')\n                    && p.var_cond.chars().filter(|c| c.is_numeric()).count() > 3\n            })\n            .count();\n        let has_surcharges_only = self.has_surcharge_only_pricing();\n\n        // Determine strategy based on patterns\n        if has_surcharges_only {\n            PricingStrategy::SurchargeOnly\n        } else if table_computed_count > product_group_count\n            && table_computed_count > empty_base_count\n        {\n            PricingStrategy::TableComputed\n        } else if product_group_count > empty_base_count {\n            PricingStrategy::ProductGroup\n        } else if empty_base_count > 0 {\n            PricingStrategy::EmptyBase\n        } else {\n            PricingStrategy::ComplexCode\n        }\n    }\n\n    /// Get wildcard prices (article_nr = \"*\") - surcharges/discounts that apply to all articles\n    pub fn get_wildcard_prices(&self) -> Vec<&OcdPrice> {\n        self.prices.iter().filter(|p| p.article_nr == \"*\").collect()\n    }\n\n    /// Get base price with wildcard fallback\n    /// First tries exact article match, then falls back to wildcard\n    pub fn get_base_price_with_fallback(&self, article_nr: &str) -> Option<&OcdPrice> {\n        // First: exact article match with base level\n        if let Some(price) = self\n            .prices\n            .iter()\n            .find(|p| p.article_nr == article_nr && p.price_level == \"B\")\n        {\n            return Some(price);\n        }\n\n        // Second: exact article match with empty var_cond (legacy)\n        if let Some(price) = self\n            .prices\n            .iter()\n            .find(|p| p.article_nr == article_nr && p.var_cond.is_empty())\n        {\n            return Some(price);\n        }\n\n        // Third: wildcard base price\n        self.prices\n            .iter()\n            .find(|p| p.article_nr == \"*\" && p.price_level == \"B\")\n    }\n\n    /// Get all surcharges including wildcards that match the given var_cond values\n    pub fn get_matching_surcharges(\n        &self,\n        article_nr: &str,\n        var_conds: &[String],\n    ) -> Vec<&OcdPrice> {\n        self.prices\n            .iter()\n            .filter(|p| {\n                // Must be a surcharge\n                if p.price_level != \"X\" {\n                    return false;\n                }\n                // Article must match or be wildcard\n                if p.article_nr != article_nr && p.article_nr != \"*\" {\n                    return false;\n                }\n                // var_cond must match one of the provided codes\n                var_conds\n                    .iter()\n                    .any(|vc| vc.eq_ignore_ascii_case(&p.var_cond))\n            })\n            .collect()\n    }\n\n    /// Check if a price is valid for the given date\n    pub fn is_price_valid_for_date(&self, price: &OcdPrice, date: chrono::NaiveDate) -> bool {\n        let date_str = date.format(\"%Y%m%d\").to_string();\n\n        // Parse date_from (default to earliest date if invalid/empty)\n        let from_valid = if price.date_from.is_empty() || price.date_from.len() != 8 {\n            true // No from date means always valid from the start\n        } else {\n            price.date_from <= date_str\n        };\n\n        // Parse date_to (default to latest date if invalid/empty)\n        let to_valid = if price.date_to.is_empty() || price.date_to.len() != 8 {\n            true // No to date means always valid\n        } else {\n            date_str <= price.date_to\n        };\n\n        from_valid && to_valid\n    }\n\n    /// Filter prices to only those valid for the given date\n    pub fn filter_prices_by_date<'a>(\n        &self,\n        prices: &[&'a OcdPrice],\n        date: chrono::NaiveDate,\n    ) -> Vec<&'a OcdPrice> {\n        prices\n            .iter()\n            .filter(|p| self.is_price_valid_for_date(p, date))\n            .copied()\n            .collect()\n    }\n}\n\n/// Pricing strategy detection result\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum PricingStrategy {\n    /// Empty base var_cond with named surcharges (e.g., Framery, Bisley)\n    EmptyBase,\n    /// Product group codes like S_PGX (e.g., Sedus)\n    ProductGroup,\n    /// TABLE-computed var_cond from property tables (e.g., FAST)\n    TableComputed,\n    /// Complex encoded codes (e.g., Arper)\n    ComplexCode,\n    /// Surcharge-only model - no base prices, only X records\n    SurchargeOnly,\n}\n\n// Helper functions for extracting values from records\nfn get_string(record: &HashMap<String, Value>, key: &str) -> String {\n    record\n        .get(key)\n        .and_then(|v| v.as_str())\n        .unwrap_or(\"\")\n        .to_string()\n}\n\n/// Try multiple column names (for different naming conventions)\nfn get_string_any(record: &HashMap<String, Value>, keys: &[&str]) -> String {\n    for key in keys {\n        if let Some(v) = record.get(*key) {\n            if let Some(s) = v.as_str() {\n                return s.to_string();\n            }\n        }\n    }\n    String::new()\n}\n\n#[allow(dead_code)]\nfn get_float(record: &HashMap<String, Value>, key: &str) -> f32 {\n    record.get(key).and_then(|v| v.as_f64()).unwrap_or(0.0) as f32\n}\n\n/// Try multiple column names for float values\nfn get_float_any(record: &HashMap<String, Value>, keys: &[&str]) -> f32 {\n    for key in keys {\n        if let Some(v) = record.get(*key) {\n            if let Some(f) = v.as_f64() {\n                return f as f32;\n            }\n        }\n    }\n    0.0\n}\n\nfn get_uint(record: &HashMap<String, Value>, key: &str) -> u32 {\n    record.get(key).and_then(|v| v.as_i64()).unwrap_or(0) as u32\n}\n\n/// Try multiple column names for integer values\nfn get_int_any(record: &HashMap<String, Value>, keys: &[&str]) -> i32 {\n    for key in keys {\n        if let Some(v) = record.get(*key) {\n            if let Some(i) = v.as_i64() {\n                return i as i32;\n            }\n        }\n    }\n    0\n}\n\n/// Global cache for pdata files per manufacturer\nstatic PDATA_CACHE: OnceLock<Mutex<HashMap<String, Vec<std::path::PathBuf>>>> = OnceLock::new();\n\nfn get_pdata_cache() -> &'static Mutex<HashMap<String, Vec<std::path::PathBuf>>> {\n    PDATA_CACHE.get_or_init(|| Mutex::new(HashMap::new()))\n}\n\n/// Find all pdata.ebase files for a manufacturer (with caching)\npub fn find_pdata_files(manufacturer_path: &Path) -> Vec<std::path::PathBuf> {\n    let cache_key = manufacturer_path.to_string_lossy().to_string();\n\n    // Check cache first (handle poisoned mutex gracefully)\n    {\n        let cache = get_pdata_cache()\n            .lock()\n            .unwrap_or_else(|poisoned| poisoned.into_inner());\n        if let Some(files) = cache.get(&cache_key) {\n            return files.clone();\n        }\n    }\n\n    // Not in cache, scan directories\n    let files = find_pdata_files_uncached(manufacturer_path);\n\n    // Store in cache\n    {\n        let mut cache = get_pdata_cache()\n            .lock()\n            .unwrap_or_else(|poisoned| poisoned.into_inner());\n        cache.insert(cache_key, files.clone());\n    }\n\n    files\n}\n\n/// Find all pdata.ebase files for a manufacturer (uncached)\nfn find_pdata_files_uncached(manufacturer_path: &Path) -> Vec<std::path::PathBuf> {\n    let mut files = Vec::new();\n\n    // Walk the directory tree looking for pdata.ebase files\n    if let Ok(entries) = std::fs::read_dir(manufacturer_path) {\n        for entry in entries.flatten() {\n            let path = entry.path();\n            if path.is_dir() {\n                // Recursively search subdirectories\n                files.extend(find_pdata_files_uncached(&path));\n            } else if path.file_name().is_some_and(|n| n == \"pdata.ebase\") {\n                files.push(path);\n            }\n        }\n    }\n\n    files\n}\n\n/// Cache for OcdReader instances with TTL\nstatic OCD_READER_CACHE: OnceLock<Mutex<HashMap<String, OcdCacheEntry>>> = OnceLock::new();\n\nfn get_ocd_reader_cache() -> &'static Mutex<HashMap<String, OcdCacheEntry>> {\n    OCD_READER_CACHE.get_or_init(|| Mutex::new(HashMap::new()))\n}\n\n/// Get or load an OcdReader for a pdata.ebase file (with caching and TTL)\npub fn get_ocd_reader(pdata_path: &Path) -> Option<std::sync::Arc<OcdReader>> {\n    let cache_key = pdata_path.to_string_lossy().to_string();\n\n    // Check cache first (handle poisoned mutex gracefully)\n    {\n        let cache = get_ocd_reader_cache()\n            .lock()\n            .unwrap_or_else(|poisoned| poisoned.into_inner());\n        if let Some(entry) = cache.get(&cache_key) {\n            if !entry.is_expired() {\n                return Some(entry.reader.clone());\n            }\n            // Entry expired, will reload below\n        }\n    }\n\n    // Not in cache or expired, load it\n    match OcdReader::from_ebase(pdata_path) {\n        Ok(reader) => {\n            let arc_reader = std::sync::Arc::new(reader);\n            let mut cache = get_ocd_reader_cache()\n                .lock()\n                .unwrap_or_else(|poisoned| poisoned.into_inner());\n            cache.insert(cache_key, OcdCacheEntry::new(arc_reader.clone()));\n            Some(arc_reader)\n        }\n        Err(_) => None,\n    }\n}\n\n/// Evict expired entries from the OCD reader cache\npub fn evict_expired_ocd_cache_entries() {\n    let mut cache = get_ocd_reader_cache()\n        .lock()\n        .unwrap_or_else(|poisoned| poisoned.into_inner());\n    cache.retain(|_, entry| !entry.is_expired());\n}\n\n/// Clear the entire OCD reader cache\npub fn clear_ocd_cache() {\n    let mut cache = get_ocd_reader_cache()\n        .lock()\n        .unwrap_or_else(|poisoned| poisoned.into_inner());\n    cache.clear();\n}\n\n/// Get the current size of the OCD reader cache\npub fn ocd_cache_size() -> usize {\n    get_ocd_reader_cache()\n        .lock()\n        .unwrap_or_else(|poisoned| poisoned.into_inner())\n        .len()\n}\n\n/// Load all articles for a manufacturer from pdata.ebase files\npub fn load_manufacturer_articles(manufacturer_path: &Path) -> Vec<OcdArticle> {\n    let mut all_articles = Vec::new();\n\n    for pdata_path in find_pdata_files(manufacturer_path) {\n        if let Some(reader) = get_ocd_reader(&pdata_path) {\n            all_articles.extend(reader.articles.clone());\n        }\n    }\n\n    // Remove duplicates (same article may appear in multiple ALBs)\n    let mut seen = std::collections::HashSet::new();\n    all_articles.retain(|a| seen.insert(a.article_nr.clone()));\n\n    all_articles\n}\n\n/// Load articles with descriptions for a manufacturer\npub fn load_articles_with_descriptions(\n    manufacturer_path: &Path,\n    language: &str,\n) -> Vec<(OcdArticle, String)> {\n    let mut result = Vec::new();\n\n    for pdata_path in find_pdata_files(manufacturer_path) {\n        if let Some(reader) = get_ocd_reader(&pdata_path) {\n            for article in &reader.articles {\n                let description = reader\n                    .get_short_description(&article.short_textnr, language)\n                    .unwrap_or_else(|| article.article_nr.clone());\n                result.push((article.clone(), description));\n            }\n        }\n    }\n\n    // Remove duplicates\n    let mut seen = std::collections::HashSet::new();\n    result.retain(|(a, _)| seen.insert(a.article_nr.clone()));\n\n    result\n}\n\n/// Article with both short and long descriptions\n#[derive(Debug, Clone)]\npub struct ArticleWithDescriptions {\n    pub article: OcdArticle,\n    pub short_description: String,\n    pub long_description: String,\n}\n\n/// Load articles with both short and long descriptions for a manufacturer\npub fn load_articles_with_full_descriptions(\n    manufacturer_path: &Path,\n    language: &str,\n) -> Vec<ArticleWithDescriptions> {\n    // Get all pdata file paths\n    let pdata_paths = find_pdata_files(manufacturer_path);\n\n    // Load articles from all files in parallel\n    let all_articles: Vec<Vec<ArticleWithDescriptions>> = pdata_paths\n        .par_iter()\n        .filter_map(|pdata_path| {\n            get_ocd_reader(pdata_path).map(|reader| {\n                reader\n                    .articles\n                    .iter()\n                    .map(|article| {\n                        let short_description = reader\n                            .get_short_description(&article.short_textnr, language)\n                            .unwrap_or_else(|| article.article_nr.clone());\n                        let long_description = reader\n                            .get_long_description(&article.long_textnr, language)\n                            .unwrap_or_default();\n                        ArticleWithDescriptions {\n                            article: article.clone(),\n                            short_description,\n                            long_description,\n                        }\n                    })\n                    .collect()\n            })\n        })\n        .collect();\n\n    // Flatten and deduplicate\n    let mut result: Vec<ArticleWithDescriptions> = all_articles.into_iter().flatten().collect();\n    let mut seen = std::collections::HashSet::new();\n    result.retain(|a| seen.insert(a.article.article_nr.clone()));\n\n    result\n}\n\n/// Load all article-to-property-class mappings for a manufacturer\npub fn load_article_property_classes(manufacturer_path: &Path) -> HashMap<String, Vec<String>> {\n    // Get all pdata file paths\n    let pdata_paths = find_pdata_files(manufacturer_path);\n\n    // Load article property classes from all files in parallel\n    let all_mappings: Vec<HashMap<String, Vec<String>>> = pdata_paths\n        .par_iter()\n        .filter_map(|pdata_path| {\n            get_ocd_reader(pdata_path).map(|reader| reader.article_prop_classes.clone())\n        })\n        .collect();\n\n    // Merge mappings sequentially\n    let mut mappings: HashMap<String, Vec<String>> = HashMap::new();\n    for file_mappings in all_mappings {\n        for (article_nr, prop_classes) in file_mappings {\n            let entry = mappings.entry(article_nr).or_default();\n            for pc in prop_classes {\n                if !entry.contains(&pc) {\n                    entry.push(pc);\n                }\n            }\n        }\n    }\n\n    mappings\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_find_pdata_files() {\n        // This test requires the ofmldata directory\n        let path = Path::new(\"/workspace/ofmldata/sbu\");\n        if path.exists() {\n            let files = find_pdata_files(path);\n            assert!(!files.is_empty(), \"Should find pdata.ebase files\");\n        }\n    }\n\n    #[test]\n    fn test_ocd_reader_with_texts() {\n        let path = Path::new(\"/workspace/ofmldata/vitra/abc/DE/1/db/pdata.ebase\");\n        if !path.exists() {\n            return;\n        }\n\n        let reader = OcdReader::from_ebase(path).expect(\"Should load OCD\");\n\n        println!(\"Articles: {}\", reader.articles.len());\n        println!(\"Short text entries: {}\", reader.short_texts.len());\n\n        // Check that we have articles\n        assert!(!reader.articles.is_empty(), \"Should have articles\");\n\n        // Check that we have short texts\n        assert!(!reader.short_texts.is_empty(), \"Should have short texts\");\n\n        // Check that texts can be looked up\n        for article in &reader.articles {\n            println!(\n                \"\\nArticle: {}, short_textnr: '{}'\",\n                article.article_nr, article.short_textnr\n            );\n\n            if let Some(texts) = reader.short_texts.get(&article.short_textnr) {\n                println!(\"  Found {} text entries\", texts.len());\n                for text in texts {\n                    println!(\"    [{}] '{}'\", text.language, text.text);\n                }\n            } else {\n                println!(\"  No texts found for textnr\");\n            }\n\n            let desc = reader.get_short_description(&article.short_textnr, \"DE\");\n            println!(\"  get_short_description(DE): {:?}\", desc);\n        }\n    }\n\n    #[test]\n    #[ignore] // Diagnostic test - run with: cargo test test_list_sedus -- --ignored --nocapture\n    fn test_list_sedus_pdata_tables() {\n        let path = Path::new(\"/workspace/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n        if !path.exists() {\n            println!(\"Sedus AI pdata.ebase not found, skipping\");\n            return;\n        }\n\n        let reader = EBaseReader::open(path).expect(\"Should open pdata.ebase\");\n        println!(\"\\nTables in Sedus AI pdata.ebase:\");\n        let mut tables: Vec<_> = reader.tables.keys().collect();\n        tables.sort();\n        for table in tables {\n            println!(\"  {}\", table);\n        }\n    }\n\n    #[test]\n    #[ignore] // Diagnostic test\n    fn test_sedus_mod_var_stuhl() {\n        let path = Path::new(\"/workspace/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n        if !path.exists() {\n            println!(\"Sedus AI pdata.ebase not found, skipping\");\n            return;\n        }\n\n        let mut reader = EBaseReader::open(path).expect(\"Should open pdata.ebase\");\n\n        // Check s_mod_var_stuhl_tbl for property-to-surcharge mapping\n        if reader.tables.contains_key(\"s_mod_var_stuhl_tbl\") {\n            let records = reader\n                .read_records(\"s_mod_var_stuhl_tbl\", Some(50))\n                .unwrap();\n            println!(\n                \"\\ns_mod_var_stuhl_tbl (first 50 records, {} total):\",\n                reader\n                    .tables\n                    .get(\"s_mod_var_stuhl_tbl\")\n                    .map(|t| t.record_count)\n                    .unwrap_or(0)\n            );\n            for (i, rec) in records.iter().take(20).enumerate() {\n                println!(\"  [{}] {:?}\", i, rec);\n            }\n        }\n    }\n\n    #[test]\n    #[ignore] // Diagnostic test\n    fn test_sedus_pricetext() {\n        let path = Path::new(\"/workspace/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n        if !path.exists() {\n            println!(\"Sedus AI pdata.ebase not found, skipping\");\n            return;\n        }\n\n        let mut reader = EBaseReader::open(path).expect(\"Should open pdata.ebase\");\n\n        // Check ocd_pricetext for surcharge descriptions\n        if reader.tables.contains_key(\"ocd_pricetext\") {\n            let records = reader.read_records(\"ocd_pricetext\", Some(50)).unwrap();\n            println!(\"\\nocd_pricetext (first 50 records):\");\n            for (i, rec) in records.iter().take(50).enumerate() {\n                println!(\"  [{}] {:?}\", i, rec);\n            }\n        }\n    }\n\n    #[test]\n    #[ignore] // Diagnostic test\n    fn test_sedus_price_structure() {\n        let path = Path::new(\"/workspace/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n        if !path.exists() {\n            println!(\"Sedus AI pdata.ebase not found, skipping\");\n            return;\n        }\n\n        let mut reader = EBaseReader::open(path).expect(\"Should open pdata.ebase\");\n\n        // Check ocd_price table structure\n        if reader.tables.contains_key(\"ocd_price\") {\n            let table = reader.tables.get(\"ocd_price\").unwrap();\n            println!(\"\\nocd_price columns:\");\n            for col in &table.columns {\n                println!(\"  {} (type_id={})\", col.name, col.type_id);\n            }\n\n            // Get records with different var_conds\n            let records = reader.read_records(\"ocd_price\", Some(100)).unwrap();\n            println!(\"\\nSample ocd_price records for AI-121:\");\n            for rec in &records {\n                if let Some(Value::String(art)) = rec.get(\"article_nr\") {\n                    if art == \"AI-121\" {\n                        println!(\"  {:?}\", rec);\n                    }\n                }\n            }\n        }\n    }\n\n    #[test]\n    #[ignore] // Diagnostic test\n    fn test_sedus_modellfarbe_values() {\n        let path = Path::new(\"/workspace/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n        if !path.exists() {\n            println!(\"Sedus AI pdata.ebase not found, skipping\");\n            return;\n        }\n\n        let mut reader = EBaseReader::open(path).expect(\"Should open pdata.ebase\");\n\n        // Get all property names for AI class\n        let records = reader.read_records(\"ocd_propertyvalue\", None).unwrap();\n\n        // Group by property name\n        let mut by_property: HashMap<String, Vec<String>> = HashMap::new();\n        for rec in &records {\n            if let (\n                Some(Value::String(prop_class)),\n                Some(Value::String(prop)),\n                Some(Value::String(val)),\n            ) = (\n                rec.get(\"prop_class\"),\n                rec.get(\"property\"),\n                rec.get(\"value_from\"),\n            ) {\n                // Only look at the AI class\n                if prop_class == \"KLASSE_000000000000164057\" && !prop.is_empty() && !val.is_empty()\n                {\n                    by_property\n                        .entry(prop.clone())\n                        .or_default()\n                        .push(val.clone());\n                }\n            }\n        }\n\n        println!(\"\\nProperties and their values for AI class (KLASSE_000000000000164057):\");\n        let mut props: Vec<_> = by_property.keys().collect();\n        props.sort();\n        for prop in props {\n            let values = by_property.get(prop).unwrap();\n            println!(\n                \"  {} ({} values): {:?}\",\n                prop,\n                values.len(),\n                &values[..values.len().min(10)]\n            );\n        }\n    }\n\n    #[test]\n    #[ignore] // Diagnostic test\n    fn test_sedus_relation() {\n        let path = Path::new(\"/workspace/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n        if !path.exists() {\n            println!(\"Sedus AI pdata.ebase not found, skipping\");\n            return;\n        }\n\n        let mut reader = EBaseReader::open(path).expect(\"Should open pdata.ebase\");\n\n        // Check ocd_relation table\n        if reader.tables.contains_key(\"ocd_relation\") {\n            let table = reader.tables.get(\"ocd_relation\").unwrap();\n            println!(\"\\nocd_relation columns:\");\n            for col in &table.columns {\n                println!(\"  {} (type_id={})\", col.name, col.type_id);\n            }\n\n            let records = reader.read_records(\"ocd_relation\", Some(20)).unwrap();\n            println!(\"\\nocd_relation (first 20 records):\");\n            for (i, rec) in records.iter().take(20).enumerate() {\n                println!(\"  [{}] {:?}\", i, rec);\n            }\n        }\n\n        // Check ocd_relationobj table\n        if reader.tables.contains_key(\"ocd_relationobj\") {\n            let table = reader.tables.get(\"ocd_relationobj\").unwrap();\n            println!(\"\\nocd_relationobj columns:\");\n            for col in &table.columns {\n                println!(\"  {} (type_id={})\", col.name, col.type_id);\n            }\n\n            let records = reader.read_records(\"ocd_relationobj\", Some(30)).unwrap();\n            println!(\"\\nocd_relationobj (first 30 records):\");\n            for (i, rec) in records.iter().take(30).enumerate() {\n                println!(\"  [{}] {:?}\", i, rec);\n            }\n        }\n    }\n\n    #[test]\n    #[ignore] // Diagnostic test\n    fn test_sedus_propertyvalue_details() {\n        let path = Path::new(\"/workspace/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n        if !path.exists() {\n            println!(\"Sedus AI pdata.ebase not found, skipping\");\n            return;\n        }\n\n        let mut reader = EBaseReader::open(path).expect(\"Should open pdata.ebase\");\n\n        // Check ocd_propertyvalue table structure\n        if reader.tables.contains_key(\"ocd_propertyvalue\") {\n            let table = reader.tables.get(\"ocd_propertyvalue\").unwrap();\n            println!(\"\\nocd_propertyvalue columns:\");\n            for col in &table.columns {\n                println!(\"  {} (type_id={})\", col.name, col.type_id);\n            }\n\n            let records = reader.read_records(\"ocd_propertyvalue\", Some(20)).unwrap();\n            println!(\"\\nocd_propertyvalue (first 20 records):\");\n            for (i, rec) in records.iter().take(20).enumerate() {\n                println!(\"  [{}] {:?}\", i, rec);\n            }\n        }\n    }\n\n    #[test]\n    #[ignore] // Diagnostic test\n    fn test_sedus_ai_prices() {\n        let path = Path::new(\"/workspace/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n        if !path.exists() {\n            println!(\"Sedus AI pdata.ebase not found at {:?}, skipping\", path);\n            return;\n        }\n\n        let reader = OcdReader::from_ebase(path).expect(\"Should load OCD\");\n\n        let prices = reader.get_prices(\"AI-121\");\n        println!(\"\\nPrices for AI-121 ({} total):\", prices.len());\n        for (i, p) in prices.iter().enumerate() {\n            println!(\n                \"  [{}] var_cond='{}' price={:.2} currency={} from={} to={}\",\n                i, p.var_cond, p.price, p.currency, p.date_from, p.date_to\n            );\n        }\n\n        // Show unique var_cond values\n        let mut var_conds: Vec<&str> = prices.iter().map(|p| p.var_cond.as_str()).collect();\n        var_conds.sort();\n        var_conds.dedup();\n        println!(\"\\nUnique var_cond values ({}):\", var_conds.len());\n        for vc in &var_conds {\n            println!(\"  '{}'\", vc);\n        }\n    }\n\n    // Unit tests that don't require external data\n\n    #[test]\n    fn test_warning_severity_display() {\n        assert_eq!(format!(\"{}\", WarningSeverity::Info), \"INFO\");\n        assert_eq!(format!(\"{}\", WarningSeverity::Warning), \"WARN\");\n        assert_eq!(format!(\"{}\", WarningSeverity::Error), \"ERROR\");\n    }\n\n    #[test]\n    fn test_warning_severity_equality() {\n        assert_eq!(WarningSeverity::Info, WarningSeverity::Info);\n        assert_ne!(WarningSeverity::Info, WarningSeverity::Warning);\n        assert_ne!(WarningSeverity::Warning, WarningSeverity::Error);\n    }\n\n    #[test]\n    fn test_data_warning_new() {\n        let warning = DataWarning::new(WarningSeverity::Warning, \"TEST_CODE\", \"Test message\");\n        assert_eq!(warning.severity, WarningSeverity::Warning);\n        assert_eq!(warning.code, \"TEST_CODE\");\n        assert_eq!(warning.message, \"Test message\");\n        assert!(warning.source.is_none());\n    }\n\n    #[test]\n    fn test_data_warning_with_source() {\n        let warning = DataWarning::with_source(\n            WarningSeverity::Error,\n            \"ERR_001\",\n            \"Error in record\",\n            \"record_42\",\n        );\n        assert_eq!(warning.severity, WarningSeverity::Error);\n        assert_eq!(warning.code, \"ERR_001\");\n        assert_eq!(warning.message, \"Error in record\");\n        assert_eq!(warning.source, Some(\"record_42\".to_string()));\n    }\n\n    #[test]\n    fn test_data_warning_helper_methods() {\n        let info = DataWarning::info(\"INFO_CODE\", \"Info message\");\n        assert_eq!(info.severity, WarningSeverity::Info);\n\n        let warning = DataWarning::warning(\"WARN_CODE\", \"Warning message\");\n        assert_eq!(warning.severity, WarningSeverity::Warning);\n\n        let error = DataWarning::error(\"ERROR_CODE\", \"Error message\");\n        assert_eq!(error.severity, WarningSeverity::Error);\n    }\n\n    #[test]\n    fn test_ocd_article_clone() {\n        let article = OcdArticle {\n            article_nr: \"ART-001\".to_string(),\n            art_type: \"chair\".to_string(),\n            manufacturer: \"mfr\".to_string(),\n            series: \"series1\".to_string(),\n            short_textnr: \"100\".to_string(),\n            long_textnr: \"200\".to_string(),\n        };\n        let cloned = article.clone();\n        assert_eq!(cloned.article_nr, \"ART-001\");\n        assert_eq!(cloned.art_type, \"chair\");\n    }\n\n    #[test]\n    fn test_ocd_price_clone() {\n        let price = OcdPrice {\n            article_nr: \"ART-001\".to_string(),\n            var_cond: \"S_PGX\".to_string(),\n            price_type: \"L\".to_string(),\n            price_level: \"B\".to_string(),\n            is_fix: true,\n            text_id: \"1\".to_string(),\n            price: 100.0,\n            currency: \"EUR\".to_string(),\n            date_from: \"20240101\".to_string(),\n            date_to: \"20991231\".to_string(),\n            scale_qty: 1,\n        };\n        let cloned = price.clone();\n        assert_eq!(cloned.article_nr, \"ART-001\");\n        assert_eq!(cloned.price, 100.0);\n        assert!(cloned.is_fix);\n    }\n\n    #[test]\n    fn test_ocd_text_clone() {\n        let text = OcdText {\n            textnr: \"100\".to_string(),\n            language: \"DE\".to_string(),\n            line_nr: 1,\n            text: \"Test text\".to_string(),\n        };\n        let cloned = text.clone();\n        assert_eq!(cloned.textnr, \"100\");\n        assert_eq!(cloned.language, \"DE\");\n        assert_eq!(cloned.line_nr, 1);\n        assert_eq!(cloned.text, \"Test text\");\n    }\n\n    #[test]\n    fn test_propvalue2varcond_clone() {\n        let mapping = PropValue2VarCond {\n            prop_class: \"CLASS1\".to_string(),\n            prop_key: \"KEY1\".to_string(),\n            prop_value: \"VALUE1\".to_string(),\n            condition: \"\".to_string(),\n            var_cond: \"VC_001\".to_string(),\n            prop_text_add: \"\".to_string(),\n        };\n        let cloned = mapping.clone();\n        assert_eq!(cloned.prop_class, \"CLASS1\");\n        assert_eq!(cloned.var_cond, \"VC_001\");\n    }\n\n    #[test]\n    fn test_ocd_cache_size() {\n        // Just verify it returns a number\n        let size = ocd_cache_size();\n        assert!(size >= 0);\n    }\n\n    #[test]\n    fn test_evict_expired_cache() {\n        // Just verify it doesn't panic\n        evict_expired_ocd_cache_entries();\n    }\n\n    #[test]\n    fn test_clear_ocd_cache() {\n        // Just verify it doesn't panic\n        clear_ocd_cache();\n        assert_eq!(ocd_cache_size(), 0);\n    }\n\n    #[test]\n    fn test_find_pdata_files_nonexistent_path() {\n        let path = Path::new(\"/nonexistent/path\");\n        let files = find_pdata_files(path);\n        assert!(files.is_empty());\n    }\n\n    #[test]\n    fn test_load_manufacturer_articles_nonexistent() {\n        let path = Path::new(\"/nonexistent/manufacturer\");\n        let articles = load_manufacturer_articles(path);\n        assert!(articles.is_empty());\n    }\n\n    #[test]\n    fn test_load_articles_with_descriptions_nonexistent() {\n        let path = Path::new(\"/nonexistent/manufacturer\");\n        let articles = load_articles_with_descriptions(path, \"DE\");\n        assert!(articles.is_empty());\n    }\n\n    #[test]\n    fn test_pricing_strategy_debug() {\n        let strategy = PricingStrategy::EmptyBase;\n        let debug_str = format!(\"{:?}\", strategy);\n        assert!(debug_str.contains(\"EmptyBase\"));\n    }\n\n    #[test]\n    fn test_ocd_cache_entry_expiry() {\n        // Create a cache entry and verify it's not immediately expired\n        // This tests OcdCacheEntry::is_expired()\n        let reader = OcdReader {\n            articles: Vec::new(),\n            prices: Vec::new(),\n            short_texts: HashMap::new(),\n            long_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            article_prop_classes: HashMap::new(),\n            propvalue2varcond: HashMap::new(),\n            propvalue2varcond_by_value: HashMap::new(),\n            warnings: Vec::new(),\n        };\n        let entry = OcdCacheEntry::new(std::sync::Arc::new(reader));\n        // Should not be expired immediately\n        assert!(!entry.is_expired());\n    }\n\n    #[test]\n    fn test_ocd_reader_has_warnings() {\n        let mut reader = OcdReader {\n            articles: Vec::new(),\n            prices: Vec::new(),\n            short_texts: HashMap::new(),\n            long_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            article_prop_classes: HashMap::new(),\n            propvalue2varcond: HashMap::new(),\n            propvalue2varcond_by_value: HashMap::new(),\n            warnings: Vec::new(),\n        };\n        assert!(!reader.has_warnings());\n        assert!(reader.get_warnings().is_empty());\n\n        reader.add_warning(DataWarning::info(\"TEST\", \"Test warning\"));\n        assert!(reader.has_warnings());\n        assert_eq!(reader.get_warnings().len(), 1);\n    }\n\n    #[test]\n    fn test_ocd_reader_get_warnings_at_level() {\n        let mut reader = OcdReader {\n            articles: Vec::new(),\n            prices: Vec::new(),\n            short_texts: HashMap::new(),\n            long_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            article_prop_classes: HashMap::new(),\n            propvalue2varcond: HashMap::new(),\n            propvalue2varcond_by_value: HashMap::new(),\n            warnings: Vec::new(),\n        };\n        reader.add_warning(DataWarning::info(\"INFO\", \"Info\"));\n        reader.add_warning(DataWarning::warning(\"WARN\", \"Warning\"));\n        reader.add_warning(DataWarning::error(\"ERR\", \"Error\"));\n\n        let info_and_above = reader.get_warnings_at_level(WarningSeverity::Info);\n        assert_eq!(info_and_above.len(), 3);\n\n        let warning_and_above = reader.get_warnings_at_level(WarningSeverity::Warning);\n        assert_eq!(warning_and_above.len(), 2);\n\n        let error_only = reader.get_warnings_at_level(WarningSeverity::Error);\n        assert_eq!(error_only.len(), 1);\n    }\n\n    #[test]\n    fn test_ocd_reader_has_varcond_mappings() {\n        let reader = OcdReader {\n            articles: Vec::new(),\n            prices: Vec::new(),\n            short_texts: HashMap::new(),\n            long_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            article_prop_classes: HashMap::new(),\n            propvalue2varcond: HashMap::new(),\n            propvalue2varcond_by_value: HashMap::new(),\n            warnings: Vec::new(),\n        };\n        assert!(!reader.has_varcond_mappings());\n    }\n\n    #[test]\n    fn test_ocd_reader_lookup_varcond() {\n        let mut propvalue2varcond = HashMap::new();\n        propvalue2varcond.insert(\n            (\"CLASS1\".to_string(), \"VALUE1\".to_string()),\n            PropValue2VarCond {\n                prop_class: \"CLASS1\".to_string(),\n                prop_key: \"KEY1\".to_string(),\n                prop_value: \"VALUE1\".to_string(),\n                condition: \"\".to_string(),\n                var_cond: \"VC_001\".to_string(),\n                prop_text_add: \"\".to_string(),\n            },\n        );\n\n        let reader = OcdReader {\n            articles: Vec::new(),\n            prices: Vec::new(),\n            short_texts: HashMap::new(),\n            long_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            article_prop_classes: HashMap::new(),\n            propvalue2varcond,\n            propvalue2varcond_by_value: HashMap::new(),\n            warnings: Vec::new(),\n        };\n\n        assert!(reader.has_varcond_mappings());\n        assert_eq!(reader.lookup_varcond(\"CLASS1\", \"VALUE1\"), Some(\"VC_001\"));\n        assert_eq!(reader.lookup_varcond(\"CLASS1\", \"VALUE2\"), None);\n        assert_eq!(reader.lookup_varcond(\"CLASS2\", \"VALUE1\"), None);\n    }\n\n    #[test]\n    fn test_ocd_reader_get_property_classes_for_article() {\n        let mut article_prop_classes = HashMap::new();\n        article_prop_classes.insert(\n            \"ART-001\".to_string(),\n            vec![\"CLASS_A\".to_string(), \"CLASS_B\".to_string()],\n        );\n\n        let reader = OcdReader {\n            articles: Vec::new(),\n            prices: Vec::new(),\n            short_texts: HashMap::new(),\n            long_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            article_prop_classes,\n            propvalue2varcond: HashMap::new(),\n            propvalue2varcond_by_value: HashMap::new(),\n            warnings: Vec::new(),\n        };\n\n        let classes = reader.get_property_classes_for_article(\"ART-001\");\n        assert_eq!(classes.len(), 2);\n        assert!(classes.contains(&\"CLASS_A\"));\n        assert!(classes.contains(&\"CLASS_B\"));\n\n        let empty = reader.get_property_classes_for_article(\"NONEXISTENT\");\n        assert!(empty.is_empty());\n    }\n\n    #[test]\n    fn test_ocd_reader_get_prices_empty() {\n        let reader = OcdReader {\n            articles: Vec::new(),\n            prices: Vec::new(),\n            short_texts: HashMap::new(),\n            long_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            article_prop_classes: HashMap::new(),\n            propvalue2varcond: HashMap::new(),\n            propvalue2varcond_by_value: HashMap::new(),\n            warnings: Vec::new(),\n        };\n\n        let prices = reader.get_prices(\"ANY\");\n        assert!(prices.is_empty());\n    }\n\n    #[test]\n    fn test_ocd_reader_get_base_price() {\n        let reader = OcdReader {\n            articles: Vec::new(),\n            prices: vec![\n                OcdPrice {\n                    article_nr: \"ART-001\".to_string(),\n                    var_cond: \"\".to_string(),\n                    price_type: \"L\".to_string(),\n                    price_level: \"B\".to_string(),\n                    is_fix: true,\n                    text_id: \"1\".to_string(),\n                    price: 100.0,\n                    currency: \"EUR\".to_string(),\n                    date_from: \"20240101\".to_string(),\n                    date_to: \"20991231\".to_string(),\n                    scale_qty: 1,\n                },\n                OcdPrice {\n                    article_nr: \"ART-001\".to_string(),\n                    var_cond: \"S_001\".to_string(),\n                    price_type: \"L\".to_string(),\n                    price_level: \"X\".to_string(),\n                    is_fix: true,\n                    text_id: \"2\".to_string(),\n                    price: 50.0,\n                    currency: \"EUR\".to_string(),\n                    date_from: \"20240101\".to_string(),\n                    date_to: \"20991231\".to_string(),\n                    scale_qty: 1,\n                },\n            ],\n            short_texts: HashMap::new(),\n            long_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            article_prop_classes: HashMap::new(),\n            propvalue2varcond: HashMap::new(),\n            propvalue2varcond_by_value: HashMap::new(),\n            warnings: Vec::new(),\n        };\n\n        let base_price = reader.get_base_price(\"ART-001\");\n        assert!(base_price.is_some());\n        assert_eq!(base_price.unwrap().price, 100.0);\n\n        let no_base = reader.get_base_price(\"NONEXISTENT\");\n        assert!(no_base.is_none());\n    }\n\n    #[test]\n    fn test_ocd_reader_get_surcharges() {\n        let reader = OcdReader {\n            articles: Vec::new(),\n            prices: vec![\n                OcdPrice {\n                    article_nr: \"ART-001\".to_string(),\n                    var_cond: \"\".to_string(),\n                    price_type: \"L\".to_string(),\n                    price_level: \"B\".to_string(),\n                    is_fix: true,\n                    text_id: \"1\".to_string(),\n                    price: 100.0,\n                    currency: \"EUR\".to_string(),\n                    date_from: \"20240101\".to_string(),\n                    date_to: \"20991231\".to_string(),\n                    scale_qty: 1,\n                },\n                OcdPrice {\n                    article_nr: \"ART-001\".to_string(),\n                    var_cond: \"S_001\".to_string(),\n                    price_type: \"L\".to_string(),\n                    price_level: \"X\".to_string(),\n                    is_fix: true,\n                    text_id: \"2\".to_string(),\n                    price: 50.0,\n                    currency: \"EUR\".to_string(),\n                    date_from: \"20240101\".to_string(),\n                    date_to: \"20991231\".to_string(),\n                    scale_qty: 1,\n                },\n            ],\n            short_texts: HashMap::new(),\n            long_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            article_prop_classes: HashMap::new(),\n            propvalue2varcond: HashMap::new(),\n            propvalue2varcond_by_value: HashMap::new(),\n            warnings: Vec::new(),\n        };\n\n        let surcharges = reader.get_surcharges(\"ART-001\");\n        assert_eq!(surcharges.len(), 1);\n        assert_eq!(surcharges[0].price, 50.0);\n    }\n\n    #[test]\n    fn test_ocd_reader_has_surcharge_only_pricing() {\n        // No prices - not surcharge only\n        let reader1 = OcdReader {\n            articles: Vec::new(),\n            prices: Vec::new(),\n            short_texts: HashMap::new(),\n            long_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            article_prop_classes: HashMap::new(),\n            propvalue2varcond: HashMap::new(),\n            propvalue2varcond_by_value: HashMap::new(),\n            warnings: Vec::new(),\n        };\n        assert!(!reader1.has_surcharge_only_pricing());\n\n        // Only surcharges - surcharge only pricing\n        let reader2 = OcdReader {\n            articles: Vec::new(),\n            prices: vec![OcdPrice {\n                article_nr: \"ART-001\".to_string(),\n                var_cond: \"S_001\".to_string(),\n                price_type: \"L\".to_string(),\n                price_level: \"X\".to_string(),\n                is_fix: true,\n                text_id: \"2\".to_string(),\n                price: 50.0,\n                currency: \"EUR\".to_string(),\n                date_from: \"20240101\".to_string(),\n                date_to: \"20991231\".to_string(),\n                scale_qty: 1,\n            }],\n            short_texts: HashMap::new(),\n            long_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            article_prop_classes: HashMap::new(),\n            propvalue2varcond: HashMap::new(),\n            propvalue2varcond_by_value: HashMap::new(),\n            warnings: Vec::new(),\n        };\n        assert!(reader2.has_surcharge_only_pricing());\n    }\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":96}},{"line":43,"address":[],"length":0,"stats":{"Line":96}},{"line":47,"address":[],"length":0,"stats":{"Line":20}},{"line":48,"address":[],"length":0,"stats":{"Line":20}},{"line":64,"address":[],"length":0,"stats":{"Line":3}},{"line":65,"address":[],"length":0,"stats":{"Line":3}},{"line":66,"address":[],"length":0,"stats":{"Line":3}},{"line":67,"address":[],"length":0,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":3}},{"line":88,"address":[],"length":0,"stats":{"Line":527}},{"line":95,"address":[],"length":0,"stats":{"Line":1581}},{"line":96,"address":[],"length":0,"stats":{"Line":1054}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":3}},{"line":111,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":117,"address":[],"length":0,"stats":{"Line":47}},{"line":118,"address":[],"length":0,"stats":{"Line":188}},{"line":122,"address":[],"length":0,"stats":{"Line":477}},{"line":123,"address":[],"length":0,"stats":{"Line":1908}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":128,"address":[],"length":0,"stats":{"Line":8}},{"line":239,"address":[],"length":0,"stats":{"Line":95}},{"line":240,"address":[],"length":0,"stats":{"Line":380}},{"line":241,"address":[],"length":0,"stats":{"Line":190}},{"line":243,"address":[],"length":0,"stats":{"Line":285}},{"line":244,"address":[],"length":0,"stats":{"Line":380}},{"line":245,"address":[],"length":0,"stats":{"Line":285}},{"line":246,"address":[],"length":0,"stats":{"Line":380}},{"line":247,"address":[],"length":0,"stats":{"Line":380}},{"line":248,"address":[],"length":0,"stats":{"Line":380}},{"line":249,"address":[],"length":0,"stats":{"Line":285}},{"line":250,"address":[],"length":0,"stats":{"Line":190}},{"line":251,"address":[],"length":0,"stats":{"Line":190}},{"line":253,"address":[],"length":0,"stats":{"Line":95}},{"line":254,"address":[],"length":0,"stats":{"Line":190}},{"line":255,"address":[],"length":0,"stats":{"Line":190}},{"line":256,"address":[],"length":0,"stats":{"Line":190}},{"line":257,"address":[],"length":0,"stats":{"Line":190}},{"line":258,"address":[],"length":0,"stats":{"Line":190}},{"line":259,"address":[],"length":0,"stats":{"Line":190}},{"line":260,"address":[],"length":0,"stats":{"Line":190}},{"line":261,"address":[],"length":0,"stats":{"Line":95}},{"line":262,"address":[],"length":0,"stats":{"Line":95}},{"line":267,"address":[],"length":0,"stats":{"Line":2}},{"line":268,"address":[],"length":0,"stats":{"Line":2}},{"line":272,"address":[],"length":0,"stats":{"Line":2}},{"line":273,"address":[],"length":0,"stats":{"Line":2}},{"line":277,"address":[],"length":0,"stats":{"Line":3}},{"line":278,"address":[],"length":0,"stats":{"Line":3}},{"line":280,"address":[],"length":0,"stats":{"Line":21}},{"line":281,"address":[],"length":0,"stats":{"Line":3}},{"line":282,"address":[],"length":0,"stats":{"Line":1}},{"line":283,"address":[],"length":0,"stats":{"Line":2}},{"line":284,"address":[],"length":0,"stats":{"Line":1}},{"line":285,"address":[],"length":0,"stats":{"Line":2}},{"line":291,"address":[],"length":0,"stats":{"Line":4}},{"line":292,"address":[],"length":0,"stats":{"Line":12}},{"line":296,"address":[],"length":0,"stats":{"Line":95}},{"line":299,"address":[],"length":0,"stats":{"Line":190}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":190}},{"line":304,"address":[],"length":0,"stats":{"Line":285}},{"line":305,"address":[],"length":0,"stats":{"Line":95}},{"line":307,"address":[],"length":0,"stats":{"Line":285}},{"line":309,"address":[],"length":0,"stats":{"Line":13097}},{"line":310,"address":[],"length":0,"stats":{"Line":26004}},{"line":311,"address":[],"length":0,"stats":{"Line":26004}},{"line":313,"address":[],"length":0,"stats":{"Line":13557}},{"line":314,"address":[],"length":0,"stats":{"Line":10192}},{"line":318,"address":[],"length":0,"stats":{"Line":95}},{"line":324,"address":[],"length":0,"stats":{"Line":95}},{"line":325,"address":[],"length":0,"stats":{"Line":190}},{"line":326,"address":[],"length":0,"stats":{"Line":95}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":2}},{"line":367,"address":[],"length":0,"stats":{"Line":2}},{"line":372,"address":[],"length":0,"stats":{"Line":3}},{"line":374,"address":[],"length":0,"stats":{"Line":12}},{"line":375,"address":[],"length":0,"stats":{"Line":7}},{"line":376,"address":[],"length":0,"stats":{"Line":1}},{"line":380,"address":[],"length":0,"stats":{"Line":4}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":2}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":2}},{"line":410,"address":[],"length":0,"stats":{"Line":2}},{"line":411,"address":[],"length":0,"stats":{"Line":4}},{"line":412,"address":[],"length":0,"stats":{"Line":9}},{"line":417,"address":[],"length":0,"stats":{"Line":95}},{"line":418,"address":[],"length":0,"stats":{"Line":190}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":190}},{"line":423,"address":[],"length":0,"stats":{"Line":285}},{"line":424,"address":[],"length":0,"stats":{"Line":95}},{"line":426,"address":[],"length":0,"stats":{"Line":95}},{"line":427,"address":[],"length":0,"stats":{"Line":95}},{"line":428,"address":[],"length":0,"stats":{"Line":95}},{"line":429,"address":[],"length":0,"stats":{"Line":7692}},{"line":430,"address":[],"length":0,"stats":{"Line":7692}},{"line":431,"address":[],"length":0,"stats":{"Line":7692}},{"line":432,"address":[],"length":0,"stats":{"Line":7692}},{"line":433,"address":[],"length":0,"stats":{"Line":7692}},{"line":434,"address":[],"length":0,"stats":{"Line":7692}},{"line":436,"address":[],"length":0,"stats":{"Line":5223}},{"line":437,"address":[],"length":0,"stats":{"Line":95}},{"line":441,"address":[],"length":0,"stats":{"Line":95}},{"line":444,"address":[],"length":0,"stats":{"Line":190}},{"line":446,"address":[],"length":0,"stats":{"Line":190}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":190}},{"line":451,"address":[],"length":0,"stats":{"Line":285}},{"line":452,"address":[],"length":0,"stats":{"Line":95}},{"line":454,"address":[],"length":0,"stats":{"Line":190}},{"line":455,"address":[],"length":0,"stats":{"Line":285}},{"line":457,"address":[],"length":0,"stats":{"Line":31254}},{"line":459,"address":[],"length":0,"stats":{"Line":93477}},{"line":460,"address":[],"length":0,"stats":{"Line":31159}},{"line":461,"address":[],"length":0,"stats":{"Line":31159}},{"line":462,"address":[],"length":0,"stats":{"Line":93477}},{"line":463,"address":[],"length":0,"stats":{"Line":31159}},{"line":464,"address":[],"length":0,"stats":{"Line":31159}},{"line":465,"address":[],"length":0,"stats":{"Line":93477}},{"line":466,"address":[],"length":0,"stats":{"Line":31159}},{"line":467,"address":[],"length":0,"stats":{"Line":31159}},{"line":469,"address":[],"length":0,"stats":{"Line":93477}},{"line":470,"address":[],"length":0,"stats":{"Line":31159}},{"line":471,"address":[],"length":0,"stats":{"Line":31159}},{"line":472,"address":[],"length":0,"stats":{"Line":124636}},{"line":473,"address":[],"length":0,"stats":{"Line":93477}},{"line":474,"address":[],"length":0,"stats":{"Line":31159}},{"line":475,"address":[],"length":0,"stats":{"Line":31159}},{"line":476,"address":[],"length":0,"stats":{"Line":124636}},{"line":478,"address":[],"length":0,"stats":{"Line":93477}},{"line":479,"address":[],"length":0,"stats":{"Line":31159}},{"line":480,"address":[],"length":0,"stats":{"Line":31159}},{"line":481,"address":[],"length":0,"stats":{"Line":63614}},{"line":482,"address":[],"length":0,"stats":{"Line":2592}},{"line":485,"address":[],"length":0,"stats":{"Line":93477}},{"line":486,"address":[],"length":0,"stats":{"Line":31159}},{"line":487,"address":[],"length":0,"stats":{"Line":31159}},{"line":488,"address":[],"length":0,"stats":{"Line":124636}},{"line":489,"address":[],"length":0,"stats":{"Line":63462}},{"line":490,"address":[],"length":0,"stats":{"Line":2288}},{"line":492,"address":[],"length":0,"stats":{"Line":63382}},{"line":493,"address":[],"length":0,"stats":{"Line":2128}},{"line":495,"address":[],"length":0,"stats":{"Line":124636}},{"line":497,"address":[],"length":0,"stats":{"Line":62318}},{"line":498,"address":[],"length":0,"stats":{"Line":62318}},{"line":499,"address":[],"length":0,"stats":{"Line":62318}},{"line":500,"address":[],"length":0,"stats":{"Line":62318}},{"line":501,"address":[],"length":0,"stats":{"Line":62318}},{"line":502,"address":[],"length":0,"stats":{"Line":62318}},{"line":503,"address":[],"length":0,"stats":{"Line":62318}},{"line":504,"address":[],"length":0,"stats":{"Line":62318}},{"line":505,"address":[],"length":0,"stats":{"Line":62318}},{"line":506,"address":[],"length":0,"stats":{"Line":62318}},{"line":507,"address":[],"length":0,"stats":{"Line":31159}},{"line":508,"address":[],"length":0,"stats":{"Line":31159}},{"line":513,"address":[],"length":0,"stats":{"Line":62318}},{"line":514,"address":[],"length":0,"stats":{"Line":1162}},{"line":515,"address":[],"length":0,"stats":{"Line":1162}},{"line":518,"address":[],"length":0,"stats":{"Line":29997}},{"line":519,"address":[],"length":0,"stats":{"Line":87984}},{"line":521,"address":[],"length":0,"stats":{"Line":324}},{"line":522,"address":[],"length":0,"stats":{"Line":324}},{"line":525,"address":[],"length":0,"stats":{"Line":59346}},{"line":526,"address":[],"length":0,"stats":{"Line":59259}},{"line":528,"address":[],"length":0,"stats":{"Line":669}},{"line":529,"address":[],"length":0,"stats":{"Line":669}},{"line":532,"address":[],"length":0,"stats":{"Line":29004}},{"line":533,"address":[],"length":0,"stats":{"Line":232032}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":29004}},{"line":543,"address":[],"length":0,"stats":{"Line":139}},{"line":544,"address":[],"length":0,"stats":{"Line":176}},{"line":545,"address":[],"length":0,"stats":{"Line":44}},{"line":546,"address":[],"length":0,"stats":{"Line":44}},{"line":553,"address":[],"length":0,"stats":{"Line":380}},{"line":554,"address":[],"length":0,"stats":{"Line":285}},{"line":556,"address":[],"length":0,"stats":{"Line":95}},{"line":563,"address":[],"length":0,"stats":{"Line":95}},{"line":567,"address":[],"length":0,"stats":{"Line":190}},{"line":569,"address":[],"length":0,"stats":{"Line":62413}},{"line":575,"address":[],"length":0,"stats":{"Line":124636}},{"line":576,"address":[],"length":0,"stats":{"Line":124636}},{"line":577,"address":[],"length":0,"stats":{"Line":124636}},{"line":578,"address":[],"length":0,"stats":{"Line":124636}},{"line":581,"address":[],"length":0,"stats":{"Line":62318}},{"line":582,"address":[],"length":0,"stats":{"Line":1162}},{"line":583,"address":[],"length":0,"stats":{"Line":3264}},{"line":584,"address":[],"length":0,"stats":{"Line":799}},{"line":585,"address":[],"length":0,"stats":{"Line":475}},{"line":588,"address":[],"length":0,"stats":{"Line":1425}},{"line":591,"address":[],"length":0,"stats":{"Line":950}},{"line":593,"address":[],"length":0,"stats":{"Line":9709}},{"line":595,"address":[],"length":0,"stats":{"Line":475}},{"line":603,"address":[],"length":0,"stats":{"Line":950}},{"line":604,"address":[],"length":0,"stats":{"Line":475}},{"line":605,"address":[],"length":0,"stats":{"Line":475}},{"line":608,"address":[],"length":0,"stats":{"Line":475}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":1900}},{"line":632,"address":[],"length":0,"stats":{"Line":475}},{"line":633,"address":[],"length":0,"stats":{"Line":475}},{"line":634,"address":[],"length":0,"stats":{"Line":475}},{"line":635,"address":[],"length":0,"stats":{"Line":475}},{"line":643,"address":[],"length":0,"stats":{"Line":95}},{"line":647,"address":[],"length":0,"stats":{"Line":285}},{"line":651,"address":[],"length":0,"stats":{"Line":570}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":570}},{"line":656,"address":[],"length":0,"stats":{"Line":855}},{"line":657,"address":[],"length":0,"stats":{"Line":285}},{"line":659,"address":[],"length":0,"stats":{"Line":855}},{"line":661,"address":[],"length":0,"stats":{"Line":91821}},{"line":663,"address":[],"length":0,"stats":{"Line":183072}},{"line":664,"address":[],"length":0,"stats":{"Line":183072}},{"line":665,"address":[],"length":0,"stats":{"Line":183072}},{"line":666,"address":[],"length":0,"stats":{"Line":91536}},{"line":669,"address":[],"length":0,"stats":{"Line":84835}},{"line":670,"address":[],"length":0,"stats":{"Line":195335}},{"line":675,"address":[],"length":0,"stats":{"Line":12942}},{"line":676,"address":[],"length":0,"stats":{"Line":24744}},{"line":679,"address":[],"length":0,"stats":{"Line":285}},{"line":683,"address":[],"length":0,"stats":{"Line":1098}},{"line":684,"address":[],"length":0,"stats":{"Line":4718}},{"line":685,"address":[],"length":0,"stats":{"Line":978}},{"line":686,"address":[],"length":0,"stats":{"Line":978}},{"line":687,"address":[],"length":0,"stats":{"Line":326}},{"line":688,"address":[],"length":0,"stats":{"Line":35803}},{"line":689,"address":[],"length":0,"stats":{"Line":1134}},{"line":690,"address":[],"length":0,"stats":{"Line":326}},{"line":692,"address":[],"length":0,"stats":{"Line":652}},{"line":694,"address":[],"length":0,"stats":{"Line":428}},{"line":696,"address":[],"length":0,"stats":{"Line":438}},{"line":702,"address":[],"length":0,"stats":{"Line":1098}},{"line":703,"address":[],"length":0,"stats":{"Line":4606}},{"line":704,"address":[],"length":0,"stats":{"Line":642}},{"line":705,"address":[],"length":0,"stats":{"Line":642}},{"line":706,"address":[],"length":0,"stats":{"Line":214}},{"line":707,"address":[],"length":0,"stats":{"Line":20439}},{"line":708,"address":[],"length":0,"stats":{"Line":1040}},{"line":709,"address":[],"length":0,"stats":{"Line":214}},{"line":711,"address":[],"length":0,"stats":{"Line":428}},{"line":713,"address":[],"length":0,"stats":{"Line":176}},{"line":715,"address":[],"length":0,"stats":{"Line":340}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":0}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":788,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":2}},{"line":796,"address":[],"length":0,"stats":{"Line":2}},{"line":798,"address":[],"length":0,"stats":{"Line":6}},{"line":799,"address":[],"length":0,"stats":{"Line":3}},{"line":801,"address":[],"length":0,"stats":{"Line":1}},{"line":802,"address":[],"length":0,"stats":{"Line":1}},{"line":803,"address":[],"length":0,"stats":{"Line":3}},{"line":805,"address":[],"length":0,"stats":{"Line":3}},{"line":807,"address":[],"length":0,"stats":{"Line":6}},{"line":812,"address":[],"length":0,"stats":{"Line":1}},{"line":813,"address":[],"length":0,"stats":{"Line":1}},{"line":815,"address":[],"length":0,"stats":{"Line":5}},{"line":820,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":41}},{"line":830,"address":[],"length":0,"stats":{"Line":41}},{"line":832,"address":[],"length":0,"stats":{"Line":56657}},{"line":838,"address":[],"length":0,"stats":{"Line":2}},{"line":840,"address":[],"length":0,"stats":{"Line":8}},{"line":841,"address":[],"length":0,"stats":{"Line":8}},{"line":842,"address":[],"length":0,"stats":{"Line":4}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":0}},{"line":859,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}},{"line":876,"address":[],"length":0,"stats":{"Line":0}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":0}},{"line":879,"address":[],"length":0,"stats":{"Line":0}},{"line":881,"address":[],"length":0,"stats":{"Line":0}},{"line":886,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":894,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":0}},{"line":904,"address":[],"length":0,"stats":{"Line":0}},{"line":906,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":912,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":923,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":927,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":0}},{"line":931,"address":[],"length":0,"stats":{"Line":0}},{"line":932,"address":[],"length":0,"stats":{"Line":0}},{"line":935,"address":[],"length":0,"stats":{"Line":0}},{"line":936,"address":[],"length":0,"stats":{"Line":0}},{"line":937,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":944,"address":[],"length":0,"stats":{"Line":0}},{"line":947,"address":[],"length":0,"stats":{"Line":0}},{"line":948,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":0}},{"line":954,"address":[],"length":0,"stats":{"Line":0}},{"line":955,"address":[],"length":0,"stats":{"Line":0}},{"line":957,"address":[],"length":0,"stats":{"Line":0}},{"line":960,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":969,"address":[],"length":0,"stats":{"Line":0}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":165690}},{"line":994,"address":[],"length":0,"stats":{"Line":165690}},{"line":995,"address":[],"length":0,"stats":{"Line":331380}},{"line":996,"address":[],"length":0,"stats":{"Line":497070}},{"line":1002,"address":[],"length":0,"stats":{"Line":342749}},{"line":1003,"address":[],"length":0,"stats":{"Line":685498}},{"line":1004,"address":[],"length":0,"stats":{"Line":1028247}},{"line":1005,"address":[],"length":0,"stats":{"Line":685498}},{"line":1006,"address":[],"length":0,"stats":{"Line":685498}},{"line":1010,"address":[],"length":0,"stats":{"Line":0}},{"line":1014,"address":[],"length":0,"stats":{"Line":0}},{"line":1015,"address":[],"length":0,"stats":{"Line":0}},{"line":1019,"address":[],"length":0,"stats":{"Line":31159}},{"line":1020,"address":[],"length":0,"stats":{"Line":62318}},{"line":1021,"address":[],"length":0,"stats":{"Line":93477}},{"line":1022,"address":[],"length":0,"stats":{"Line":62318}},{"line":1023,"address":[],"length":0,"stats":{"Line":31159}},{"line":1027,"address":[],"length":0,"stats":{"Line":0}},{"line":1030,"address":[],"length":0,"stats":{"Line":45768}},{"line":1031,"address":[],"length":0,"stats":{"Line":320376}},{"line":1035,"address":[],"length":0,"stats":{"Line":93477}},{"line":1036,"address":[],"length":0,"stats":{"Line":186954}},{"line":1037,"address":[],"length":0,"stats":{"Line":280431}},{"line":1038,"address":[],"length":0,"stats":{"Line":186954}},{"line":1039,"address":[],"length":0,"stats":{"Line":93477}},{"line":1043,"address":[],"length":0,"stats":{"Line":0}},{"line":1049,"address":[],"length":0,"stats":{"Line":15}},{"line":1050,"address":[],"length":0,"stats":{"Line":32}},{"line":1054,"address":[],"length":0,"stats":{"Line":9}},{"line":1055,"address":[],"length":0,"stats":{"Line":27}},{"line":1059,"address":[],"length":0,"stats":{"Line":18}},{"line":1061,"address":[],"length":0,"stats":{"Line":9}},{"line":1062,"address":[],"length":0,"stats":{"Line":21}},{"line":1063,"address":[],"length":0,"stats":{"Line":6}},{"line":1068,"address":[],"length":0,"stats":{"Line":18}},{"line":1072,"address":[],"length":0,"stats":{"Line":12}},{"line":1074,"address":[],"length":0,"stats":{"Line":6}},{"line":1075,"address":[],"length":0,"stats":{"Line":24}},{"line":1078,"address":[],"length":0,"stats":{"Line":6}},{"line":1082,"address":[],"length":0,"stats":{"Line":1193}},{"line":1083,"address":[],"length":0,"stats":{"Line":2386}},{"line":1086,"address":[],"length":0,"stats":{"Line":2383}},{"line":1087,"address":[],"length":0,"stats":{"Line":12565}},{"line":1088,"address":[],"length":0,"stats":{"Line":30555}},{"line":1089,"address":[],"length":0,"stats":{"Line":11372}},{"line":1091,"address":[],"length":0,"stats":{"Line":3561}},{"line":1092,"address":[],"length":0,"stats":{"Line":37294}},{"line":1093,"address":[],"length":0,"stats":{"Line":230}},{"line":1098,"address":[],"length":0,"stats":{"Line":1193}},{"line":1104,"address":[],"length":0,"stats":{"Line":213}},{"line":1105,"address":[],"length":0,"stats":{"Line":428}},{"line":1109,"address":[],"length":0,"stats":{"Line":114}},{"line":1110,"address":[],"length":0,"stats":{"Line":342}},{"line":1114,"address":[],"length":0,"stats":{"Line":228}},{"line":1116,"address":[],"length":0,"stats":{"Line":114}},{"line":1117,"address":[],"length":0,"stats":{"Line":247}},{"line":1118,"address":[],"length":0,"stats":{"Line":19}},{"line":1119,"address":[],"length":0,"stats":{"Line":19}},{"line":1126,"address":[],"length":0,"stats":{"Line":95}},{"line":1127,"address":[],"length":0,"stats":{"Line":95}},{"line":1128,"address":[],"length":0,"stats":{"Line":285}},{"line":1129,"address":[],"length":0,"stats":{"Line":190}},{"line":1131,"address":[],"length":0,"stats":{"Line":95}},{"line":1132,"address":[],"length":0,"stats":{"Line":475}},{"line":1133,"address":[],"length":0,"stats":{"Line":95}},{"line":1135,"address":[],"length":0,"stats":{"Line":0}},{"line":1140,"address":[],"length":0,"stats":{"Line":1}},{"line":1141,"address":[],"length":0,"stats":{"Line":2}},{"line":1143,"address":[],"length":0,"stats":{"Line":1}},{"line":1144,"address":[],"length":0,"stats":{"Line":2}},{"line":1148,"address":[],"length":0,"stats":{"Line":1}},{"line":1149,"address":[],"length":0,"stats":{"Line":2}},{"line":1151,"address":[],"length":0,"stats":{"Line":1}},{"line":1152,"address":[],"length":0,"stats":{"Line":1}},{"line":1156,"address":[],"length":0,"stats":{"Line":2}},{"line":1157,"address":[],"length":0,"stats":{"Line":2}},{"line":1159,"address":[],"length":0,"stats":{"Line":2}},{"line":1164,"address":[],"length":0,"stats":{"Line":1}},{"line":1165,"address":[],"length":0,"stats":{"Line":2}},{"line":1167,"address":[],"length":0,"stats":{"Line":2}},{"line":1168,"address":[],"length":0,"stats":{"Line":0}},{"line":1169,"address":[],"length":0,"stats":{"Line":0}},{"line":1174,"address":[],"length":0,"stats":{"Line":2}},{"line":1175,"address":[],"length":0,"stats":{"Line":2}},{"line":1177,"address":[],"length":0,"stats":{"Line":1}},{"line":1181,"address":[],"length":0,"stats":{"Line":1}},{"line":1185,"address":[],"length":0,"stats":{"Line":2}},{"line":1187,"address":[],"length":0,"stats":{"Line":2}},{"line":1188,"address":[],"length":0,"stats":{"Line":0}},{"line":1189,"address":[],"length":0,"stats":{"Line":0}},{"line":1190,"address":[],"length":0,"stats":{"Line":0}},{"line":1191,"address":[],"length":0,"stats":{"Line":0}},{"line":1192,"address":[],"length":0,"stats":{"Line":0}},{"line":1193,"address":[],"length":0,"stats":{"Line":0}},{"line":1199,"address":[],"length":0,"stats":{"Line":2}},{"line":1200,"address":[],"length":0,"stats":{"Line":2}},{"line":1202,"address":[],"length":0,"stats":{"Line":1}},{"line":1214,"address":[],"length":0,"stats":{"Line":1}},{"line":1219,"address":[],"length":0,"stats":{"Line":3}},{"line":1222,"address":[],"length":0,"stats":{"Line":3}},{"line":1224,"address":[],"length":0,"stats":{"Line":38}},{"line":1225,"address":[],"length":0,"stats":{"Line":148}},{"line":1226,"address":[],"length":0,"stats":{"Line":37}},{"line":1227,"address":[],"length":0,"stats":{"Line":37}},{"line":1228,"address":[],"length":0,"stats":{"Line":37}},{"line":1229,"address":[],"length":0,"stats":{"Line":1135}},{"line":1230,"address":[],"length":0,"stats":{"Line":3294}},{"line":1231,"address":[],"length":0,"stats":{"Line":2196}},{"line":1232,"address":[],"length":0,"stats":{"Line":2642}},{"line":1233,"address":[],"length":0,"stats":{"Line":3294}},{"line":1234,"address":[],"length":0,"stats":{"Line":2196}},{"line":1235,"address":[],"length":0,"stats":{"Line":1098}},{"line":1236,"address":[],"length":0,"stats":{"Line":1098}},{"line":1237,"address":[],"length":0,"stats":{"Line":3294}},{"line":1238,"address":[],"length":0,"stats":{"Line":1098}},{"line":1239,"address":[],"length":0,"stats":{"Line":1098}},{"line":1242,"address":[],"length":0,"stats":{"Line":37}},{"line":1248,"address":[],"length":0,"stats":{"Line":6}},{"line":1249,"address":[],"length":0,"stats":{"Line":2}},{"line":1250,"address":[],"length":0,"stats":{"Line":4394}},{"line":1252,"address":[],"length":0,"stats":{"Line":1}},{"line":1256,"address":[],"length":0,"stats":{"Line":1}},{"line":1258,"address":[],"length":0,"stats":{"Line":3}},{"line":1261,"address":[],"length":0,"stats":{"Line":3}},{"line":1263,"address":[],"length":0,"stats":{"Line":38}},{"line":1264,"address":[],"length":0,"stats":{"Line":185}},{"line":1269,"address":[],"length":0,"stats":{"Line":3}},{"line":1270,"address":[],"length":0,"stats":{"Line":75}},{"line":1271,"address":[],"length":0,"stats":{"Line":1624}},{"line":1272,"address":[],"length":0,"stats":{"Line":2645}},{"line":1273,"address":[],"length":0,"stats":{"Line":2425}},{"line":1274,"address":[],"length":0,"stats":{"Line":2844}},{"line":1275,"address":[],"length":0,"stats":{"Line":1896}},{"line":1281,"address":[],"length":0,"stats":{"Line":1}}],"covered":377,"coverable":542},{"path":["/","workspace","crates","ofml-lib","src","oap","ocd_properties.rs"],"content":"//! OCD Property Reader - Reads property definitions and values from pdata.ebase\n//!\n//! This module extracts configuration options from OCD tables:\n//! - ocd_property: Property definitions\n//! - ocd_propertyvalue: Available options for each property\n//! - ocd_propertytext: Labels for properties and values\n//! - ocd_propertyclass: Property groupings\n\nuse std::collections::HashMap;\nuse std::path::Path;\n\nuse rayon::prelude::*;\n\nuse crate::ebase::{EBaseReader, Value};\n\n/// A property definition from OCD\n#[derive(Debug, Clone)]\npub struct OcdPropertyDef {\n    /// Property class (grouping)\n    pub prop_class: String,\n    /// Property name/key\n    pub property: String,\n    /// Display order\n    pub position: u16,\n    /// Text number for label lookup\n    pub textnr: String,\n    /// Property type (CHOICE, RANGE, INT, etc.)\n    pub prop_type: String,\n    /// Number of digits\n    pub digits: u16,\n    /// Decimal digits\n    pub dec_digits: u8,\n    /// Whether input is required\n    pub need_input: bool,\n    /// Whether additional values are allowed\n    pub add_values: bool,\n    /// Whether property can be restricted\n    pub restrictable: bool,\n    /// Allow multiple selections\n    pub multi_option: bool,\n    /// Relation object ID (for TABLE relations)\n    pub rel_obj: u32,\n    /// Property scope (C=Choice, R=Result, RG=Range, etc.)\n    pub scope: String,\n    /// Source series/family this property was loaded from (e.g., \"kr\", \"wkm\")\n    /// Used to filter properties relevant to a specific family\n    pub source_series: Option<String>,\n}\n\n/// A property value/option from OCD\n#[derive(Debug, Clone)]\npub struct OcdPropertyValue {\n    /// Property class\n    pub prop_class: String,\n    /// Property name\n    pub property: String,\n    /// Display order\n    pub position: u16,\n    /// Text number for label lookup\n    pub textnr: String,\n    /// Whether this is the default value\n    pub is_default: bool,\n    /// Value or range start\n    pub value_from: String,\n    /// Range end (for range types)\n    pub value_to: String,\n    /// Operator for value_from comparison\n    pub op_from: String,\n    /// Operator for value_to comparison\n    pub op_to: String,\n    /// Step/raster value\n    pub raster: String,\n}\n\n/// A property class/group from OCD\n#[derive(Debug, Clone)]\npub struct OcdPropertyClass {\n    /// Class identifier\n    pub prop_class: String,\n    /// Text number for label lookup\n    pub textnr: String,\n    /// Display order\n    pub position: u16,\n}\n\n/// A property text label from OCD\n#[derive(Debug, Clone)]\npub struct OcdPropertyText {\n    /// Text number (reference key)\n    pub textnr: String,\n    /// Language code\n    pub language: String,\n    /// Line number\n    pub line_nr: u8,\n    /// Text content\n    pub text: String,\n}\n\n/// A relation object definition from ocd_relationobj\n#[derive(Debug, Clone)]\npub struct OcdRelationObj {\n    /// Relation object ID\n    pub rel_obj: u32,\n    /// Relation name (links to ocd_relation)\n    pub rel_name: String,\n    /// Relation type (TABLE, EXPR, etc.)\n    pub rel_type: String,\n    /// Position\n    pub position: u16,\n}\n\n/// A relation definition from ocd_relation\n#[derive(Debug, Clone)]\npub struct OcdRelation {\n    /// Relation name (links from ocd_relationobj)\n    pub rel_name: String,\n    /// Block number within relation\n    pub rel_blocknr: u16,\n    /// Relation expression text\n    pub rel_block: String,\n}\n\n/// Parsed TABLE relation for property value lookup\n#[derive(Debug, Clone)]\npub struct TableRelation {\n    /// Custom table name (e.g., \"wkt_groesse_tbl\")\n    pub table_name: String,\n    /// Column mappings: (table_column, property_or_self)\n    /// e.g., [(\"Abmessung\", \"Abmessung\"), (\"Groesse\", \"$SELF.Groesse\")]\n    pub column_mappings: Vec<(String, String)>,\n    /// The target column that provides values for this property\n    pub target_column: Option<String>,\n}\n\n/// A property group from ocd_propertygroup\n#[derive(Debug, Clone)]\npub struct OcdPropertyGroup {\n    /// Property class this group belongs to\n    pub prop_class: String,\n    /// Property name\n    pub property: String,\n    /// Group identifier\n    pub prop_group: String,\n    /// Display order within the group\n    pub position: u16,\n}\n\n/// Article to property group mapping from ocd_article2propgroup\n#[derive(Debug, Clone)]\npub struct OcdArticle2PropGroup {\n    /// Article number\n    pub article_nr: String,\n    /// Property group identifier\n    pub prop_group: String,\n    /// Display order\n    pub position: u16,\n    /// Text number for label lookup\n    pub textnr: String,\n}\n\n/// Rounding rule from ocd_rounding\n#[derive(Debug, Clone)]\npub struct OcdRounding {\n    /// Rounding rule identifier\n    pub id: String,\n    /// Rule number/sequence\n    pub nr: u16,\n    /// Rounding type (e.g., \"ROUND\", \"FLOOR\", \"CEIL\")\n    pub rounding_type: String,\n    /// Precision (decimal places)\n    pub precision: u8,\n    /// Minimum value for this rule to apply\n    pub min: f64,\n    /// Maximum value for this rule to apply\n    pub max: f64,\n    /// Amount to add before rounding\n    pub add_before: f64,\n    /// Amount to add after rounding\n    pub add_after: f64,\n}\n\n/// Tax scheme from ocd_taxscheme\n#[derive(Debug, Clone)]\npub struct OcdTaxScheme {\n    /// Tax identifier\n    pub tax_id: String,\n    /// Country code\n    pub country: String,\n    /// Region code\n    pub region: String,\n    /// Tax category\n    pub tax_category: String,\n    /// Tax type\n    pub tax_type: String,\n    /// Tax percentage/number\n    pub number: f64,\n}\n\n/// Article taxes from ocd_articletaxes\n#[derive(Debug, Clone)]\npub struct OcdArticleTaxes {\n    /// Article number\n    pub article_nr: String,\n    /// Tax identifier (links to ocd_taxscheme)\n    pub tax_id: String,\n    /// Valid from date (YYYYMMDD)\n    pub date_from: String,\n    /// Valid to date (YYYYMMDD)\n    pub date_to: String,\n}\n\n/// Code scheme from ocd_codescheme\n#[derive(Debug, Clone)]\npub struct OcdCodeScheme {\n    /// Scheme identifier\n    pub scheme_id: String,\n    /// Scheme pattern/format\n    pub scheme: String,\n    /// Variant code separator\n    pub varcode_sep: String,\n    /// Value separator\n    pub value_sep: String,\n    /// Multi-option separator\n    pub mo_sep: String,\n    /// Multi-option bracket\n    pub mo_bracket: String,\n    /// Character for invisible options\n    pub invisible_char: String,\n    /// Character for unselected options\n    pub unselect_char: String,\n    /// Visibility flag\n    pub visibility: String,\n    /// Trim whitespace\n    pub trim: bool,\n}\n\n/// Article base properties from ocd_artbase\n#[derive(Debug, Clone)]\npub struct OcdArtBase {\n    /// Article number\n    pub article_nr: String,\n    /// Property class\n    pub prop_class: String,\n    /// Property name\n    pub property: String,\n    /// Property value\n    pub prop_value: String,\n}\n\n/// Packaging information from ocd_packaging\n#[derive(Debug, Clone)]\npub struct OcdPackaging {\n    /// Article number\n    pub article_nr: String,\n    /// Variant condition\n    pub var_cond: String,\n    /// Width\n    pub width: f64,\n    /// Depth\n    pub depth: f64,\n    /// Height\n    pub height: f64,\n    /// Net weight\n    pub net_weight: f64,\n    /// Tare weight\n    pub tara_weight: f64,\n    /// Volume\n    pub volume: f64,\n    /// Items per unit\n    pub items_per_unit: u32,\n    /// Pack units\n    pub pack_units: u32,\n    /// Measure unit (mm, cm, m)\n    pub measure_unit: String,\n    /// Weight unit (g, kg)\n    pub weight_unit: String,\n    /// Volume unit (l, m¬≥)\n    pub volume_unit: String,\n}\n\n/// Bill of items entry from ocd_billofitems\n#[derive(Debug, Clone)]\npub struct OcdBillOfItems {\n    /// Composite product ID\n    pub composite_id: String,\n    /// Item ID (article number or sub-composite)\n    pub item_id: String,\n    /// Position within the bill\n    pub item_pos: u16,\n    /// Quantity\n    pub quantity: f64,\n    /// Quantity unit\n    pub quant_unit: String,\n    /// Whether item is configurable\n    pub configurable: bool,\n    /// Relation object for configuration\n    pub rel_obj: u32,\n    /// Text ID for description\n    pub txt_id: String,\n}\n\n/// Composite product from ocd_composite\n#[derive(Debug, Clone)]\npub struct OcdComposite {\n    /// Composite product ID\n    pub composite_id: String,\n    /// Basket mode (how to add to basket)\n    pub basket_mode: String,\n    /// Price mode (how to calculate price)\n    pub price_mode: String,\n    /// Text mode (how to display text)\n    pub text_mode: String,\n    /// Whether composite is configurable\n    pub configurable: bool,\n    /// Whether items are configurable\n    pub items_configurable: bool,\n    /// Whether composite is fixed\n    pub is_fixed: bool,\n}\n\n/// Version information from ocd_version\n#[derive(Debug, Clone)]\npub struct OcdVersion {\n    /// Data version\n    pub data_version: String,\n    /// Format version\n    pub format_version: String,\n    /// Region code\n    pub region: String,\n    /// Valid from date\n    pub date_from: String,\n    /// Valid to date\n    pub date_to: String,\n    /// Relation coding type\n    pub rel_coding: String,\n    /// Comment\n    pub comment: String,\n    /// Available tables\n    pub tables: String,\n    /// Variant condition variable\n    pub varcond_var: String,\n    /// Placeholder enabled\n    pub placeholder_on: bool,\n}\n\n/// OCD Property Reader - loads all property configuration data\npub struct OcdPropertyReader {\n    /// Property definitions by (prop_class, property)\n    pub properties: HashMap<(String, String), OcdPropertyDef>,\n    /// Property values by (prop_class, property)\n    pub values: HashMap<(String, String), Vec<OcdPropertyValue>>,\n    /// Property classes by prop_class\n    pub classes: HashMap<String, OcdPropertyClass>,\n    /// Property texts by textnr (for property labels)\n    pub texts: HashMap<String, Vec<OcdPropertyText>>,\n    /// Property VALUE texts by textnr (for value descriptions like \"6235\" -> \"Armlehne\")\n    pub value_texts: HashMap<String, Vec<OcdPropertyText>>,\n    /// Price texts by textnr (for surcharge descriptions)\n    pub price_texts: HashMap<String, Vec<OcdPropertyText>>,\n    /// Property class texts by textnr (for property class/group labels)\n    pub prop_class_texts: HashMap<String, Vec<OcdPropertyText>>,\n    /// Hint texts by textnr (for help/tooltip texts)\n    pub hint_texts: HashMap<String, Vec<OcdPropertyText>>,\n    /// User messages by textnr\n    pub user_messages: HashMap<String, Vec<OcdPropertyText>>,\n    /// Property group texts by textnr\n    pub prop_group_texts: HashMap<String, Vec<OcdPropertyText>>,\n    /// Relation objects by rel_obj ID\n    pub relation_objs: HashMap<u32, OcdRelationObj>,\n    /// Relations by rel_name (each rel_name can have multiple blocks)\n    pub relations: HashMap<String, Vec<OcdRelation>>,\n    /// Custom table data: table_name -> records (each record is field->value)\n    pub custom_tables: HashMap<String, Vec<HashMap<String, String>>>,\n    /// Property groups by (prop_class, property)\n    pub property_groups: HashMap<(String, String), OcdPropertyGroup>,\n    /// Article to property group mappings by article_nr\n    pub article_prop_groups: HashMap<String, Vec<OcdArticle2PropGroup>>,\n    /// Rounding rules by id\n    pub rounding_rules: HashMap<String, Vec<OcdRounding>>,\n    /// Tax schemes by tax_id\n    pub tax_schemes: HashMap<String, OcdTaxScheme>,\n    /// Article taxes by article_nr\n    pub article_taxes: HashMap<String, Vec<OcdArticleTaxes>>,\n    /// Code schemes by scheme_id\n    pub code_schemes: HashMap<String, OcdCodeScheme>,\n    /// Article base properties by article_nr\n    pub art_base: HashMap<String, Vec<OcdArtBase>>,\n    /// Packaging info by article_nr\n    pub packaging: HashMap<String, Vec<OcdPackaging>>,\n    /// Bill of items by composite_id\n    pub bill_of_items: HashMap<String, Vec<OcdBillOfItems>>,\n    /// Composite products by composite_id\n    pub composites: HashMap<String, OcdComposite>,\n    /// Version information (single record)\n    pub version: Option<OcdVersion>,\n}\n\nimpl OcdPropertyReader {\n    /// Load property data from a pdata.ebase file\n    pub fn from_ebase(path: &Path) -> Result<Self, String> {\n        let mut reader = EBaseReader::open(path).map_err(|e| e.to_string())?;\n\n        // Core property data\n        let properties = Self::read_properties(&mut reader)?;\n        let values = Self::read_property_values(&mut reader)?;\n        let classes = Self::read_property_classes(&mut reader)?;\n\n        // Text tables\n        let texts = Self::read_property_texts(&mut reader, \"ocd_propertytext\")?;\n        let value_texts = Self::read_property_texts(&mut reader, \"ocd_propvaluetext\")?;\n        let price_texts = Self::read_property_texts(&mut reader, \"ocd_pricetext\")?;\n        let prop_class_texts = Self::read_property_texts(&mut reader, \"ocd_propclasstext\")?;\n        let hint_texts = Self::read_property_texts(&mut reader, \"ocd_prophinttext\")?;\n        let user_messages = Self::read_property_texts(&mut reader, \"ocd_usermessage\")?;\n        let prop_group_texts = Self::read_property_texts(&mut reader, \"ocd_propgrouptext\")?;\n\n        // Relations\n        let relation_objs = Self::read_relation_objs(&mut reader)?;\n        let relations = Self::read_relations(&mut reader)?;\n\n        // Property groups\n        let property_groups = Self::read_property_groups(&mut reader)?;\n        let article_prop_groups = Self::read_article_prop_groups(&mut reader)?;\n\n        // Pricing support tables\n        let rounding_rules = Self::read_rounding_rules(&mut reader)?;\n        let tax_schemes = Self::read_tax_schemes(&mut reader)?;\n        let article_taxes = Self::read_article_taxes(&mut reader)?;\n\n        // Other tables\n        let code_schemes = Self::read_code_schemes(&mut reader)?;\n        let art_base = Self::read_art_base(&mut reader)?;\n        let packaging = Self::read_packaging(&mut reader)?;\n        let bill_of_items = Self::read_bill_of_items(&mut reader)?;\n        let composites = Self::read_composites(&mut reader)?;\n        let version = Self::read_version(&mut reader)?;\n\n        // Find which custom tables are referenced by TABLE relations\n        let mut custom_tables = HashMap::new();\n        for rel_list in relations.values() {\n            for rel in rel_list {\n                if let Some(parsed) = Self::parse_table_relation(&rel.rel_block) {\n                    let table_name_lower = parsed.table_name.to_lowercase() + \"_tbl\";\n                    if let std::collections::hash_map::Entry::Vacant(e) =\n                        custom_tables.entry(table_name_lower.clone())\n                    {\n                        if let Ok(table_data) =\n                            Self::read_custom_table(&mut reader, &table_name_lower)\n                        {\n                            e.insert(table_data);\n                        }\n                    }\n                }\n            }\n        }\n\n        Ok(Self {\n            properties,\n            values,\n            classes,\n            texts,\n            value_texts,\n            price_texts,\n            prop_class_texts,\n            hint_texts,\n            user_messages,\n            prop_group_texts,\n            relation_objs,\n            relations,\n            custom_tables,\n            property_groups,\n            article_prop_groups,\n            rounding_rules,\n            tax_schemes,\n            article_taxes,\n            code_schemes,\n            art_base,\n            packaging,\n            bill_of_items,\n            composites,\n            version,\n        })\n    }\n\n    /// Read property definitions from ocd_property table\n    fn read_properties(\n        reader: &mut EBaseReader,\n    ) -> Result<HashMap<(String, String), OcdPropertyDef>, String> {\n        let mut result = HashMap::new();\n\n        if !reader.tables.contains_key(\"ocd_property\") {\n            return Ok(result);\n        }\n\n        let records = reader\n            .read_records(\"ocd_property\", None)\n            .map_err(|e| e.to_string())?;\n\n        for record in &records {\n            let prop_class = get_string(record, \"prop_class\");\n            let property = get_string(record, \"property\");\n\n            if prop_class.is_empty() || property.is_empty() {\n                continue;\n            }\n\n            let def = OcdPropertyDef {\n                prop_class: prop_class.clone(),\n                property: property.clone(),\n                position: get_u16(record, \"pos_prop\"),\n                textnr: get_string(record, \"prop_textnr\"),\n                prop_type: get_string(record, \"prop_type\"),\n                digits: get_u16(record, \"digits\"),\n                dec_digits: get_u8(record, \"dec_digits\"),\n                need_input: get_u8(record, \"need_input\") != 0,\n                add_values: get_u8(record, \"add_values\") != 0,\n                restrictable: get_u8(record, \"restrictable\") != 0,\n                multi_option: get_u8(record, \"multi_option\") != 0,\n                rel_obj: get_u32(record, \"rel_obj\"),\n                scope: get_string(record, \"scope\"),\n                source_series: None, // Set during manufacturer loading\n            };\n\n            result.insert((prop_class, property), def);\n        }\n\n        Ok(result)\n    }\n\n    /// Read property values from ocd_propertyvalue table\n    fn read_property_values(\n        reader: &mut EBaseReader,\n    ) -> Result<HashMap<(String, String), Vec<OcdPropertyValue>>, String> {\n        let mut result: HashMap<(String, String), Vec<OcdPropertyValue>> = HashMap::new();\n\n        if !reader.tables.contains_key(\"ocd_propertyvalue\") {\n            return Ok(result);\n        }\n\n        let records = reader\n            .read_records(\"ocd_propertyvalue\", None)\n            .map_err(|e| e.to_string())?;\n\n        for record in &records {\n            let prop_class = get_string(record, \"prop_class\");\n            let property = get_string(record, \"property\");\n\n            if prop_class.is_empty() || property.is_empty() {\n                continue;\n            }\n\n            let value = OcdPropertyValue {\n                prop_class: prop_class.clone(),\n                property: property.clone(),\n                position: get_u16(record, \"pos_pval\"),\n                textnr: get_string(record, \"pval_textnr\"),\n                is_default: get_u8(record, \"is_default\") != 0,\n                value_from: get_string(record, \"value_from\"),\n                value_to: get_string(record, \"value_to\"),\n                op_from: get_string(record, \"op_from\"),\n                op_to: get_string(record, \"op_to\"),\n                raster: get_string(record, \"raster\"),\n            };\n\n            result\n                .entry((prop_class, property))\n                .or_default()\n                .push(value);\n        }\n\n        // Sort values by position\n        for values in result.values_mut() {\n            values.sort_by_key(|v| v.position);\n        }\n\n        Ok(result)\n    }\n\n    /// Read property classes from ocd_propertyclass table\n    fn read_property_classes(\n        reader: &mut EBaseReader,\n    ) -> Result<HashMap<String, OcdPropertyClass>, String> {\n        let mut result = HashMap::new();\n\n        if !reader.tables.contains_key(\"ocd_propertyclass\") {\n            return Ok(result);\n        }\n\n        let records = reader\n            .read_records(\"ocd_propertyclass\", None)\n            .map_err(|e| e.to_string())?;\n\n        for record in &records {\n            let prop_class = get_string(record, \"prop_class\");\n\n            if prop_class.is_empty() {\n                continue;\n            }\n\n            let class = OcdPropertyClass {\n                prop_class: prop_class.clone(),\n                textnr: get_string(record, \"textnr\"),\n                position: get_u16(record, \"pos_pclass\"),\n            };\n\n            result.insert(prop_class, class);\n        }\n\n        Ok(result)\n    }\n\n    /// Read property texts from a text table (ocd_propertytext or ocd_propvaluetext)\n    fn read_property_texts(\n        reader: &mut EBaseReader,\n        table_name: &str,\n    ) -> Result<HashMap<String, Vec<OcdPropertyText>>, String> {\n        let mut result: HashMap<String, Vec<OcdPropertyText>> = HashMap::new();\n\n        if !reader.tables.contains_key(table_name) {\n            return Ok(result);\n        }\n\n        let records = reader\n            .read_records(table_name, None)\n            .map_err(|e| e.to_string())?;\n\n        for record in &records {\n            let textnr = get_string(record, \"textnr\");\n\n            if textnr.is_empty() {\n                continue;\n            }\n\n            let text = OcdPropertyText {\n                textnr: textnr.clone(),\n                language: get_string(record, \"language\"),\n                line_nr: get_u8(record, \"line_nr\"),\n                text: get_string(record, \"text\"),\n            };\n\n            result.entry(textnr).or_default().push(text);\n        }\n\n        // Sort by line number\n        for texts in result.values_mut() {\n            texts.sort_by_key(|t| t.line_nr);\n        }\n\n        Ok(result)\n    }\n\n    /// Read relation objects from ocd_relationobj table\n    fn read_relation_objs(\n        reader: &mut EBaseReader,\n    ) -> Result<HashMap<u32, OcdRelationObj>, String> {\n        let mut result = HashMap::new();\n\n        if !reader.tables.contains_key(\"ocd_relationobj\") {\n            return Ok(result);\n        }\n\n        let records = reader\n            .read_records(\"ocd_relationobj\", None)\n            .map_err(|e| e.to_string())?;\n\n        for record in &records {\n            let rel_obj = get_u32(record, \"rel_obj\");\n            if rel_obj == 0 {\n                continue;\n            }\n\n            let obj = OcdRelationObj {\n                rel_obj,\n                rel_name: get_string(record, \"rel_name\"),\n                rel_type: get_string(record, \"rel_type\"),\n                position: get_u16(record, \"position\"),\n            };\n\n            result.insert(rel_obj, obj);\n        }\n\n        Ok(result)\n    }\n\n    /// Read relations from ocd_relation table\n    fn read_relations(\n        reader: &mut EBaseReader,\n    ) -> Result<HashMap<String, Vec<OcdRelation>>, String> {\n        let mut result: HashMap<String, Vec<OcdRelation>> = HashMap::new();\n\n        if !reader.tables.contains_key(\"ocd_relation\") {\n            return Ok(result);\n        }\n\n        let records = reader\n            .read_records(\"ocd_relation\", None)\n            .map_err(|e| e.to_string())?;\n\n        for record in &records {\n            let rel_name = get_string(record, \"rel_name\");\n            if rel_name.is_empty() {\n                continue;\n            }\n\n            let rel = OcdRelation {\n                rel_name: rel_name.clone(),\n                rel_blocknr: get_u16(record, \"rel_blocknr\"),\n                rel_block: get_string(record, \"rel_block\"),\n            };\n\n            result.entry(rel_name).or_default().push(rel);\n        }\n\n        // Sort by block number\n        for relations in result.values_mut() {\n            relations.sort_by_key(|r| r.rel_blocknr);\n        }\n\n        Ok(result)\n    }\n\n    /// Parse a TABLE relation expression\n    /// Format: TABLE TableName (col1=prop1, col2=$SELF.prop2)\n    pub fn parse_table_relation(rel_text: &str) -> Option<TableRelation> {\n        let text = rel_text.trim();\n        if !text.to_uppercase().starts_with(\"TABLE \") {\n            return None;\n        }\n\n        // Remove \"TABLE \" prefix\n        let rest = text[6..].trim();\n\n        // Find table name (until '(' or whitespace)\n        let table_end = rest.find(|c: char| c == '(' || c.is_whitespace())?;\n        let table_name = rest[..table_end].trim().to_string();\n\n        // Find the parentheses content\n        let paren_start = rest.find('(')?;\n        let paren_end = rest.rfind(')')?;\n        if paren_end <= paren_start {\n            return None;\n        }\n\n        let mapping_text = &rest[paren_start + 1..paren_end];\n\n        // Parse column mappings: col1=val1, col2=val2, ...\n        let mut column_mappings = Vec::new();\n        let mut target_column = None;\n\n        for part in mapping_text.split(',') {\n            let part = part.trim();\n            if let Some(eq_pos) = part.find('=') {\n                let col = part[..eq_pos].trim().to_string();\n                let val = part[eq_pos + 1..].trim().to_string();\n\n                // If value contains $SELF, this is the target column\n                if val.contains(\"$SELF\") {\n                    // Extract the property name from $SELF.property\n                    if val.find('.').is_some() {\n                        target_column = Some(col.clone());\n                    }\n                }\n\n                column_mappings.push((col, val));\n            }\n        }\n\n        Some(TableRelation {\n            table_name,\n            column_mappings,\n            target_column,\n        })\n    }\n\n    /// Read a custom table dynamically\n    /// Some tables use a pivot format with columns: line, name, value\n    /// This function detects and handles both formats\n    fn read_custom_table(\n        reader: &mut EBaseReader,\n        table_name: &str,\n    ) -> Result<Vec<HashMap<String, String>>, String> {\n        if !reader.tables.contains_key(table_name) {\n            return Ok(Vec::new());\n        }\n\n        let records = reader\n            .read_records(table_name, None)\n            .map_err(|e| e.to_string())?;\n\n        if records.is_empty() {\n            return Ok(Vec::new());\n        }\n\n        // Check if this is a pivot table (has line, name, value columns)\n        let first_record = &records[0];\n        let has_line = first_record.contains_key(\"line\");\n        let has_name = first_record.contains_key(\"name\");\n        let has_value = first_record.contains_key(\"value\");\n\n        if has_line && has_name && has_value {\n            // This is a pivot table - unpivot it\n            Self::unpivot_table(&records)\n        } else {\n            // Normal table format\n            let mut result = Vec::new();\n            for record in &records {\n                let mut row = HashMap::new();\n                for (key, value) in record {\n                    let str_value = match value {\n                        Value::String(s) => s.clone(),\n                        Value::Int(i) => i.to_string(),\n                        Value::UInt(u) => u.to_string(),\n                        Value::Float(f) => f.to_string(),\n                        Value::Blob(_) | Value::Null => String::new(),\n                    };\n                    row.insert(key.clone(), str_value);\n                }\n                result.push(row);\n            }\n            Ok(result)\n        }\n    }\n\n    /// Unpivot a table with line/name/value columns into proper rows\n    fn unpivot_table(\n        records: &[HashMap<String, Value>],\n    ) -> Result<Vec<HashMap<String, String>>, String> {\n        // Group records by line number\n        let mut lines: HashMap<String, HashMap<String, String>> = HashMap::new();\n\n        for record in records {\n            let line = match record.get(\"line\") {\n                Some(Value::String(s)) => s.clone(),\n                Some(Value::Int(i)) => i.to_string(),\n                Some(Value::UInt(u)) => u.to_string(),\n                _ => continue,\n            };\n\n            let name = match record.get(\"name\") {\n                Some(Value::String(s)) => s.to_lowercase(),\n                _ => continue,\n            };\n\n            let value = match record.get(\"value\") {\n                Some(Value::String(s)) => s.clone(),\n                Some(Value::Int(i)) => i.to_string(),\n                Some(Value::UInt(u)) => u.to_string(),\n                Some(Value::Float(f)) => f.to_string(),\n                _ => String::new(),\n            };\n\n            lines.entry(line).or_default().insert(name, value);\n        }\n\n        // Convert to vector of rows\n        let mut result: Vec<HashMap<String, String>> = lines.into_values().collect();\n\n        // Sort by line number if present (for deterministic ordering)\n        result.sort_by(|a, b| {\n            let a_line = a\n                .get(\"line\")\n                .and_then(|s| s.parse::<u32>().ok())\n                .unwrap_or(0);\n            let b_line = b\n                .get(\"line\")\n                .and_then(|s| s.parse::<u32>().ok())\n                .unwrap_or(0);\n            a_line.cmp(&b_line)\n        });\n\n        Ok(result)\n    }\n\n    /// Read property groups from ocd_propertygroup table\n    fn read_property_groups(\n        reader: &mut EBaseReader,\n    ) -> Result<HashMap<(String, String), OcdPropertyGroup>, String> {\n        let mut result = HashMap::new();\n\n        if !reader.tables.contains_key(\"ocd_propertygroup\") {\n            return Ok(result);\n        }\n\n        let records = reader\n            .read_records(\"ocd_propertygroup\", None)\n            .map_err(|e| e.to_string())?;\n\n        for record in &records {\n            let prop_class = get_string(record, \"prop_class\");\n            let property = get_string(record, \"property\");\n\n            if prop_class.is_empty() || property.is_empty() {\n                continue;\n            }\n\n            let group = OcdPropertyGroup {\n                prop_class: prop_class.clone(),\n                property: property.clone(),\n                prop_group: get_string(record, \"prop_group\"),\n                position: get_u16(record, \"pos_prop\"),\n            };\n\n            result.insert((prop_class, property), group);\n        }\n\n        Ok(result)\n    }\n\n    /// Read article to property group mappings from ocd_article2propgroup table\n    fn read_article_prop_groups(\n        reader: &mut EBaseReader,\n    ) -> Result<HashMap<String, Vec<OcdArticle2PropGroup>>, String> {\n        let mut result: HashMap<String, Vec<OcdArticle2PropGroup>> = HashMap::new();\n\n        if !reader.tables.contains_key(\"ocd_article2propgroup\") {\n            return Ok(result);\n        }\n\n        let records = reader\n            .read_records(\"ocd_article2propgroup\", None)\n            .map_err(|e| e.to_string())?;\n\n        for record in &records {\n            let article_nr = get_string(record, \"article_nr\");\n\n            if article_nr.is_empty() {\n                continue;\n            }\n\n            let mapping = OcdArticle2PropGroup {\n                article_nr: article_nr.clone(),\n                prop_group: get_string(record, \"prop_group\"),\n                position: get_u16(record, \"pos_group\"),\n                textnr: get_string(record, \"textnr\"),\n            };\n\n            result.entry(article_nr).or_default().push(mapping);\n        }\n\n        // Sort by position\n        for mappings in result.values_mut() {\n            mappings.sort_by_key(|m| m.position);\n        }\n\n        Ok(result)\n    }\n\n    /// Read rounding rules from ocd_rounding table\n    fn read_rounding_rules(\n        reader: &mut EBaseReader,\n    ) -> Result<HashMap<String, Vec<OcdRounding>>, String> {\n        let mut result: HashMap<String, Vec<OcdRounding>> = HashMap::new();\n\n        if !reader.tables.contains_key(\"ocd_rounding\") {\n            return Ok(result);\n        }\n\n        let records = reader\n            .read_records(\"ocd_rounding\", None)\n            .map_err(|e| e.to_string())?;\n\n        for record in &records {\n            let id = get_string(record, \"id\");\n\n            if id.is_empty() {\n                continue;\n            }\n\n            let rule = OcdRounding {\n                id: id.clone(),\n                nr: get_u16(record, \"nr\"),\n                rounding_type: get_string(record, \"type\"),\n                precision: get_u8(record, \"precision\"),\n                min: get_f64(record, \"min\"),\n                max: get_f64(record, \"max\"),\n                add_before: get_f64(record, \"add_before\"),\n                add_after: get_f64(record, \"add_after\"),\n            };\n\n            result.entry(id).or_default().push(rule);\n        }\n\n        // Sort by nr\n        for rules in result.values_mut() {\n            rules.sort_by_key(|r| r.nr);\n        }\n\n        Ok(result)\n    }\n\n    /// Read tax schemes from ocd_taxscheme table\n    fn read_tax_schemes(\n        reader: &mut EBaseReader,\n    ) -> Result<HashMap<String, OcdTaxScheme>, String> {\n        let mut result = HashMap::new();\n\n        if !reader.tables.contains_key(\"ocd_taxscheme\") {\n            return Ok(result);\n        }\n\n        let records = reader\n            .read_records(\"ocd_taxscheme\", None)\n            .map_err(|e| e.to_string())?;\n\n        for record in &records {\n            let tax_id = get_string(record, \"tax_id\");\n\n            if tax_id.is_empty() {\n                continue;\n            }\n\n            let scheme = OcdTaxScheme {\n                tax_id: tax_id.clone(),\n                country: get_string(record, \"country\"),\n                region: get_string(record, \"region\"),\n                tax_category: get_string(record, \"tax_category\"),\n                tax_type: get_string(record, \"tax_type\"),\n                number: get_f64(record, \"number\"),\n            };\n\n            result.insert(tax_id, scheme);\n        }\n\n        Ok(result)\n    }\n\n    /// Read article taxes from ocd_articletaxes table\n    fn read_article_taxes(\n        reader: &mut EBaseReader,\n    ) -> Result<HashMap<String, Vec<OcdArticleTaxes>>, String> {\n        let mut result: HashMap<String, Vec<OcdArticleTaxes>> = HashMap::new();\n\n        if !reader.tables.contains_key(\"ocd_articletaxes\") {\n            return Ok(result);\n        }\n\n        let records = reader\n            .read_records(\"ocd_articletaxes\", None)\n            .map_err(|e| e.to_string())?;\n\n        for record in &records {\n            let article_nr = get_string(record, \"article_nr\");\n\n            if article_nr.is_empty() {\n                continue;\n            }\n\n            let tax = OcdArticleTaxes {\n                article_nr: article_nr.clone(),\n                tax_id: get_string(record, \"tax_id\"),\n                date_from: get_string(record, \"date_from\"),\n                date_to: get_string(record, \"date_to\"),\n            };\n\n            result.entry(article_nr).or_default().push(tax);\n        }\n\n        Ok(result)\n    }\n\n    /// Read code schemes from ocd_codescheme table\n    fn read_code_schemes(\n        reader: &mut EBaseReader,\n    ) -> Result<HashMap<String, OcdCodeScheme>, String> {\n        let mut result = HashMap::new();\n\n        if !reader.tables.contains_key(\"ocd_codescheme\") {\n            return Ok(result);\n        }\n\n        let records = reader\n            .read_records(\"ocd_codescheme\", None)\n            .map_err(|e| e.to_string())?;\n\n        for record in &records {\n            let scheme_id = get_string(record, \"scheme_id\");\n\n            if scheme_id.is_empty() {\n                continue;\n            }\n\n            let scheme = OcdCodeScheme {\n                scheme_id: scheme_id.clone(),\n                scheme: get_string(record, \"scheme\"),\n                varcode_sep: get_string(record, \"varcode_sep\"),\n                value_sep: get_string(record, \"value_sep\"),\n                mo_sep: get_string(record, \"mo_sep\"),\n                mo_bracket: get_string(record, \"mo_bracket\"),\n                invisible_char: get_string(record, \"invisible_char\"),\n                unselect_char: get_string(record, \"unselect_char\"),\n                visibility: get_string(record, \"visibility\"),\n                trim: get_u8(record, \"trim\") != 0,\n            };\n\n            result.insert(scheme_id, scheme);\n        }\n\n        Ok(result)\n    }\n\n    /// Read article base properties from ocd_artbase table\n    fn read_art_base(\n        reader: &mut EBaseReader,\n    ) -> Result<HashMap<String, Vec<OcdArtBase>>, String> {\n        let mut result: HashMap<String, Vec<OcdArtBase>> = HashMap::new();\n\n        if !reader.tables.contains_key(\"ocd_artbase\") {\n            return Ok(result);\n        }\n\n        let records = reader\n            .read_records(\"ocd_artbase\", None)\n            .map_err(|e| e.to_string())?;\n\n        for record in &records {\n            let article_nr = get_string(record, \"article_nr\");\n\n            if article_nr.is_empty() {\n                continue;\n            }\n\n            let base = OcdArtBase {\n                article_nr: article_nr.clone(),\n                prop_class: get_string(record, \"prop_class\"),\n                property: get_string(record, \"property\"),\n                prop_value: get_string(record, \"prop_value\"),\n            };\n\n            result.entry(article_nr).or_default().push(base);\n        }\n\n        Ok(result)\n    }\n\n    /// Read packaging info from ocd_packaging table\n    fn read_packaging(\n        reader: &mut EBaseReader,\n    ) -> Result<HashMap<String, Vec<OcdPackaging>>, String> {\n        let mut result: HashMap<String, Vec<OcdPackaging>> = HashMap::new();\n\n        if !reader.tables.contains_key(\"ocd_packaging\") {\n            return Ok(result);\n        }\n\n        let records = reader\n            .read_records(\"ocd_packaging\", None)\n            .map_err(|e| e.to_string())?;\n\n        for record in &records {\n            let article_nr = get_string(record, \"article_nr\");\n\n            if article_nr.is_empty() {\n                continue;\n            }\n\n            let pkg = OcdPackaging {\n                article_nr: article_nr.clone(),\n                var_cond: get_string(record, \"var_cond\"),\n                width: get_f64(record, \"width\"),\n                depth: get_f64(record, \"depth\"),\n                height: get_f64(record, \"height\"),\n                net_weight: get_f64(record, \"net_weight\"),\n                tara_weight: get_f64(record, \"tara_weight\"),\n                volume: get_f64(record, \"volume\"),\n                items_per_unit: get_u32(record, \"items_per_unit\"),\n                pack_units: get_u32(record, \"pack_units\"),\n                measure_unit: get_string(record, \"measure_unit\"),\n                weight_unit: get_string(record, \"weight_unit\"),\n                volume_unit: get_string(record, \"volume_unit\"),\n            };\n\n            result.entry(article_nr).or_default().push(pkg);\n        }\n\n        Ok(result)\n    }\n\n    /// Read bill of items from ocd_billofitems table\n    fn read_bill_of_items(\n        reader: &mut EBaseReader,\n    ) -> Result<HashMap<String, Vec<OcdBillOfItems>>, String> {\n        let mut result: HashMap<String, Vec<OcdBillOfItems>> = HashMap::new();\n\n        if !reader.tables.contains_key(\"ocd_billofitems\") {\n            return Ok(result);\n        }\n\n        let records = reader\n            .read_records(\"ocd_billofitems\", None)\n            .map_err(|e| e.to_string())?;\n\n        for record in &records {\n            let composite_id = get_string(record, \"composite_id\");\n\n            if composite_id.is_empty() {\n                continue;\n            }\n\n            let item = OcdBillOfItems {\n                composite_id: composite_id.clone(),\n                item_id: get_string(record, \"item_id\"),\n                item_pos: get_u16(record, \"item_pos\"),\n                quantity: get_f64(record, \"quanity\"), // Note: typo in original schema\n                quant_unit: get_string(record, \"quant_unit\"),\n                configurable: get_u8(record, \"configurable\") != 0,\n                rel_obj: get_u32(record, \"rel_obj\"),\n                txt_id: get_string(record, \"txt_id\"),\n            };\n\n            result.entry(composite_id).or_default().push(item);\n        }\n\n        // Sort by item_pos\n        for items in result.values_mut() {\n            items.sort_by_key(|i| i.item_pos);\n        }\n\n        Ok(result)\n    }\n\n    /// Read composite products from ocd_composite table\n    fn read_composites(\n        reader: &mut EBaseReader,\n    ) -> Result<HashMap<String, OcdComposite>, String> {\n        let mut result = HashMap::new();\n\n        if !reader.tables.contains_key(\"ocd_composite\") {\n            return Ok(result);\n        }\n\n        let records = reader\n            .read_records(\"ocd_composite\", None)\n            .map_err(|e| e.to_string())?;\n\n        for record in &records {\n            let composite_id = get_string(record, \"composite_id\");\n\n            if composite_id.is_empty() {\n                continue;\n            }\n\n            let composite = OcdComposite {\n                composite_id: composite_id.clone(),\n                basket_mode: get_string(record, \"basket_mode\"),\n                price_mode: get_string(record, \"price_mode\"),\n                text_mode: get_string(record, \"text_mode\"),\n                configurable: get_u8(record, \"configurable\") != 0,\n                items_configurable: get_u8(record, \"items_configurable\") != 0,\n                is_fixed: get_u8(record, \"is_fixed\") != 0,\n            };\n\n            result.insert(composite_id, composite);\n        }\n\n        Ok(result)\n    }\n\n    /// Read version info from ocd_version table\n    fn read_version(reader: &mut EBaseReader) -> Result<Option<OcdVersion>, String> {\n        if !reader.tables.contains_key(\"ocd_version\") {\n            return Ok(None);\n        }\n\n        let records = reader\n            .read_records(\"ocd_version\", Some(1))\n            .map_err(|e| e.to_string())?;\n\n        if let Some(record) = records.first() {\n            Ok(Some(OcdVersion {\n                data_version: get_string(record, \"data_version\"),\n                format_version: get_string(record, \"format_version\"),\n                region: get_string(record, \"region\"),\n                date_from: get_string(record, \"date_from\"),\n                date_to: get_string(record, \"date_to\"),\n                rel_coding: get_string(record, \"rel_coding\"),\n                comment: get_string(record, \"comment\"),\n                tables: get_string(record, \"tables\"),\n                varcond_var: get_string(record, \"varcond_var\"),\n                placeholder_on: get_u8(record, \"placeholder_on\") != 0,\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Get property values from a TABLE relation\n    /// Returns values by querying the custom table with current property selections\n    pub fn get_table_values(\n        &self,\n        prop_class: &str,\n        property: &str,\n        current_selections: &HashMap<String, String>,\n    ) -> Vec<OcdPropertyValue> {\n        let mut result = Vec::new();\n\n        // Get the property definition\n        let prop_def = match self\n            .properties\n            .get(&(prop_class.to_string(), property.to_string()))\n        {\n            Some(def) => def,\n            None => return result,\n        };\n\n        // Check if this property has a relation object\n        if prop_def.rel_obj == 0 {\n            return result;\n        }\n\n        // Get the relation object to find the rel_name\n        let rel_obj = match self.relation_objs.get(&prop_def.rel_obj) {\n            Some(obj) => obj,\n            None => return result,\n        };\n\n        // Get the relations by rel_name\n        let relations = match self.relations.get(&rel_obj.rel_name) {\n            Some(rels) => rels,\n            None => return result,\n        };\n\n        // Concatenate all relation blocks\n        let rel_text: String = relations\n            .iter()\n            .map(|r| r.rel_block.clone())\n            .collect::<Vec<_>>()\n            .join(\" \");\n\n        // Find TABLE relation\n        if let Some(table_rel) = Self::parse_table_relation(&rel_text) {\n            let table_name = table_rel.table_name.to_lowercase() + \"_tbl\";\n\n            // Get the custom table data\n            let table_data = match self.custom_tables.get(&table_name) {\n                Some(data) => data,\n                None => return result,\n            };\n\n            // Find the target column (the one with $SELF reference)\n            let target_col = match &table_rel.target_column {\n                Some(col) => col.to_lowercase(),\n                None => {\n                    // If no explicit target, use the property name\n                    property.to_lowercase()\n                }\n            };\n\n            // Build filter conditions from column mappings\n            let mut filters: Vec<(String, String)> = Vec::new();\n            for (col, val) in &table_rel.column_mappings {\n                if !val.contains(\"$SELF\") {\n                    // This is a filter column - value references another property\n                    if let Some(selected_value) = current_selections.get(val) {\n                        filters.push((col.to_lowercase(), selected_value.clone()));\n                    }\n                }\n            }\n\n            // Query the table and collect unique values for the target column\n            let mut seen_values = std::collections::HashSet::new();\n            let mut position: u16 = 1;\n\n            // Common text/label column names to check in the table\n            let text_columns = [\"text\", \"description\", \"desc\", \"label\", \"name\", \"bezeichnung\"];\n\n            for row in table_data {\n                // Check if this row matches all filters (or no filters means match all)\n                let matches = filters.is_empty()\n                    || filters.iter().all(|(col, expected)| {\n                        row.get(col)\n                            .map(|v| v.eq_ignore_ascii_case(expected))\n                            .unwrap_or(false)\n                    });\n\n                if matches {\n                    // Get the value from target column\n                    if let Some(value) = row.get(&target_col) {\n                        if !value.is_empty() && !seen_values.contains(value) {\n                            seen_values.insert(value.clone());\n\n                            // Try to find textnr from multiple sources:\n                            // 1. Check for text column in the table row\n                            // 2. Check if value itself is a valid textnr in value_texts\n                            // 3. Use empty string (value will be used as label)\n                            let textnr = text_columns\n                                .iter()\n                                .filter_map(|col| row.get(*col))\n                                .find(|v| !v.is_empty())\n                                .cloned()\n                                .or_else(|| {\n                                    // Check if the value itself is a valid textnr\n                                    if self.value_texts.contains_key(value) {\n                                        Some(value.clone())\n                                    } else {\n                                        None\n                                    }\n                                })\n                                .unwrap_or_default();\n\n                            // Create a synthetic property value\n                            result.push(OcdPropertyValue {\n                                prop_class: prop_class.to_string(),\n                                property: property.to_string(),\n                                position,\n                                textnr,\n                                is_default: position == 1,\n                                value_from: value.clone(),\n                                value_to: String::new(),\n                                op_from: String::new(),\n                                op_to: String::new(),\n                                raster: String::new(),\n                            });\n\n                            position += 1;\n                        }\n                    }\n                }\n            }\n        }\n\n        result\n    }\n\n    /// Check if a property uses TABLE relations\n    pub fn property_uses_table(&self, prop_class: &str, property: &str) -> bool {\n        if let Some(def) = self\n            .properties\n            .get(&(prop_class.to_string(), property.to_string()))\n        {\n            if def.rel_obj > 0 {\n                if let Some(rel_obj) = self.relation_objs.get(&def.rel_obj) {\n                    if let Some(relations) = self.relations.get(&rel_obj.rel_name) {\n                        return relations\n                            .iter()\n                            .any(|r| r.rel_block.trim().to_uppercase().starts_with(\"TABLE \"));\n                    }\n                }\n            }\n        }\n        false\n    }\n\n    /// Compute var_cond from property selections using TABLE relations\n    /// This handles manufacturers like FAST that use $VARCOND = PropertyName assignments\n    /// with cascading TABLE lookups to derive the var_cond dynamically.\n    ///\n    /// Returns the computed var_cond if successful, None if this manufacturer\n    /// doesn't use TABLE-based var_cond computation.\n    pub fn compute_varcond_from_selections(\n        &self,\n        prop_class: &str,\n        selections: &HashMap<String, String>,\n    ) -> Option<String> {\n        // Step 1: Find $VARCOND assignment in relations\n        // Look for patterns like: \"$VARCOND = PropertyName\" or \"$VARCOND=PropertyName\"\n        let mut varcond_property: Option<String> = None;\n\n        for relations in self.relations.values() {\n            for rel in relations {\n                let block = rel.rel_block.trim().to_uppercase();\n                if block.contains(\"$VARCOND\") && block.contains('=') {\n                    // Parse $VARCOND = PropertyName\n                    // Handle both \"$VARCOND = Artikelnummer\" and \"$VARCOND=Artikelnummer\"\n                    let parts: Vec<&str> = block.split('=').collect();\n                    if parts.len() == 2 {\n                        let left = parts[0].trim();\n                        let right = parts[1].trim();\n                        if left.contains(\"$VARCOND\") || left.contains(\"VARCOND\") {\n                            // right is the property name that provides var_cond\n                            varcond_property = Some(right.to_string());\n                            break;\n                        }\n                    }\n                }\n            }\n            if varcond_property.is_some() {\n                break;\n            }\n        }\n\n        let varcond_prop = varcond_property?;\n\n        // Step 2: Compute the value of that property via TABLE lookups\n        // The property might be computed from other properties via cascading tables\n        self.compute_property_value(prop_class, &varcond_prop, selections)\n    }\n\n    /// Compute a property value via TABLE lookups\n    /// Handles cascading dependencies where one property depends on others\n    fn compute_property_value(\n        &self,\n        prop_class: &str,\n        property: &str,\n        selections: &HashMap<String, String>,\n    ) -> Option<String> {\n        // Check if this property value is directly provided in selections\n        if let Some(value) = selections.get(property) {\n            return Some(value.clone());\n        }\n        // Also check case-insensitive\n        let prop_lower = property.to_lowercase();\n        for (key, value) in selections {\n            if key.to_lowercase() == prop_lower {\n                return Some(value.clone());\n            }\n        }\n\n        // Try to find a matching TABLE relation across all relations\n        // This handles cases where multiple products share a property class but have\n        // different TABLE relations (e.g., FAST WKM vs KR both use \"Rahmen\" class)\n        let result = self.try_compute_from_any_table_relation(prop_class, property, selections);\n        if result.is_some() {\n            return result;\n        }\n\n        // Fallback: Find the property definition and use its specific relation\n        let prop_key = (prop_class.to_string(), property.to_string());\n        let prop_def = self.properties.get(&prop_key).or_else(|| {\n            // Try case-insensitive search\n            self.properties\n                .iter()\n                .find(|((pc, p), _)| pc == prop_class && p.to_uppercase() == property)\n                .map(|(_, def)| def)\n        })?;\n\n        // Get the relation object\n        if prop_def.rel_obj == 0 {\n            return None;\n        }\n        let rel_obj = self.relation_objs.get(&prop_def.rel_obj)?;\n\n        // Get relations\n        let relations = self.relations.get(&rel_obj.rel_name)?;\n\n        // Concatenate relation blocks\n        let rel_text: String = relations\n            .iter()\n            .map(|r| r.rel_block.clone())\n            .collect::<Vec<_>>()\n            .join(\" \");\n\n        // Parse TABLE relation\n        let table_rel = Self::parse_table_relation(&rel_text)?;\n        let table_name = table_rel.table_name.to_lowercase() + \"_tbl\";\n\n        // Get the custom table data\n        let table_data = self.custom_tables.get(&table_name)?;\n\n        // Build filter conditions - first compute any dependent property values\n        let mut computed_selections = selections.clone();\n        for (_col, val) in &table_rel.column_mappings {\n            if !val.contains(\"$SELF\") {\n                // This column references another property - recursively compute its value\n                if !computed_selections.contains_key(val) {\n                    let val_upper = val.to_uppercase();\n                    let found = computed_selections\n                        .iter()\n                        .any(|(k, _)| k.to_uppercase() == val_upper);\n                    if !found {\n                        // Try to compute this dependent property\n                        if let Some(computed) =\n                            self.compute_property_value(prop_class, val, selections)\n                        {\n                            computed_selections.insert(val.clone(), computed);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Build filter conditions from computed selections\n        let mut filters: Vec<(String, String)> = Vec::new();\n        for (col, val) in &table_rel.column_mappings {\n            if !val.contains(\"$SELF\") {\n                // Look for value in selections (case-insensitive)\n                let val_lower = val.to_lowercase();\n                let val_upper = val.to_uppercase();\n                for (sel_key, sel_val) in &computed_selections {\n                    if sel_key.to_lowercase() == val_lower || sel_key.to_uppercase() == val_upper {\n                        filters.push((col.to_lowercase(), sel_val.clone()));\n                        break;\n                    }\n                }\n            }\n        }\n\n        // Find the target column (the one with $SELF reference)\n        let target_col = table_rel\n            .target_column\n            .as_ref()\n            .map(|s| s.to_lowercase())\n            .unwrap_or_else(|| property.to_lowercase());\n\n        // Query the table\n        for row in table_data {\n            // Check if this row matches all filters\n            let matches = filters.is_empty()\n                || filters.iter().all(|(col, expected)| {\n                    row.get(col)\n                        .map(|v| v.eq_ignore_ascii_case(expected))\n                        .unwrap_or(false)\n                });\n\n            if matches {\n                // Get the value from target column\n                if let Some(value) = row.get(&target_col) {\n                    if !value.is_empty() {\n                        return Some(value.clone());\n                    }\n                }\n            }\n        }\n\n        None\n    }\n\n    /// Try to compute a property value from any matching TABLE relation\n    /// This handles cases where multiple products share a property class but have\n    /// different TABLE relations with different input properties\n    fn try_compute_from_any_table_relation(\n        &self,\n        _prop_class: &str,\n        target_property: &str,\n        selections: &HashMap<String, String>,\n    ) -> Option<String> {\n        let target_upper = target_property.to_uppercase();\n\n        // Collect all TABLE relations that output the target property\n        let mut candidate_relations: Vec<(&str, TableRelation)> = Vec::new();\n\n        for (rel_name, relations) in &self.relations {\n            for rel in relations {\n                if let Some(table_rel) = Self::parse_table_relation(&rel.rel_block) {\n                    // Check if this TABLE outputs the target property\n                    let outputs_target = table_rel.column_mappings.iter().any(|(col, val)| {\n                        val.contains(\"$SELF\") && col.to_uppercase() == target_upper\n                    });\n\n                    if outputs_target {\n                        candidate_relations.push((rel_name.as_str(), table_rel));\n                    }\n                }\n            }\n        }\n\n        // Try each candidate relation - use the one that matches available selections\n        for (_rel_name, table_rel) in candidate_relations {\n            // Check if all required input properties are available in selections\n            let mut required_inputs: Vec<String> = Vec::new();\n            for (col, val) in &table_rel.column_mappings {\n                if !val.contains(\"$SELF\") {\n                    // This is an input column\n                    required_inputs.push(val.clone());\n                }\n                // Also check the column name as potential input (for direct mappings like Moos=Moos)\n                if col.to_uppercase() == val.to_uppercase() && !val.contains(\"$SELF\") {\n                    required_inputs.push(col.clone());\n                }\n            }\n\n            // Check if all required inputs are available (case-insensitive)\n            let all_inputs_available = required_inputs.iter().all(|input| {\n                let input_lower = input.to_lowercase();\n                selections\n                    .iter()\n                    .any(|(k, _)| k.to_lowercase() == input_lower)\n            });\n\n            if !all_inputs_available {\n                continue; // Try next candidate\n            }\n\n            // All inputs available - try to execute this table lookup\n            let table_name = table_rel.table_name.to_lowercase() + \"_tbl\";\n            let table_data = match self.custom_tables.get(&table_name) {\n                Some(data) => data,\n                None => continue,\n            };\n\n            // Build filter conditions\n            let mut filters: Vec<(String, String)> = Vec::new();\n            for (col, val) in &table_rel.column_mappings {\n                if !val.contains(\"$SELF\") {\n                    // Look for value in selections (case-insensitive)\n                    let val_lower = val.to_lowercase();\n                    for (sel_key, sel_val) in selections {\n                        if sel_key.to_lowercase() == val_lower {\n                            filters.push((col.to_lowercase(), sel_val.clone()));\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // Find target column - must match the target property we're looking for\n            // When a TABLE has multiple $SELF outputs (like Groesse + Artikelnummer),\n            // we need to select the one matching our target property\n            let target_col = table_rel\n                .column_mappings\n                .iter()\n                .find(|(col, val)| val.contains(\"$SELF\") && col.to_uppercase() == target_upper)\n                .map(|(col, _)| col.to_lowercase())\n                .unwrap_or_else(|| target_property.to_lowercase());\n\n            // Query the table\n            for row in table_data {\n                let matches = filters.is_empty()\n                    || filters.iter().all(|(col, expected)| {\n                        row.get(col)\n                            .map(|v| v.eq_ignore_ascii_case(expected))\n                            .unwrap_or(false)\n                    });\n\n                if matches {\n                    if let Some(value) = row.get(&target_col) {\n                        if !value.is_empty() {\n                            return Some(value.clone());\n                        }\n                    }\n                }\n            }\n        }\n\n        None\n    }\n\n    /// Check if this manufacturer uses TABLE-based var_cond computation\n    /// Returns true if there's a $VARCOND assignment in any relation\n    pub fn uses_table_varcond(&self) -> bool {\n        for relations in self.relations.values() {\n            for rel in relations {\n                let block = rel.rel_block.trim().to_uppercase();\n                if block.contains(\"$VARCOND\") && block.contains('=') {\n                    return true;\n                }\n            }\n        }\n        false\n    }\n\n    /// Get all properties for a property class\n    pub fn get_properties_for_class(&self, prop_class: &str) -> Vec<&OcdPropertyDef> {\n        let mut props: Vec<_> = self\n            .properties\n            .iter()\n            .filter(|((pc, _), _)| pc == prop_class)\n            .map(|(_, def)| def)\n            .collect();\n        props.sort_by_key(|p| p.position);\n        props\n    }\n\n    /// Get properties for a property class filtered by source series\n    /// This is used when different families share a property class but have different properties\n    /// (e.g., FAST KR vs WKM both use \"Rahmen\" but have different configurable properties)\n    pub fn get_properties_for_class_and_series(\n        &self,\n        prop_class: &str,\n        series: &str,\n    ) -> Vec<&OcdPropertyDef> {\n        let series_lower = series.to_lowercase();\n        let mut props: Vec<_> = self\n            .properties\n            .iter()\n            .filter(|((pc, _), def)| {\n                pc == prop_class\n                    && def\n                        .source_series\n                        .as_ref()\n                        .map(|s| s.to_lowercase() == series_lower)\n                        .unwrap_or(false)\n            })\n            .map(|(_, def)| def)\n            .collect();\n        props.sort_by_key(|p| p.position);\n        props\n    }\n\n    /// Get all values for a property\n    pub fn get_values_for_property(\n        &self,\n        prop_class: &str,\n        property: &str,\n    ) -> Vec<&OcdPropertyValue> {\n        self.values\n            .get(&(prop_class.to_string(), property.to_string()))\n            .map(|v| v.iter().collect())\n            .unwrap_or_default()\n    }\n\n    /// Get text for a textnr in a specific language\n    pub fn get_text(&self, textnr: &str, language: &str) -> Option<String> {\n        self.texts.get(textnr).and_then(|texts| {\n            // Try exact language match first (case-insensitive)\n            let lang_lower = language.to_lowercase();\n            let exact_match: Vec<_> = texts\n                .iter()\n                .filter(|t| t.language.to_lowercase() == lang_lower)\n                .map(|t| t.text.clone())\n                .collect();\n\n            if !exact_match.is_empty() {\n                return Some(exact_match.join(\" \"));\n            }\n\n            // Try empty language (universal)\n            let empty_match: Vec<_> = texts\n                .iter()\n                .filter(|t| t.language.is_empty())\n                .map(|t| t.text.clone())\n                .collect();\n\n            if !empty_match.is_empty() {\n                return Some(empty_match.join(\" \"));\n            }\n\n            // Fallback priority: EN > other languages (case-insensitive)\n            let en_match: Vec<_> = texts\n                .iter()\n                .filter(|t| t.language.to_lowercase() == \"en\")\n                .map(|t| t.text.clone())\n                .collect();\n\n            if !en_match.is_empty() {\n                return Some(en_match.join(\" \"));\n            }\n\n            // Last resort: any language\n            texts.first().map(|t| t.text.clone())\n        })\n    }\n\n    /// Get property label\n    pub fn get_property_label(\n        &self,\n        prop_class: &str,\n        property: &str,\n        language: &str,\n    ) -> Option<String> {\n        self.properties\n            .get(&(prop_class.to_string(), property.to_string()))\n            .and_then(|def| self.get_text(&def.textnr, language))\n    }\n\n    /// Get property value label from ocd_propvaluetext\n    pub fn get_value_label(&self, value: &OcdPropertyValue, language: &str) -> Option<String> {\n        self.get_value_text(&value.textnr, language)\n    }\n\n    /// Get text from value_texts (ocd_propvaluetext)\n    pub fn get_value_text(&self, textnr: &str, language: &str) -> Option<String> {\n        self.value_texts.get(textnr).and_then(|texts| {\n            // Try exact language match first (case-insensitive)\n            let lang_lower = language.to_lowercase();\n            let exact_match: Vec<_> = texts\n                .iter()\n                .filter(|t| t.language.to_lowercase() == lang_lower)\n                .map(|t| t.text.clone())\n                .collect();\n\n            if !exact_match.is_empty() {\n                return Some(exact_match.join(\" \"));\n            }\n\n            // Try empty language (universal)\n            let empty_match: Vec<_> = texts\n                .iter()\n                .filter(|t| t.language.is_empty())\n                .map(|t| t.text.clone())\n                .collect();\n\n            if !empty_match.is_empty() {\n                return Some(empty_match.join(\" \"));\n            }\n\n            // Fallback: EN > any language\n            let en_match: Vec<_> = texts\n                .iter()\n                .filter(|t| t.language.to_lowercase() == \"en\")\n                .map(|t| t.text.clone())\n                .collect();\n\n            if !en_match.is_empty() {\n                return Some(en_match.join(\" \"));\n            }\n\n            // Last resort: any language\n            texts.first().map(|t| t.text.clone())\n        })\n    }\n\n    /// Get text from price_texts (ocd_pricetext) for surcharge descriptions\n    pub fn get_price_text(&self, textnr: &str, language: &str) -> Option<String> {\n        self.price_texts.get(textnr).and_then(|texts| {\n            // Try exact language match first (case-insensitive)\n            let lang_lower = language.to_lowercase();\n            let exact_match: Vec<_> = texts\n                .iter()\n                .filter(|t| t.language.to_lowercase() == lang_lower)\n                .map(|t| t.text.clone())\n                .collect();\n\n            if !exact_match.is_empty() {\n                return Some(exact_match.join(\" \"));\n            }\n\n            // Try empty language (universal)\n            let empty_match: Vec<_> = texts\n                .iter()\n                .filter(|t| t.language.is_empty())\n                .map(|t| t.text.clone())\n                .collect();\n\n            if !empty_match.is_empty() {\n                return Some(empty_match.join(\" \"));\n            }\n\n            // Fallback: EN > any language\n            let en_match: Vec<_> = texts\n                .iter()\n                .filter(|t| t.language.to_lowercase() == \"en\")\n                .map(|t| t.text.clone())\n                .collect();\n\n            if !en_match.is_empty() {\n                return Some(en_match.join(\" \"));\n            }\n\n            // Last resort: any language\n            texts.first().map(|t| t.text.clone())\n        })\n    }\n\n    /// Get the default value for a property\n    pub fn get_default_value(&self, prop_class: &str, property: &str) -> Option<&OcdPropertyValue> {\n        self.values\n            .get(&(prop_class.to_string(), property.to_string()))\n            .and_then(|values| {\n                values\n                    .iter()\n                    .find(|v| v.is_default)\n                    .or_else(|| values.first())\n            })\n    }\n\n    /// Get all unique property classes\n    pub fn get_property_classes(&self) -> Vec<&str> {\n        let mut classes: Vec<_> = self.classes.keys().map(|s| s.as_str()).collect();\n        classes.sort();\n        classes.dedup();\n        classes\n    }\n\n    /// Check if this reader has any property data\n    pub fn has_properties(&self) -> bool {\n        !self.properties.is_empty()\n    }\n\n    /// Get statistics about loaded data\n    pub fn stats(&self) -> (usize, usize, usize, usize) {\n        (\n            self.properties.len(),\n            self.values.values().map(|v| v.len()).sum(),\n            self.classes.len(),\n            self.texts.len(),\n        )\n    }\n\n    // ========== Helper methods for new OCD tables ==========\n\n    /// Get display label for a property class from ocd_propclasstext\n    /// This provides human-readable names for property classes like \"Farbe\" -> \"Color\"\n    pub fn get_class_label(&self, textnr: &str, language: &str) -> Option<String> {\n        self.prop_class_texts.get(textnr).and_then(|texts| {\n            let lang_upper = language.to_uppercase();\n            // Try exact language match first\n            if let Some(text) = texts.iter().find(|t| t.language.to_uppercase() == lang_upper) {\n                return Some(text.text.clone());\n            }\n            // Try English fallback\n            if let Some(text) = texts.iter().find(|t| t.language.eq_ignore_ascii_case(\"EN\")) {\n                return Some(text.text.clone());\n            }\n            // Return any available text\n            texts.first().map(|t| t.text.clone())\n        })\n    }\n\n    /// Get hint text for a property from ocd_prophinttext\n    /// Hints provide additional context or tooltips for properties\n    pub fn get_hint_text(&self, textnr: &str, language: &str) -> Option<String> {\n        self.hint_texts.get(textnr).and_then(|texts| {\n            let lang_upper = language.to_uppercase();\n            if let Some(text) = texts.iter().find(|t| t.language.to_uppercase() == lang_upper) {\n                return Some(text.text.clone());\n            }\n            if let Some(text) = texts.iter().find(|t| t.language.eq_ignore_ascii_case(\"EN\")) {\n                return Some(text.text.clone());\n            }\n            texts.first().map(|t| t.text.clone())\n        })\n    }\n\n    /// Get user message by id from ocd_usermessage\n    /// User messages are displayed to the user during configuration\n    pub fn get_user_message(&self, textnr: &str, language: &str) -> Option<String> {\n        self.user_messages.get(textnr).and_then(|texts| {\n            let lang_upper = language.to_uppercase();\n            if let Some(text) = texts.iter().find(|t| t.language.to_uppercase() == lang_upper) {\n                return Some(text.text.clone());\n            }\n            if let Some(text) = texts.iter().find(|t| t.language.eq_ignore_ascii_case(\"EN\")) {\n                return Some(text.text.clone());\n            }\n            texts.first().map(|t| t.text.clone())\n        })\n    }\n\n    /// Get property group label from ocd_propgrouptext\n    pub fn get_prop_group_label(&self, textnr: &str, language: &str) -> Option<String> {\n        self.prop_group_texts.get(textnr).and_then(|texts| {\n            let lang_upper = language.to_uppercase();\n            if let Some(text) = texts.iter().find(|t| t.language.to_uppercase() == lang_upper) {\n                return Some(text.text.clone());\n            }\n            if let Some(text) = texts.iter().find(|t| t.language.eq_ignore_ascii_case(\"EN\")) {\n                return Some(text.text.clone());\n            }\n            texts.first().map(|t| t.text.clone())\n        })\n    }\n\n    /// Get all property groups for a property class\n    /// Returns groups sorted by position\n    pub fn get_property_groups_for_class(&self, prop_class: &str) -> Vec<&OcdPropertyGroup> {\n        let mut groups: Vec<_> = self\n            .property_groups\n            .iter()\n            .filter(|((pc, _), _)| pc == prop_class)\n            .map(|(_, g)| g)\n            .collect();\n        groups.sort_by_key(|g| g.position);\n        groups\n    }\n\n    /// Get property groups assigned to an article from ocd_article2propgroup\n    pub fn get_article_property_groups(&self, article_nr: &str) -> Vec<&OcdArticle2PropGroup> {\n        self.article_prop_groups\n            .get(article_nr)\n            .map(|v| v.iter().collect())\n            .unwrap_or_default()\n    }\n\n    /// Get rounding rules by id from ocd_rounding\n    /// Returns all rounding rules for the given id, sorted by nr\n    pub fn get_rounding_rules(&self, id: &str) -> Vec<&OcdRounding> {\n        self.rounding_rules\n            .get(id)\n            .map(|rules| {\n                let mut sorted: Vec<_> = rules.iter().collect();\n                sorted.sort_by_key(|r| r.nr);\n                sorted\n            })\n            .unwrap_or_default()\n    }\n\n    /// Get tax scheme by tax_id from ocd_taxscheme\n    pub fn get_tax_scheme(&self, tax_id: &str) -> Option<&OcdTaxScheme> {\n        self.tax_schemes.get(tax_id)\n    }\n\n    /// Get tax assignments for an article from ocd_articletaxes\n    pub fn get_article_taxes(&self, article_nr: &str) -> Vec<&OcdArticleTaxes> {\n        self.article_taxes\n            .get(article_nr)\n            .map(|v| v.iter().collect())\n            .unwrap_or_default()\n    }\n\n    /// Get code scheme by code_id from ocd_codescheme\n    pub fn get_code_scheme(&self, code_id: &str) -> Option<&OcdCodeScheme> {\n        self.code_schemes.get(code_id)\n    }\n\n    /// Format a variant code using the default code scheme\n    /// Returns the formatted code or the original if no scheme is available\n    pub fn format_variant_code(&self, variant_code: &str) -> String {\n        // Try to find a default code scheme\n        let scheme = self\n            .code_schemes\n            .get(\"DEFAULT\")\n            .or_else(|| self.code_schemes.get(\"1\"))\n            .or_else(|| self.code_schemes.values().next());\n\n        if let Some(scheme) = scheme {\n            // Apply formatting rules\n            let mut formatted = variant_code.to_string();\n\n            // Trim if specified\n            if scheme.trim {\n                formatted = formatted.trim().to_string();\n            }\n\n            // Replace separators if different from default\n            if !scheme.varcode_sep.is_empty() && scheme.varcode_sep != \"_\" {\n                // The raw variant code uses _ as separator\n                // Replace with the scheme's separator\n                formatted = formatted.replace('_', &scheme.varcode_sep);\n            }\n\n            formatted\n        } else {\n            variant_code.to_string()\n        }\n    }\n\n    /// Get a human-readable variant code display\n    /// Uses code scheme formatting if available\n    pub fn format_variant_code_display(\n        &self,\n        variant_code: &str,\n        max_length: usize,\n    ) -> String {\n        let formatted = self.format_variant_code(variant_code);\n\n        // Truncate if too long\n        if formatted.chars().count() > max_length {\n            let truncated: String = formatted.chars().take(max_length - 3).collect();\n            format!(\"{}...\", truncated)\n        } else {\n            formatted\n        }\n    }\n\n    /// Get article base information from ocd_artbase\n    pub fn get_art_base(&self, article_nr: &str) -> Vec<&OcdArtBase> {\n        self.art_base\n            .get(article_nr)\n            .map(|v| v.iter().collect())\n            .unwrap_or_default()\n    }\n\n    /// Get packaging information for an article from ocd_packaging\n    pub fn get_packaging(&self, article_nr: &str) -> Vec<&OcdPackaging> {\n        self.packaging\n            .get(article_nr)\n            .map(|v| v.iter().collect())\n            .unwrap_or_default()\n    }\n\n    /// Get bill of items (components) for a composite from ocd_billofitems\n    pub fn get_bill_of_items(&self, composite_id: &str) -> Vec<&OcdBillOfItems> {\n        self.bill_of_items\n            .get(composite_id)\n            .map(|v| v.iter().collect())\n            .unwrap_or_default()\n    }\n\n    /// Get composite product information from ocd_composite\n    pub fn get_composite(&self, product_id: &str) -> Option<&OcdComposite> {\n        self.composites.get(product_id)\n    }\n\n    /// Get data version information from ocd_version\n    pub fn get_data_version(&self) -> Option<&OcdVersion> {\n        self.version.as_ref()\n    }\n\n    /// Check if data is valid for a given date\n    /// Returns None if no version info, or Some(true/false) for validity\n    pub fn is_data_valid_for_date(&self, date: chrono::NaiveDate) -> Option<bool> {\n        let version = self.version.as_ref()?;\n\n        // Parse date_from (format: YYYYMMDD)\n        let date_from = chrono::NaiveDate::parse_from_str(&version.date_from, \"%Y%m%d\").ok();\n        let date_to = chrono::NaiveDate::parse_from_str(&version.date_to, \"%Y%m%d\").ok();\n\n        match (date_from, date_to) {\n            (Some(from), Some(to)) => Some(date >= from && date <= to),\n            (Some(from), None) => Some(date >= from),\n            (None, Some(to)) => Some(date <= to),\n            (None, None) => None, // No dates to check\n        }\n    }\n\n    /// Get a warning message if data is expired for a given date\n    pub fn get_data_validity_warning(&self, date: chrono::NaiveDate) -> Option<String> {\n        let version = self.version.as_ref()?;\n\n        if let Some(valid) = self.is_data_valid_for_date(date) {\n            if !valid {\n                // Data is not valid for this date\n                let date_to = chrono::NaiveDate::parse_from_str(&version.date_to, \"%Y%m%d\").ok();\n                if let Some(to) = date_to {\n                    if date > to {\n                        return Some(format!(\n                            \"Preisdaten abgelaufen seit {}\",\n                            to.format(\"%d.%m.%Y\")\n                        ));\n                    }\n                }\n                return Some(\"Preisdaten au√üerhalb G√ºltigkeitszeitraum\".to_string());\n            }\n        }\n        None\n    }\n\n    /// Apply rounding rules to a value\n    /// Returns the rounded value according to the rules\n    pub fn apply_rounding(&self, rounding_id: &str, value: f64) -> f64 {\n        let rules = self.get_rounding_rules(rounding_id);\n        if rules.is_empty() {\n            return value;\n        }\n\n        // Find the applicable rule based on min/max range\n        for rule in rules {\n            if value >= rule.min && value <= rule.max {\n                let adjusted = value + rule.add_before;\n                let rounded = match rule.rounding_type.as_str() {\n                    \"UP\" => (adjusted / 10f64.powi(rule.precision as i32)).ceil()\n                        * 10f64.powi(rule.precision as i32),\n                    \"DOWN\" => (adjusted / 10f64.powi(rule.precision as i32)).floor()\n                        * 10f64.powi(rule.precision as i32),\n                    _ => (adjusted / 10f64.powi(rule.precision as i32)).round()\n                        * 10f64.powi(rule.precision as i32),\n                };\n                return rounded + rule.add_after;\n            }\n        }\n\n        value\n    }\n\n    /// Calculate tax for an article based on its tax assignments\n    pub fn calculate_article_tax(&self, article_nr: &str, base_price: f64) -> f64 {\n        let taxes = self.get_article_taxes(article_nr);\n        let mut total_tax = 0.0;\n\n        for tax_assignment in taxes {\n            if let Some(scheme) = self.get_tax_scheme(&tax_assignment.tax_id) {\n                // Apply tax based on type\n                match scheme.tax_type.as_str() {\n                    \"PERCENT\" => total_tax += base_price * (scheme.number / 100.0),\n                    \"ABSOLUTE\" => total_tax += scheme.number,\n                    _ => {}\n                }\n            }\n        }\n\n        total_tax\n    }\n}\n\n// Helper functions\nfn get_string(record: &HashMap<String, Value>, key: &str) -> String {\n    record\n        .get(key)\n        .and_then(|v| v.as_str())\n        .unwrap_or(\"\")\n        .to_string()\n}\n\nfn get_u8(record: &HashMap<String, Value>, key: &str) -> u8 {\n    record.get(key).and_then(|v| v.as_i64()).unwrap_or(0) as u8\n}\n\nfn get_u16(record: &HashMap<String, Value>, key: &str) -> u16 {\n    record.get(key).and_then(|v| v.as_i64()).unwrap_or(0) as u16\n}\n\nfn get_u32(record: &HashMap<String, Value>, key: &str) -> u32 {\n    record.get(key).and_then(|v| v.as_i64()).unwrap_or(0) as u32\n}\n\nfn get_f64(record: &HashMap<String, Value>, key: &str) -> f64 {\n    record\n        .get(key)\n        .and_then(|v| match v {\n            Value::Float(f) => Some(*f),\n            Value::Int(i) => Some(*i as f64),\n            Value::UInt(u) => Some(*u as f64),\n            Value::String(s) => s.parse::<f64>().ok(),\n            _ => None,\n        })\n        .unwrap_or(0.0)\n}\n\nuse std::sync::{Arc, Mutex, OnceLock};\nuse std::time::{Duration, Instant};\n\n/// Cache entry with TTL support\nstruct CacheEntry<T> {\n    data: T,\n    created_at: Instant,\n}\n\nimpl<T> CacheEntry<T> {\n    fn new(data: T) -> Self {\n        Self {\n            data,\n            created_at: Instant::now(),\n        }\n    }\n\n    fn is_expired(&self, ttl: Duration) -> bool {\n        self.created_at.elapsed() > ttl\n    }\n}\n\n/// Default TTL for property cache (5 minutes)\nconst PROPERTY_CACHE_TTL: Duration = Duration::from_secs(300);\n\n/// Cache for aggregated property readers per manufacturer\nstatic PROPERTY_CACHE: OnceLock<Mutex<HashMap<String, CacheEntry<Arc<OcdPropertyReader>>>>> =\n    OnceLock::new();\n\nfn get_property_cache() -> &'static Mutex<HashMap<String, CacheEntry<Arc<OcdPropertyReader>>>> {\n    PROPERTY_CACHE.get_or_init(|| Mutex::new(HashMap::new()))\n}\n\n/// Clear the property cache (useful for testing)\npub fn clear_property_cache() {\n    if let Some(cache) = PROPERTY_CACHE.get() {\n        if let Ok(mut guard) = cache.lock() {\n            guard.clear();\n        }\n    }\n}\n\n/// Evict expired entries from the property cache\npub fn evict_expired_cache_entries() {\n    if let Some(cache) = PROPERTY_CACHE.get() {\n        if let Ok(mut guard) = cache.lock() {\n            guard.retain(|_, entry| !entry.is_expired(PROPERTY_CACHE_TTL));\n        }\n    }\n}\n\n/// Get cache statistics (for debugging/monitoring)\npub fn get_cache_stats() -> (usize, usize) {\n    let mut total = 0;\n    let mut expired = 0;\n    if let Some(cache) = PROPERTY_CACHE.get() {\n        if let Ok(guard) = cache.lock() {\n            total = guard.len();\n            expired = guard.values().filter(|e| e.is_expired(PROPERTY_CACHE_TTL)).count();\n        }\n    }\n    (total, expired)\n}\n\n/// Find all pdata.ebase files and aggregate property data (with caching)\npub fn load_manufacturer_properties(manufacturer_path: &Path) -> OcdPropertyReader {\n    let cache_key = manufacturer_path.to_string_lossy().to_string();\n\n    // Check cache first (handle poisoned mutex gracefully)\n    {\n        let cache = get_property_cache()\n            .lock()\n            .unwrap_or_else(|poisoned| poisoned.into_inner());\n        if let Some(entry) = cache.get(&cache_key) {\n            // Return cached data if not expired\n            if !entry.is_expired(PROPERTY_CACHE_TTL) {\n                let reader = &entry.data;\n                return OcdPropertyReader {\n                    properties: reader.properties.clone(),\n                    values: reader.values.clone(),\n                    classes: reader.classes.clone(),\n                    texts: reader.texts.clone(),\n                    value_texts: reader.value_texts.clone(),\n                    price_texts: reader.price_texts.clone(),\n                    prop_class_texts: reader.prop_class_texts.clone(),\n                    hint_texts: reader.hint_texts.clone(),\n                    user_messages: reader.user_messages.clone(),\n                    prop_group_texts: reader.prop_group_texts.clone(),\n                    relation_objs: reader.relation_objs.clone(),\n                    relations: reader.relations.clone(),\n                    custom_tables: reader.custom_tables.clone(),\n                    property_groups: reader.property_groups.clone(),\n                    article_prop_groups: reader.article_prop_groups.clone(),\n                    rounding_rules: reader.rounding_rules.clone(),\n                    tax_schemes: reader.tax_schemes.clone(),\n                    article_taxes: reader.article_taxes.clone(),\n                    code_schemes: reader.code_schemes.clone(),\n                    art_base: reader.art_base.clone(),\n                    packaging: reader.packaging.clone(),\n                    bill_of_items: reader.bill_of_items.clone(),\n                    composites: reader.composites.clone(),\n                    version: reader.version.clone(),\n                };\n            }\n            // Entry is expired, will be replaced below\n        }\n    }\n\n    // Not in cache, load it\n    let combined = load_manufacturer_properties_uncached(manufacturer_path);\n\n    // Store in cache (handle poisoned mutex gracefully)\n    {\n        let mut cache = get_property_cache()\n            .lock()\n            .unwrap_or_else(|poisoned| poisoned.into_inner());\n        cache.insert(\n            cache_key,\n            CacheEntry::new(Arc::new(OcdPropertyReader {\n                properties: combined.properties.clone(),\n                values: combined.values.clone(),\n                classes: combined.classes.clone(),\n                texts: combined.texts.clone(),\n                value_texts: combined.value_texts.clone(),\n                price_texts: combined.price_texts.clone(),\n                prop_class_texts: combined.prop_class_texts.clone(),\n                hint_texts: combined.hint_texts.clone(),\n                user_messages: combined.user_messages.clone(),\n                prop_group_texts: combined.prop_group_texts.clone(),\n                relation_objs: combined.relation_objs.clone(),\n                relations: combined.relations.clone(),\n                custom_tables: combined.custom_tables.clone(),\n                property_groups: combined.property_groups.clone(),\n                article_prop_groups: combined.article_prop_groups.clone(),\n                rounding_rules: combined.rounding_rules.clone(),\n                tax_schemes: combined.tax_schemes.clone(),\n                article_taxes: combined.article_taxes.clone(),\n                code_schemes: combined.code_schemes.clone(),\n                art_base: combined.art_base.clone(),\n                packaging: combined.packaging.clone(),\n                bill_of_items: combined.bill_of_items.clone(),\n                composites: combined.composites.clone(),\n                version: combined.version.clone(),\n            })),\n        );\n    }\n\n    combined\n}\n\n/// Extract series name from pdata.ebase path\n/// e.g., \"/reference/ofmldata/fast/kr/DE/1/db/pdata.ebase\" -> Some(\"kr\")\nfn extract_series_from_path(pdata_path: &Path) -> Option<String> {\n    // Path structure: manufacturer/series/LANG/version/db/pdata.ebase\n    // We need to go up 4 levels from pdata.ebase to get the series\n    pdata_path\n        .parent() // db\n        .and_then(|p| p.parent()) // version\n        .and_then(|p| p.parent()) // LANG\n        .and_then(|p| p.parent()) // series\n        .and_then(|p| p.file_name())\n        .and_then(|n| n.to_str())\n        .map(|s| s.to_lowercase())\n}\n\n/// Find all pdata.ebase files and aggregate property data (uncached)\nfn load_manufacturer_properties_uncached(manufacturer_path: &Path) -> OcdPropertyReader {\n    let mut combined = OcdPropertyReader {\n        properties: HashMap::new(),\n        values: HashMap::new(),\n        classes: HashMap::new(),\n        texts: HashMap::new(),\n        value_texts: HashMap::new(),\n        price_texts: HashMap::new(),\n        prop_class_texts: HashMap::new(),\n        hint_texts: HashMap::new(),\n        user_messages: HashMap::new(),\n        prop_group_texts: HashMap::new(),\n        relation_objs: HashMap::new(),\n        relations: HashMap::new(),\n        custom_tables: HashMap::new(),\n        property_groups: HashMap::new(),\n        article_prop_groups: HashMap::new(),\n        rounding_rules: HashMap::new(),\n        tax_schemes: HashMap::new(),\n        article_taxes: HashMap::new(),\n        code_schemes: HashMap::new(),\n        art_base: HashMap::new(),\n        packaging: HashMap::new(),\n        bill_of_items: HashMap::new(),\n        composites: HashMap::new(),\n        version: None,\n    };\n\n    // Find all pdata.ebase files\n    let pdata_paths = super::ocd::find_pdata_files(manufacturer_path);\n\n    // Load all EBase files in parallel\n    let loaded_readers: Vec<(Option<String>, OcdPropertyReader)> = pdata_paths\n        .par_iter()\n        .filter_map(|pdata_path| {\n            let series = extract_series_from_path(pdata_path);\n            OcdPropertyReader::from_ebase(pdata_path)\n                .ok()\n                .map(|reader| (series, reader))\n        })\n        .collect();\n\n    // Merge sequentially (needed for textnr validity checks)\n    for (series, reader) in loaded_readers {\n        // FIRST: Merge texts so we can check textnr validity when merging properties\n        for (key, texts) in reader.texts {\n            combined.texts.entry(key).or_default().extend(texts);\n        }\n        for (key, texts) in reader.value_texts {\n            combined.value_texts.entry(key).or_default().extend(texts);\n        }\n        for (key, texts) in reader.price_texts {\n            combined.price_texts.entry(key).or_default().extend(texts);\n        }\n\n        // THEN: Merge properties - prefer properties with valid textnr\n        for (key, mut prop) in reader.properties {\n            // Set the source series for this property\n            prop.source_series = series.clone();\n\n            combined\n                .properties\n                .entry(key)\n                .and_modify(|existing| {\n                    // Prefer properties with valid textnr (that exists in our texts)\n                    let new_has_valid_textnr =\n                        !prop.textnr.is_empty() && combined.texts.contains_key(&prop.textnr);\n                    let existing_has_valid_textnr = !existing.textnr.is_empty()\n                        && combined.texts.contains_key(&existing.textnr);\n\n                    // Replace if:\n                    // 1. New has valid textnr and existing doesn't, OR\n                    // 2. New has TABLE relation and existing doesn't\n                    if (new_has_valid_textnr && !existing_has_valid_textnr)\n                        || (prop.rel_obj > 0 && existing.rel_obj == 0)\n                    {\n                        *existing = prop.clone();\n                    }\n                })\n                .or_insert(prop);\n        }\n        for (key, values) in reader.values {\n            combined.values.entry(key).or_default().extend(values);\n        }\n        combined.classes.extend(reader.classes);\n\n        // Merge relation data\n        combined.relation_objs.extend(reader.relation_objs);\n        for (key, relations) in reader.relations {\n            combined.relations.entry(key).or_default().extend(relations);\n        }\n        for (key, table_data) in reader.custom_tables {\n            combined\n                .custom_tables\n                .entry(key)\n                .or_default()\n                .extend(table_data);\n        }\n\n        // Merge new text tables\n        for (key, texts) in reader.prop_class_texts {\n            combined.prop_class_texts.entry(key).or_default().extend(texts);\n        }\n        for (key, texts) in reader.hint_texts {\n            combined.hint_texts.entry(key).or_default().extend(texts);\n        }\n        for (key, texts) in reader.user_messages {\n            combined.user_messages.entry(key).or_default().extend(texts);\n        }\n        for (key, texts) in reader.prop_group_texts {\n            combined.prop_group_texts.entry(key).or_default().extend(texts);\n        }\n\n        // Merge property groups and article mappings\n        combined.property_groups.extend(reader.property_groups);\n        for (key, mappings) in reader.article_prop_groups {\n            combined.article_prop_groups.entry(key).or_default().extend(mappings);\n        }\n\n        // Merge pricing support tables\n        for (key, rules) in reader.rounding_rules {\n            combined.rounding_rules.entry(key).or_default().extend(rules);\n        }\n        combined.tax_schemes.extend(reader.tax_schemes);\n        for (key, taxes) in reader.article_taxes {\n            combined.article_taxes.entry(key).or_default().extend(taxes);\n        }\n\n        // Merge other tables\n        combined.code_schemes.extend(reader.code_schemes);\n        for (key, bases) in reader.art_base {\n            combined.art_base.entry(key).or_default().extend(bases);\n        }\n        for (key, pkgs) in reader.packaging {\n            combined.packaging.entry(key).or_default().extend(pkgs);\n        }\n        for (key, items) in reader.bill_of_items {\n            combined.bill_of_items.entry(key).or_default().extend(items);\n        }\n        combined.composites.extend(reader.composites);\n\n        // Take version info if not already set\n        if combined.version.is_none() {\n            combined.version = reader.version;\n        }\n    }\n\n    // Deduplicate and sort\n    for values in combined.values.values_mut() {\n        values.sort_by_key(|v| v.position);\n        values.dedup_by(|a, b| a.value_from == b.value_from);\n    }\n\n    for texts in combined.texts.values_mut() {\n        texts.sort_by_key(|t| t.line_nr);\n        texts.dedup_by(|a, b| a.language == b.language && a.line_nr == b.line_nr);\n    }\n\n    for texts in combined.value_texts.values_mut() {\n        texts.sort_by_key(|t| t.line_nr);\n        texts.dedup_by(|a, b| a.language == b.language && a.line_nr == b.line_nr);\n    }\n\n    for texts in combined.price_texts.values_mut() {\n        texts.sort_by_key(|t| t.line_nr);\n        texts.dedup_by(|a, b| a.language == b.language && a.line_nr == b.line_nr);\n    }\n\n    for texts in combined.prop_class_texts.values_mut() {\n        texts.sort_by_key(|t| t.line_nr);\n        texts.dedup_by(|a, b| a.language == b.language && a.line_nr == b.line_nr);\n    }\n\n    for texts in combined.hint_texts.values_mut() {\n        texts.sort_by_key(|t| t.line_nr);\n        texts.dedup_by(|a, b| a.language == b.language && a.line_nr == b.line_nr);\n    }\n\n    for texts in combined.user_messages.values_mut() {\n        texts.sort_by_key(|t| t.line_nr);\n        texts.dedup_by(|a, b| a.language == b.language && a.line_nr == b.line_nr);\n    }\n\n    for texts in combined.prop_group_texts.values_mut() {\n        texts.sort_by_key(|t| t.line_nr);\n        texts.dedup_by(|a, b| a.language == b.language && a.line_nr == b.line_nr);\n    }\n\n    // Deduplicate article prop groups\n    for mappings in combined.article_prop_groups.values_mut() {\n        mappings.sort_by_key(|m| m.position);\n        mappings.dedup_by(|a, b| a.prop_group == b.prop_group);\n    }\n\n    // Deduplicate rounding rules\n    for rules in combined.rounding_rules.values_mut() {\n        rules.sort_by_key(|r| r.nr);\n        rules.dedup_by(|a, b| a.nr == b.nr);\n    }\n\n    // Deduplicate relations\n    for relations in combined.relations.values_mut() {\n        relations.sort_by_key(|r| r.rel_blocknr);\n        relations.dedup_by(|a, b| a.rel_blocknr == b.rel_blocknr);\n    }\n\n    combined\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_load_vitra_classic_properties() {\n        let path = Path::new(\"/workspace/ofmldata/vitra/classic/DE/1/db/pdata.ebase\");\n        if !path.exists() {\n            return;\n        }\n\n        let reader = OcdPropertyReader::from_ebase(path).expect(\"Should load\");\n        let (props, vals, classes, texts) = reader.stats();\n\n        println!(\"Properties: {}\", props);\n        println!(\"Values: {}\", vals);\n        println!(\"Classes: {}\", classes);\n        println!(\"Texts: {}\", texts);\n\n        assert!(props > 0, \"Should have properties\");\n        assert!(vals > 0, \"Should have values\");\n\n        // Print some property classes\n        println!(\"\\nProperty classes:\");\n        for class in reader.get_property_classes().iter().take(10) {\n            println!(\"  {}\", class);\n        }\n\n        // Print some properties with their values\n        println!(\"\\nSample properties:\");\n        for ((pc, prop), def) in reader.properties.iter().take(5) {\n            let label = reader\n                .get_property_label(pc, prop, \"DE\")\n                .unwrap_or_default();\n            println!(\"  {}.{} = {} (type: {})\", pc, prop, label, def.prop_type);\n\n            let values = reader.get_values_for_property(pc, prop);\n            for val in values.iter().take(3) {\n                let val_label = reader.get_value_label(val, \"DE\").unwrap_or_default();\n                println!(\"    - {} = {}\", val.value_from, val_label);\n            }\n        }\n    }\n\n    #[test]\n    fn test_load_manufacturer_properties() {\n        let path = Path::new(\"/workspace/ofmldata/vitra\");\n        if !path.exists() {\n            return;\n        }\n\n        let reader = load_manufacturer_properties(path);\n        let (props, vals, classes, texts) = reader.stats();\n\n        println!(\"Total properties: {}\", props);\n        println!(\"Total values: {}\", vals);\n        println!(\"Total classes: {}\", classes);\n        println!(\"Total texts: {}\", texts);\n\n        assert!(props > 100, \"Should have many properties across series\");\n    }\n\n    #[test]\n    fn test_ocd_property_def_debug_clone() {\n        let def = OcdPropertyDef {\n            prop_class: \"PC1\".to_string(),\n            property: \"Color\".to_string(),\n            position: 1,\n            textnr: \"T100\".to_string(),\n            prop_type: \"CHOICE\".to_string(),\n            digits: 5,\n            dec_digits: 0,\n            need_input: true,\n            add_values: false,\n            restrictable: true,\n            multi_option: false,\n            rel_obj: 0,\n            scope: \"C\".to_string(),\n            source_series: Some(\"classic\".to_string()),\n        };\n\n        let debug_str = format!(\"{:?}\", def);\n        assert!(debug_str.contains(\"Color\"));\n\n        let cloned = def.clone();\n        assert_eq!(cloned.property, \"Color\");\n        assert_eq!(cloned.prop_class, \"PC1\");\n    }\n\n    #[test]\n    fn test_ocd_property_value_debug_clone() {\n        let val = OcdPropertyValue {\n            prop_class: \"PC1\".to_string(),\n            property: \"Color\".to_string(),\n            position: 1,\n            textnr: \"T200\".to_string(),\n            is_default: true,\n            value_from: \"RED\".to_string(),\n            value_to: \"\".to_string(),\n            op_from: \"=\".to_string(),\n            op_to: \"\".to_string(),\n            raster: \"\".to_string(),\n        };\n\n        let debug_str = format!(\"{:?}\", val);\n        assert!(debug_str.contains(\"RED\"));\n\n        let cloned = val.clone();\n        assert_eq!(cloned.value_from, \"RED\");\n        assert!(cloned.is_default);\n    }\n\n    #[test]\n    fn test_ocd_property_class_debug_clone() {\n        let class = OcdPropertyClass {\n            prop_class: \"Dimensions\".to_string(),\n            textnr: \"T300\".to_string(),\n            position: 1,\n        };\n\n        let debug_str = format!(\"{:?}\", class);\n        assert!(debug_str.contains(\"Dimensions\"));\n\n        let cloned = class.clone();\n        assert_eq!(cloned.prop_class, \"Dimensions\");\n    }\n\n    #[test]\n    fn test_ocd_property_text_debug_clone() {\n        let text = OcdPropertyText {\n            textnr: \"T100\".to_string(),\n            language: \"DE\".to_string(),\n            line_nr: 1,\n            text: \"Farbe\".to_string(),\n        };\n\n        let debug_str = format!(\"{:?}\", text);\n        assert!(debug_str.contains(\"Farbe\"));\n\n        let cloned = text.clone();\n        assert_eq!(cloned.text, \"Farbe\");\n        assert_eq!(cloned.language, \"DE\");\n    }\n\n    #[test]\n    fn test_ocd_relation_obj_debug_clone() {\n        let rel_obj = OcdRelationObj {\n            rel_obj: 123,\n            rel_name: \"color_relation\".to_string(),\n            rel_type: \"TABLE\".to_string(),\n            position: 1,\n        };\n\n        let debug_str = format!(\"{:?}\", rel_obj);\n        assert!(debug_str.contains(\"color_relation\"));\n\n        let cloned = rel_obj.clone();\n        assert_eq!(cloned.rel_obj, 123);\n    }\n\n    #[test]\n    fn test_ocd_relation_debug_clone() {\n        let rel = OcdRelation {\n            rel_name: \"color_relation\".to_string(),\n            rel_blocknr: 1,\n            rel_block: \"TABLE color_tbl\".to_string(),\n        };\n\n        let debug_str = format!(\"{:?}\", rel);\n        assert!(debug_str.contains(\"TABLE\"));\n\n        let cloned = rel.clone();\n        assert_eq!(cloned.rel_name, \"color_relation\");\n    }\n\n    #[test]\n    fn test_table_relation_debug_clone() {\n        let table_rel = TableRelation {\n            table_name: \"color_tbl\".to_string(),\n            column_mappings: vec![\n                (\"Color\".to_string(), \"Color\".to_string()),\n                (\"Code\".to_string(), \"$SELF.Code\".to_string()),\n            ],\n            target_column: Some(\"Value\".to_string()),\n        };\n\n        let debug_str = format!(\"{:?}\", table_rel);\n        assert!(debug_str.contains(\"color_tbl\"));\n\n        let cloned = table_rel.clone();\n        assert_eq!(cloned.column_mappings.len(), 2);\n    }\n\n    #[test]\n    fn test_ocd_property_group_debug_clone() {\n        let group = OcdPropertyGroup {\n            prop_class: \"PC1\".to_string(),\n            property: \"Size\".to_string(),\n            prop_group: \"Dimensions\".to_string(),\n            position: 1,\n        };\n\n        let debug_str = format!(\"{:?}\", group);\n        assert!(debug_str.contains(\"Dimensions\"));\n\n        let cloned = group.clone();\n        assert_eq!(cloned.prop_group, \"Dimensions\");\n    }\n\n    #[test]\n    fn test_ocd_article2prop_group_debug_clone() {\n        let mapping = OcdArticle2PropGroup {\n            article_nr: \"ART001\".to_string(),\n            prop_group: \"Standard\".to_string(),\n            position: 1,\n            textnr: \"T400\".to_string(),\n        };\n\n        let debug_str = format!(\"{:?}\", mapping);\n        assert!(debug_str.contains(\"ART001\"));\n\n        let cloned = mapping.clone();\n        assert_eq!(cloned.article_nr, \"ART001\");\n    }\n\n    #[test]\n    fn test_ocd_rounding_debug_clone() {\n        let rounding = OcdRounding {\n            id: \"R1\".to_string(),\n            nr: 1,\n            rounding_type: \"ROUND\".to_string(),\n            precision: 2,\n            min: 0.0,\n            max: 1000.0,\n            add_before: 0.0,\n            add_after: 0.0,\n        };\n\n        let debug_str = format!(\"{:?}\", rounding);\n        assert!(debug_str.contains(\"ROUND\"));\n\n        let cloned = rounding.clone();\n        assert_eq!(cloned.precision, 2);\n    }\n\n    #[test]\n    fn test_ocd_tax_scheme_debug_clone() {\n        let tax = OcdTaxScheme {\n            tax_id: \"VAT19\".to_string(),\n            country: \"DE\".to_string(),\n            region: \"\".to_string(),\n            tax_category: \"standard\".to_string(),\n            tax_type: \"VAT\".to_string(),\n            number: 19.0,\n        };\n\n        let debug_str = format!(\"{:?}\", tax);\n        assert!(debug_str.contains(\"VAT19\"));\n\n        let cloned = tax.clone();\n        assert_eq!(cloned.number, 19.0);\n    }\n\n    #[test]\n    fn test_ocd_article_taxes_debug_clone() {\n        let tax = OcdArticleTaxes {\n            article_nr: \"ART001\".to_string(),\n            tax_id: \"VAT19\".to_string(),\n            date_from: \"20240101\".to_string(),\n            date_to: \"20241231\".to_string(),\n        };\n\n        let debug_str = format!(\"{:?}\", tax);\n        assert!(debug_str.contains(\"ART001\"));\n\n        let cloned = tax.clone();\n        assert_eq!(cloned.tax_id, \"VAT19\");\n    }\n\n    #[test]\n    fn test_ocd_code_scheme_debug_clone() {\n        let scheme = OcdCodeScheme {\n            scheme_id: \"S1\".to_string(),\n            scheme: \"{PC}.{PROP}\".to_string(),\n            varcode_sep: \"-\".to_string(),\n            value_sep: \"=\".to_string(),\n            mo_sep: \",\".to_string(),\n            mo_bracket: \"()\".to_string(),\n            invisible_char: \"_\".to_string(),\n            unselect_char: \"*\".to_string(),\n            visibility: \"Y\".to_string(),\n            trim: true,\n        };\n\n        let debug_str = format!(\"{:?}\", scheme);\n        assert!(debug_str.contains(\"S1\"));\n\n        let cloned = scheme.clone();\n        assert!(cloned.trim);\n    }\n\n    #[test]\n    fn test_ocd_art_base_debug_clone() {\n        let art = OcdArtBase {\n            article_nr: \"ART001\".to_string(),\n            prop_class: \"PC1\".to_string(),\n            property: \"Color\".to_string(),\n            prop_value: \"RED\".to_string(),\n        };\n\n        let debug_str = format!(\"{:?}\", art);\n        assert!(debug_str.contains(\"ART001\"));\n\n        let cloned = art.clone();\n        assert_eq!(cloned.prop_value, \"RED\");\n    }\n\n    #[test]\n    fn test_ocd_packaging_debug_clone() {\n        let pack = OcdPackaging {\n            article_nr: \"ART001\".to_string(),\n            var_cond: \"*\".to_string(),\n            width: 100.0,\n            depth: 50.0,\n            height: 30.0,\n            net_weight: 10.0,\n            tara_weight: 2.0,\n            volume: 0.15,\n            items_per_unit: 1,\n            pack_units: 1,\n            measure_unit: \"mm\".to_string(),\n            weight_unit: \"kg\".to_string(),\n            volume_unit: \"m3\".to_string(),\n        };\n\n        let debug_str = format!(\"{:?}\", pack);\n        assert!(debug_str.contains(\"ART001\"));\n\n        let cloned = pack.clone();\n        assert_eq!(cloned.width, 100.0);\n    }\n\n    #[test]\n    fn test_ocd_bill_of_items_debug_clone() {\n        let boi = OcdBillOfItems {\n            composite_id: \"COMP1\".to_string(),\n            item_id: \"ITEM1\".to_string(),\n            item_pos: 1,\n            quantity: 2.0,\n            quant_unit: \"PC\".to_string(),\n            configurable: true,\n            rel_obj: 0,\n            txt_id: \"\".to_string(),\n        };\n\n        let debug_str = format!(\"{:?}\", boi);\n        assert!(debug_str.contains(\"COMP1\"));\n\n        let cloned = boi.clone();\n        assert!(cloned.configurable);\n    }\n\n    #[test]\n    fn test_ocd_property_reader_new_empty() {\n        let reader = OcdPropertyReader {\n            properties: HashMap::new(),\n            values: HashMap::new(),\n            classes: HashMap::new(),\n            texts: HashMap::new(),\n            value_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            prop_class_texts: HashMap::new(),\n            hint_texts: HashMap::new(),\n            user_messages: HashMap::new(),\n            prop_group_texts: HashMap::new(),\n            relation_objs: HashMap::new(),\n            relations: HashMap::new(),\n            custom_tables: HashMap::new(),\n            property_groups: HashMap::new(),\n            article_prop_groups: HashMap::new(),\n            rounding_rules: HashMap::new(),\n            tax_schemes: HashMap::new(),\n            article_taxes: HashMap::new(),\n            code_schemes: HashMap::new(),\n            art_base: HashMap::new(),\n            packaging: HashMap::new(),\n            bill_of_items: HashMap::new(),\n            composites: HashMap::new(),\n            version: None,\n        };\n\n        let (props, vals, classes, texts) = reader.stats();\n        assert_eq!(props, 0);\n        assert_eq!(vals, 0);\n        assert_eq!(classes, 0);\n        assert_eq!(texts, 0);\n\n        let classes_list = reader.get_property_classes();\n        assert!(classes_list.is_empty());\n    }\n\n    #[test]\n    fn test_ocd_property_reader_get_methods() {\n        let mut reader = OcdPropertyReader {\n            properties: HashMap::new(),\n            values: HashMap::new(),\n            classes: HashMap::new(),\n            texts: HashMap::new(),\n            value_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            prop_class_texts: HashMap::new(),\n            hint_texts: HashMap::new(),\n            user_messages: HashMap::new(),\n            prop_group_texts: HashMap::new(),\n            relation_objs: HashMap::new(),\n            relations: HashMap::new(),\n            custom_tables: HashMap::new(),\n            property_groups: HashMap::new(),\n            article_prop_groups: HashMap::new(),\n            rounding_rules: HashMap::new(),\n            tax_schemes: HashMap::new(),\n            article_taxes: HashMap::new(),\n            code_schemes: HashMap::new(),\n            art_base: HashMap::new(),\n            packaging: HashMap::new(),\n            bill_of_items: HashMap::new(),\n            composites: HashMap::new(),\n            version: None,\n        };\n\n        // Add some test data\n        reader.properties.insert(\n            (\"PC1\".to_string(), \"Color\".to_string()),\n            OcdPropertyDef {\n                prop_class: \"PC1\".to_string(),\n                property: \"Color\".to_string(),\n                position: 1,\n                textnr: \"T100\".to_string(),\n                prop_type: \"CHOICE\".to_string(),\n                digits: 5,\n                dec_digits: 0,\n                need_input: true,\n                add_values: false,\n                restrictable: true,\n                multi_option: false,\n                rel_obj: 0,\n                scope: \"C\".to_string(),\n                source_series: None,\n            },\n        );\n\n        reader.values.insert(\n            (\"PC1\".to_string(), \"Color\".to_string()),\n            vec![OcdPropertyValue {\n                prop_class: \"PC1\".to_string(),\n                property: \"Color\".to_string(),\n                position: 1,\n                textnr: \"T200\".to_string(),\n                is_default: true,\n                value_from: \"RED\".to_string(),\n                value_to: \"\".to_string(),\n                op_from: \"=\".to_string(),\n                op_to: \"\".to_string(),\n                raster: \"\".to_string(),\n            }],\n        );\n\n        reader.texts.insert(\n            \"T100\".to_string(),\n            vec![OcdPropertyText {\n                textnr: \"T100\".to_string(),\n                language: \"DE\".to_string(),\n                line_nr: 1,\n                text: \"Farbe\".to_string(),\n            }],\n        );\n\n        // Test get methods\n        let values = reader.get_values_for_property(\"PC1\", \"Color\");\n        assert_eq!(values.len(), 1);\n        assert_eq!(values[0].value_from, \"RED\");\n\n        let label = reader.get_property_label(\"PC1\", \"Color\", \"DE\");\n        assert_eq!(label, Some(\"Farbe\".to_string()));\n\n        // When EN is not found, fallback to other language (DE in this case)\n        let fallback_label = reader.get_property_label(\"PC1\", \"Color\", \"EN\");\n        // Fallback exists since we added \"DE\" text\n        assert!(fallback_label.is_some());\n\n        // Test with non-existent property\n        let no_label = reader.get_property_label(\"PC99\", \"NoProperty\", \"DE\");\n        assert!(no_label.is_none());\n\n        let (props, _, _, _) = reader.stats();\n        assert_eq!(props, 1);\n    }\n\n    #[test]\n    fn test_ocd_property_reader_get_value_text() {\n        let mut reader = OcdPropertyReader {\n            properties: HashMap::new(),\n            values: HashMap::new(),\n            classes: HashMap::new(),\n            texts: HashMap::new(),\n            value_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            prop_class_texts: HashMap::new(),\n            hint_texts: HashMap::new(),\n            user_messages: HashMap::new(),\n            prop_group_texts: HashMap::new(),\n            relation_objs: HashMap::new(),\n            relations: HashMap::new(),\n            custom_tables: HashMap::new(),\n            property_groups: HashMap::new(),\n            article_prop_groups: HashMap::new(),\n            rounding_rules: HashMap::new(),\n            tax_schemes: HashMap::new(),\n            article_taxes: HashMap::new(),\n            code_schemes: HashMap::new(),\n            art_base: HashMap::new(),\n            packaging: HashMap::new(),\n            bill_of_items: HashMap::new(),\n            composites: HashMap::new(),\n            version: None,\n        };\n\n        // Add test value texts with different languages\n        reader.value_texts.insert(\n            \"VT100\".to_string(),\n            vec![\n                OcdPropertyText {\n                    textnr: \"VT100\".to_string(),\n                    language: \"DE\".to_string(),\n                    line_nr: 1,\n                    text: \"Rot\".to_string(),\n                },\n                OcdPropertyText {\n                    textnr: \"VT100\".to_string(),\n                    language: \"EN\".to_string(),\n                    line_nr: 1,\n                    text: \"Red\".to_string(),\n                },\n            ],\n        );\n\n        // Add text with empty language (universal)\n        reader.value_texts.insert(\n            \"VT200\".to_string(),\n            vec![OcdPropertyText {\n                textnr: \"VT200\".to_string(),\n                language: \"\".to_string(),\n                line_nr: 1,\n                text: \"Universal Value\".to_string(),\n            }],\n        );\n\n        // Test exact language match\n        let de_text = reader.get_value_text(\"VT100\", \"DE\");\n        assert_eq!(de_text, Some(\"Rot\".to_string()));\n\n        let en_text = reader.get_value_text(\"VT100\", \"EN\");\n        assert_eq!(en_text, Some(\"Red\".to_string()));\n\n        // Test empty language match (universal)\n        let universal = reader.get_value_text(\"VT200\", \"FR\");\n        assert_eq!(universal, Some(\"Universal Value\".to_string()));\n\n        // Test fallback to EN\n        reader.value_texts.insert(\n            \"VT300\".to_string(),\n            vec![OcdPropertyText {\n                textnr: \"VT300\".to_string(),\n                language: \"EN\".to_string(),\n                line_nr: 1,\n                text: \"English Fallback\".to_string(),\n            }],\n        );\n        let fallback = reader.get_value_text(\"VT300\", \"FR\");\n        assert_eq!(fallback, Some(\"English Fallback\".to_string()));\n\n        // Test non-existent\n        let none = reader.get_value_text(\"VT999\", \"DE\");\n        assert!(none.is_none());\n    }\n\n    #[test]\n    fn test_ocd_property_reader_get_price_text() {\n        let mut reader = OcdPropertyReader {\n            properties: HashMap::new(),\n            values: HashMap::new(),\n            classes: HashMap::new(),\n            texts: HashMap::new(),\n            value_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            prop_class_texts: HashMap::new(),\n            hint_texts: HashMap::new(),\n            user_messages: HashMap::new(),\n            prop_group_texts: HashMap::new(),\n            relation_objs: HashMap::new(),\n            relations: HashMap::new(),\n            custom_tables: HashMap::new(),\n            property_groups: HashMap::new(),\n            article_prop_groups: HashMap::new(),\n            rounding_rules: HashMap::new(),\n            tax_schemes: HashMap::new(),\n            article_taxes: HashMap::new(),\n            code_schemes: HashMap::new(),\n            art_base: HashMap::new(),\n            packaging: HashMap::new(),\n            bill_of_items: HashMap::new(),\n            composites: HashMap::new(),\n            version: None,\n        };\n\n        reader.price_texts.insert(\n            \"PT100\".to_string(),\n            vec![OcdPropertyText {\n                textnr: \"PT100\".to_string(),\n                language: \"DE\".to_string(),\n                line_nr: 1,\n                text: \"Aufpreis\".to_string(),\n            }],\n        );\n\n        let text = reader.get_price_text(\"PT100\", \"DE\");\n        assert_eq!(text, Some(\"Aufpreis\".to_string()));\n\n        let none = reader.get_price_text(\"PT999\", \"DE\");\n        assert!(none.is_none());\n    }\n\n    #[test]\n    fn test_ocd_property_reader_get_default_value() {\n        let mut reader = OcdPropertyReader {\n            properties: HashMap::new(),\n            values: HashMap::new(),\n            classes: HashMap::new(),\n            texts: HashMap::new(),\n            value_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            prop_class_texts: HashMap::new(),\n            hint_texts: HashMap::new(),\n            user_messages: HashMap::new(),\n            prop_group_texts: HashMap::new(),\n            relation_objs: HashMap::new(),\n            relations: HashMap::new(),\n            custom_tables: HashMap::new(),\n            property_groups: HashMap::new(),\n            article_prop_groups: HashMap::new(),\n            rounding_rules: HashMap::new(),\n            tax_schemes: HashMap::new(),\n            article_taxes: HashMap::new(),\n            code_schemes: HashMap::new(),\n            art_base: HashMap::new(),\n            packaging: HashMap::new(),\n            bill_of_items: HashMap::new(),\n            composites: HashMap::new(),\n            version: None,\n        };\n\n        reader.values.insert(\n            (\"PC1\".to_string(), \"Color\".to_string()),\n            vec![\n                OcdPropertyValue {\n                    prop_class: \"PC1\".to_string(),\n                    property: \"Color\".to_string(),\n                    position: 1,\n                    textnr: \"\".to_string(),\n                    is_default: false,\n                    value_from: \"RED\".to_string(),\n                    value_to: \"RED\".to_string(),\n                    op_from: \"=\".to_string(),\n                    op_to: \"\".to_string(),\n                    raster: \"\".to_string(),\n                },\n                OcdPropertyValue {\n                    prop_class: \"PC1\".to_string(),\n                    property: \"Color\".to_string(),\n                    position: 2,\n                    textnr: \"\".to_string(),\n                    is_default: true,\n                    value_from: \"BLUE\".to_string(),\n                    value_to: \"BLUE\".to_string(),\n                    op_from: \"=\".to_string(),\n                    op_to: \"\".to_string(),\n                    raster: \"\".to_string(),\n                },\n            ],\n        );\n\n        let default = reader.get_default_value(\"PC1\", \"Color\");\n        assert!(default.is_some());\n        assert_eq!(default.unwrap().value_from, \"BLUE\");\n        assert!(default.unwrap().is_default);\n\n        // Test fallback to first when no default\n        reader.values.insert(\n            (\"PC1\".to_string(), \"Size\".to_string()),\n            vec![OcdPropertyValue {\n                prop_class: \"PC1\".to_string(),\n                property: \"Size\".to_string(),\n                position: 1,\n                textnr: \"\".to_string(),\n                is_default: false,\n                value_from: \"L\".to_string(),\n                value_to: \"L\".to_string(),\n                op_from: \"=\".to_string(),\n                op_to: \"\".to_string(),\n                raster: \"\".to_string(),\n            }],\n        );\n\n        let first = reader.get_default_value(\"PC1\", \"Size\");\n        assert!(first.is_some());\n        assert_eq!(first.unwrap().value_from, \"L\");\n\n        // Test non-existent\n        let none = reader.get_default_value(\"PC99\", \"Missing\");\n        assert!(none.is_none());\n    }\n\n    #[test]\n    fn test_ocd_property_reader_has_properties() {\n        let mut reader = OcdPropertyReader {\n            properties: HashMap::new(),\n            values: HashMap::new(),\n            classes: HashMap::new(),\n            texts: HashMap::new(),\n            value_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            prop_class_texts: HashMap::new(),\n            hint_texts: HashMap::new(),\n            user_messages: HashMap::new(),\n            prop_group_texts: HashMap::new(),\n            relation_objs: HashMap::new(),\n            relations: HashMap::new(),\n            custom_tables: HashMap::new(),\n            property_groups: HashMap::new(),\n            article_prop_groups: HashMap::new(),\n            rounding_rules: HashMap::new(),\n            tax_schemes: HashMap::new(),\n            article_taxes: HashMap::new(),\n            code_schemes: HashMap::new(),\n            art_base: HashMap::new(),\n            packaging: HashMap::new(),\n            bill_of_items: HashMap::new(),\n            composites: HashMap::new(),\n            version: None,\n        };\n\n        assert!(!reader.has_properties());\n\n        reader.properties.insert(\n            (\"PC1\".to_string(), \"Color\".to_string()),\n            OcdPropertyDef {\n                prop_class: \"PC1\".to_string(),\n                property: \"Color\".to_string(),\n                position: 1,\n                textnr: \"\".to_string(),\n                prop_type: \"CHOICE\".to_string(),\n                digits: 0,\n                dec_digits: 0,\n                need_input: false,\n                add_values: false,\n                restrictable: false,\n                multi_option: false,\n                rel_obj: 0,\n                scope: \"C\".to_string(),\n                source_series: None,\n            },\n        );\n\n        assert!(reader.has_properties());\n    }\n\n    #[test]\n    fn test_ocd_property_reader_get_class_label() {\n        let mut reader = OcdPropertyReader {\n            properties: HashMap::new(),\n            values: HashMap::new(),\n            classes: HashMap::new(),\n            texts: HashMap::new(),\n            value_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            prop_class_texts: HashMap::new(),\n            hint_texts: HashMap::new(),\n            user_messages: HashMap::new(),\n            prop_group_texts: HashMap::new(),\n            relation_objs: HashMap::new(),\n            relations: HashMap::new(),\n            custom_tables: HashMap::new(),\n            property_groups: HashMap::new(),\n            article_prop_groups: HashMap::new(),\n            rounding_rules: HashMap::new(),\n            tax_schemes: HashMap::new(),\n            article_taxes: HashMap::new(),\n            code_schemes: HashMap::new(),\n            art_base: HashMap::new(),\n            packaging: HashMap::new(),\n            bill_of_items: HashMap::new(),\n            composites: HashMap::new(),\n            version: None,\n        };\n\n        reader.prop_class_texts.insert(\n            \"CT100\".to_string(),\n            vec![\n                OcdPropertyText {\n                    textnr: \"CT100\".to_string(),\n                    language: \"DE\".to_string(),\n                    line_nr: 1,\n                    text: \"Hauptfarbe\".to_string(),\n                },\n                OcdPropertyText {\n                    textnr: \"CT100\".to_string(),\n                    language: \"EN\".to_string(),\n                    line_nr: 1,\n                    text: \"Main Color\".to_string(),\n                },\n            ],\n        );\n\n        // Exact match\n        let de = reader.get_class_label(\"CT100\", \"DE\");\n        assert_eq!(de, Some(\"Hauptfarbe\".to_string()));\n\n        // EN fallback when requested language not found\n        let fr = reader.get_class_label(\"CT100\", \"FR\");\n        assert_eq!(fr, Some(\"Main Color\".to_string()));\n\n        // Non-existent\n        let none = reader.get_class_label(\"CT999\", \"DE\");\n        assert!(none.is_none());\n    }\n\n    #[test]\n    fn test_ocd_property_reader_get_hint_text() {\n        let mut reader = OcdPropertyReader {\n            properties: HashMap::new(),\n            values: HashMap::new(),\n            classes: HashMap::new(),\n            texts: HashMap::new(),\n            value_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            prop_class_texts: HashMap::new(),\n            hint_texts: HashMap::new(),\n            user_messages: HashMap::new(),\n            prop_group_texts: HashMap::new(),\n            relation_objs: HashMap::new(),\n            relations: HashMap::new(),\n            custom_tables: HashMap::new(),\n            property_groups: HashMap::new(),\n            article_prop_groups: HashMap::new(),\n            rounding_rules: HashMap::new(),\n            tax_schemes: HashMap::new(),\n            article_taxes: HashMap::new(),\n            code_schemes: HashMap::new(),\n            art_base: HashMap::new(),\n            packaging: HashMap::new(),\n            bill_of_items: HashMap::new(),\n            composites: HashMap::new(),\n            version: None,\n        };\n\n        reader.hint_texts.insert(\n            \"HT100\".to_string(),\n            vec![OcdPropertyText {\n                textnr: \"HT100\".to_string(),\n                language: \"DE\".to_string(),\n                line_nr: 1,\n                text: \"W√§hlen Sie eine Farbe\".to_string(),\n            }],\n        );\n\n        let hint = reader.get_hint_text(\"HT100\", \"DE\");\n        assert_eq!(hint, Some(\"W√§hlen Sie eine Farbe\".to_string()));\n\n        let none = reader.get_hint_text(\"HT999\", \"DE\");\n        assert!(none.is_none());\n    }\n\n    #[test]\n    fn test_ocd_property_reader_get_user_message() {\n        let mut reader = OcdPropertyReader {\n            properties: HashMap::new(),\n            values: HashMap::new(),\n            classes: HashMap::new(),\n            texts: HashMap::new(),\n            value_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            prop_class_texts: HashMap::new(),\n            hint_texts: HashMap::new(),\n            user_messages: HashMap::new(),\n            prop_group_texts: HashMap::new(),\n            relation_objs: HashMap::new(),\n            relations: HashMap::new(),\n            custom_tables: HashMap::new(),\n            property_groups: HashMap::new(),\n            article_prop_groups: HashMap::new(),\n            rounding_rules: HashMap::new(),\n            tax_schemes: HashMap::new(),\n            article_taxes: HashMap::new(),\n            code_schemes: HashMap::new(),\n            art_base: HashMap::new(),\n            packaging: HashMap::new(),\n            bill_of_items: HashMap::new(),\n            composites: HashMap::new(),\n            version: None,\n        };\n\n        reader.user_messages.insert(\n            \"UM100\".to_string(),\n            vec![OcdPropertyText {\n                textnr: \"UM100\".to_string(),\n                language: \"EN\".to_string(),\n                line_nr: 1,\n                text: \"Please select a color\".to_string(),\n            }],\n        );\n\n        let msg = reader.get_user_message(\"UM100\", \"EN\");\n        assert_eq!(msg, Some(\"Please select a color\".to_string()));\n\n        // Fallback to EN when requested language not found\n        let fallback = reader.get_user_message(\"UM100\", \"FR\");\n        assert_eq!(fallback, Some(\"Please select a color\".to_string()));\n    }\n\n    #[test]\n    fn test_ocd_property_reader_get_prop_group_label() {\n        let mut reader = OcdPropertyReader {\n            properties: HashMap::new(),\n            values: HashMap::new(),\n            classes: HashMap::new(),\n            texts: HashMap::new(),\n            value_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            prop_class_texts: HashMap::new(),\n            hint_texts: HashMap::new(),\n            user_messages: HashMap::new(),\n            prop_group_texts: HashMap::new(),\n            relation_objs: HashMap::new(),\n            relations: HashMap::new(),\n            custom_tables: HashMap::new(),\n            property_groups: HashMap::new(),\n            article_prop_groups: HashMap::new(),\n            rounding_rules: HashMap::new(),\n            tax_schemes: HashMap::new(),\n            article_taxes: HashMap::new(),\n            code_schemes: HashMap::new(),\n            art_base: HashMap::new(),\n            packaging: HashMap::new(),\n            bill_of_items: HashMap::new(),\n            composites: HashMap::new(),\n            version: None,\n        };\n\n        reader.prop_group_texts.insert(\n            \"PG100\".to_string(),\n            vec![OcdPropertyText {\n                textnr: \"PG100\".to_string(),\n                language: \"DE\".to_string(),\n                line_nr: 1,\n                text: \"Farboptionen\".to_string(),\n            }],\n        );\n\n        let label = reader.get_prop_group_label(\"PG100\", \"DE\");\n        assert_eq!(label, Some(\"Farboptionen\".to_string()));\n    }\n\n    #[test]\n    fn test_ocd_property_reader_get_property_groups_for_class() {\n        let mut reader = OcdPropertyReader {\n            properties: HashMap::new(),\n            values: HashMap::new(),\n            classes: HashMap::new(),\n            texts: HashMap::new(),\n            value_texts: HashMap::new(),\n            price_texts: HashMap::new(),\n            prop_class_texts: HashMap::new(),\n            hint_texts: HashMap::new(),\n            user_messages: HashMap::new(),\n            prop_group_texts: HashMap::new(),\n            relation_objs: HashMap::new(),\n            relations: HashMap::new(),\n            custom_tables: HashMap::new(),\n            property_groups: HashMap::new(),\n            article_prop_groups: HashMap::new(),\n            rounding_rules: HashMap::new(),\n            tax_schemes: HashMap::new(),\n            article_taxes: HashMap::new(),\n            code_schemes: HashMap::new(),\n            art_base: HashMap::new(),\n            packaging: HashMap::new(),\n            bill_of_items: HashMap::new(),\n            composites: HashMap::new(),\n            version: None,\n        };\n\n        reader.property_groups.insert(\n            (\"PC1\".to_string(), \"Color\".to_string()),\n            OcdPropertyGroup {\n                prop_class: \"PC1\".to_string(),\n                property: \"Color\".to_string(),\n                prop_group: \"G1\".to_string(),\n                position: 2,\n            },\n        );\n\n        reader.property_groups.insert(\n            (\"PC1\".to_string(), \"Size\".to_string()),\n            OcdPropertyGroup {\n                prop_class: \"PC1\".to_string(),\n                property: \"Size\".to_string(),\n                prop_group: \"G2\".to_string(),\n                position: 1,\n            },\n        );\n\n        reader.property_groups.insert(\n            (\"PC2\".to_string(), \"Material\".to_string()),\n            OcdPropertyGroup {\n                prop_class: \"PC2\".to_string(),\n                property: \"Material\".to_string(),\n                prop_group: \"G3\".to_string(),\n                position: 1,\n            },\n        );\n\n        let groups = reader.get_property_groups_for_class(\"PC1\");\n        assert_eq!(groups.len(), 2);\n        // Should be sorted by position\n        assert_eq!(groups[0].property, \"Size\"); // position 1\n        assert_eq!(groups[1].property, \"Color\"); // position 2\n\n        let empty = reader.get_property_groups_for_class(\"PC99\");\n        assert!(empty.is_empty());\n    }\n\n    #[test]\n    fn test_ocd_composite_debug_clone() {\n        let composite = OcdComposite {\n            composite_id: \"COMP1\".to_string(),\n            basket_mode: \"ADD\".to_string(),\n            price_mode: \"SUM\".to_string(),\n            text_mode: \"CONCAT\".to_string(),\n            configurable: true,\n            items_configurable: false,\n            is_fixed: true,\n        };\n\n        let debug_str = format!(\"{:?}\", composite);\n        assert!(debug_str.contains(\"OcdComposite\"));\n        assert!(debug_str.contains(\"COMP1\"));\n\n        let cloned = composite.clone();\n        assert_eq!(cloned.composite_id, \"COMP1\");\n        assert!(cloned.configurable);\n        assert!(cloned.is_fixed);\n    }\n\n    #[test]\n    fn test_ocd_version_debug_clone() {\n        let version = OcdVersion {\n            data_version: \"1.0\".to_string(),\n            format_version: \"4.3\".to_string(),\n            region: \"DE\".to_string(),\n            date_from: \"2024-01-01\".to_string(),\n            date_to: \"2024-12-31\".to_string(),\n            rel_coding: \"HEX\".to_string(),\n            comment: \"Test data\".to_string(),\n            tables: \"ocd_propertydef,ocd_price\".to_string(),\n            varcond_var: \"VC\".to_string(),\n            placeholder_on: true,\n        };\n\n        let debug_str = format!(\"{:?}\", version);\n        assert!(debug_str.contains(\"OcdVersion\"));\n        assert!(debug_str.contains(\"1.0\"));\n\n        let cloned = version.clone();\n        assert_eq!(cloned.data_version, \"1.0\");\n        assert!(cloned.tables.contains(\"ocd_propertydef\"));\n        assert!(cloned.placeholder_on);\n    }\n}\n","traces":[{"line":400,"address":[],"length":0,"stats":{"Line":37}},{"line":401,"address":[],"length":0,"stats":{"Line":148}},{"line":404,"address":[],"length":0,"stats":{"Line":111}},{"line":405,"address":[],"length":0,"stats":{"Line":111}},{"line":406,"address":[],"length":0,"stats":{"Line":111}},{"line":409,"address":[],"length":0,"stats":{"Line":148}},{"line":410,"address":[],"length":0,"stats":{"Line":148}},{"line":411,"address":[],"length":0,"stats":{"Line":148}},{"line":412,"address":[],"length":0,"stats":{"Line":148}},{"line":413,"address":[],"length":0,"stats":{"Line":148}},{"line":414,"address":[],"length":0,"stats":{"Line":148}},{"line":415,"address":[],"length":0,"stats":{"Line":148}},{"line":418,"address":[],"length":0,"stats":{"Line":111}},{"line":419,"address":[],"length":0,"stats":{"Line":111}},{"line":422,"address":[],"length":0,"stats":{"Line":111}},{"line":423,"address":[],"length":0,"stats":{"Line":111}},{"line":426,"address":[],"length":0,"stats":{"Line":111}},{"line":427,"address":[],"length":0,"stats":{"Line":111}},{"line":428,"address":[],"length":0,"stats":{"Line":111}},{"line":431,"address":[],"length":0,"stats":{"Line":111}},{"line":432,"address":[],"length":0,"stats":{"Line":111}},{"line":433,"address":[],"length":0,"stats":{"Line":111}},{"line":434,"address":[],"length":0,"stats":{"Line":111}},{"line":435,"address":[],"length":0,"stats":{"Line":111}},{"line":436,"address":[],"length":0,"stats":{"Line":111}},{"line":439,"address":[],"length":0,"stats":{"Line":74}},{"line":440,"address":[],"length":0,"stats":{"Line":249}},{"line":441,"address":[],"length":0,"stats":{"Line":693}},{"line":442,"address":[],"length":0,"stats":{"Line":259}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":37}},{"line":458,"address":[],"length":0,"stats":{"Line":74}},{"line":459,"address":[],"length":0,"stats":{"Line":74}},{"line":460,"address":[],"length":0,"stats":{"Line":74}},{"line":461,"address":[],"length":0,"stats":{"Line":74}},{"line":462,"address":[],"length":0,"stats":{"Line":74}},{"line":463,"address":[],"length":0,"stats":{"Line":74}},{"line":464,"address":[],"length":0,"stats":{"Line":74}},{"line":465,"address":[],"length":0,"stats":{"Line":74}},{"line":466,"address":[],"length":0,"stats":{"Line":74}},{"line":467,"address":[],"length":0,"stats":{"Line":74}},{"line":468,"address":[],"length":0,"stats":{"Line":74}},{"line":469,"address":[],"length":0,"stats":{"Line":74}},{"line":470,"address":[],"length":0,"stats":{"Line":74}},{"line":471,"address":[],"length":0,"stats":{"Line":74}},{"line":472,"address":[],"length":0,"stats":{"Line":74}},{"line":473,"address":[],"length":0,"stats":{"Line":74}},{"line":474,"address":[],"length":0,"stats":{"Line":74}},{"line":475,"address":[],"length":0,"stats":{"Line":74}},{"line":476,"address":[],"length":0,"stats":{"Line":74}},{"line":477,"address":[],"length":0,"stats":{"Line":74}},{"line":478,"address":[],"length":0,"stats":{"Line":74}},{"line":479,"address":[],"length":0,"stats":{"Line":74}},{"line":480,"address":[],"length":0,"stats":{"Line":37}},{"line":481,"address":[],"length":0,"stats":{"Line":37}},{"line":486,"address":[],"length":0,"stats":{"Line":37}},{"line":489,"address":[],"length":0,"stats":{"Line":74}},{"line":491,"address":[],"length":0,"stats":{"Line":74}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":74}},{"line":496,"address":[],"length":0,"stats":{"Line":111}},{"line":497,"address":[],"length":0,"stats":{"Line":37}},{"line":499,"address":[],"length":0,"stats":{"Line":869}},{"line":500,"address":[],"length":0,"stats":{"Line":1664}},{"line":501,"address":[],"length":0,"stats":{"Line":1664}},{"line":503,"address":[],"length":0,"stats":{"Line":1664}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":1248}},{"line":509,"address":[],"length":0,"stats":{"Line":1248}},{"line":510,"address":[],"length":0,"stats":{"Line":1664}},{"line":511,"address":[],"length":0,"stats":{"Line":1664}},{"line":512,"address":[],"length":0,"stats":{"Line":1664}},{"line":513,"address":[],"length":0,"stats":{"Line":1664}},{"line":514,"address":[],"length":0,"stats":{"Line":1664}},{"line":515,"address":[],"length":0,"stats":{"Line":1248}},{"line":516,"address":[],"length":0,"stats":{"Line":1248}},{"line":517,"address":[],"length":0,"stats":{"Line":1248}},{"line":518,"address":[],"length":0,"stats":{"Line":1248}},{"line":519,"address":[],"length":0,"stats":{"Line":1664}},{"line":520,"address":[],"length":0,"stats":{"Line":1248}},{"line":524,"address":[],"length":0,"stats":{"Line":1664}},{"line":527,"address":[],"length":0,"stats":{"Line":37}},{"line":531,"address":[],"length":0,"stats":{"Line":37}},{"line":534,"address":[],"length":0,"stats":{"Line":111}},{"line":536,"address":[],"length":0,"stats":{"Line":74}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":74}},{"line":541,"address":[],"length":0,"stats":{"Line":111}},{"line":542,"address":[],"length":0,"stats":{"Line":37}},{"line":544,"address":[],"length":0,"stats":{"Line":8875}},{"line":545,"address":[],"length":0,"stats":{"Line":17676}},{"line":546,"address":[],"length":0,"stats":{"Line":17676}},{"line":548,"address":[],"length":0,"stats":{"Line":14976}},{"line":549,"address":[],"length":0,"stats":{"Line":2918}},{"line":553,"address":[],"length":0,"stats":{"Line":4503}},{"line":554,"address":[],"length":0,"stats":{"Line":4503}},{"line":555,"address":[],"length":0,"stats":{"Line":6004}},{"line":556,"address":[],"length":0,"stats":{"Line":6004}},{"line":557,"address":[],"length":0,"stats":{"Line":4503}},{"line":558,"address":[],"length":0,"stats":{"Line":6004}},{"line":559,"address":[],"length":0,"stats":{"Line":6004}},{"line":560,"address":[],"length":0,"stats":{"Line":6004}},{"line":561,"address":[],"length":0,"stats":{"Line":6004}},{"line":562,"address":[],"length":0,"stats":{"Line":3002}},{"line":565,"address":[],"length":0,"stats":{"Line":3002}},{"line":566,"address":[],"length":0,"stats":{"Line":3002}},{"line":568,"address":[],"length":0,"stats":{"Line":3002}},{"line":572,"address":[],"length":0,"stats":{"Line":313}},{"line":573,"address":[],"length":0,"stats":{"Line":478}},{"line":576,"address":[],"length":0,"stats":{"Line":37}},{"line":580,"address":[],"length":0,"stats":{"Line":37}},{"line":583,"address":[],"length":0,"stats":{"Line":74}},{"line":585,"address":[],"length":0,"stats":{"Line":74}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":74}},{"line":590,"address":[],"length":0,"stats":{"Line":111}},{"line":591,"address":[],"length":0,"stats":{"Line":37}},{"line":593,"address":[],"length":0,"stats":{"Line":4705}},{"line":594,"address":[],"length":0,"stats":{"Line":9336}},{"line":596,"address":[],"length":0,"stats":{"Line":4668}},{"line":597,"address":[],"length":0,"stats":{"Line":720}},{"line":601,"address":[],"length":0,"stats":{"Line":4842}},{"line":602,"address":[],"length":0,"stats":{"Line":6456}},{"line":603,"address":[],"length":0,"stats":{"Line":3228}},{"line":606,"address":[],"length":0,"stats":{"Line":6456}},{"line":609,"address":[],"length":0,"stats":{"Line":37}},{"line":613,"address":[],"length":0,"stats":{"Line":259}},{"line":617,"address":[],"length":0,"stats":{"Line":777}},{"line":619,"address":[],"length":0,"stats":{"Line":518}},{"line":620,"address":[],"length":0,"stats":{"Line":37}},{"line":623,"address":[],"length":0,"stats":{"Line":444}},{"line":624,"address":[],"length":0,"stats":{"Line":666}},{"line":625,"address":[],"length":0,"stats":{"Line":222}},{"line":627,"address":[],"length":0,"stats":{"Line":19754}},{"line":628,"address":[],"length":0,"stats":{"Line":39064}},{"line":630,"address":[],"length":0,"stats":{"Line":19532}},{"line":631,"address":[],"length":0,"stats":{"Line":965}},{"line":635,"address":[],"length":0,"stats":{"Line":26403}},{"line":636,"address":[],"length":0,"stats":{"Line":35204}},{"line":637,"address":[],"length":0,"stats":{"Line":35204}},{"line":638,"address":[],"length":0,"stats":{"Line":17602}},{"line":641,"address":[],"length":0,"stats":{"Line":44005}},{"line":645,"address":[],"length":0,"stats":{"Line":3958}},{"line":646,"address":[],"length":0,"stats":{"Line":7028}},{"line":649,"address":[],"length":0,"stats":{"Line":222}},{"line":653,"address":[],"length":0,"stats":{"Line":37}},{"line":656,"address":[],"length":0,"stats":{"Line":74}},{"line":658,"address":[],"length":0,"stats":{"Line":74}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":74}},{"line":663,"address":[],"length":0,"stats":{"Line":111}},{"line":664,"address":[],"length":0,"stats":{"Line":37}},{"line":666,"address":[],"length":0,"stats":{"Line":387}},{"line":667,"address":[],"length":0,"stats":{"Line":700}},{"line":668,"address":[],"length":0,"stats":{"Line":175}},{"line":669,"address":[],"length":0,"stats":{"Line":2}},{"line":674,"address":[],"length":0,"stats":{"Line":692}},{"line":675,"address":[],"length":0,"stats":{"Line":692}},{"line":676,"address":[],"length":0,"stats":{"Line":346}},{"line":679,"address":[],"length":0,"stats":{"Line":692}},{"line":682,"address":[],"length":0,"stats":{"Line":37}},{"line":686,"address":[],"length":0,"stats":{"Line":37}},{"line":689,"address":[],"length":0,"stats":{"Line":111}},{"line":691,"address":[],"length":0,"stats":{"Line":74}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":74}},{"line":696,"address":[],"length":0,"stats":{"Line":111}},{"line":697,"address":[],"length":0,"stats":{"Line":37}},{"line":699,"address":[],"length":0,"stats":{"Line":559}},{"line":700,"address":[],"length":0,"stats":{"Line":1044}},{"line":701,"address":[],"length":0,"stats":{"Line":522}},{"line":702,"address":[],"length":0,"stats":{"Line":2}},{"line":706,"address":[],"length":0,"stats":{"Line":777}},{"line":707,"address":[],"length":0,"stats":{"Line":1036}},{"line":708,"address":[],"length":0,"stats":{"Line":518}},{"line":711,"address":[],"length":0,"stats":{"Line":1295}},{"line":715,"address":[],"length":0,"stats":{"Line":249}},{"line":716,"address":[],"length":0,"stats":{"Line":350}},{"line":719,"address":[],"length":0,"stats":{"Line":37}},{"line":724,"address":[],"length":0,"stats":{"Line":361}},{"line":725,"address":[],"length":0,"stats":{"Line":1083}},{"line":726,"address":[],"length":0,"stats":{"Line":361}},{"line":727,"address":[],"length":0,"stats":{"Line":361}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":0}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":782,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[],"length":0,"stats":{"Line":0}},{"line":788,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":796,"address":[],"length":0,"stats":{"Line":0}},{"line":797,"address":[],"length":0,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":802,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":806,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":820,"address":[],"length":0,"stats":{"Line":0}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}},{"line":832,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":836,"address":[],"length":0,"stats":{"Line":0}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":0}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":859,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":866,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":37}},{"line":878,"address":[],"length":0,"stats":{"Line":74}},{"line":880,"address":[],"length":0,"stats":{"Line":74}},{"line":881,"address":[],"length":0,"stats":{"Line":37}},{"line":884,"address":[],"length":0,"stats":{"Line":0}},{"line":885,"address":[],"length":0,"stats":{"Line":0}},{"line":886,"address":[],"length":0,"stats":{"Line":0}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":890,"address":[],"length":0,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":893,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":0}},{"line":906,"address":[],"length":0,"stats":{"Line":0}},{"line":910,"address":[],"length":0,"stats":{"Line":37}},{"line":913,"address":[],"length":0,"stats":{"Line":111}},{"line":915,"address":[],"length":0,"stats":{"Line":74}},{"line":916,"address":[],"length":0,"stats":{"Line":37}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":920,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[],"length":0,"stats":{"Line":0}},{"line":923,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":926,"address":[],"length":0,"stats":{"Line":0}},{"line":927,"address":[],"length":0,"stats":{"Line":0}},{"line":931,"address":[],"length":0,"stats":{"Line":0}},{"line":932,"address":[],"length":0,"stats":{"Line":0}},{"line":933,"address":[],"length":0,"stats":{"Line":0}},{"line":934,"address":[],"length":0,"stats":{"Line":0}},{"line":937,"address":[],"length":0,"stats":{"Line":0}},{"line":941,"address":[],"length":0,"stats":{"Line":0}},{"line":942,"address":[],"length":0,"stats":{"Line":0}},{"line":945,"address":[],"length":0,"stats":{"Line":0}},{"line":949,"address":[],"length":0,"stats":{"Line":37}},{"line":952,"address":[],"length":0,"stats":{"Line":111}},{"line":954,"address":[],"length":0,"stats":{"Line":74}},{"line":955,"address":[],"length":0,"stats":{"Line":0}},{"line":958,"address":[],"length":0,"stats":{"Line":74}},{"line":959,"address":[],"length":0,"stats":{"Line":111}},{"line":960,"address":[],"length":0,"stats":{"Line":37}},{"line":962,"address":[],"length":0,"stats":{"Line":37}},{"line":963,"address":[],"length":0,"stats":{"Line":0}},{"line":965,"address":[],"length":0,"stats":{"Line":0}},{"line":966,"address":[],"length":0,"stats":{"Line":0}},{"line":970,"address":[],"length":0,"stats":{"Line":0}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":972,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[],"length":0,"stats":{"Line":0}},{"line":977,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":984,"address":[],"length":0,"stats":{"Line":74}},{"line":985,"address":[],"length":0,"stats":{"Line":0}},{"line":988,"address":[],"length":0,"stats":{"Line":37}},{"line":992,"address":[],"length":0,"stats":{"Line":37}},{"line":995,"address":[],"length":0,"stats":{"Line":74}},{"line":997,"address":[],"length":0,"stats":{"Line":74}},{"line":998,"address":[],"length":0,"stats":{"Line":0}},{"line":1001,"address":[],"length":0,"stats":{"Line":74}},{"line":1002,"address":[],"length":0,"stats":{"Line":111}},{"line":1003,"address":[],"length":0,"stats":{"Line":37}},{"line":1005,"address":[],"length":0,"stats":{"Line":37}},{"line":1006,"address":[],"length":0,"stats":{"Line":0}},{"line":1008,"address":[],"length":0,"stats":{"Line":0}},{"line":1009,"address":[],"length":0,"stats":{"Line":0}},{"line":1013,"address":[],"length":0,"stats":{"Line":0}},{"line":1014,"address":[],"length":0,"stats":{"Line":0}},{"line":1015,"address":[],"length":0,"stats":{"Line":0}},{"line":1016,"address":[],"length":0,"stats":{"Line":0}},{"line":1017,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":0}},{"line":1021,"address":[],"length":0,"stats":{"Line":0}},{"line":1024,"address":[],"length":0,"stats":{"Line":37}},{"line":1028,"address":[],"length":0,"stats":{"Line":37}},{"line":1031,"address":[],"length":0,"stats":{"Line":111}},{"line":1033,"address":[],"length":0,"stats":{"Line":74}},{"line":1034,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":74}},{"line":1038,"address":[],"length":0,"stats":{"Line":111}},{"line":1039,"address":[],"length":0,"stats":{"Line":37}},{"line":1041,"address":[],"length":0,"stats":{"Line":37}},{"line":1042,"address":[],"length":0,"stats":{"Line":0}},{"line":1044,"address":[],"length":0,"stats":{"Line":0}},{"line":1045,"address":[],"length":0,"stats":{"Line":0}},{"line":1049,"address":[],"length":0,"stats":{"Line":0}},{"line":1050,"address":[],"length":0,"stats":{"Line":0}},{"line":1051,"address":[],"length":0,"stats":{"Line":0}},{"line":1052,"address":[],"length":0,"stats":{"Line":0}},{"line":1055,"address":[],"length":0,"stats":{"Line":0}},{"line":1058,"address":[],"length":0,"stats":{"Line":37}},{"line":1062,"address":[],"length":0,"stats":{"Line":37}},{"line":1065,"address":[],"length":0,"stats":{"Line":74}},{"line":1067,"address":[],"length":0,"stats":{"Line":74}},{"line":1068,"address":[],"length":0,"stats":{"Line":0}},{"line":1071,"address":[],"length":0,"stats":{"Line":74}},{"line":1072,"address":[],"length":0,"stats":{"Line":111}},{"line":1073,"address":[],"length":0,"stats":{"Line":37}},{"line":1075,"address":[],"length":0,"stats":{"Line":51}},{"line":1076,"address":[],"length":0,"stats":{"Line":28}},{"line":1078,"address":[],"length":0,"stats":{"Line":14}},{"line":1079,"address":[],"length":0,"stats":{"Line":0}},{"line":1083,"address":[],"length":0,"stats":{"Line":21}},{"line":1084,"address":[],"length":0,"stats":{"Line":28}},{"line":1085,"address":[],"length":0,"stats":{"Line":28}},{"line":1086,"address":[],"length":0,"stats":{"Line":28}},{"line":1087,"address":[],"length":0,"stats":{"Line":28}},{"line":1088,"address":[],"length":0,"stats":{"Line":28}},{"line":1089,"address":[],"length":0,"stats":{"Line":28}},{"line":1090,"address":[],"length":0,"stats":{"Line":28}},{"line":1091,"address":[],"length":0,"stats":{"Line":28}},{"line":1092,"address":[],"length":0,"stats":{"Line":14}},{"line":1095,"address":[],"length":0,"stats":{"Line":28}},{"line":1098,"address":[],"length":0,"stats":{"Line":37}},{"line":1102,"address":[],"length":0,"stats":{"Line":37}},{"line":1105,"address":[],"length":0,"stats":{"Line":111}},{"line":1107,"address":[],"length":0,"stats":{"Line":74}},{"line":1108,"address":[],"length":0,"stats":{"Line":0}},{"line":1111,"address":[],"length":0,"stats":{"Line":74}},{"line":1112,"address":[],"length":0,"stats":{"Line":111}},{"line":1113,"address":[],"length":0,"stats":{"Line":37}},{"line":1115,"address":[],"length":0,"stats":{"Line":8547}},{"line":1116,"address":[],"length":0,"stats":{"Line":17020}},{"line":1118,"address":[],"length":0,"stats":{"Line":8510}},{"line":1119,"address":[],"length":0,"stats":{"Line":868}},{"line":1123,"address":[],"length":0,"stats":{"Line":10161}},{"line":1124,"address":[],"length":0,"stats":{"Line":13548}},{"line":1125,"address":[],"length":0,"stats":{"Line":13548}},{"line":1126,"address":[],"length":0,"stats":{"Line":6774}},{"line":1129,"address":[],"length":0,"stats":{"Line":16935}},{"line":1132,"address":[],"length":0,"stats":{"Line":37}},{"line":1136,"address":[],"length":0,"stats":{"Line":37}},{"line":1139,"address":[],"length":0,"stats":{"Line":111}},{"line":1141,"address":[],"length":0,"stats":{"Line":74}},{"line":1142,"address":[],"length":0,"stats":{"Line":0}},{"line":1145,"address":[],"length":0,"stats":{"Line":74}},{"line":1146,"address":[],"length":0,"stats":{"Line":111}},{"line":1147,"address":[],"length":0,"stats":{"Line":37}},{"line":1149,"address":[],"length":0,"stats":{"Line":37}},{"line":1150,"address":[],"length":0,"stats":{"Line":0}},{"line":1152,"address":[],"length":0,"stats":{"Line":0}},{"line":1153,"address":[],"length":0,"stats":{"Line":0}},{"line":1157,"address":[],"length":0,"stats":{"Line":0}},{"line":1158,"address":[],"length":0,"stats":{"Line":0}},{"line":1159,"address":[],"length":0,"stats":{"Line":0}},{"line":1160,"address":[],"length":0,"stats":{"Line":0}},{"line":1161,"address":[],"length":0,"stats":{"Line":0}},{"line":1162,"address":[],"length":0,"stats":{"Line":0}},{"line":1163,"address":[],"length":0,"stats":{"Line":0}},{"line":1164,"address":[],"length":0,"stats":{"Line":0}},{"line":1165,"address":[],"length":0,"stats":{"Line":0}},{"line":1166,"address":[],"length":0,"stats":{"Line":0}},{"line":1167,"address":[],"length":0,"stats":{"Line":0}},{"line":1168,"address":[],"length":0,"stats":{"Line":0}},{"line":1169,"address":[],"length":0,"stats":{"Line":0}},{"line":1172,"address":[],"length":0,"stats":{"Line":0}},{"line":1175,"address":[],"length":0,"stats":{"Line":37}},{"line":1179,"address":[],"length":0,"stats":{"Line":37}},{"line":1182,"address":[],"length":0,"stats":{"Line":111}},{"line":1184,"address":[],"length":0,"stats":{"Line":74}},{"line":1185,"address":[],"length":0,"stats":{"Line":37}},{"line":1188,"address":[],"length":0,"stats":{"Line":0}},{"line":1189,"address":[],"length":0,"stats":{"Line":0}},{"line":1190,"address":[],"length":0,"stats":{"Line":0}},{"line":1192,"address":[],"length":0,"stats":{"Line":0}},{"line":1193,"address":[],"length":0,"stats":{"Line":0}},{"line":1195,"address":[],"length":0,"stats":{"Line":0}},{"line":1196,"address":[],"length":0,"stats":{"Line":0}},{"line":1200,"address":[],"length":0,"stats":{"Line":0}},{"line":1201,"address":[],"length":0,"stats":{"Line":0}},{"line":1202,"address":[],"length":0,"stats":{"Line":0}},{"line":1203,"address":[],"length":0,"stats":{"Line":0}},{"line":1204,"address":[],"length":0,"stats":{"Line":0}},{"line":1205,"address":[],"length":0,"stats":{"Line":0}},{"line":1206,"address":[],"length":0,"stats":{"Line":0}},{"line":1207,"address":[],"length":0,"stats":{"Line":0}},{"line":1210,"address":[],"length":0,"stats":{"Line":0}},{"line":1214,"address":[],"length":0,"stats":{"Line":0}},{"line":1215,"address":[],"length":0,"stats":{"Line":0}},{"line":1218,"address":[],"length":0,"stats":{"Line":0}},{"line":1222,"address":[],"length":0,"stats":{"Line":37}},{"line":1225,"address":[],"length":0,"stats":{"Line":74}},{"line":1227,"address":[],"length":0,"stats":{"Line":74}},{"line":1228,"address":[],"length":0,"stats":{"Line":37}},{"line":1231,"address":[],"length":0,"stats":{"Line":0}},{"line":1232,"address":[],"length":0,"stats":{"Line":0}},{"line":1233,"address":[],"length":0,"stats":{"Line":0}},{"line":1235,"address":[],"length":0,"stats":{"Line":0}},{"line":1236,"address":[],"length":0,"stats":{"Line":0}},{"line":1238,"address":[],"length":0,"stats":{"Line":0}},{"line":1239,"address":[],"length":0,"stats":{"Line":0}},{"line":1243,"address":[],"length":0,"stats":{"Line":0}},{"line":1244,"address":[],"length":0,"stats":{"Line":0}},{"line":1245,"address":[],"length":0,"stats":{"Line":0}},{"line":1246,"address":[],"length":0,"stats":{"Line":0}},{"line":1247,"address":[],"length":0,"stats":{"Line":0}},{"line":1248,"address":[],"length":0,"stats":{"Line":0}},{"line":1249,"address":[],"length":0,"stats":{"Line":0}},{"line":1252,"address":[],"length":0,"stats":{"Line":0}},{"line":1255,"address":[],"length":0,"stats":{"Line":0}},{"line":1259,"address":[],"length":0,"stats":{"Line":37}},{"line":1260,"address":[],"length":0,"stats":{"Line":74}},{"line":1261,"address":[],"length":0,"stats":{"Line":0}},{"line":1264,"address":[],"length":0,"stats":{"Line":74}},{"line":1265,"address":[],"length":0,"stats":{"Line":111}},{"line":1266,"address":[],"length":0,"stats":{"Line":37}},{"line":1268,"address":[],"length":0,"stats":{"Line":74}},{"line":1269,"address":[],"length":0,"stats":{"Line":37}},{"line":1270,"address":[],"length":0,"stats":{"Line":148}},{"line":1271,"address":[],"length":0,"stats":{"Line":148}},{"line":1272,"address":[],"length":0,"stats":{"Line":148}},{"line":1273,"address":[],"length":0,"stats":{"Line":148}},{"line":1274,"address":[],"length":0,"stats":{"Line":148}},{"line":1275,"address":[],"length":0,"stats":{"Line":148}},{"line":1276,"address":[],"length":0,"stats":{"Line":148}},{"line":1277,"address":[],"length":0,"stats":{"Line":148}},{"line":1278,"address":[],"length":0,"stats":{"Line":148}},{"line":1279,"address":[],"length":0,"stats":{"Line":74}},{"line":1282,"address":[],"length":0,"stats":{"Line":0}},{"line":1288,"address":[],"length":0,"stats":{"Line":23}},{"line":1294,"address":[],"length":0,"stats":{"Line":46}},{"line":1297,"address":[],"length":0,"stats":{"Line":69}},{"line":1298,"address":[],"length":0,"stats":{"Line":46}},{"line":1299,"address":[],"length":0,"stats":{"Line":92}},{"line":1301,"address":[],"length":0,"stats":{"Line":46}},{"line":1302,"address":[],"length":0,"stats":{"Line":0}},{"line":1306,"address":[],"length":0,"stats":{"Line":23}},{"line":1307,"address":[],"length":0,"stats":{"Line":0}},{"line":1311,"address":[],"length":0,"stats":{"Line":69}},{"line":1312,"address":[],"length":0,"stats":{"Line":46}},{"line":1313,"address":[],"length":0,"stats":{"Line":0}},{"line":1317,"address":[],"length":0,"stats":{"Line":63}},{"line":1318,"address":[],"length":0,"stats":{"Line":34}},{"line":1319,"address":[],"length":0,"stats":{"Line":6}},{"line":1323,"address":[],"length":0,"stats":{"Line":51}},{"line":1325,"address":[],"length":0,"stats":{"Line":51}},{"line":1330,"address":[],"length":0,"stats":{"Line":17}},{"line":1331,"address":[],"length":0,"stats":{"Line":0}},{"line":1334,"address":[],"length":0,"stats":{"Line":0}},{"line":1335,"address":[],"length":0,"stats":{"Line":0}},{"line":1336,"address":[],"length":0,"stats":{"Line":0}},{"line":1340,"address":[],"length":0,"stats":{"Line":0}},{"line":1341,"address":[],"length":0,"stats":{"Line":0}},{"line":1344,"address":[],"length":0,"stats":{"Line":0}},{"line":1349,"address":[],"length":0,"stats":{"Line":0}},{"line":1350,"address":[],"length":0,"stats":{"Line":0}},{"line":1351,"address":[],"length":0,"stats":{"Line":0}},{"line":1353,"address":[],"length":0,"stats":{"Line":0}},{"line":1354,"address":[],"length":0,"stats":{"Line":0}},{"line":1360,"address":[],"length":0,"stats":{"Line":0}},{"line":1361,"address":[],"length":0,"stats":{"Line":0}},{"line":1364,"address":[],"length":0,"stats":{"Line":0}},{"line":1366,"address":[],"length":0,"stats":{"Line":0}},{"line":1368,"address":[],"length":0,"stats":{"Line":0}},{"line":1369,"address":[],"length":0,"stats":{"Line":0}},{"line":1370,"address":[],"length":0,"stats":{"Line":0}},{"line":1371,"address":[],"length":0,"stats":{"Line":0}},{"line":1372,"address":[],"length":0,"stats":{"Line":0}},{"line":1375,"address":[],"length":0,"stats":{"Line":0}},{"line":1377,"address":[],"length":0,"stats":{"Line":0}},{"line":1378,"address":[],"length":0,"stats":{"Line":0}},{"line":1379,"address":[],"length":0,"stats":{"Line":0}},{"line":1385,"address":[],"length":0,"stats":{"Line":0}},{"line":1387,"address":[],"length":0,"stats":{"Line":0}},{"line":1388,"address":[],"length":0,"stats":{"Line":0}},{"line":1390,"address":[],"length":0,"stats":{"Line":0}},{"line":1392,"address":[],"length":0,"stats":{"Line":0}},{"line":1393,"address":[],"length":0,"stats":{"Line":0}},{"line":1395,"address":[],"length":0,"stats":{"Line":0}},{"line":1401,"address":[],"length":0,"stats":{"Line":0}},{"line":1402,"address":[],"length":0,"stats":{"Line":0}},{"line":1403,"address":[],"length":0,"stats":{"Line":0}},{"line":1404,"address":[],"length":0,"stats":{"Line":0}},{"line":1405,"address":[],"length":0,"stats":{"Line":0}},{"line":1406,"address":[],"length":0,"stats":{"Line":0}},{"line":1407,"address":[],"length":0,"stats":{"Line":0}},{"line":1408,"address":[],"length":0,"stats":{"Line":0}},{"line":1409,"address":[],"length":0,"stats":{"Line":0}},{"line":1410,"address":[],"length":0,"stats":{"Line":0}},{"line":1411,"address":[],"length":0,"stats":{"Line":0}},{"line":1414,"address":[],"length":0,"stats":{"Line":0}},{"line":1421,"address":[],"length":0,"stats":{"Line":17}},{"line":1425,"address":[],"length":0,"stats":{"Line":0}},{"line":1426,"address":[],"length":0,"stats":{"Line":0}},{"line":1427,"address":[],"length":0,"stats":{"Line":0}},{"line":1428,"address":[],"length":0,"stats":{"Line":0}},{"line":1430,"address":[],"length":0,"stats":{"Line":0}},{"line":1431,"address":[],"length":0,"stats":{"Line":0}},{"line":1432,"address":[],"length":0,"stats":{"Line":0}},{"line":1433,"address":[],"length":0,"stats":{"Line":0}},{"line":1434,"address":[],"length":0,"stats":{"Line":0}},{"line":1435,"address":[],"length":0,"stats":{"Line":0}},{"line":1440,"address":[],"length":0,"stats":{"Line":0}},{"line":1449,"address":[],"length":0,"stats":{"Line":0}},{"line":1456,"address":[],"length":0,"stats":{"Line":0}},{"line":1458,"address":[],"length":0,"stats":{"Line":0}},{"line":1459,"address":[],"length":0,"stats":{"Line":0}},{"line":1460,"address":[],"length":0,"stats":{"Line":0}},{"line":1461,"address":[],"length":0,"stats":{"Line":0}},{"line":1464,"address":[],"length":0,"stats":{"Line":0}},{"line":1465,"address":[],"length":0,"stats":{"Line":0}},{"line":1466,"address":[],"length":0,"stats":{"Line":0}},{"line":1467,"address":[],"length":0,"stats":{"Line":0}},{"line":1468,"address":[],"length":0,"stats":{"Line":0}},{"line":1470,"address":[],"length":0,"stats":{"Line":0}},{"line":1471,"address":[],"length":0,"stats":{"Line":0}},{"line":1476,"address":[],"length":0,"stats":{"Line":0}},{"line":1477,"address":[],"length":0,"stats":{"Line":0}},{"line":1481,"address":[],"length":0,"stats":{"Line":0}},{"line":1485,"address":[],"length":0,"stats":{"Line":0}},{"line":1490,"address":[],"length":0,"stats":{"Line":0}},{"line":1497,"address":[],"length":0,"stats":{"Line":0}},{"line":1498,"address":[],"length":0,"stats":{"Line":0}},{"line":1501,"address":[],"length":0,"stats":{"Line":0}},{"line":1502,"address":[],"length":0,"stats":{"Line":0}},{"line":1503,"address":[],"length":0,"stats":{"Line":0}},{"line":1504,"address":[],"length":0,"stats":{"Line":0}},{"line":1511,"address":[],"length":0,"stats":{"Line":0}},{"line":1512,"address":[],"length":0,"stats":{"Line":0}},{"line":1513,"address":[],"length":0,"stats":{"Line":0}},{"line":1517,"address":[],"length":0,"stats":{"Line":0}},{"line":1518,"address":[],"length":0,"stats":{"Line":0}},{"line":1520,"address":[],"length":0,"stats":{"Line":0}},{"line":1521,"address":[],"length":0,"stats":{"Line":0}},{"line":1522,"address":[],"length":0,"stats":{"Line":0}},{"line":1523,"address":[],"length":0,"stats":{"Line":0}},{"line":1527,"address":[],"length":0,"stats":{"Line":0}},{"line":1528,"address":[],"length":0,"stats":{"Line":0}},{"line":1530,"address":[],"length":0,"stats":{"Line":0}},{"line":1533,"address":[],"length":0,"stats":{"Line":0}},{"line":1536,"address":[],"length":0,"stats":{"Line":0}},{"line":1538,"address":[],"length":0,"stats":{"Line":0}},{"line":1543,"address":[],"length":0,"stats":{"Line":0}},{"line":1544,"address":[],"length":0,"stats":{"Line":0}},{"line":1547,"address":[],"length":0,"stats":{"Line":0}},{"line":1550,"address":[],"length":0,"stats":{"Line":0}},{"line":1551,"address":[],"length":0,"stats":{"Line":0}},{"line":1552,"address":[],"length":0,"stats":{"Line":0}},{"line":1554,"address":[],"length":0,"stats":{"Line":0}},{"line":1555,"address":[],"length":0,"stats":{"Line":0}},{"line":1556,"address":[],"length":0,"stats":{"Line":0}},{"line":1558,"address":[],"length":0,"stats":{"Line":0}},{"line":1559,"address":[],"length":0,"stats":{"Line":0}},{"line":1561,"address":[],"length":0,"stats":{"Line":0}},{"line":1562,"address":[],"length":0,"stats":{"Line":0}},{"line":1564,"address":[],"length":0,"stats":{"Line":0}},{"line":1572,"address":[],"length":0,"stats":{"Line":0}},{"line":1573,"address":[],"length":0,"stats":{"Line":0}},{"line":1574,"address":[],"length":0,"stats":{"Line":0}},{"line":1576,"address":[],"length":0,"stats":{"Line":0}},{"line":1577,"address":[],"length":0,"stats":{"Line":0}},{"line":1578,"address":[],"length":0,"stats":{"Line":0}},{"line":1579,"address":[],"length":0,"stats":{"Line":0}},{"line":1580,"address":[],"length":0,"stats":{"Line":0}},{"line":1581,"address":[],"length":0,"stats":{"Line":0}},{"line":1588,"address":[],"length":0,"stats":{"Line":0}},{"line":1589,"address":[],"length":0,"stats":{"Line":0}},{"line":1591,"address":[],"length":0,"stats":{"Line":0}},{"line":1592,"address":[],"length":0,"stats":{"Line":0}},{"line":1595,"address":[],"length":0,"stats":{"Line":0}},{"line":1597,"address":[],"length":0,"stats":{"Line":0}},{"line":1598,"address":[],"length":0,"stats":{"Line":0}},{"line":1599,"address":[],"length":0,"stats":{"Line":0}},{"line":1600,"address":[],"length":0,"stats":{"Line":0}},{"line":1601,"address":[],"length":0,"stats":{"Line":0}},{"line":1604,"address":[],"length":0,"stats":{"Line":0}},{"line":1606,"address":[],"length":0,"stats":{"Line":0}},{"line":1607,"address":[],"length":0,"stats":{"Line":0}},{"line":1608,"address":[],"length":0,"stats":{"Line":0}},{"line":1614,"address":[],"length":0,"stats":{"Line":0}},{"line":1620,"address":[],"length":0,"stats":{"Line":0}},{"line":1626,"address":[],"length":0,"stats":{"Line":0}},{"line":1629,"address":[],"length":0,"stats":{"Line":0}},{"line":1631,"address":[],"length":0,"stats":{"Line":0}},{"line":1632,"address":[],"length":0,"stats":{"Line":0}},{"line":1633,"address":[],"length":0,"stats":{"Line":0}},{"line":1635,"address":[],"length":0,"stats":{"Line":0}},{"line":1636,"address":[],"length":0,"stats":{"Line":0}},{"line":1639,"address":[],"length":0,"stats":{"Line":0}},{"line":1640,"address":[],"length":0,"stats":{"Line":0}},{"line":1647,"address":[],"length":0,"stats":{"Line":0}},{"line":1649,"address":[],"length":0,"stats":{"Line":0}},{"line":1650,"address":[],"length":0,"stats":{"Line":0}},{"line":1651,"address":[],"length":0,"stats":{"Line":0}},{"line":1653,"address":[],"length":0,"stats":{"Line":0}},{"line":1656,"address":[],"length":0,"stats":{"Line":0}},{"line":1657,"address":[],"length":0,"stats":{"Line":0}},{"line":1662,"address":[],"length":0,"stats":{"Line":0}},{"line":1663,"address":[],"length":0,"stats":{"Line":0}},{"line":1664,"address":[],"length":0,"stats":{"Line":0}},{"line":1665,"address":[],"length":0,"stats":{"Line":0}},{"line":1666,"address":[],"length":0,"stats":{"Line":0}},{"line":1669,"address":[],"length":0,"stats":{"Line":0}},{"line":1670,"address":[],"length":0,"stats":{"Line":0}},{"line":1674,"address":[],"length":0,"stats":{"Line":0}},{"line":1675,"address":[],"length":0,"stats":{"Line":0}},{"line":1676,"address":[],"length":0,"stats":{"Line":0}},{"line":1677,"address":[],"length":0,"stats":{"Line":0}},{"line":1681,"address":[],"length":0,"stats":{"Line":0}},{"line":1682,"address":[],"length":0,"stats":{"Line":0}},{"line":1683,"address":[],"length":0,"stats":{"Line":0}},{"line":1685,"address":[],"length":0,"stats":{"Line":0}},{"line":1686,"address":[],"length":0,"stats":{"Line":0}},{"line":1687,"address":[],"length":0,"stats":{"Line":0}},{"line":1688,"address":[],"length":0,"stats":{"Line":0}},{"line":1689,"address":[],"length":0,"stats":{"Line":0}},{"line":1698,"address":[],"length":0,"stats":{"Line":0}},{"line":1699,"address":[],"length":0,"stats":{"Line":0}},{"line":1701,"address":[],"length":0,"stats":{"Line":0}},{"line":1702,"address":[],"length":0,"stats":{"Line":0}},{"line":1703,"address":[],"length":0,"stats":{"Line":0}},{"line":1706,"address":[],"length":0,"stats":{"Line":0}},{"line":1707,"address":[],"length":0,"stats":{"Line":0}},{"line":1708,"address":[],"length":0,"stats":{"Line":0}},{"line":1709,"address":[],"length":0,"stats":{"Line":0}},{"line":1710,"address":[],"length":0,"stats":{"Line":0}},{"line":1711,"address":[],"length":0,"stats":{"Line":0}},{"line":1714,"address":[],"length":0,"stats":{"Line":0}},{"line":1715,"address":[],"length":0,"stats":{"Line":0}},{"line":1716,"address":[],"length":0,"stats":{"Line":0}},{"line":1717,"address":[],"length":0,"stats":{"Line":0}},{"line":1724,"address":[],"length":0,"stats":{"Line":0}},{"line":1729,"address":[],"length":0,"stats":{"Line":0}},{"line":1730,"address":[],"length":0,"stats":{"Line":0}},{"line":1731,"address":[],"length":0,"stats":{"Line":0}},{"line":1732,"address":[],"length":0,"stats":{"Line":0}},{"line":1733,"address":[],"length":0,"stats":{"Line":0}},{"line":1734,"address":[],"length":0,"stats":{"Line":0}},{"line":1738,"address":[],"length":0,"stats":{"Line":0}},{"line":1742,"address":[],"length":0,"stats":{"Line":7628}},{"line":1743,"address":[],"length":0,"stats":{"Line":22884}},{"line":1744,"address":[],"length":0,"stats":{"Line":7628}},{"line":1746,"address":[],"length":0,"stats":{"Line":5454020}},{"line":1747,"address":[],"length":0,"stats":{"Line":7628}},{"line":1749,"address":[],"length":0,"stats":{"Line":15256}},{"line":1750,"address":[],"length":0,"stats":{"Line":7628}},{"line":1756,"address":[],"length":0,"stats":{"Line":0}},{"line":1761,"address":[],"length":0,"stats":{"Line":0}},{"line":1762,"address":[],"length":0,"stats":{"Line":0}},{"line":1763,"address":[],"length":0,"stats":{"Line":0}},{"line":1765,"address":[],"length":0,"stats":{"Line":0}},{"line":1766,"address":[],"length":0,"stats":{"Line":0}},{"line":1767,"address":[],"length":0,"stats":{"Line":0}},{"line":1768,"address":[],"length":0,"stats":{"Line":0}},{"line":1769,"address":[],"length":0,"stats":{"Line":0}},{"line":1770,"address":[],"length":0,"stats":{"Line":0}},{"line":1771,"address":[],"length":0,"stats":{"Line":0}},{"line":1773,"address":[],"length":0,"stats":{"Line":0}},{"line":1775,"address":[],"length":0,"stats":{"Line":0}},{"line":1776,"address":[],"length":0,"stats":{"Line":0}},{"line":1780,"address":[],"length":0,"stats":{"Line":203}},{"line":1785,"address":[],"length":0,"stats":{"Line":203}},{"line":1786,"address":[],"length":0,"stats":{"Line":812}},{"line":1787,"address":[],"length":0,"stats":{"Line":525}},{"line":1792,"address":[],"length":0,"stats":{"Line":204}},{"line":1793,"address":[],"length":0,"stats":{"Line":950}},{"line":1795,"address":[],"length":0,"stats":{"Line":402}},{"line":1796,"address":[],"length":0,"stats":{"Line":402}},{"line":1797,"address":[],"length":0,"stats":{"Line":134}},{"line":1798,"address":[],"length":0,"stats":{"Line":658}},{"line":1799,"address":[],"length":0,"stats":{"Line":398}},{"line":1800,"address":[],"length":0,"stats":{"Line":134}},{"line":1802,"address":[],"length":0,"stats":{"Line":134}},{"line":1803,"address":[],"length":0,"stats":{"Line":264}},{"line":1807,"address":[],"length":0,"stats":{"Line":6}},{"line":1808,"address":[],"length":0,"stats":{"Line":2}},{"line":1809,"address":[],"length":0,"stats":{"Line":6}},{"line":1810,"address":[],"length":0,"stats":{"Line":2}},{"line":1811,"address":[],"length":0,"stats":{"Line":2}},{"line":1813,"address":[],"length":0,"stats":{"Line":2}},{"line":1814,"address":[],"length":0,"stats":{"Line":0}},{"line":1818,"address":[],"length":0,"stats":{"Line":6}},{"line":1819,"address":[],"length":0,"stats":{"Line":2}},{"line":1820,"address":[],"length":0,"stats":{"Line":6}},{"line":1821,"address":[],"length":0,"stats":{"Line":4}},{"line":1822,"address":[],"length":0,"stats":{"Line":2}},{"line":1824,"address":[],"length":0,"stats":{"Line":2}},{"line":1825,"address":[],"length":0,"stats":{"Line":2}},{"line":1829,"address":[],"length":0,"stats":{"Line":4}},{"line":1834,"address":[],"length":0,"stats":{"Line":205}},{"line":1840,"address":[],"length":0,"stats":{"Line":205}},{"line":1841,"address":[],"length":0,"stats":{"Line":820}},{"line":1842,"address":[],"length":0,"stats":{"Line":1021}},{"line":1846,"address":[],"length":0,"stats":{"Line":1865}},{"line":1847,"address":[],"length":0,"stats":{"Line":7460}},{"line":1851,"address":[],"length":0,"stats":{"Line":1870}},{"line":1852,"address":[],"length":0,"stats":{"Line":8353}},{"line":1854,"address":[],"length":0,"stats":{"Line":2619}},{"line":1855,"address":[],"length":0,"stats":{"Line":2619}},{"line":1856,"address":[],"length":0,"stats":{"Line":873}},{"line":1857,"address":[],"length":0,"stats":{"Line":4253}},{"line":1858,"address":[],"length":0,"stats":{"Line":2521}},{"line":1859,"address":[],"length":0,"stats":{"Line":873}},{"line":1861,"address":[],"length":0,"stats":{"Line":873}},{"line":1862,"address":[],"length":0,"stats":{"Line":1648}},{"line":1866,"address":[],"length":0,"stats":{"Line":147}},{"line":1867,"address":[],"length":0,"stats":{"Line":49}},{"line":1868,"address":[],"length":0,"stats":{"Line":147}},{"line":1869,"address":[],"length":0,"stats":{"Line":51}},{"line":1870,"address":[],"length":0,"stats":{"Line":49}},{"line":1872,"address":[],"length":0,"stats":{"Line":49}},{"line":1873,"address":[],"length":0,"stats":{"Line":2}},{"line":1877,"address":[],"length":0,"stats":{"Line":144}},{"line":1878,"address":[],"length":0,"stats":{"Line":48}},{"line":1879,"address":[],"length":0,"stats":{"Line":144}},{"line":1880,"address":[],"length":0,"stats":{"Line":144}},{"line":1881,"address":[],"length":0,"stats":{"Line":48}},{"line":1883,"address":[],"length":0,"stats":{"Line":48}},{"line":1884,"address":[],"length":0,"stats":{"Line":96}},{"line":1888,"address":[],"length":0,"stats":{"Line":0}},{"line":1893,"address":[],"length":0,"stats":{"Line":2}},{"line":1894,"address":[],"length":0,"stats":{"Line":9}},{"line":1896,"address":[],"length":0,"stats":{"Line":3}},{"line":1897,"address":[],"length":0,"stats":{"Line":3}},{"line":1898,"address":[],"length":0,"stats":{"Line":1}},{"line":1899,"address":[],"length":0,"stats":{"Line":3}},{"line":1900,"address":[],"length":0,"stats":{"Line":3}},{"line":1901,"address":[],"length":0,"stats":{"Line":1}},{"line":1903,"address":[],"length":0,"stats":{"Line":1}},{"line":1904,"address":[],"length":0,"stats":{"Line":2}},{"line":1908,"address":[],"length":0,"stats":{"Line":0}},{"line":1909,"address":[],"length":0,"stats":{"Line":0}},{"line":1910,"address":[],"length":0,"stats":{"Line":0}},{"line":1911,"address":[],"length":0,"stats":{"Line":0}},{"line":1912,"address":[],"length":0,"stats":{"Line":0}},{"line":1914,"address":[],"length":0,"stats":{"Line":0}},{"line":1915,"address":[],"length":0,"stats":{"Line":0}},{"line":1919,"address":[],"length":0,"stats":{"Line":0}},{"line":1920,"address":[],"length":0,"stats":{"Line":0}},{"line":1921,"address":[],"length":0,"stats":{"Line":0}},{"line":1922,"address":[],"length":0,"stats":{"Line":0}},{"line":1923,"address":[],"length":0,"stats":{"Line":0}},{"line":1925,"address":[],"length":0,"stats":{"Line":0}},{"line":1926,"address":[],"length":0,"stats":{"Line":0}},{"line":1930,"address":[],"length":0,"stats":{"Line":0}},{"line":1935,"address":[],"length":0,"stats":{"Line":3}},{"line":1936,"address":[],"length":0,"stats":{"Line":3}},{"line":1937,"address":[],"length":0,"stats":{"Line":12}},{"line":1938,"address":[],"length":0,"stats":{"Line":5}},{"line":1939,"address":[],"length":0,"stats":{"Line":2}},{"line":1940,"address":[],"length":0,"stats":{"Line":2}},{"line":1941,"address":[],"length":0,"stats":{"Line":2}},{"line":1942,"address":[],"length":0,"stats":{"Line":4}},{"line":1947,"address":[],"length":0,"stats":{"Line":17}},{"line":1948,"address":[],"length":0,"stats":{"Line":14150}},{"line":1949,"address":[],"length":0,"stats":{"Line":17}},{"line":1950,"address":[],"length":0,"stats":{"Line":34}},{"line":1951,"address":[],"length":0,"stats":{"Line":17}},{"line":1955,"address":[],"length":0,"stats":{"Line":2}},{"line":1956,"address":[],"length":0,"stats":{"Line":2}},{"line":1960,"address":[],"length":0,"stats":{"Line":2}},{"line":1962,"address":[],"length":0,"stats":{"Line":4}},{"line":1963,"address":[],"length":0,"stats":{"Line":10}},{"line":1964,"address":[],"length":0,"stats":{"Line":4}},{"line":1965,"address":[],"length":0,"stats":{"Line":4}},{"line":1973,"address":[],"length":0,"stats":{"Line":205}},{"line":1974,"address":[],"length":0,"stats":{"Line":822}},{"line":1975,"address":[],"length":0,"stats":{"Line":6}},{"line":1977,"address":[],"length":0,"stats":{"Line":11}},{"line":1978,"address":[],"length":0,"stats":{"Line":1}},{"line":1981,"address":[],"length":0,"stats":{"Line":9}},{"line":1982,"address":[],"length":0,"stats":{"Line":1}},{"line":1985,"address":[],"length":0,"stats":{"Line":0}},{"line":1991,"address":[],"length":0,"stats":{"Line":204}},{"line":1992,"address":[],"length":0,"stats":{"Line":817}},{"line":1993,"address":[],"length":0,"stats":{"Line":3}},{"line":1994,"address":[],"length":0,"stats":{"Line":5}},{"line":1995,"address":[],"length":0,"stats":{"Line":1}},{"line":1997,"address":[],"length":0,"stats":{"Line":0}},{"line":1998,"address":[],"length":0,"stats":{"Line":0}},{"line":2000,"address":[],"length":0,"stats":{"Line":0}},{"line":2006,"address":[],"length":0,"stats":{"Line":2}},{"line":2007,"address":[],"length":0,"stats":{"Line":10}},{"line":2008,"address":[],"length":0,"stats":{"Line":6}},{"line":2009,"address":[],"length":0,"stats":{"Line":9}},{"line":2010,"address":[],"length":0,"stats":{"Line":1}},{"line":2012,"address":[],"length":0,"stats":{"Line":6}},{"line":2013,"address":[],"length":0,"stats":{"Line":1}},{"line":2015,"address":[],"length":0,"stats":{"Line":0}},{"line":2020,"address":[],"length":0,"stats":{"Line":203}},{"line":2021,"address":[],"length":0,"stats":{"Line":813}},{"line":2022,"address":[],"length":0,"stats":{"Line":3}},{"line":2023,"address":[],"length":0,"stats":{"Line":5}},{"line":2024,"address":[],"length":0,"stats":{"Line":1}},{"line":2026,"address":[],"length":0,"stats":{"Line":0}},{"line":2027,"address":[],"length":0,"stats":{"Line":0}},{"line":2029,"address":[],"length":0,"stats":{"Line":0}},{"line":2035,"address":[],"length":0,"stats":{"Line":2}},{"line":2036,"address":[],"length":0,"stats":{"Line":6}},{"line":2037,"address":[],"length":0,"stats":{"Line":2}},{"line":2039,"address":[],"length":0,"stats":{"Line":14}},{"line":2040,"address":[],"length":0,"stats":{"Line":2}},{"line":2042,"address":[],"length":0,"stats":{"Line":4}},{"line":2043,"address":[],"length":0,"stats":{"Line":2}},{"line":2047,"address":[],"length":0,"stats":{"Line":0}},{"line":2048,"address":[],"length":0,"stats":{"Line":0}},{"line":2049,"address":[],"length":0,"stats":{"Line":0}},{"line":2050,"address":[],"length":0,"stats":{"Line":0}},{"line":2056,"address":[],"length":0,"stats":{"Line":0}},{"line":2057,"address":[],"length":0,"stats":{"Line":0}},{"line":2058,"address":[],"length":0,"stats":{"Line":0}},{"line":2059,"address":[],"length":0,"stats":{"Line":0}},{"line":2060,"address":[],"length":0,"stats":{"Line":0}},{"line":2061,"address":[],"length":0,"stats":{"Line":0}},{"line":2062,"address":[],"length":0,"stats":{"Line":0}},{"line":2068,"address":[],"length":0,"stats":{"Line":0}},{"line":2069,"address":[],"length":0,"stats":{"Line":0}},{"line":2073,"address":[],"length":0,"stats":{"Line":0}},{"line":2074,"address":[],"length":0,"stats":{"Line":0}},{"line":2075,"address":[],"length":0,"stats":{"Line":0}},{"line":2076,"address":[],"length":0,"stats":{"Line":0}},{"line":2081,"address":[],"length":0,"stats":{"Line":0}},{"line":2082,"address":[],"length":0,"stats":{"Line":0}},{"line":2087,"address":[],"length":0,"stats":{"Line":0}},{"line":2089,"address":[],"length":0,"stats":{"Line":0}},{"line":2090,"address":[],"length":0,"stats":{"Line":0}},{"line":2092,"address":[],"length":0,"stats":{"Line":0}},{"line":2093,"address":[],"length":0,"stats":{"Line":0}},{"line":2095,"address":[],"length":0,"stats":{"Line":0}},{"line":2097,"address":[],"length":0,"stats":{"Line":0}},{"line":2100,"address":[],"length":0,"stats":{"Line":0}},{"line":2101,"address":[],"length":0,"stats":{"Line":0}},{"line":2105,"address":[],"length":0,"stats":{"Line":0}},{"line":2108,"address":[],"length":0,"stats":{"Line":0}},{"line":2111,"address":[],"length":0,"stats":{"Line":0}},{"line":2113,"address":[],"length":0,"stats":{"Line":0}},{"line":2119,"address":[],"length":0,"stats":{"Line":0}},{"line":2124,"address":[],"length":0,"stats":{"Line":0}},{"line":2127,"address":[],"length":0,"stats":{"Line":0}},{"line":2128,"address":[],"length":0,"stats":{"Line":0}},{"line":2129,"address":[],"length":0,"stats":{"Line":0}},{"line":2131,"address":[],"length":0,"stats":{"Line":0}},{"line":2136,"address":[],"length":0,"stats":{"Line":0}},{"line":2137,"address":[],"length":0,"stats":{"Line":0}},{"line":2138,"address":[],"length":0,"stats":{"Line":0}},{"line":2139,"address":[],"length":0,"stats":{"Line":0}},{"line":2144,"address":[],"length":0,"stats":{"Line":0}},{"line":2145,"address":[],"length":0,"stats":{"Line":0}},{"line":2146,"address":[],"length":0,"stats":{"Line":0}},{"line":2147,"address":[],"length":0,"stats":{"Line":0}},{"line":2152,"address":[],"length":0,"stats":{"Line":0}},{"line":2153,"address":[],"length":0,"stats":{"Line":0}},{"line":2154,"address":[],"length":0,"stats":{"Line":0}},{"line":2155,"address":[],"length":0,"stats":{"Line":0}},{"line":2160,"address":[],"length":0,"stats":{"Line":0}},{"line":2161,"address":[],"length":0,"stats":{"Line":0}},{"line":2165,"address":[],"length":0,"stats":{"Line":0}},{"line":2166,"address":[],"length":0,"stats":{"Line":0}},{"line":2171,"address":[],"length":0,"stats":{"Line":0}},{"line":2172,"address":[],"length":0,"stats":{"Line":0}},{"line":2175,"address":[],"length":0,"stats":{"Line":0}},{"line":2176,"address":[],"length":0,"stats":{"Line":0}},{"line":2178,"address":[],"length":0,"stats":{"Line":0}},{"line":2179,"address":[],"length":0,"stats":{"Line":0}},{"line":2180,"address":[],"length":0,"stats":{"Line":0}},{"line":2181,"address":[],"length":0,"stats":{"Line":0}},{"line":2182,"address":[],"length":0,"stats":{"Line":0}},{"line":2187,"address":[],"length":0,"stats":{"Line":0}},{"line":2188,"address":[],"length":0,"stats":{"Line":0}},{"line":2190,"address":[],"length":0,"stats":{"Line":0}},{"line":2191,"address":[],"length":0,"stats":{"Line":0}},{"line":2193,"address":[],"length":0,"stats":{"Line":0}},{"line":2194,"address":[],"length":0,"stats":{"Line":0}},{"line":2195,"address":[],"length":0,"stats":{"Line":0}},{"line":2196,"address":[],"length":0,"stats":{"Line":0}},{"line":2197,"address":[],"length":0,"stats":{"Line":0}},{"line":2198,"address":[],"length":0,"stats":{"Line":0}},{"line":2202,"address":[],"length":0,"stats":{"Line":0}},{"line":2205,"address":[],"length":0,"stats":{"Line":0}},{"line":2210,"address":[],"length":0,"stats":{"Line":0}},{"line":2211,"address":[],"length":0,"stats":{"Line":0}},{"line":2212,"address":[],"length":0,"stats":{"Line":0}},{"line":2213,"address":[],"length":0,"stats":{"Line":0}},{"line":2217,"address":[],"length":0,"stats":{"Line":0}},{"line":2218,"address":[],"length":0,"stats":{"Line":0}},{"line":2219,"address":[],"length":0,"stats":{"Line":0}},{"line":2220,"address":[],"length":0,"stats":{"Line":0}},{"line":2221,"address":[],"length":0,"stats":{"Line":0}},{"line":2222,"address":[],"length":0,"stats":{"Line":0}},{"line":2223,"address":[],"length":0,"stats":{"Line":0}},{"line":2224,"address":[],"length":0,"stats":{"Line":0}},{"line":2225,"address":[],"length":0,"stats":{"Line":0}},{"line":2226,"address":[],"length":0,"stats":{"Line":0}},{"line":2228,"address":[],"length":0,"stats":{"Line":0}},{"line":2232,"address":[],"length":0,"stats":{"Line":0}},{"line":2236,"address":[],"length":0,"stats":{"Line":0}},{"line":2237,"address":[],"length":0,"stats":{"Line":0}},{"line":2238,"address":[],"length":0,"stats":{"Line":0}},{"line":2240,"address":[],"length":0,"stats":{"Line":0}},{"line":2241,"address":[],"length":0,"stats":{"Line":0}},{"line":2243,"address":[],"length":0,"stats":{"Line":0}},{"line":2244,"address":[],"length":0,"stats":{"Line":0}},{"line":2245,"address":[],"length":0,"stats":{"Line":0}},{"line":2246,"address":[],"length":0,"stats":{"Line":0}},{"line":2251,"address":[],"length":0,"stats":{"Line":0}},{"line":2256,"address":[],"length":0,"stats":{"Line":66918}},{"line":2257,"address":[],"length":0,"stats":{"Line":66918}},{"line":2258,"address":[],"length":0,"stats":{"Line":133836}},{"line":2259,"address":[],"length":0,"stats":{"Line":200754}},{"line":2264,"address":[],"length":0,"stats":{"Line":12426}},{"line":2265,"address":[],"length":0,"stats":{"Line":86982}},{"line":2268,"address":[],"length":0,"stats":{"Line":4379}},{"line":2269,"address":[],"length":0,"stats":{"Line":27425}},{"line":2272,"address":[],"length":0,"stats":{"Line":591}},{"line":2273,"address":[],"length":0,"stats":{"Line":4137}},{"line":2276,"address":[],"length":0,"stats":{"Line":0}},{"line":2277,"address":[],"length":0,"stats":{"Line":0}},{"line":2278,"address":[],"length":0,"stats":{"Line":0}},{"line":2279,"address":[],"length":0,"stats":{"Line":0}},{"line":2280,"address":[],"length":0,"stats":{"Line":0}},{"line":2281,"address":[],"length":0,"stats":{"Line":0}},{"line":2282,"address":[],"length":0,"stats":{"Line":0}},{"line":2283,"address":[],"length":0,"stats":{"Line":0}},{"line":2284,"address":[],"length":0,"stats":{"Line":0}},{"line":2299,"address":[],"length":0,"stats":{"Line":1}},{"line":2302,"address":[],"length":0,"stats":{"Line":1}},{"line":2306,"address":[],"length":0,"stats":{"Line":0}},{"line":2307,"address":[],"length":0,"stats":{"Line":0}},{"line":2318,"address":[],"length":0,"stats":{"Line":2}},{"line":2319,"address":[],"length":0,"stats":{"Line":6}},{"line":2323,"address":[],"length":0,"stats":{"Line":0}},{"line":2324,"address":[],"length":0,"stats":{"Line":0}},{"line":2325,"address":[],"length":0,"stats":{"Line":0}},{"line":2326,"address":[],"length":0,"stats":{"Line":0}},{"line":2332,"address":[],"length":0,"stats":{"Line":0}},{"line":2333,"address":[],"length":0,"stats":{"Line":0}},{"line":2334,"address":[],"length":0,"stats":{"Line":0}},{"line":2335,"address":[],"length":0,"stats":{"Line":0}},{"line":2341,"address":[],"length":0,"stats":{"Line":0}},{"line":2342,"address":[],"length":0,"stats":{"Line":0}},{"line":2343,"address":[],"length":0,"stats":{"Line":0}},{"line":2344,"address":[],"length":0,"stats":{"Line":0}},{"line":2345,"address":[],"length":0,"stats":{"Line":0}},{"line":2346,"address":[],"length":0,"stats":{"Line":0}},{"line":2347,"address":[],"length":0,"stats":{"Line":0}},{"line":2350,"address":[],"length":0,"stats":{"Line":0}},{"line":2354,"address":[],"length":0,"stats":{"Line":1}},{"line":2355,"address":[],"length":0,"stats":{"Line":3}},{"line":2359,"address":[],"length":0,"stats":{"Line":2}},{"line":2361,"address":[],"length":0,"stats":{"Line":1}},{"line":2362,"address":[],"length":0,"stats":{"Line":2}},{"line":2364,"address":[],"length":0,"stats":{"Line":0}},{"line":2365,"address":[],"length":0,"stats":{"Line":0}},{"line":2366,"address":[],"length":0,"stats":{"Line":0}},{"line":2367,"address":[],"length":0,"stats":{"Line":0}},{"line":2368,"address":[],"length":0,"stats":{"Line":0}},{"line":2369,"address":[],"length":0,"stats":{"Line":0}},{"line":2370,"address":[],"length":0,"stats":{"Line":0}},{"line":2371,"address":[],"length":0,"stats":{"Line":0}},{"line":2372,"address":[],"length":0,"stats":{"Line":0}},{"line":2373,"address":[],"length":0,"stats":{"Line":0}},{"line":2374,"address":[],"length":0,"stats":{"Line":0}},{"line":2375,"address":[],"length":0,"stats":{"Line":0}},{"line":2376,"address":[],"length":0,"stats":{"Line":0}},{"line":2377,"address":[],"length":0,"stats":{"Line":0}},{"line":2378,"address":[],"length":0,"stats":{"Line":0}},{"line":2379,"address":[],"length":0,"stats":{"Line":0}},{"line":2380,"address":[],"length":0,"stats":{"Line":0}},{"line":2381,"address":[],"length":0,"stats":{"Line":0}},{"line":2382,"address":[],"length":0,"stats":{"Line":0}},{"line":2383,"address":[],"length":0,"stats":{"Line":0}},{"line":2384,"address":[],"length":0,"stats":{"Line":0}},{"line":2385,"address":[],"length":0,"stats":{"Line":0}},{"line":2386,"address":[],"length":0,"stats":{"Line":0}},{"line":2387,"address":[],"length":0,"stats":{"Line":0}},{"line":2388,"address":[],"length":0,"stats":{"Line":0}},{"line":2389,"address":[],"length":0,"stats":{"Line":0}},{"line":2390,"address":[],"length":0,"stats":{"Line":0}},{"line":2398,"address":[],"length":0,"stats":{"Line":3}},{"line":2402,"address":[],"length":0,"stats":{"Line":2}},{"line":2404,"address":[],"length":0,"stats":{"Line":1}},{"line":2405,"address":[],"length":0,"stats":{"Line":3}},{"line":2406,"address":[],"length":0,"stats":{"Line":2}},{"line":2407,"address":[],"length":0,"stats":{"Line":3}},{"line":2408,"address":[],"length":0,"stats":{"Line":3}},{"line":2409,"address":[],"length":0,"stats":{"Line":3}},{"line":2410,"address":[],"length":0,"stats":{"Line":3}},{"line":2411,"address":[],"length":0,"stats":{"Line":3}},{"line":2412,"address":[],"length":0,"stats":{"Line":3}},{"line":2413,"address":[],"length":0,"stats":{"Line":3}},{"line":2414,"address":[],"length":0,"stats":{"Line":3}},{"line":2415,"address":[],"length":0,"stats":{"Line":3}},{"line":2416,"address":[],"length":0,"stats":{"Line":3}},{"line":2417,"address":[],"length":0,"stats":{"Line":3}},{"line":2418,"address":[],"length":0,"stats":{"Line":3}},{"line":2419,"address":[],"length":0,"stats":{"Line":3}},{"line":2420,"address":[],"length":0,"stats":{"Line":3}},{"line":2421,"address":[],"length":0,"stats":{"Line":3}},{"line":2422,"address":[],"length":0,"stats":{"Line":3}},{"line":2423,"address":[],"length":0,"stats":{"Line":3}},{"line":2424,"address":[],"length":0,"stats":{"Line":3}},{"line":2425,"address":[],"length":0,"stats":{"Line":3}},{"line":2426,"address":[],"length":0,"stats":{"Line":3}},{"line":2427,"address":[],"length":0,"stats":{"Line":3}},{"line":2428,"address":[],"length":0,"stats":{"Line":3}},{"line":2429,"address":[],"length":0,"stats":{"Line":3}},{"line":2430,"address":[],"length":0,"stats":{"Line":3}},{"line":2431,"address":[],"length":0,"stats":{"Line":1}},{"line":2436,"address":[],"length":0,"stats":{"Line":1}},{"line":2441,"address":[],"length":0,"stats":{"Line":37}},{"line":2444,"address":[],"length":0,"stats":{"Line":37}},{"line":2446,"address":[],"length":0,"stats":{"Line":111}},{"line":2447,"address":[],"length":0,"stats":{"Line":111}},{"line":2448,"address":[],"length":0,"stats":{"Line":111}},{"line":2449,"address":[],"length":0,"stats":{"Line":111}},{"line":2450,"address":[],"length":0,"stats":{"Line":111}},{"line":2451,"address":[],"length":0,"stats":{"Line":111}},{"line":2455,"address":[],"length":0,"stats":{"Line":1}},{"line":2457,"address":[],"length":0,"stats":{"Line":2}},{"line":2458,"address":[],"length":0,"stats":{"Line":2}},{"line":2459,"address":[],"length":0,"stats":{"Line":2}},{"line":2460,"address":[],"length":0,"stats":{"Line":2}},{"line":2461,"address":[],"length":0,"stats":{"Line":2}},{"line":2462,"address":[],"length":0,"stats":{"Line":2}},{"line":2463,"address":[],"length":0,"stats":{"Line":2}},{"line":2464,"address":[],"length":0,"stats":{"Line":2}},{"line":2465,"address":[],"length":0,"stats":{"Line":2}},{"line":2466,"address":[],"length":0,"stats":{"Line":2}},{"line":2467,"address":[],"length":0,"stats":{"Line":2}},{"line":2468,"address":[],"length":0,"stats":{"Line":2}},{"line":2469,"address":[],"length":0,"stats":{"Line":2}},{"line":2470,"address":[],"length":0,"stats":{"Line":2}},{"line":2471,"address":[],"length":0,"stats":{"Line":2}},{"line":2472,"address":[],"length":0,"stats":{"Line":2}},{"line":2473,"address":[],"length":0,"stats":{"Line":2}},{"line":2474,"address":[],"length":0,"stats":{"Line":2}},{"line":2475,"address":[],"length":0,"stats":{"Line":2}},{"line":2476,"address":[],"length":0,"stats":{"Line":2}},{"line":2477,"address":[],"length":0,"stats":{"Line":2}},{"line":2478,"address":[],"length":0,"stats":{"Line":2}},{"line":2479,"address":[],"length":0,"stats":{"Line":1}},{"line":2484,"address":[],"length":0,"stats":{"Line":3}},{"line":2487,"address":[],"length":0,"stats":{"Line":3}},{"line":2489,"address":[],"length":0,"stats":{"Line":38}},{"line":2490,"address":[],"length":0,"stats":{"Line":111}},{"line":2491,"address":[],"length":0,"stats":{"Line":74}},{"line":2492,"address":[],"length":0,"stats":{"Line":37}},{"line":2493,"address":[],"length":0,"stats":{"Line":111}},{"line":2498,"address":[],"length":0,"stats":{"Line":112}},{"line":2500,"address":[],"length":0,"stats":{"Line":1525}},{"line":2501,"address":[],"length":0,"stats":{"Line":1488}},{"line":2503,"address":[],"length":0,"stats":{"Line":11313}},{"line":2504,"address":[],"length":0,"stats":{"Line":11276}},{"line":2506,"address":[],"length":0,"stats":{"Line":1165}},{"line":2507,"address":[],"length":0,"stats":{"Line":1128}},{"line":2511,"address":[],"length":0,"stats":{"Line":1285}},{"line":2513,"address":[],"length":0,"stats":{"Line":1248}},{"line":2515,"address":[],"length":0,"stats":{"Line":416}},{"line":2516,"address":[],"length":0,"stats":{"Line":416}},{"line":2517,"address":[],"length":0,"stats":{"Line":832}},{"line":2518,"address":[],"length":0,"stats":{"Line":475}},{"line":2520,"address":[],"length":0,"stats":{"Line":59}},{"line":2521,"address":[],"length":0,"stats":{"Line":236}},{"line":2522,"address":[],"length":0,"stats":{"Line":118}},{"line":2523,"address":[],"length":0,"stats":{"Line":177}},{"line":2528,"address":[],"length":0,"stats":{"Line":109}},{"line":2529,"address":[],"length":0,"stats":{"Line":65}},{"line":2531,"address":[],"length":0,"stats":{"Line":12}},{"line":2534,"address":[],"length":0,"stats":{"Line":832}},{"line":2536,"address":[],"length":0,"stats":{"Line":993}},{"line":2537,"address":[],"length":0,"stats":{"Line":956}},{"line":2539,"address":[],"length":0,"stats":{"Line":111}},{"line":2542,"address":[],"length":0,"stats":{"Line":111}},{"line":2543,"address":[],"length":0,"stats":{"Line":737}},{"line":2544,"address":[],"length":0,"stats":{"Line":700}},{"line":2546,"address":[],"length":0,"stats":{"Line":37}},{"line":2547,"address":[],"length":0,"stats":{"Line":0}},{"line":2548,"address":[],"length":0,"stats":{"Line":0}},{"line":2549,"address":[],"length":0,"stats":{"Line":0}},{"line":2551,"address":[],"length":0,"stats":{"Line":0}},{"line":2555,"address":[],"length":0,"stats":{"Line":201}},{"line":2556,"address":[],"length":0,"stats":{"Line":164}},{"line":2558,"address":[],"length":0,"stats":{"Line":37}},{"line":2559,"address":[],"length":0,"stats":{"Line":0}},{"line":2561,"address":[],"length":0,"stats":{"Line":37}},{"line":2562,"address":[],"length":0,"stats":{"Line":0}},{"line":2564,"address":[],"length":0,"stats":{"Line":37}},{"line":2565,"address":[],"length":0,"stats":{"Line":0}},{"line":2569,"address":[],"length":0,"stats":{"Line":111}},{"line":2570,"address":[],"length":0,"stats":{"Line":37}},{"line":2571,"address":[],"length":0,"stats":{"Line":0}},{"line":2575,"address":[],"length":0,"stats":{"Line":37}},{"line":2576,"address":[],"length":0,"stats":{"Line":0}},{"line":2578,"address":[],"length":0,"stats":{"Line":111}},{"line":2579,"address":[],"length":0,"stats":{"Line":37}},{"line":2580,"address":[],"length":0,"stats":{"Line":0}},{"line":2584,"address":[],"length":0,"stats":{"Line":111}},{"line":2585,"address":[],"length":0,"stats":{"Line":2793}},{"line":2586,"address":[],"length":0,"stats":{"Line":2756}},{"line":2588,"address":[],"length":0,"stats":{"Line":37}},{"line":2589,"address":[],"length":0,"stats":{"Line":0}},{"line":2591,"address":[],"length":0,"stats":{"Line":37}},{"line":2592,"address":[],"length":0,"stats":{"Line":0}},{"line":2594,"address":[],"length":0,"stats":{"Line":111}},{"line":2597,"address":[],"length":0,"stats":{"Line":75}},{"line":2598,"address":[],"length":0,"stats":{"Line":1}},{"line":2603,"address":[],"length":0,"stats":{"Line":212}},{"line":2604,"address":[],"length":0,"stats":{"Line":420}},{"line":2605,"address":[],"length":0,"stats":{"Line":3002}},{"line":2608,"address":[],"length":0,"stats":{"Line":346}},{"line":2609,"address":[],"length":0,"stats":{"Line":688}},{"line":2610,"address":[],"length":0,"stats":{"Line":1284}},{"line":2613,"address":[],"length":0,"stats":{"Line":1935}},{"line":2614,"address":[],"length":0,"stats":{"Line":3866}},{"line":2615,"address":[],"length":0,"stats":{"Line":13313}},{"line":2618,"address":[],"length":0,"stats":{"Line":263}},{"line":2619,"address":[],"length":0,"stats":{"Line":522}},{"line":2620,"address":[],"length":0,"stats":{"Line":979}},{"line":2623,"address":[],"length":0,"stats":{"Line":43}},{"line":2624,"address":[],"length":0,"stats":{"Line":82}},{"line":2625,"address":[],"length":0,"stats":{"Line":101}},{"line":2628,"address":[],"length":0,"stats":{"Line":2}},{"line":2629,"address":[],"length":0,"stats":{"Line":0}},{"line":2630,"address":[],"length":0,"stats":{"Line":0}},{"line":2633,"address":[],"length":0,"stats":{"Line":2}},{"line":2634,"address":[],"length":0,"stats":{"Line":0}},{"line":2635,"address":[],"length":0,"stats":{"Line":0}},{"line":2638,"address":[],"length":0,"stats":{"Line":2}},{"line":2639,"address":[],"length":0,"stats":{"Line":0}},{"line":2640,"address":[],"length":0,"stats":{"Line":0}},{"line":2644,"address":[],"length":0,"stats":{"Line":2}},{"line":2645,"address":[],"length":0,"stats":{"Line":0}},{"line":2646,"address":[],"length":0,"stats":{"Line":0}},{"line":2650,"address":[],"length":0,"stats":{"Line":2}},{"line":2651,"address":[],"length":0,"stats":{"Line":0}},{"line":2652,"address":[],"length":0,"stats":{"Line":0}},{"line":2656,"address":[],"length":0,"stats":{"Line":141}},{"line":2657,"address":[],"length":0,"stats":{"Line":278}},{"line":2658,"address":[],"length":0,"stats":{"Line":518}},{"line":2661,"address":[],"length":0,"stats":{"Line":1}}],"covered":580,"coverable":1203},{"path":["/","workspace","crates","ofml-lib","src","oap","ocd_relation.rs"],"content":"//! OCD Relation Rules Parser and Evaluator\r\n//!\r\n//! This module handles the ocd_relation rules that assign $VarCond values\r\n//! based on property conditions. These are used for pricing surcharge matching\r\n//! when the simpler propvalue2varcond table is not present.\r\n//!\r\n//! Rule syntax examples:\r\n//! - `$VarCond = 'PG_ADJUSTABLE_SEAT' if (M_ARTNO = 'ONE' and M_SEAT = 'YES')`\r\n//! - `$VarCond = 'PG_LAN' if M_LAN = 'YES'`\r\n//! - `M_TXT_COLOR = 'RAL9005' if M_EXTERIOR in ('RAL9016MAT','NCSS2010Y20R')`\r\n\r\nuse std::collections::{HashMap, HashSet};\r\nuse std::path::Path;\r\n\r\nuse tracing::{debug, trace, warn};\r\n\r\nuse crate::ebase::EBaseReader;\r\n\r\n/// A parsed relation rule for $VarCond assignment\r\n#[derive(Debug, Clone)]\r\npub struct VarCondRule {\r\n    /// The var_cond value to assign if condition is true\r\n    pub var_cond: String,\r\n    /// The condition expression\r\n    pub condition: Condition,\r\n}\r\n\r\n/// A condition expression\r\n#[derive(Debug, Clone)]\r\npub enum Condition {\r\n    /// Property equals value: `M_PROP = 'value'`\r\n    Equals { property: String, value: String },\r\n    /// Property not equals value: `M_PROP <> 'value'`\r\n    NotEquals { property: String, value: String },\r\n    /// Property in list: `M_PROP in ('v1','v2')`\r\n    In { property: String, values: Vec<String> },\r\n    /// Property not in list: `M_PROP not in ('v1','v2')`\r\n    NotIn { property: String, values: Vec<String> },\r\n    /// Logical AND of conditions\r\n    And(Box<Condition>, Box<Condition>),\r\n    /// Logical OR of conditions\r\n    Or(Box<Condition>, Box<Condition>),\r\n    /// Always true (for unconditional rules)\r\n    True,\r\n}\r\n\r\nimpl Condition {\r\n    /// Evaluate condition against property values\r\n    pub fn evaluate(&self, properties: &HashMap<String, String>) -> bool {\r\n        match self {\r\n            Condition::Equals { property, value } => {\r\n                properties.get(property).map(|v| v == value).unwrap_or(false)\r\n            }\r\n            Condition::NotEquals { property, value } => {\r\n                properties.get(property).map(|v| v != value).unwrap_or(true)\r\n            }\r\n            Condition::In { property, values } => {\r\n                properties.get(property).map(|v| values.contains(v)).unwrap_or(false)\r\n            }\r\n            Condition::NotIn { property, values } => {\r\n                properties.get(property).map(|v| !values.contains(v)).unwrap_or(true)\r\n            }\r\n            Condition::And(left, right) => {\r\n                left.evaluate(properties) && right.evaluate(properties)\r\n            }\r\n            Condition::Or(left, right) => {\r\n                left.evaluate(properties) || right.evaluate(properties)\r\n            }\r\n            Condition::True => true,\r\n        }\r\n    }\r\n}\r\n\r\n/// Relation rule reader and evaluator\r\npub struct RelationRuleReader {\r\n    /// Parsed $VarCond assignment rules\r\n    pub varcond_rules: Vec<VarCondRule>,\r\n    /// Raw relation blocks (for debugging)\r\n    pub raw_relations: Vec<(String, String)>, // (rel_name, rel_block)\r\n}\r\n\r\nimpl RelationRuleReader {\r\n    /// Load relation rules from an ebase file\r\n    pub fn from_ebase(path: &Path) -> Option<Self> {\r\n        let mut reader = EBaseReader::open(path).ok()?;\r\n\r\n        // First, find which relation names have domain='P' (Pricing)\r\n        let pricing_relation_names: HashSet<String> = reader\r\n            .read_records(\"ocd_relationobj\", None)\r\n            .ok()?\r\n            .iter()\r\n            .filter_map(|record| {\r\n                let rel_domain = record.get(\"rel_domain\")?.as_str()?.to_string();\r\n                if rel_domain.contains('P') {\r\n                    Some(record.get(\"rel_name\")?.as_str()?.to_string())\r\n                } else {\r\n                    None\r\n                }\r\n            })\r\n            .collect();\r\n\r\n        if pricing_relation_names.is_empty() {\r\n            return None;\r\n        }\r\n\r\n        trace!(?pricing_relation_names, \"Found pricing relations\");\r\n\r\n        // Load relation blocks for pricing relations\r\n        let relations = reader.read_records(\"ocd_relation\", None).ok()?;\r\n\r\n        let mut varcond_rules = Vec::new();\r\n        let mut raw_relations = Vec::new();\r\n\r\n        for record in &relations {\r\n            let rel_name = record.get(\"rel_name\").and_then(|v| v.as_str()).unwrap_or(\"\");\r\n            let rel_block = record.get(\"rel_block\").and_then(|v| v.as_str()).unwrap_or(\"\");\r\n\r\n            if !pricing_relation_names.contains(rel_name) {\r\n                continue;\r\n            }\r\n\r\n            raw_relations.push((rel_name.to_string(), rel_block.to_string()));\r\n\r\n            // Parse $VarCond assignment rules\r\n            if let Some(rule) = parse_varcond_rule(rel_block) {\r\n                debug!(\r\n                    rel_name = rel_name,\r\n                    var_cond = rule.var_cond,\r\n                    \"Parsed VarCond rule\"\r\n                );\r\n                varcond_rules.push(rule);\r\n            }\r\n        }\r\n\r\n        if varcond_rules.is_empty() && raw_relations.is_empty() {\r\n            return None;\r\n        }\r\n\r\n        Some(Self {\r\n            varcond_rules,\r\n            raw_relations,\r\n        })\r\n    }\r\n\r\n    /// Evaluate all rules and return matching var_cond values\r\n    pub fn evaluate(&self, properties: &HashMap<String, String>) -> Vec<String> {\r\n        self.varcond_rules\r\n            .iter()\r\n            .filter_map(|rule| {\r\n                if rule.condition.evaluate(properties) {\r\n                    trace!(\r\n                        var_cond = rule.var_cond,\r\n                        \"VarCond rule matched\"\r\n                    );\r\n                    Some(rule.var_cond.clone())\r\n                } else {\r\n                    None\r\n                }\r\n            })\r\n            .collect()\r\n    }\r\n\r\n    /// Check if any pricing relations exist\r\n    pub fn has_pricing_rules(&self) -> bool {\r\n        !self.varcond_rules.is_empty()\r\n    }\r\n}\r\n\r\n/// Parse a $VarCond assignment rule from a relation block\r\nfn parse_varcond_rule(block: &str) -> Option<VarCondRule> {\r\n    // Pattern: $VarCond = 'VALUE' if CONDITION\r\n    let block = block.trim();\r\n\r\n    if !block.starts_with(\"$VarCond\") {\r\n        return None;\r\n    }\r\n\r\n    // Split on \" if \" to separate assignment from condition\r\n    let parts: Vec<&str> = block.splitn(2, \" if \").collect();\r\n\r\n    // Extract var_cond value from: $VarCond = 'VALUE'\r\n    let assignment = parts.first()?;\r\n    let var_cond = extract_quoted_value(assignment)?;\r\n\r\n    // Parse condition if present\r\n    let condition = if parts.len() > 1 {\r\n        parse_condition(parts[1].trim())\r\n    } else {\r\n        Condition::True\r\n    };\r\n\r\n    Some(VarCondRule { var_cond, condition })\r\n}\r\n\r\n/// Extract a quoted value from text like \"$VarCond = 'VALUE'\"\r\nfn extract_quoted_value(text: &str) -> Option<String> {\r\n    let start = text.find('\\'')?;\r\n    let end = text.rfind('\\'')?;\r\n    if end > start {\r\n        Some(text[start + 1..end].to_string())\r\n    } else {\r\n        None\r\n    }\r\n}\r\n\r\n/// Parse a condition expression\r\n///\r\n/// Parses expressions like:\r\n/// - `M_PROP = 'value'`\r\n/// - `M_PROP <> 'value'`\r\n/// - `M_PROP in ('v1','v2')`\r\n/// - `M_PROP not in ('v1','v2')`\r\n/// - `cond1 and cond2`\r\n/// - `cond1 or cond2`\r\npub fn parse_condition(expr: &str) -> Condition {\r\n    let expr = expr.trim();\r\n\r\n    // Remove trailing comma if present (some rules end with a comma)\r\n    let expr = expr.trim_end_matches(',');\r\n\r\n    // Remove outer parentheses if they're balanced\r\n    let expr = strip_outer_parens(expr);\r\n\r\n    // Check for OR at the top level (lowest precedence)\r\n    if let Some(pos) = find_operator_at_level(expr, \" or \") {\r\n        let left = parse_condition(&expr[..pos]);\r\n        let right = parse_condition(&expr[pos + 4..]);\r\n        return Condition::Or(Box::new(left), Box::new(right));\r\n    }\r\n\r\n    // Check for AND at the top level\r\n    if let Some(pos) = find_operator_at_level(expr, \" and \") {\r\n        let left = parse_condition(&expr[..pos]);\r\n        let right = parse_condition(&expr[pos + 5..]);\r\n        return Condition::And(Box::new(left), Box::new(right));\r\n    }\r\n\r\n    // Parse simple comparisons\r\n    if let Some(cond) = parse_not_in(expr) {\r\n        return cond;\r\n    }\r\n    if let Some(cond) = parse_in(expr) {\r\n        return cond;\r\n    }\r\n    if let Some(cond) = parse_not_equals(expr) {\r\n        return cond;\r\n    }\r\n    if let Some(cond) = parse_equals(expr) {\r\n        return cond;\r\n    }\r\n\r\n    // Fallback to true for unparseable conditions\r\n    warn!(expr = expr, \"Could not parse condition expression\");\r\n    Condition::True\r\n}\r\n\r\n/// Strip outer parentheses if they wrap the entire expression\r\nfn strip_outer_parens(expr: &str) -> &str {\r\n    let expr = expr.trim();\r\n    if !expr.starts_with('(') || !expr.ends_with(')') {\r\n        return expr;\r\n    }\r\n\r\n    // Check if the opening paren at the start matches the closing at the end\r\n    let inner = &expr[1..expr.len()-1];\r\n    let mut depth = 0;\r\n    for (i, c) in inner.chars().enumerate() {\r\n        match c {\r\n            '(' => depth += 1,\r\n            ')' => {\r\n                depth -= 1;\r\n                // If depth goes negative before the end, the parens don't match\r\n                if depth < 0 && i < inner.len() - 1 {\r\n                    return expr;\r\n                }\r\n            }\r\n            _ => {}\r\n        }\r\n    }\r\n\r\n    // If depth is 0 at the end, the outer parens match\r\n    if depth == 0 {\r\n        inner.trim()\r\n    } else {\r\n        expr\r\n    }\r\n}\r\n\r\n/// Find operator at top level (not inside parentheses or quotes)\r\nfn find_operator_at_level(expr: &str, op: &str) -> Option<usize> {\r\n    let mut depth = 0;\r\n    let mut in_quote = false;\r\n    let expr_lower = expr.to_lowercase();\r\n    let op_lower = op.to_lowercase();\r\n\r\n    let bytes = expr_lower.as_bytes();\r\n    let op_bytes = op_lower.as_bytes();\r\n    let expr_bytes = expr.as_bytes(); // For checking quotes in original case\r\n\r\n    for i in 0..bytes.len() {\r\n        // Track quotes\r\n        if expr_bytes[i] == b'\\'' {\r\n            in_quote = !in_quote;\r\n            continue;\r\n        }\r\n\r\n        // Skip if inside quotes\r\n        if in_quote {\r\n            continue;\r\n        }\r\n\r\n        match bytes[i] {\r\n            b'(' => depth += 1,\r\n            b')' => depth -= 1,\r\n            _ if depth == 0 && i + op_bytes.len() <= bytes.len() => {\r\n                if &bytes[i..i + op_bytes.len()] == op_bytes {\r\n                    return Some(i);\r\n                }\r\n            }\r\n            _ => {}\r\n        }\r\n    }\r\n    None\r\n}\r\n\r\n/// Parse: M_PROP = 'value'\r\nfn parse_equals(expr: &str) -> Option<Condition> {\r\n    // Find = but not <> or in ()\r\n    let parts: Vec<&str> = expr.splitn(2, \" = \").collect();\r\n    if parts.len() != 2 {\r\n        // Try without spaces around =\r\n        let parts: Vec<&str> = expr.splitn(2, '=').collect();\r\n        if parts.len() != 2 {\r\n            return None;\r\n        }\r\n        let property = parts[0].trim().to_string();\r\n        let value = extract_quoted_value(parts[1].trim())?;\r\n        return Some(Condition::Equals { property, value });\r\n    }\r\n    let property = parts[0].trim().to_string();\r\n    let value = extract_quoted_value(parts[1].trim())?;\r\n    Some(Condition::Equals { property, value })\r\n}\r\n\r\n/// Parse: M_PROP <> 'value'\r\nfn parse_not_equals(expr: &str) -> Option<Condition> {\r\n    let parts: Vec<&str> = expr.splitn(2, \" <> \").collect();\r\n    if parts.len() != 2 {\r\n        // Try without spaces\r\n        let parts: Vec<&str> = expr.splitn(2, \"<>\").collect();\r\n        if parts.len() != 2 {\r\n            return None;\r\n        }\r\n        let property = parts[0].trim().to_string();\r\n        let value = extract_quoted_value(parts[1].trim())?;\r\n        return Some(Condition::NotEquals { property, value });\r\n    }\r\n    let property = parts[0].trim().to_string();\r\n    let value = extract_quoted_value(parts[1].trim())?;\r\n    Some(Condition::NotEquals { property, value })\r\n}\r\n\r\n/// Parse: M_PROP in ('v1','v2')\r\nfn parse_in(expr: &str) -> Option<Condition> {\r\n    let expr_lower = expr.to_lowercase();\r\n    let in_pos = expr_lower.find(\" in \")?;\r\n\r\n    let property = expr[..in_pos].trim().to_string();\r\n    let values_part = expr[in_pos + 4..].trim();\r\n\r\n    // Extract values from parentheses\r\n    let values = extract_value_list(values_part)?;\r\n\r\n    Some(Condition::In { property, values })\r\n}\r\n\r\n/// Parse: M_PROP not in ('v1','v2')\r\nfn parse_not_in(expr: &str) -> Option<Condition> {\r\n    let expr_lower = expr.to_lowercase();\r\n    let not_in_pos = expr_lower.find(\" not in \")?;\r\n\r\n    let property = expr[..not_in_pos].trim().to_string();\r\n    let values_part = expr[not_in_pos + 8..].trim();\r\n\r\n    // Extract values from parentheses\r\n    let values = extract_value_list(values_part)?;\r\n\r\n    Some(Condition::NotIn { property, values })\r\n}\r\n\r\n/// Extract values from a parenthesized list like ('v1','v2','v3')\r\nfn extract_value_list(text: &str) -> Option<Vec<String>> {\r\n    let text = text.trim();\r\n    if !text.starts_with('(') || !text.ends_with(')') {\r\n        return None;\r\n    }\r\n\r\n    let inner = &text[1..text.len()-1];\r\n    let values: Vec<String> = inner\r\n        .split(',')\r\n        .filter_map(|s| {\r\n            let s = s.trim();\r\n            if s.starts_with('\\'') && s.ends_with('\\'') && s.len() >= 2 {\r\n                Some(s[1..s.len()-1].to_string())\r\n            } else {\r\n                None\r\n            }\r\n        })\r\n        .collect();\r\n\r\n    if values.is_empty() {\r\n        None\r\n    } else {\r\n        Some(values)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_parse_simple_equals() {\r\n        let rule = parse_varcond_rule(\"$VarCond = 'PG_LAN' if M_LAN = 'YES'\").unwrap();\r\n        assert_eq!(rule.var_cond, \"PG_LAN\");\r\n\r\n        let mut props = HashMap::new();\r\n        props.insert(\"M_LAN\".to_string(), \"YES\".to_string());\r\n        assert!(rule.condition.evaluate(&props));\r\n\r\n        props.insert(\"M_LAN\".to_string(), \"NO\".to_string());\r\n        assert!(!rule.condition.evaluate(&props));\r\n    }\r\n\r\n    #[test]\r\n    fn test_parse_and_condition() {\r\n        let rule = parse_varcond_rule(\r\n            \"$VarCond = 'PG_ADJUSTABLE_SEAT' if (M_ARTNO = 'ONE' and M_SEAT = 'YES')\"\r\n        ).unwrap();\r\n        assert_eq!(rule.var_cond, \"PG_ADJUSTABLE_SEAT\");\r\n\r\n        let mut props = HashMap::new();\r\n        props.insert(\"M_ARTNO\".to_string(), \"ONE\".to_string());\r\n        props.insert(\"M_SEAT\".to_string(), \"YES\".to_string());\r\n        assert!(rule.condition.evaluate(&props));\r\n\r\n        // Missing one condition\r\n        props.insert(\"M_SEAT\".to_string(), \"NO\".to_string());\r\n        assert!(!rule.condition.evaluate(&props));\r\n    }\r\n\r\n    #[test]\r\n    fn test_parse_not_in() {\r\n        let rule = parse_varcond_rule(\r\n            \"$VarCond = 'PG_EXTERIOR_PANEL_OPTION_COLOR' if (M_ARTNO = 'ONE' and M_EXTERIOR not in ('RAL9016MAT','S7500N','RAL9005'))\"\r\n        ).unwrap();\r\n        assert_eq!(rule.var_cond, \"PG_EXTERIOR_PANEL_OPTION_COLOR\");\r\n\r\n        let mut props = HashMap::new();\r\n        props.insert(\"M_ARTNO\".to_string(), \"ONE\".to_string());\r\n        props.insert(\"M_EXTERIOR\".to_string(), \"CUSTOM_COLOR\".to_string());\r\n        assert!(rule.condition.evaluate(&props));\r\n\r\n        // Standard color - should NOT match\r\n        props.insert(\"M_EXTERIOR\".to_string(), \"RAL9005\".to_string());\r\n        assert!(!rule.condition.evaluate(&props));\r\n    }\r\n\r\n    #[test]\r\n    fn test_parse_in_list() {\r\n        let rule = parse_varcond_rule(\r\n            \"$VarCond = 'PG_KICKPLATE' if M_KICKPLATE = 'YES' and M_ARTNO in ('ONE','ONE_PREMIUM')\"\r\n        ).unwrap();\r\n\r\n        let mut props = HashMap::new();\r\n        props.insert(\"M_KICKPLATE\".to_string(), \"YES\".to_string());\r\n        props.insert(\"M_ARTNO\".to_string(), \"ONE\".to_string());\r\n        assert!(rule.condition.evaluate(&props));\r\n\r\n        props.insert(\"M_ARTNO\".to_string(), \"ONE_LOUNGE\".to_string());\r\n        assert!(!rule.condition.evaluate(&props));\r\n    }\r\n}\r\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":25}},{"line":50,"address":[],"length":0,"stats":{"Line":25}},{"line":51,"address":[],"length":0,"stats":{"Line":28}},{"line":52,"address":[],"length":0,"stats":{"Line":98}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":4}},{"line":58,"address":[],"length":0,"stats":{"Line":16}},{"line":60,"address":[],"length":0,"stats":{"Line":4}},{"line":61,"address":[],"length":0,"stats":{"Line":14}},{"line":63,"address":[],"length":0,"stats":{"Line":14}},{"line":64,"address":[],"length":0,"stats":{"Line":42}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":4}},{"line":172,"address":[],"length":0,"stats":{"Line":12}},{"line":174,"address":[],"length":0,"stats":{"Line":4}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":20}},{"line":182,"address":[],"length":0,"stats":{"Line":8}},{"line":183,"address":[],"length":0,"stats":{"Line":12}},{"line":186,"address":[],"length":0,"stats":{"Line":8}},{"line":187,"address":[],"length":0,"stats":{"Line":8}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":4}},{"line":196,"address":[],"length":0,"stats":{"Line":13}},{"line":197,"address":[],"length":0,"stats":{"Line":39}},{"line":198,"address":[],"length":0,"stats":{"Line":39}},{"line":199,"address":[],"length":0,"stats":{"Line":13}},{"line":200,"address":[],"length":0,"stats":{"Line":26}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":15}},{"line":216,"address":[],"length":0,"stats":{"Line":45}},{"line":219,"address":[],"length":0,"stats":{"Line":45}},{"line":222,"address":[],"length":0,"stats":{"Line":45}},{"line":225,"address":[],"length":0,"stats":{"Line":30}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":34}},{"line":233,"address":[],"length":0,"stats":{"Line":12}},{"line":234,"address":[],"length":0,"stats":{"Line":12}},{"line":235,"address":[],"length":0,"stats":{"Line":12}},{"line":239,"address":[],"length":0,"stats":{"Line":12}},{"line":240,"address":[],"length":0,"stats":{"Line":1}},{"line":242,"address":[],"length":0,"stats":{"Line":11}},{"line":243,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":9}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":18}},{"line":249,"address":[],"length":0,"stats":{"Line":9}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":15}},{"line":259,"address":[],"length":0,"stats":{"Line":45}},{"line":260,"address":[],"length":0,"stats":{"Line":17}},{"line":261,"address":[],"length":0,"stats":{"Line":13}},{"line":265,"address":[],"length":0,"stats":{"Line":6}},{"line":266,"address":[],"length":0,"stats":{"Line":4}},{"line":267,"address":[],"length":0,"stats":{"Line":216}},{"line":268,"address":[],"length":0,"stats":{"Line":105}},{"line":269,"address":[],"length":0,"stats":{"Line":1}},{"line":271,"address":[],"length":0,"stats":{"Line":1}},{"line":273,"address":[],"length":0,"stats":{"Line":1}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":103}},{"line":282,"address":[],"length":0,"stats":{"Line":2}},{"line":283,"address":[],"length":0,"stats":{"Line":2}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":30}},{"line":291,"address":[],"length":0,"stats":{"Line":60}},{"line":292,"address":[],"length":0,"stats":{"Line":60}},{"line":293,"address":[],"length":0,"stats":{"Line":90}},{"line":294,"address":[],"length":0,"stats":{"Line":90}},{"line":296,"address":[],"length":0,"stats":{"Line":90}},{"line":297,"address":[],"length":0,"stats":{"Line":90}},{"line":298,"address":[],"length":0,"stats":{"Line":90}},{"line":300,"address":[],"length":0,"stats":{"Line":781}},{"line":302,"address":[],"length":0,"stats":{"Line":721}},{"line":303,"address":[],"length":0,"stats":{"Line":86}},{"line":304,"address":[],"length":0,"stats":{"Line":86}},{"line":308,"address":[],"length":0,"stats":{"Line":635}},{"line":309,"address":[],"length":0,"stats":{"Line":217}},{"line":312,"address":[],"length":0,"stats":{"Line":418}},{"line":313,"address":[],"length":0,"stats":{"Line":6}},{"line":314,"address":[],"length":0,"stats":{"Line":6}},{"line":315,"address":[],"length":0,"stats":{"Line":2391}},{"line":316,"address":[],"length":0,"stats":{"Line":1588}},{"line":317,"address":[],"length":0,"stats":{"Line":4}},{"line":320,"address":[],"length":0,"stats":{"Line":9}},{"line":323,"address":[],"length":0,"stats":{"Line":26}},{"line":327,"address":[],"length":0,"stats":{"Line":9}},{"line":329,"address":[],"length":0,"stats":{"Line":45}},{"line":330,"address":[],"length":0,"stats":{"Line":9}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":27}},{"line":341,"address":[],"length":0,"stats":{"Line":27}},{"line":342,"address":[],"length":0,"stats":{"Line":9}},{"line":346,"address":[],"length":0,"stats":{"Line":9}},{"line":347,"address":[],"length":0,"stats":{"Line":45}},{"line":348,"address":[],"length":0,"stats":{"Line":9}},{"line":350,"address":[],"length":0,"stats":{"Line":45}},{"line":351,"address":[],"length":0,"stats":{"Line":9}},{"line":352,"address":[],"length":0,"stats":{"Line":9}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":10}},{"line":365,"address":[],"length":0,"stats":{"Line":30}},{"line":366,"address":[],"length":0,"stats":{"Line":20}},{"line":368,"address":[],"length":0,"stats":{"Line":3}},{"line":369,"address":[],"length":0,"stats":{"Line":3}},{"line":372,"address":[],"length":0,"stats":{"Line":3}},{"line":374,"address":[],"length":0,"stats":{"Line":1}},{"line":378,"address":[],"length":0,"stats":{"Line":11}},{"line":379,"address":[],"length":0,"stats":{"Line":33}},{"line":380,"address":[],"length":0,"stats":{"Line":22}},{"line":382,"address":[],"length":0,"stats":{"Line":3}},{"line":383,"address":[],"length":0,"stats":{"Line":3}},{"line":386,"address":[],"length":0,"stats":{"Line":3}},{"line":388,"address":[],"length":0,"stats":{"Line":1}},{"line":392,"address":[],"length":0,"stats":{"Line":2}},{"line":393,"address":[],"length":0,"stats":{"Line":6}},{"line":394,"address":[],"length":0,"stats":{"Line":4}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":6}},{"line":399,"address":[],"length":0,"stats":{"Line":6}},{"line":401,"address":[],"length":0,"stats":{"Line":7}},{"line":402,"address":[],"length":0,"stats":{"Line":15}},{"line":403,"address":[],"length":0,"stats":{"Line":25}},{"line":404,"address":[],"length":0,"stats":{"Line":10}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":4}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":2}}],"covered":113,"coverable":184},{"path":["/","workspace","crates","ofml-lib","src","oap","price.rs"],"content":"//! Price lookup from EBASE databases\n//!\n//! This module provides price lookup functionality using article number\n//! and variant code to query EBASE price tables.\n//!\n//! ## Price Calculation Order\n//!\n//! Per OCD 4.3 spec and reference application behavior:\n//! 1. Base Price (Level 'B') - Applied first\n//! 2. Surcharges (Level 'X') - Accumulated and added to base\n//! 3. Discounts (Level 'D') - Subtracted last\n//!\n//! Formula: Total = Base + Œ£(Surcharges) - Œ£(Discounts)\n\nuse std::path::{Path, PathBuf};\n\nuse chrono::NaiveDate;\nuse rust_decimal::Decimal;\nuse serde::{Deserialize, Serialize};\nuse thiserror::Error;\n\nuse super::ocd::{find_pdata_files, get_ocd_reader, OcdPrice, OcdReader};\nuse super::{PriceResult, Surcharge};\n\n/// Errors that can occur during price lookup\n#[derive(Debug, Error)]\npub enum PriceError {\n    #[error(\"Price table not found for manufacturer: {0}\")]\n    PriceTableNotFound(String),\n\n    #[error(\"Article not found in price table: {0}\")]\n    ArticleNotFound(String),\n\n    #[error(\"Variant not found: {0}\")]\n    VariantNotFound(String),\n\n    #[error(\"No valid price for date: {0}\")]\n    NoValidPriceForDate(NaiveDate),\n\n    #[error(\"EBASE read error: {0}\")]\n    EbaseError(String),\n}\n\n/// A discount entry (price_level='D')\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Discount {\n    /// Discount description (from ocd_pricetext or var_cond)\n    pub name: String,\n    /// Discount value (positive = amount to subtract)\n    pub amount: Decimal,\n    /// Whether amount is a percentage of base price\n    pub is_percentage: bool,\n    /// Original var_cond from ocd_price\n    pub var_cond: String,\n}\n\n/// Detailed price breakdown for display\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PriceBreakdown {\n    /// Base price amount (price_level='B')\n    pub base: Decimal,\n    /// List of applied surcharges (price_level='X')\n    pub surcharges: Vec<Surcharge>,\n    /// List of applied discounts (price_level='D')\n    pub discounts: Vec<Discount>,\n    /// Total after all surcharges and discounts\n    pub total: Decimal,\n    /// Currency code (e.g., \"EUR\")\n    pub currency: String,\n    /// Price date used for lookup\n    pub price_date: NaiveDate,\n    /// Whether this is a surcharge-only pricing model (base=0)\n    pub is_surcharge_only: bool,\n}\n\nimpl PriceBreakdown {\n    /// Create a new price breakdown\n    pub fn new(\n        base: Decimal,\n        surcharges: Vec<Surcharge>,\n        discounts: Vec<Discount>,\n        currency: String,\n        price_date: NaiveDate,\n    ) -> Self {\n        let is_surcharge_only = base.is_zero() && !surcharges.is_empty();\n        let total = Self::compute_total(&base, &surcharges, &discounts);\n        Self {\n            base,\n            surcharges,\n            discounts,\n            total,\n            currency,\n            price_date,\n            is_surcharge_only,\n        }\n    }\n\n    /// Compute total from base, surcharges, and discounts\n    /// Formula: Total = Base + Œ£(Surcharges) - Œ£(Discounts)\n    fn compute_total(base: &Decimal, surcharges: &[Surcharge], discounts: &[Discount]) -> Decimal {\n        let mut total = *base;\n\n        // Add surcharges\n        for surcharge in surcharges {\n            if surcharge.is_percentage {\n                total += *base * surcharge.amount / Decimal::from(100);\n            } else {\n                total += surcharge.amount;\n            }\n        }\n\n        // Subtract discounts\n        for discount in discounts {\n            if discount.is_percentage {\n                total -= *base * discount.amount / Decimal::from(100);\n            } else {\n                total -= discount.amount;\n            }\n        }\n\n        total\n    }\n\n    /// Get sum of all surcharges\n    pub fn surcharges_total(&self) -> Decimal {\n        self.surcharges\n            .iter()\n            .map(|s| {\n                if s.is_percentage {\n                    self.base * s.amount / Decimal::from(100)\n                } else {\n                    s.amount\n                }\n            })\n            .sum()\n    }\n\n    /// Get sum of all discounts\n    pub fn discounts_total(&self) -> Decimal {\n        self.discounts\n            .iter()\n            .map(|d| {\n                if d.is_percentage {\n                    self.base * d.amount / Decimal::from(100)\n                } else {\n                    d.amount\n                }\n            })\n            .sum()\n    }\n\n    /// Convert to PriceResult (for compatibility)\n    pub fn to_price_result(\n        self,\n        valid_from: NaiveDate,\n        valid_to: Option<NaiveDate>,\n    ) -> PriceResult {\n        PriceResult::new(\n            self.base,\n            self.surcharges,\n            self.currency,\n            self.price_date,\n            valid_from,\n            valid_to,\n        )\n    }\n}\n\n/// Query parameters for price lookup\n#[derive(Debug, Clone)]\npub struct PriceQuery {\n    /// Manufacturer ID\n    pub manufacturer: String,\n    /// EBASE article number\n    pub article_number: String,\n    /// Generated variant code\n    pub variant_code: String,\n    /// Price lookup date\n    pub price_date: NaiveDate,\n}\n\nimpl PriceQuery {\n    /// Create a new price query\n    pub fn new(\n        manufacturer: String,\n        article_number: String,\n        variant_code: String,\n        price_date: NaiveDate,\n    ) -> Self {\n        Self {\n            manufacturer,\n            article_number,\n            variant_code,\n            price_date,\n        }\n    }\n}\n\n/// Price lookup service\n///\n/// This struct provides methods to look up prices from EBASE databases.\n/// It handles caching and date-based validity filtering.\npub struct PriceLookup {\n    /// Path to OFML data directory (e.g., /reference/ofmldata)\n    data_path: PathBuf,\n}\n\nimpl PriceLookup {\n    /// Create a new price lookup service with real EBASE lookup\n    pub fn new(data_path: impl AsRef<Path>) -> Self {\n        Self {\n            data_path: data_path.as_ref().to_path_buf(),\n        }\n    }\n\n    /// Look up price for a configured article\n    ///\n    /// # Arguments\n    /// * `query` - Price query parameters\n    ///\n    /// # Returns\n    /// `Ok(PriceResult)` with pricing info, or `Err(PriceError)` if lookup fails\n    pub fn lookup(&self, query: &PriceQuery) -> Result<PriceResult, PriceError> {\n        let mfr_path = self.data_path.join(&query.manufacturer);\n\n        // Find pdata.ebase files for this manufacturer\n        let pdata_files = find_pdata_files(&mfr_path);\n        if pdata_files.is_empty() {\n            return Err(PriceError::PriceTableNotFound(query.manufacturer.clone()));\n        }\n\n        // Try each pdata file to find the article\n        for pdata_path in &pdata_files {\n            if let Some(reader) = get_ocd_reader(pdata_path) {\n                // Get all prices for this article\n                let prices = reader.get_prices(&query.article_number);\n\n                if prices.is_empty() {\n                    continue;\n                }\n\n                // Match prices against variant code\n                if let Some(result) = self.match_prices(&reader, &prices, &query.variant_code) {\n                    let valid_from = parse_date(&result.base_price.date_from)\n                        .unwrap_or(query.price_date);\n                    let valid_to = parse_date(&result.base_price.date_to);\n\n                    return Ok(PriceResult::new(\n                        result.base_amount,\n                        result.surcharges,\n                        result.currency,\n                        query.price_date,\n                        valid_from,\n                        valid_to,\n                    ));\n                }\n            }\n        }\n\n        Err(PriceError::ArticleNotFound(query.article_number.clone()))\n    }\n\n    /// Match prices to variant code\n    fn match_prices<'a>(\n        &self,\n        reader: &OcdReader,\n        prices: &'a [&'a OcdPrice],\n        variant_code: &str,\n    ) -> Option<MatchedPriceResult<'a>> {\n        // Separate by price level\n        let mut base_prices: Vec<&OcdPrice> = Vec::new();\n        let mut surcharge_prices: Vec<&OcdPrice> = Vec::new();\n        let mut discount_prices: Vec<&OcdPrice> = Vec::new();\n\n        for price in prices {\n            match price.price_level.as_str() {\n                \"B\" => base_prices.push(price),\n                \"X\" => surcharge_prices.push(price),\n                \"D\" => discount_prices.push(price),\n                _ => {}\n            }\n        }\n\n        // Find matching base price\n        let base_price = self.find_matching_base_price(&base_prices, variant_code)?;\n        let base_amount = Decimal::from_f32_retain(base_price.price).unwrap_or_default();\n\n        // Find matching surcharges\n        let mut surcharges = Vec::new();\n        for price in &surcharge_prices {\n            if self.var_cond_matches(&price.var_cond, variant_code) {\n                let amount = Decimal::from_f32_retain(price.price).unwrap_or_default();\n                let description = reader\n                    .get_price_description(price, \"DE\")\n                    .trim()\n                    .to_string();\n                surcharges.push(Surcharge {\n                    name: if description.is_empty() {\n                        price.var_cond.clone()\n                    } else {\n                        description\n                    },\n                    amount,\n                    is_percentage: false,\n                });\n            }\n        }\n\n        // Find matching discounts (as negative surcharges)\n        for price in &discount_prices {\n            if self.var_cond_matches(&price.var_cond, variant_code) {\n                let amount = Decimal::from_f32_retain(price.price).unwrap_or_default();\n                let description = reader\n                    .get_price_description(price, \"DE\")\n                    .trim()\n                    .to_string();\n                surcharges.push(Surcharge {\n                    name: format!(\n                        \"Rabatt: {}\",\n                        if description.is_empty() {\n                            &price.var_cond\n                        } else {\n                            &description\n                        }\n                    ),\n                    amount: -amount, // Negate for discounts\n                    is_percentage: false,\n                });\n            }\n        }\n\n        Some(MatchedPriceResult {\n            base_price,\n            base_amount,\n            surcharges,\n            currency: base_price.currency.clone(),\n        })\n    }\n\n    /// Find matching base price (level 'B')\n    fn find_matching_base_price<'a>(\n        &self,\n        base_prices: &[&'a OcdPrice],\n        variant_code: &str,\n    ) -> Option<&'a OcdPrice> {\n        // Common base price indicators\n        const BASE_INDICATORS: &[&str] = &[\"S_PGX\", \"BASE\", \"STANDARD\", \"\"];\n\n        // First try to find a base price matching the variant code\n        for price in base_prices {\n            if self.var_cond_matches(&price.var_cond, variant_code) {\n                return Some(price);\n            }\n        }\n\n        // Fall back to standard base price indicators\n        for indicator in BASE_INDICATORS {\n            for price in base_prices {\n                if price.var_cond.eq_ignore_ascii_case(indicator) {\n                    return Some(price);\n                }\n            }\n        }\n\n        // Last resort: first base price\n        base_prices.first().copied()\n    }\n\n    /// Check if var_cond matches variant code\n    fn var_cond_matches(&self, var_cond: &str, variant_code: &str) -> bool {\n        if var_cond.is_empty() {\n            return false;\n        }\n\n        // Common base indicators should not match as surcharges\n        const BASE_INDICATORS: &[&str] = &[\"S_PGX\", \"BASE\", \"STANDARD\"];\n        for indicator in BASE_INDICATORS {\n            if var_cond.eq_ignore_ascii_case(indicator) {\n                return false;\n            }\n        }\n\n        // Strategy 1: Direct match - var_cond like \"S_166\" matches variant code containing \"166\"\n        if let Some(suffix) = var_cond.strip_prefix(\"S_\") {\n            // Check each component of the variant code\n            for component in variant_code.split('_') {\n                if component == suffix || component.ends_with(suffix) {\n                    return true;\n                }\n            }\n        }\n\n        // Strategy 2: Exact match in variant components\n        for component in variant_code.split('_') {\n            if component == var_cond {\n                return true;\n            }\n        }\n\n        // Strategy 3: Variant contains var_cond\n        if variant_code.contains(var_cond) {\n            return true;\n        }\n\n        false\n    }\n}\n\n/// Internal result from price matching\nstruct MatchedPriceResult<'a> {\n    base_price: &'a OcdPrice,\n    base_amount: Decimal,\n    surcharges: Vec<Surcharge>,\n    currency: String,\n}\n\n/// Parse a date string in YYYYMMDD format\nfn parse_date(s: &str) -> Option<NaiveDate> {\n    NaiveDate::parse_from_str(s, \"%Y%m%d\").ok()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_price_query_new() {\n        let query = PriceQuery::new(\n            \"vitra\".to_string(),\n            \"48-123-456\".to_string(),\n            \"H720_D1200\".to_string(),\n            NaiveDate::from_ymd_opt(2025, 12, 24).unwrap(),\n        );\n        assert_eq!(query.manufacturer, \"vitra\");\n        assert_eq!(query.article_number, \"48-123-456\");\n        assert_eq!(query.variant_code, \"H720_D1200\");\n    }\n\n    #[test]\n    fn test_price_query_debug_clone() {\n        let query = PriceQuery::new(\n            \"test\".to_string(),\n            \"ART-001\".to_string(),\n            \"VAR1\".to_string(),\n            NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n        );\n        let debug = format!(\"{:?}\", query);\n        assert!(debug.contains(\"PriceQuery\"));\n        let cloned = query.clone();\n        assert_eq!(cloned.manufacturer, query.manufacturer);\n    }\n\n    #[test]\n    fn test_price_lookup_real_data() {\n        // Use the actual OFML data path\n        let lookup = PriceLookup::new(\"/reference/ofmldata\");\n\n        // Test with Sedus AI chair (known to exist in test data)\n        let query = PriceQuery::new(\n            \"sex\".to_string(),\n            \"AI-121\".to_string(),\n            \"\".to_string(), // Empty variant code for base price\n            NaiveDate::from_ymd_opt(2025, 12, 24).unwrap(),\n        );\n\n        // This may fail if data directory doesn't exist, which is okay for unit tests\n        if let Ok(price) = lookup.lookup(&query) {\n            assert!(price.base_price >= Decimal::ZERO);\n            assert!(!price.currency.is_empty());\n        }\n    }\n\n    #[test]\n    fn test_price_lookup_manufacturer_not_found() {\n        let lookup = PriceLookup::new(\"/nonexistent/path\");\n        let query = PriceQuery::new(\n            \"fakemfr\".to_string(),\n            \"FAKE-123\".to_string(),\n            \"\".to_string(),\n            NaiveDate::from_ymd_opt(2025, 12, 24).unwrap(),\n        );\n\n        let result = lookup.lookup(&query);\n        assert!(result.is_err());\n        assert!(matches!(result, Err(PriceError::PriceTableNotFound(_))));\n    }\n\n    #[test]\n    fn test_var_cond_matching() {\n        let lookup = PriceLookup::new(\"/tmp\");\n\n        // Test S_ prefix matching\n        assert!(lookup.var_cond_matches(\"S_166\", \"H720_166\"));\n        assert!(lookup.var_cond_matches(\"S_166\", \"A166_B200\"));\n        assert!(!lookup.var_cond_matches(\"S_166\", \"H720_167\"));\n\n        // Test exact component match\n        assert!(lookup.var_cond_matches(\"H720\", \"H720_D1200\"));\n        assert!(!lookup.var_cond_matches(\"H720\", \"H721_D1200\"));\n\n        // Test contains match\n        assert!(lookup.var_cond_matches(\"720\", \"H720_D1200\"));\n\n        // Test base indicators don't match\n        assert!(!lookup.var_cond_matches(\"S_PGX\", \"anything\"));\n        assert!(!lookup.var_cond_matches(\"BASE\", \"anything\"));\n        assert!(!lookup.var_cond_matches(\"STANDARD\", \"anything\"));\n\n        // Empty var_cond doesn't match\n        assert!(!lookup.var_cond_matches(\"\", \"anything\"));\n    }\n\n    #[test]\n    fn test_parse_date() {\n        assert_eq!(\n            parse_date(\"20250101\"),\n            Some(NaiveDate::from_ymd_opt(2025, 1, 1).unwrap())\n        );\n        assert_eq!(\n            parse_date(\"20251224\"),\n            Some(NaiveDate::from_ymd_opt(2025, 12, 24).unwrap())\n        );\n        assert_eq!(parse_date(\"invalid\"), None);\n        assert_eq!(parse_date(\"\"), None);\n    }\n\n    #[test]\n    fn test_price_breakdown_new() {\n        let base = Decimal::from(100);\n        let surcharges = vec![Surcharge {\n            name: \"Extra\".to_string(),\n            amount: Decimal::from(20),\n            is_percentage: false,\n        }];\n        let discounts = vec![];\n        let currency = \"EUR\".to_string();\n        let price_date = NaiveDate::from_ymd_opt(2025, 6, 15).unwrap();\n\n        let breakdown =\n            PriceBreakdown::new(base, surcharges, discounts, currency.clone(), price_date);\n\n        assert_eq!(breakdown.base, Decimal::from(100));\n        assert_eq!(breakdown.total, Decimal::from(120)); // 100 + 20\n        assert_eq!(breakdown.currency, \"EUR\");\n        assert!(!breakdown.is_surcharge_only);\n    }\n\n    #[test]\n    fn test_price_breakdown_surcharge_only() {\n        let base = Decimal::ZERO;\n        let surcharges = vec![\n            Surcharge {\n                name: \"Option A\".to_string(),\n                amount: Decimal::from(50),\n                is_percentage: false,\n            },\n            Surcharge {\n                name: \"Option B\".to_string(),\n                amount: Decimal::from(30),\n                is_percentage: false,\n            },\n        ];\n        let discounts = vec![];\n        let currency = \"EUR\".to_string();\n        let price_date = NaiveDate::from_ymd_opt(2025, 6, 15).unwrap();\n\n        let breakdown = PriceBreakdown::new(base, surcharges, discounts, currency, price_date);\n\n        assert_eq!(breakdown.base, Decimal::ZERO);\n        assert_eq!(breakdown.total, Decimal::from(80)); // 50 + 30\n        assert!(breakdown.is_surcharge_only);\n    }\n\n    #[test]\n    fn test_price_breakdown_with_percentage_surcharge() {\n        let base = Decimal::from(200);\n        let surcharges = vec![Surcharge {\n            name: \"10% extra\".to_string(),\n            amount: Decimal::from(10),\n            is_percentage: true,\n        }];\n        let discounts = vec![];\n        let currency = \"EUR\".to_string();\n        let price_date = NaiveDate::from_ymd_opt(2025, 6, 15).unwrap();\n\n        let breakdown = PriceBreakdown::new(base, surcharges, discounts, currency, price_date);\n\n        assert_eq!(breakdown.total, Decimal::from(220)); // 200 + 10% of 200\n    }\n\n    #[test]\n    fn test_price_breakdown_with_discount() {\n        let base = Decimal::from(100);\n        let surcharges = vec![];\n        let discounts = vec![Discount {\n            name: \"Holiday discount\".to_string(),\n            amount: Decimal::from(15),\n            is_percentage: false,\n            var_cond: \"HOLIDAY\".to_string(),\n        }];\n        let currency = \"EUR\".to_string();\n        let price_date = NaiveDate::from_ymd_opt(2025, 6, 15).unwrap();\n\n        let breakdown = PriceBreakdown::new(base, surcharges, discounts, currency, price_date);\n\n        assert_eq!(breakdown.total, Decimal::from(85)); // 100 - 15\n    }\n\n    #[test]\n    fn test_price_breakdown_with_percentage_discount() {\n        let base = Decimal::from(200);\n        let surcharges = vec![];\n        let discounts = vec![Discount {\n            name: \"20% off\".to_string(),\n            amount: Decimal::from(20),\n            is_percentage: true,\n            var_cond: \"SALE\".to_string(),\n        }];\n        let currency = \"EUR\".to_string();\n        let price_date = NaiveDate::from_ymd_opt(2025, 6, 15).unwrap();\n\n        let breakdown = PriceBreakdown::new(base, surcharges, discounts, currency, price_date);\n\n        assert_eq!(breakdown.total, Decimal::from(160)); // 200 - 20% of 200\n    }\n\n    #[test]\n    fn test_price_breakdown_surcharges_total() {\n        let base = Decimal::from(100);\n        let surcharges = vec![\n            Surcharge {\n                name: \"S1\".to_string(),\n                amount: Decimal::from(10),\n                is_percentage: false,\n            },\n            Surcharge {\n                name: \"S2\".to_string(),\n                amount: Decimal::from(20),\n                is_percentage: false,\n            },\n        ];\n        let discounts = vec![];\n        let currency = \"EUR\".to_string();\n        let price_date = NaiveDate::from_ymd_opt(2025, 6, 15).unwrap();\n\n        let breakdown = PriceBreakdown::new(base, surcharges, discounts, currency, price_date);\n\n        assert_eq!(breakdown.surcharges_total(), Decimal::from(30));\n    }\n\n    #[test]\n    fn test_price_breakdown_discounts_total() {\n        let base = Decimal::from(200);\n        let surcharges = vec![];\n        let discounts = vec![\n            Discount {\n                name: \"D1\".to_string(),\n                amount: Decimal::from(10),\n                is_percentage: false,\n                var_cond: \"D1\".to_string(),\n            },\n            Discount {\n                name: \"D2\".to_string(),\n                amount: Decimal::from(5),\n                is_percentage: true, // 5% of 200 = 10\n                var_cond: \"D2\".to_string(),\n            },\n        ];\n        let currency = \"EUR\".to_string();\n        let price_date = NaiveDate::from_ymd_opt(2025, 6, 15).unwrap();\n\n        let breakdown = PriceBreakdown::new(base, surcharges, discounts, currency, price_date);\n\n        assert_eq!(breakdown.discounts_total(), Decimal::from(20)); // 10 + 5% of 200\n    }\n\n    #[test]\n    fn test_price_breakdown_to_price_result() {\n        let base = Decimal::from(100);\n        let surcharges = vec![Surcharge {\n            name: \"Extra\".to_string(),\n            amount: Decimal::from(20),\n            is_percentage: false,\n        }];\n        let discounts = vec![];\n        let currency = \"EUR\".to_string();\n        let price_date = NaiveDate::from_ymd_opt(2025, 6, 15).unwrap();\n        let valid_from = NaiveDate::from_ymd_opt(2025, 1, 1).unwrap();\n        let valid_to = Some(NaiveDate::from_ymd_opt(2025, 12, 31).unwrap());\n\n        let breakdown = PriceBreakdown::new(base, surcharges, discounts, currency, price_date);\n        let result = breakdown.to_price_result(valid_from, valid_to);\n\n        assert_eq!(result.base_price, Decimal::from(100));\n        assert_eq!(result.valid_from, valid_from);\n        assert_eq!(result.valid_to, valid_to);\n    }\n\n    #[test]\n    fn test_price_breakdown_debug_clone() {\n        let breakdown = PriceBreakdown::new(\n            Decimal::from(50),\n            vec![],\n            vec![],\n            \"USD\".to_string(),\n            NaiveDate::from_ymd_opt(2025, 3, 1).unwrap(),\n        );\n\n        let debug = format!(\"{:?}\", breakdown);\n        assert!(debug.contains(\"PriceBreakdown\"));\n        assert!(debug.contains(\"USD\"));\n\n        let cloned = breakdown.clone();\n        assert_eq!(cloned.base, breakdown.base);\n        assert_eq!(cloned.currency, breakdown.currency);\n    }\n\n    #[test]\n    fn test_discount_struct() {\n        let discount = Discount {\n            name: \"Test Discount\".to_string(),\n            amount: Decimal::from(25),\n            is_percentage: true,\n            var_cond: \"TEST_COND\".to_string(),\n        };\n\n        let debug = format!(\"{:?}\", discount);\n        assert!(debug.contains(\"Discount\"));\n        assert!(debug.contains(\"Test Discount\"));\n\n        let cloned = discount.clone();\n        assert_eq!(cloned.name, discount.name);\n        assert_eq!(cloned.amount, discount.amount);\n        assert_eq!(cloned.is_percentage, discount.is_percentage);\n        assert_eq!(cloned.var_cond, discount.var_cond);\n    }\n\n    #[test]\n    fn test_price_error_display() {\n        let err1 = PriceError::PriceTableNotFound(\"testmfr\".to_string());\n        assert!(err1.to_string().contains(\"Price table not found\"));\n        assert!(err1.to_string().contains(\"testmfr\"));\n\n        let err2 = PriceError::ArticleNotFound(\"ART-999\".to_string());\n        assert!(err2.to_string().contains(\"Article not found\"));\n        assert!(err2.to_string().contains(\"ART-999\"));\n\n        let err3 = PriceError::VariantNotFound(\"VAR-X\".to_string());\n        assert!(err3.to_string().contains(\"Variant not found\"));\n        assert!(err3.to_string().contains(\"VAR-X\"));\n\n        let date = NaiveDate::from_ymd_opt(2025, 7, 4).unwrap();\n        let err4 = PriceError::NoValidPriceForDate(date);\n        assert!(err4.to_string().contains(\"No valid price for date\"));\n\n        let err5 = PriceError::EbaseError(\"read failed\".to_string());\n        assert!(err5.to_string().contains(\"EBASE read error\"));\n        assert!(err5.to_string().contains(\"read failed\"));\n    }\n\n    #[test]\n    fn test_price_error_debug() {\n        let err = PriceError::ArticleNotFound(\"TEST\".to_string());\n        let debug = format!(\"{:?}\", err);\n        assert!(debug.contains(\"ArticleNotFound\"));\n    }\n\n    #[test]\n    fn test_var_cond_suffix_match() {\n        let lookup = PriceLookup::new(\"/tmp\");\n\n        // Test suffix matching with S_ prefix\n        assert!(lookup.var_cond_matches(\"S_100\", \"A100_B200\"));\n        assert!(lookup.var_cond_matches(\"S_100\", \"XYZ100\"));\n        assert!(!lookup.var_cond_matches(\"S_100\", \"A101_B200\"));\n    }\n\n    #[test]\n    fn test_price_breakdown_mixed_surcharges_and_discounts() {\n        let base = Decimal::from(1000);\n        let surcharges = vec![\n            Surcharge {\n                name: \"Premium\".to_string(),\n                amount: Decimal::from(100),\n                is_percentage: false,\n            },\n            Surcharge {\n                name: \"Express\".to_string(),\n                amount: Decimal::from(5), // 5% = 50\n                is_percentage: true,\n            },\n        ];\n        let discounts = vec![\n            Discount {\n                name: \"Loyalty\".to_string(),\n                amount: Decimal::from(50),\n                is_percentage: false,\n                var_cond: \"LOYAL\".to_string(),\n            },\n            Discount {\n                name: \"Volume\".to_string(),\n                amount: Decimal::from(10), // 10% = 100\n                is_percentage: true,\n                var_cond: \"VOL\".to_string(),\n            },\n        ];\n        let currency = \"EUR\".to_string();\n        let price_date = NaiveDate::from_ymd_opt(2025, 6, 15).unwrap();\n\n        let breakdown = PriceBreakdown::new(base, surcharges, discounts, currency, price_date);\n\n        // Total = 1000 + 100 + 50 (5% of 1000) - 50 - 100 (10% of 1000) = 1000\n        assert_eq!(breakdown.total, Decimal::from(1000));\n        assert_eq!(breakdown.surcharges_total(), Decimal::from(150)); // 100 + 50\n        assert_eq!(breakdown.discounts_total(), Decimal::from(150)); // 50 + 100\n    }\n\n    #[test]\n    fn test_price_lookup_article_not_found() {\n        let lookup = PriceLookup::new(\"/reference/ofmldata\");\n\n        let query = PriceQuery::new(\n            \"sex\".to_string(),\n            \"NONEXISTENT-ARTICLE-999\".to_string(),\n            \"\".to_string(),\n            NaiveDate::from_ymd_opt(2025, 12, 24).unwrap(),\n        );\n\n        // This should fail with ArticleNotFound if data exists\n        let result = lookup.lookup(&query);\n        if result.is_err() {\n            // Either PriceTableNotFound (no data) or ArticleNotFound (article doesn't exist)\n            assert!(\n                matches!(result, Err(PriceError::ArticleNotFound(_)))\n                    || matches!(result, Err(PriceError::PriceTableNotFound(_)))\n            );\n        }\n    }\n\n    #[test]\n    fn test_discount_serialization() {\n        let discount = Discount {\n            name: \"Test\".to_string(),\n            amount: Decimal::from(10),\n            is_percentage: false,\n            var_cond: \"COND\".to_string(),\n        };\n\n        let json = serde_json::to_string(&discount).unwrap();\n        assert!(json.contains(\"Test\"));\n        assert!(json.contains(\"COND\"));\n\n        let parsed: Discount = serde_json::from_str(&json).unwrap();\n        assert_eq!(parsed.name, discount.name);\n    }\n\n    #[test]\n    fn test_price_breakdown_serialization() {\n        let breakdown = PriceBreakdown::new(\n            Decimal::from(100),\n            vec![],\n            vec![],\n            \"EUR\".to_string(),\n            NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n        );\n\n        let json = serde_json::to_string(&breakdown).unwrap();\n        assert!(json.contains(\"EUR\"));\n        assert!(json.contains(\"100\"));\n\n        let parsed: PriceBreakdown = serde_json::from_str(&json).unwrap();\n        assert_eq!(parsed.base, breakdown.base);\n        assert_eq!(parsed.currency, breakdown.currency);\n    }\n}\n","traces":[{"line":78,"address":[],"length":0,"stats":{"Line":11}},{"line":85,"address":[],"length":0,"stats":{"Line":34}},{"line":86,"address":[],"length":0,"stats":{"Line":55}},{"line":100,"address":[],"length":0,"stats":{"Line":11}},{"line":101,"address":[],"length":0,"stats":{"Line":22}},{"line":104,"address":[],"length":0,"stats":{"Line":29}},{"line":105,"address":[],"length":0,"stats":{"Line":11}},{"line":106,"address":[],"length":0,"stats":{"Line":4}},{"line":108,"address":[],"length":0,"stats":{"Line":7}},{"line":113,"address":[],"length":0,"stats":{"Line":23}},{"line":114,"address":[],"length":0,"stats":{"Line":9}},{"line":115,"address":[],"length":0,"stats":{"Line":6}},{"line":117,"address":[],"length":0,"stats":{"Line":3}},{"line":121,"address":[],"length":0,"stats":{"Line":11}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":128,"address":[],"length":0,"stats":{"Line":6}},{"line":129,"address":[],"length":0,"stats":{"Line":4}},{"line":130,"address":[],"length":0,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":3}},{"line":139,"address":[],"length":0,"stats":{"Line":2}},{"line":140,"address":[],"length":0,"stats":{"Line":2}},{"line":142,"address":[],"length":0,"stats":{"Line":6}},{"line":143,"address":[],"length":0,"stats":{"Line":4}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":5}},{"line":210,"address":[],"length":0,"stats":{"Line":5}},{"line":212,"address":[],"length":0,"stats":{"Line":5}},{"line":223,"address":[],"length":0,"stats":{"Line":3}},{"line":224,"address":[],"length":0,"stats":{"Line":9}},{"line":227,"address":[],"length":0,"stats":{"Line":9}},{"line":228,"address":[],"length":0,"stats":{"Line":6}},{"line":229,"address":[],"length":0,"stats":{"Line":1}},{"line":233,"address":[],"length":0,"stats":{"Line":81}},{"line":234,"address":[],"length":0,"stats":{"Line":80}},{"line":236,"address":[],"length":0,"stats":{"Line":120}},{"line":238,"address":[],"length":0,"stats":{"Line":80}},{"line":239,"address":[],"length":0,"stats":{"Line":36}},{"line":243,"address":[],"length":0,"stats":{"Line":17}},{"line":244,"address":[],"length":0,"stats":{"Line":3}},{"line":245,"address":[],"length":0,"stats":{"Line":2}},{"line":246,"address":[],"length":0,"stats":{"Line":3}},{"line":248,"address":[],"length":0,"stats":{"Line":2}},{"line":249,"address":[],"length":0,"stats":{"Line":2}},{"line":250,"address":[],"length":0,"stats":{"Line":2}},{"line":251,"address":[],"length":0,"stats":{"Line":2}},{"line":252,"address":[],"length":0,"stats":{"Line":2}},{"line":253,"address":[],"length":0,"stats":{"Line":1}},{"line":254,"address":[],"length":0,"stats":{"Line":1}},{"line":260,"address":[],"length":0,"stats":{"Line":1}},{"line":264,"address":[],"length":0,"stats":{"Line":4}},{"line":271,"address":[],"length":0,"stats":{"Line":12}},{"line":272,"address":[],"length":0,"stats":{"Line":12}},{"line":273,"address":[],"length":0,"stats":{"Line":12}},{"line":275,"address":[],"length":0,"stats":{"Line":6878}},{"line":276,"address":[],"length":0,"stats":{"Line":3437}},{"line":277,"address":[],"length":0,"stats":{"Line":3449}},{"line":278,"address":[],"length":0,"stats":{"Line":13732}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":20}},{"line":286,"address":[],"length":0,"stats":{"Line":4}},{"line":289,"address":[],"length":0,"stats":{"Line":2}},{"line":290,"address":[],"length":0,"stats":{"Line":57}},{"line":291,"address":[],"length":0,"stats":{"Line":112}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":1}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":1}},{"line":333,"address":[],"length":0,"stats":{"Line":2}},{"line":334,"address":[],"length":0,"stats":{"Line":2}},{"line":335,"address":[],"length":0,"stats":{"Line":2}},{"line":336,"address":[],"length":0,"stats":{"Line":1}},{"line":341,"address":[],"length":0,"stats":{"Line":4}},{"line":350,"address":[],"length":0,"stats":{"Line":12}},{"line":351,"address":[],"length":0,"stats":{"Line":16}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":29}},{"line":358,"address":[],"length":0,"stats":{"Line":14}},{"line":359,"address":[],"length":0,"stats":{"Line":2}},{"line":360,"address":[],"length":0,"stats":{"Line":1}},{"line":366,"address":[],"length":0,"stats":{"Line":9}},{"line":370,"address":[],"length":0,"stats":{"Line":45}},{"line":371,"address":[],"length":0,"stats":{"Line":90}},{"line":372,"address":[],"length":0,"stats":{"Line":1}},{"line":377,"address":[],"length":0,"stats":{"Line":279}},{"line":378,"address":[],"length":0,"stats":{"Line":363}},{"line":379,"address":[],"length":0,"stats":{"Line":7}},{"line":384,"address":[],"length":0,"stats":{"Line":71}},{"line":386,"address":[],"length":0,"stats":{"Line":105}},{"line":387,"address":[],"length":0,"stats":{"Line":145}},{"line":388,"address":[],"length":0,"stats":{"Line":4}},{"line":394,"address":[],"length":0,"stats":{"Line":103}},{"line":395,"address":[],"length":0,"stats":{"Line":37}},{"line":396,"address":[],"length":0,"stats":{"Line":1}},{"line":401,"address":[],"length":0,"stats":{"Line":96}},{"line":402,"address":[],"length":0,"stats":{"Line":1}},{"line":405,"address":[],"length":0,"stats":{"Line":31}},{"line":418,"address":[],"length":0,"stats":{"Line":6}},{"line":419,"address":[],"length":0,"stats":{"Line":24}}],"covered":103,"coverable":127},{"path":["/","workspace","crates","ofml-lib","src","oap","property.rs"],"content":"//! Property resolution from CLS classes and EBASE\n//!\n//! This module provides utilities for resolving property definitions\n//! from CLS class instances and enriching them with EBASE metadata.\n\nuse crate::property::{PropertyDef, PropertyManager, PropertyState, PropertyType, PropertyValue};\nuse crate::value::Value;\n\n/// Error type for property resolution\n#[derive(Debug, thiserror::Error)]\npub enum PropertyResolutionError {\n    #[error(\"Property not found: {0}\")]\n    PropertyNotFound(String),\n\n    #[error(\"Invalid property type: {0}\")]\n    InvalidPropertyType(String),\n\n    #[error(\"Value out of range: {0}\")]\n    ValueOutOfRange(String),\n\n    #[error(\"Invalid choice value: {0}\")]\n    InvalidChoiceValue(String),\n}\n\n/// Extract property definitions from a CLS class instance\n///\n/// This function reads the `propList` or property definitions from\n/// a CLS class instance and creates PropertyDef entries.\npub fn extract_properties_from_cls(instance: &Value) -> PropertyManager {\n    let mut manager = PropertyManager::new();\n\n    if let Value::Object(obj_ref) = instance {\n        let obj = obj_ref.borrow();\n\n        // Extract from prop_defs if available\n        for (name, def) in &obj.prop_defs {\n            let prop_type = parse_property_type(&Some(def.type_info.clone()));\n            let state = PropertyState::from_int(obj.prop_states.get(name).copied().unwrap_or(1));\n\n            let prop_def = PropertyDef {\n                name: name.clone(),\n                label: def.description.clone(), // Use description as label (value::PropertyDef)\n                prop_type,\n                state,\n                sort_order: def.sort_order,\n                description: Some(def.description.clone()),\n                category: None, // value::PropertyDef doesn't have category\n            };\n\n            manager.definitions.insert(name.clone(), prop_def);\n        }\n\n        // Extract current values\n        for (name, value) in &obj.properties {\n            if let Some(pv) = value_to_property_value(value) {\n                manager.values.insert(name.clone(), pv);\n            }\n        }\n    }\n\n    manager\n}\n\n/// Parse a property type from the type info string\nfn parse_property_type(type_info: &Option<String>) -> PropertyType {\n    match type_info.as_deref() {\n        Some(info) if info.starts_with(\"ch \") => {\n            // Choice list: \"ch @opt1 @opt2 @opt3\"\n            let options: Vec<String> = info[3..]\n                .split_whitespace()\n                .map(|s| s.trim_start_matches('@').to_string())\n                .collect();\n            PropertyType::Choice { options }\n        }\n        Some(info) if info.starts_with(\"i \") || info.starts_with(\"int \") => {\n            // Integer with range: \"i 0 100\" or \"int 0 100\"\n            let parts: Vec<&str> = info.split_whitespace().collect();\n            let min = parts.get(1).and_then(|s| s.parse().ok());\n            let max = parts.get(2).and_then(|s| s.parse().ok());\n            PropertyType::Int { min, max }\n        }\n        Some(info) if info.starts_with(\"f \") || info.starts_with(\"float \") => {\n            // Float with range\n            let parts: Vec<&str> = info.split_whitespace().collect();\n            let min = parts.get(1).and_then(|s| s.parse().ok());\n            let max = parts.get(2).and_then(|s| s.parse().ok());\n            PropertyType::Float { min, max }\n        }\n        Some(info) if info == \"bool\" || info == \"b\" => PropertyType::Bool,\n        Some(info) if info == \"string\" || info == \"s\" => PropertyType::String,\n        _ => PropertyType::String, // Default to string\n    }\n}\n\n/// Convert a CLS Value to a PropertyValue\nfn value_to_property_value(value: &Value) -> Option<PropertyValue> {\n    match value {\n        Value::Int(i) => Some(PropertyValue::Int(*i)),\n        Value::Float(f) => Some(PropertyValue::Float(*f)),\n        Value::Bool(b) => Some(PropertyValue::Bool(*b)),\n        Value::String(s) => Some(PropertyValue::String(s.to_string())),\n        Value::Symbol(s) => Some(PropertyValue::Symbol(s.to_string())),\n        _ => None,\n    }\n}\n\n/// Validate a property value against its definition\npub fn validate_property_value(\n    def: &PropertyDef,\n    value: &PropertyValue,\n) -> Result<(), PropertyResolutionError> {\n    match (&def.prop_type, value) {\n        (PropertyType::Int { min, max }, PropertyValue::Int(v)) => {\n            if let Some(min_val) = min {\n                if v < min_val {\n                    return Err(PropertyResolutionError::ValueOutOfRange(format!(\n                        \"{} < {} (min)\",\n                        v, min_val\n                    )));\n                }\n            }\n            if let Some(max_val) = max {\n                if v > max_val {\n                    return Err(PropertyResolutionError::ValueOutOfRange(format!(\n                        \"{} > {} (max)\",\n                        v, max_val\n                    )));\n                }\n            }\n            Ok(())\n        }\n        (PropertyType::Float { min, max }, PropertyValue::Float(v)) => {\n            if let Some(min_val) = min {\n                if v < min_val {\n                    return Err(PropertyResolutionError::ValueOutOfRange(format!(\n                        \"{} < {} (min)\",\n                        v, min_val\n                    )));\n                }\n            }\n            if let Some(max_val) = max {\n                if v > max_val {\n                    return Err(PropertyResolutionError::ValueOutOfRange(format!(\n                        \"{} > {} (max)\",\n                        v, max_val\n                    )));\n                }\n            }\n            Ok(())\n        }\n        (PropertyType::Choice { options }, PropertyValue::Symbol(s))\n        | (PropertyType::Choice { options }, PropertyValue::String(s)) => {\n            if options.contains(s) {\n                Ok(())\n            } else {\n                Err(PropertyResolutionError::InvalidChoiceValue(format!(\n                    \"{} not in {:?}\",\n                    s, options\n                )))\n            }\n        }\n        (PropertyType::Bool, PropertyValue::Bool(_)) => Ok(()),\n        (PropertyType::String, PropertyValue::String(_)) => Ok(()),\n        _ => Err(PropertyResolutionError::InvalidPropertyType(format!(\n            \"Type mismatch for {}\",\n            def.name\n        ))),\n    }\n}\n\n/// Parse a property value from a string based on property type\npub fn parse_property_value(\n    def: &PropertyDef,\n    value_str: &str,\n) -> Result<PropertyValue, PropertyResolutionError> {\n    match &def.prop_type {\n        PropertyType::Int { .. } => {\n            value_str\n                .parse::<i64>()\n                .map(PropertyValue::Int)\n                .map_err(|_| {\n                    PropertyResolutionError::InvalidPropertyType(format!(\n                        \"Cannot parse '{}' as integer\",\n                        value_str\n                    ))\n                })\n        }\n        PropertyType::Float { .. } => {\n            value_str\n                .parse::<f64>()\n                .map(PropertyValue::Float)\n                .map_err(|_| {\n                    PropertyResolutionError::InvalidPropertyType(format!(\n                        \"Cannot parse '{}' as float\",\n                        value_str\n                    ))\n                })\n        }\n        PropertyType::Bool => match value_str.to_lowercase().as_str() {\n            \"true\" | \"1\" | \"yes\" | \"ja\" => Ok(PropertyValue::Bool(true)),\n            \"false\" | \"0\" | \"no\" | \"nein\" => Ok(PropertyValue::Bool(false)),\n            _ => Err(PropertyResolutionError::InvalidPropertyType(format!(\n                \"Cannot parse '{}' as boolean\",\n                value_str\n            ))),\n        },\n        PropertyType::Choice { options } => {\n            // Try to match as symbol first\n            if options.contains(&value_str.to_string()) {\n                Ok(PropertyValue::Symbol(value_str.to_string()))\n            } else {\n                Err(PropertyResolutionError::InvalidChoiceValue(format!(\n                    \"'{}' not in {:?}\",\n                    value_str, options\n                )))\n            }\n        }\n        PropertyType::String => Ok(PropertyValue::String(value_str.to_string())),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cell::RefCell;\n    use std::rc::Rc;\n\n    #[test]\n    fn test_parse_property_type_choice() {\n        let pt = parse_property_type(&Some(\"ch @white @black @oak\".to_string()));\n        if let PropertyType::Choice { options } = pt {\n            assert_eq!(options, vec![\"white\", \"black\", \"oak\"]);\n        } else {\n            panic!(\"Expected Choice type\");\n        }\n    }\n\n    #[test]\n    fn test_parse_property_type_int() {\n        let pt = parse_property_type(&Some(\"i 0 100\".to_string()));\n        if let PropertyType::Int { min, max } = pt {\n            assert_eq!(min, Some(0));\n            assert_eq!(max, Some(100));\n        } else {\n            panic!(\"Expected Int type\");\n        }\n\n        // Also test \"int\" prefix\n        let pt2 = parse_property_type(&Some(\"int -50 50\".to_string()));\n        if let PropertyType::Int { min, max } = pt2 {\n            assert_eq!(min, Some(-50));\n            assert_eq!(max, Some(50));\n        } else {\n            panic!(\"Expected Int type\");\n        }\n    }\n\n    #[test]\n    fn test_parse_property_type_float() {\n        let pt = parse_property_type(&Some(\"f 0.0 1.0\".to_string()));\n        if let PropertyType::Float { min, max } = pt {\n            assert_eq!(min, Some(0.0));\n            assert_eq!(max, Some(1.0));\n        } else {\n            panic!(\"Expected Float type\");\n        }\n\n        // Also test \"float\" prefix\n        let pt2 = parse_property_type(&Some(\"float -100.5 100.5\".to_string()));\n        if let PropertyType::Float { min, max } = pt2 {\n            assert_eq!(min, Some(-100.5));\n            assert_eq!(max, Some(100.5));\n        } else {\n            panic!(\"Expected Float type\");\n        }\n    }\n\n    #[test]\n    fn test_parse_property_type_bool() {\n        let pt = parse_property_type(&Some(\"bool\".to_string()));\n        assert!(matches!(pt, PropertyType::Bool));\n\n        let pt2 = parse_property_type(&Some(\"b\".to_string()));\n        assert!(matches!(pt2, PropertyType::Bool));\n    }\n\n    #[test]\n    fn test_parse_property_type_string() {\n        let pt = parse_property_type(&Some(\"string\".to_string()));\n        assert!(matches!(pt, PropertyType::String));\n\n        let pt2 = parse_property_type(&Some(\"s\".to_string()));\n        assert!(matches!(pt2, PropertyType::String));\n    }\n\n    #[test]\n    fn test_parse_property_type_default() {\n        // Unknown or None defaults to String\n        let pt = parse_property_type(&None);\n        assert!(matches!(pt, PropertyType::String));\n\n        let pt2 = parse_property_type(&Some(\"unknown_type\".to_string()));\n        assert!(matches!(pt2, PropertyType::String));\n    }\n\n    #[test]\n    fn test_value_to_property_value_int() {\n        let v = Value::Int(42);\n        let pv = value_to_property_value(&v);\n        assert_eq!(pv, Some(PropertyValue::Int(42)));\n    }\n\n    #[test]\n    fn test_value_to_property_value_float() {\n        let v = Value::Float(3.14);\n        let pv = value_to_property_value(&v);\n        assert_eq!(pv, Some(PropertyValue::Float(3.14)));\n    }\n\n    #[test]\n    fn test_value_to_property_value_bool() {\n        let v = Value::Bool(true);\n        let pv = value_to_property_value(&v);\n        assert_eq!(pv, Some(PropertyValue::Bool(true)));\n    }\n\n    #[test]\n    fn test_value_to_property_value_string() {\n        let v = Value::String(Rc::new(\"test\".to_string()));\n        let pv = value_to_property_value(&v);\n        assert_eq!(pv, Some(PropertyValue::String(\"test\".to_string())));\n    }\n\n    #[test]\n    fn test_value_to_property_value_symbol() {\n        let v = Value::Symbol(Rc::new(\"sym\".to_string()));\n        let pv = value_to_property_value(&v);\n        assert_eq!(pv, Some(PropertyValue::Symbol(\"sym\".to_string())));\n    }\n\n    #[test]\n    fn test_value_to_property_value_unsupported() {\n        let v = Value::Null;\n        let pv = value_to_property_value(&v);\n        assert_eq!(pv, None);\n\n        let v2 = Value::Array(Rc::new(RefCell::new(vec![])));\n        assert_eq!(value_to_property_value(&v2), None);\n    }\n\n    #[test]\n    fn test_validate_int_in_range() {\n        let def = PropertyDef {\n            name: \"height\".to_string(),\n            label: \"Height\".to_string(),\n            prop_type: PropertyType::Int {\n                min: Some(620),\n                max: Some(820),\n            },\n            state: PropertyState::Enabled,\n            sort_order: 1,\n            description: None,\n            category: None,\n        };\n\n        assert!(validate_property_value(&def, &PropertyValue::Int(720)).is_ok());\n        assert!(validate_property_value(&def, &PropertyValue::Int(500)).is_err());\n        assert!(validate_property_value(&def, &PropertyValue::Int(900)).is_err());\n    }\n\n    #[test]\n    fn test_validate_int_no_bounds() {\n        let def = PropertyDef {\n            name: \"count\".to_string(),\n            label: \"Count\".to_string(),\n            prop_type: PropertyType::Int { min: None, max: None },\n            state: PropertyState::Enabled,\n            sort_order: 1,\n            description: None,\n            category: None,\n        };\n\n        assert!(validate_property_value(&def, &PropertyValue::Int(-1000)).is_ok());\n        assert!(validate_property_value(&def, &PropertyValue::Int(1000)).is_ok());\n    }\n\n    #[test]\n    fn test_validate_float_in_range() {\n        let def = PropertyDef {\n            name: \"ratio\".to_string(),\n            label: \"Ratio\".to_string(),\n            prop_type: PropertyType::Float {\n                min: Some(0.0),\n                max: Some(1.0),\n            },\n            state: PropertyState::Enabled,\n            sort_order: 1,\n            description: None,\n            category: None,\n        };\n\n        assert!(validate_property_value(&def, &PropertyValue::Float(0.5)).is_ok());\n        assert!(validate_property_value(&def, &PropertyValue::Float(-0.1)).is_err());\n        assert!(validate_property_value(&def, &PropertyValue::Float(1.1)).is_err());\n    }\n\n    #[test]\n    fn test_validate_float_no_bounds() {\n        let def = PropertyDef {\n            name: \"value\".to_string(),\n            label: \"Value\".to_string(),\n            prop_type: PropertyType::Float { min: None, max: None },\n            state: PropertyState::Enabled,\n            sort_order: 1,\n            description: None,\n            category: None,\n        };\n\n        assert!(validate_property_value(&def, &PropertyValue::Float(-1000.0)).is_ok());\n        assert!(validate_property_value(&def, &PropertyValue::Float(1000.0)).is_ok());\n    }\n\n    #[test]\n    fn test_validate_choice() {\n        let def = PropertyDef {\n            name: \"color\".to_string(),\n            label: \"Color\".to_string(),\n            prop_type: PropertyType::Choice {\n                options: vec![\"white\".to_string(), \"black\".to_string()],\n            },\n            state: PropertyState::Enabled,\n            sort_order: 1,\n            description: None,\n            category: None,\n        };\n\n        assert!(validate_property_value(&def, &PropertyValue::Symbol(\"white\".to_string())).is_ok());\n        assert!(validate_property_value(&def, &PropertyValue::String(\"black\".to_string())).is_ok());\n        assert!(validate_property_value(&def, &PropertyValue::Symbol(\"red\".to_string())).is_err());\n    }\n\n    #[test]\n    fn test_validate_bool() {\n        let def = PropertyDef {\n            name: \"enabled\".to_string(),\n            label: \"Enabled\".to_string(),\n            prop_type: PropertyType::Bool,\n            state: PropertyState::Enabled,\n            sort_order: 1,\n            description: None,\n            category: None,\n        };\n\n        assert!(validate_property_value(&def, &PropertyValue::Bool(true)).is_ok());\n        assert!(validate_property_value(&def, &PropertyValue::Bool(false)).is_ok());\n    }\n\n    #[test]\n    fn test_validate_string() {\n        let def = PropertyDef {\n            name: \"name\".to_string(),\n            label: \"Name\".to_string(),\n            prop_type: PropertyType::String,\n            state: PropertyState::Enabled,\n            sort_order: 1,\n            description: None,\n            category: None,\n        };\n\n        assert!(validate_property_value(&def, &PropertyValue::String(\"test\".to_string())).is_ok());\n    }\n\n    #[test]\n    fn test_validate_type_mismatch() {\n        let def = PropertyDef {\n            name: \"count\".to_string(),\n            label: \"Count\".to_string(),\n            prop_type: PropertyType::Int { min: None, max: None },\n            state: PropertyState::Enabled,\n            sort_order: 1,\n            description: None,\n            category: None,\n        };\n\n        // String value for Int type\n        let result = validate_property_value(&def, &PropertyValue::String(\"test\".to_string()));\n        assert!(result.is_err());\n        if let Err(PropertyResolutionError::InvalidPropertyType(msg)) = result {\n            assert!(msg.contains(\"Type mismatch\"));\n        }\n    }\n\n    #[test]\n    fn test_parse_property_value_int() {\n        let def = PropertyDef {\n            name: \"height\".to_string(),\n            label: \"Height\".to_string(),\n            prop_type: PropertyType::Int {\n                min: None,\n                max: None,\n            },\n            state: PropertyState::Enabled,\n            sort_order: 1,\n            description: None,\n            category: None,\n        };\n\n        let result = parse_property_value(&def, \"720\");\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), PropertyValue::Int(720));\n\n        let invalid = parse_property_value(&def, \"not_a_number\");\n        assert!(invalid.is_err());\n    }\n\n    #[test]\n    fn test_parse_property_value_float() {\n        let def = PropertyDef {\n            name: \"ratio\".to_string(),\n            label: \"Ratio\".to_string(),\n            prop_type: PropertyType::Float { min: None, max: None },\n            state: PropertyState::Enabled,\n            sort_order: 1,\n            description: None,\n            category: None,\n        };\n\n        let result = parse_property_value(&def, \"3.14\");\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), PropertyValue::Float(3.14));\n\n        let invalid = parse_property_value(&def, \"not_a_float\");\n        assert!(invalid.is_err());\n    }\n\n    #[test]\n    fn test_parse_property_value_bool() {\n        let def = PropertyDef {\n            name: \"enabled\".to_string(),\n            label: \"Enabled\".to_string(),\n            prop_type: PropertyType::Bool,\n            state: PropertyState::Enabled,\n            sort_order: 1,\n            description: None,\n            category: None,\n        };\n\n        assert_eq!(\n            parse_property_value(&def, \"true\").unwrap(),\n            PropertyValue::Bool(true)\n        );\n        assert_eq!(\n            parse_property_value(&def, \"ja\").unwrap(),\n            PropertyValue::Bool(true)\n        );\n        assert_eq!(\n            parse_property_value(&def, \"yes\").unwrap(),\n            PropertyValue::Bool(true)\n        );\n        assert_eq!(\n            parse_property_value(&def, \"1\").unwrap(),\n            PropertyValue::Bool(true)\n        );\n        assert_eq!(\n            parse_property_value(&def, \"0\").unwrap(),\n            PropertyValue::Bool(false)\n        );\n        assert_eq!(\n            parse_property_value(&def, \"false\").unwrap(),\n            PropertyValue::Bool(false)\n        );\n        assert_eq!(\n            parse_property_value(&def, \"no\").unwrap(),\n            PropertyValue::Bool(false)\n        );\n        assert_eq!(\n            parse_property_value(&def, \"nein\").unwrap(),\n            PropertyValue::Bool(false)\n        );\n\n        let invalid = parse_property_value(&def, \"maybe\");\n        assert!(invalid.is_err());\n    }\n\n    #[test]\n    fn test_parse_property_value_choice() {\n        let def = PropertyDef {\n            name: \"color\".to_string(),\n            label: \"Color\".to_string(),\n            prop_type: PropertyType::Choice {\n                options: vec![\"red\".to_string(), \"blue\".to_string()],\n            },\n            state: PropertyState::Enabled,\n            sort_order: 1,\n            description: None,\n            category: None,\n        };\n\n        let result = parse_property_value(&def, \"red\");\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), PropertyValue::Symbol(\"red\".to_string()));\n\n        let invalid = parse_property_value(&def, \"green\");\n        assert!(invalid.is_err());\n    }\n\n    #[test]\n    fn test_parse_property_value_string() {\n        let def = PropertyDef {\n            name: \"text\".to_string(),\n            label: \"Text\".to_string(),\n            prop_type: PropertyType::String,\n            state: PropertyState::Enabled,\n            sort_order: 1,\n            description: None,\n            category: None,\n        };\n\n        let result = parse_property_value(&def, \"any text here\");\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), PropertyValue::String(\"any text here\".to_string()));\n    }\n\n    #[test]\n    fn test_property_resolution_error_display() {\n        let e1 = PropertyResolutionError::PropertyNotFound(\"test\".to_string());\n        assert!(format!(\"{}\", e1).contains(\"not found\"));\n\n        let e2 = PropertyResolutionError::InvalidPropertyType(\"bad type\".to_string());\n        assert!(format!(\"{}\", e2).contains(\"Invalid property type\"));\n\n        let e3 = PropertyResolutionError::ValueOutOfRange(\"too big\".to_string());\n        assert!(format!(\"{}\", e3).contains(\"out of range\"));\n\n        let e4 = PropertyResolutionError::InvalidChoiceValue(\"invalid\".to_string());\n        assert!(format!(\"{}\", e4).contains(\"Invalid choice\"));\n    }\n\n    #[test]\n    fn test_extract_properties_from_cls_null() {\n        // Non-object value should return empty manager\n        let v = Value::Null;\n        let manager = extract_properties_from_cls(&v);\n        assert!(manager.definitions.is_empty());\n        assert!(manager.values.is_empty());\n    }\n\n    #[test]\n    fn test_extract_properties_from_cls_empty_object() {\n        use crate::value::ObjInstance;\n\n        let obj = ObjInstance::default();\n        let v = Value::Object(Rc::new(RefCell::new(obj)));\n        let manager = extract_properties_from_cls(&v);\n\n        // Empty object should return empty manager\n        assert!(manager.definitions.is_empty());\n        assert!(manager.values.is_empty());\n    }\n\n    #[test]\n    fn test_extract_properties_from_cls_with_properties() {\n        use crate::value::{ObjInstance, PropertyDef as ValuePropertyDef};\n\n        let mut obj = ObjInstance::default();\n\n        // Add a property definition\n        obj.prop_defs.insert(\"color\".to_string(), ValuePropertyDef {\n            name: \"color\".to_string(),\n            type_info: \"ch @red @blue @green\".to_string(),\n            description: \"Color Selection\".to_string(),\n            sort_order: 1,\n            group: 0,\n            choices: vec![],\n            state: 3,\n            default_value: Value::Symbol(Rc::new(\"red\".to_string())),\n        });\n\n        // Add property state\n        obj.prop_states.insert(\"color\".to_string(), 3);\n\n        // Add current value\n        obj.properties.insert(\"color\".to_string(), Value::Symbol(Rc::new(\"blue\".to_string())));\n\n        let v = Value::Object(Rc::new(RefCell::new(obj)));\n        let manager = extract_properties_from_cls(&v);\n\n        // Should have one definition\n        assert_eq!(manager.definitions.len(), 1);\n        let def = manager.definitions.get(\"color\").unwrap();\n        assert_eq!(def.name, \"color\");\n        assert_eq!(def.label, \"Color Selection\");\n\n        // Should have one value\n        assert_eq!(manager.values.len(), 1);\n        let val = manager.values.get(\"color\").unwrap();\n        assert_eq!(*val, PropertyValue::Symbol(\"blue\".to_string()));\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":3}},{"line":30,"address":[],"length":0,"stats":{"Line":6}},{"line":32,"address":[],"length":0,"stats":{"Line":5}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":36,"address":[],"length":0,"stats":{"Line":5}},{"line":37,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":8}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":3}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":4}},{"line":54,"address":[],"length":0,"stats":{"Line":4}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":56,"address":[],"length":0,"stats":{"Line":4}},{"line":61,"address":[],"length":0,"stats":{"Line":3}},{"line":65,"address":[],"length":0,"stats":{"Line":12}},{"line":66,"address":[],"length":0,"stats":{"Line":24}},{"line":67,"address":[],"length":0,"stats":{"Line":26}},{"line":69,"address":[],"length":0,"stats":{"Line":6}},{"line":71,"address":[],"length":0,"stats":{"Line":14}},{"line":75,"address":[],"length":0,"stats":{"Line":38}},{"line":77,"address":[],"length":0,"stats":{"Line":10}},{"line":78,"address":[],"length":0,"stats":{"Line":12}},{"line":79,"address":[],"length":0,"stats":{"Line":12}},{"line":82,"address":[],"length":0,"stats":{"Line":30}},{"line":84,"address":[],"length":0,"stats":{"Line":10}},{"line":85,"address":[],"length":0,"stats":{"Line":12}},{"line":86,"address":[],"length":0,"stats":{"Line":12}},{"line":89,"address":[],"length":0,"stats":{"Line":15}},{"line":90,"address":[],"length":0,"stats":{"Line":11}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":8}},{"line":97,"address":[],"length":0,"stats":{"Line":8}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":4}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":17}},{"line":112,"address":[],"length":0,"stats":{"Line":34}},{"line":113,"address":[],"length":0,"stats":{"Line":15}},{"line":114,"address":[],"length":0,"stats":{"Line":8}},{"line":115,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":1}},{"line":117,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":122,"address":[],"length":0,"stats":{"Line":6}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":124,"address":[],"length":0,"stats":{"Line":1}},{"line":125,"address":[],"length":0,"stats":{"Line":1}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":3}},{"line":132,"address":[],"length":0,"stats":{"Line":15}},{"line":133,"address":[],"length":0,"stats":{"Line":8}},{"line":134,"address":[],"length":0,"stats":{"Line":3}},{"line":135,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":1}},{"line":137,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":6}},{"line":142,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":3}},{"line":151,"address":[],"length":0,"stats":{"Line":4}},{"line":152,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":6}},{"line":154,"address":[],"length":0,"stats":{"Line":2}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":163,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":16}},{"line":176,"address":[],"length":0,"stats":{"Line":16}},{"line":178,"address":[],"length":0,"stats":{"Line":2}},{"line":180,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":3}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":2}},{"line":192,"address":[],"length":0,"stats":{"Line":3}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":1}},{"line":195,"address":[],"length":0,"stats":{"Line":1}},{"line":199,"address":[],"length":0,"stats":{"Line":9}},{"line":200,"address":[],"length":0,"stats":{"Line":34}},{"line":201,"address":[],"length":0,"stats":{"Line":18}},{"line":202,"address":[],"length":0,"stats":{"Line":1}},{"line":203,"address":[],"length":0,"stats":{"Line":1}},{"line":204,"address":[],"length":0,"stats":{"Line":1}},{"line":207,"address":[],"length":0,"stats":{"Line":2}},{"line":209,"address":[],"length":0,"stats":{"Line":6}},{"line":210,"address":[],"length":0,"stats":{"Line":1}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":213,"address":[],"length":0,"stats":{"Line":1}},{"line":214,"address":[],"length":0,"stats":{"Line":1}},{"line":218,"address":[],"length":0,"stats":{"Line":1}}],"covered":105,"coverable":105},{"path":["/","workspace","crates","ofml-lib","src","oap","variant.rs"],"content":"//! Variant code generation from property values\r\n//!\r\n//! This module implements the OFML variant code generation algorithm,\r\n//! which concatenates property value codes with underscore separators,\r\n//! ordered by property sort order.\r\n\r\nuse crate::property::{PropertyManager, PropertyValue};\r\n\r\n/// Generate an OFML variant code from property values.\r\n///\r\n/// Properties are sorted by their sort_order and concatenated with underscores.\r\n/// The resulting code identifies a specific product configuration for pricing.\r\n///\r\n/// # Arguments\r\n/// * `properties` - PropertyManager containing values and definitions\r\n///\r\n/// # Returns\r\n/// A variant code string (e.g., \"H720_D1200_CWH\")\r\npub fn generate_variant_code(properties: &PropertyManager) -> String {\r\n    let mut codes: Vec<(i32, String)> = Vec::new();\r\n\r\n    // Collect properties with sort order > 0 (participating in variant code)\r\n    for (name, value) in &properties.values {\r\n        // Get sort order from definition, default to 0 if not defined\r\n        let sort_order = properties\r\n            .definitions\r\n            .get(name)\r\n            .map(|def| def.sort_order)\r\n            .unwrap_or(0);\r\n\r\n        // Skip properties with sort_order <= 0 (not part of variant code)\r\n        if sort_order <= 0 {\r\n            continue;\r\n        }\r\n\r\n        let code = value_to_code(value);\r\n        if !code.is_empty() {\r\n            codes.push((sort_order, code));\r\n        }\r\n    }\r\n\r\n    // Sort by sort_order\r\n    codes.sort_by_key(|(order, _)| *order);\r\n\r\n    // Join with underscores\r\n    codes\r\n        .into_iter()\r\n        .map(|(_, c)| c)\r\n        .collect::<Vec<_>>()\r\n        .join(\"_\")\r\n}\r\n\r\n/// Convert a property value to its variant code representation\r\nfn value_to_code(value: &PropertyValue) -> String {\r\n    match value {\r\n        PropertyValue::Symbol(s) => s.clone(),\r\n        PropertyValue::Int(i) => format!(\"{}\", i),\r\n        PropertyValue::Float(f) => {\r\n            // Format without decimal if it's a whole number\r\n            if f.fract() == 0.0 {\r\n                format!(\"{:.0}\", f)\r\n            } else {\r\n                format!(\"{}\", f)\r\n            }\r\n        }\r\n        PropertyValue::Bool(b) => {\r\n            if *b {\r\n                \"1\".to_string()\r\n            } else {\r\n                \"0\".to_string()\r\n            }\r\n        }\r\n        PropertyValue::String(s) => s.clone(),\r\n    }\r\n}\r\n\r\n/// Validate variant code length against EBASE constraints\r\n///\r\n/// # Arguments\r\n/// * `code` - The variant code to validate\r\n/// * `max_length` - Maximum allowed length (typically 50)\r\n///\r\n/// # Returns\r\n/// `true` if valid, `false` if too long\r\npub fn validate_variant_code_length(code: &str, max_length: usize) -> bool {\r\n    code.len() <= max_length\r\n}\r\n\r\n/// Truncate or hash a variant code if it exceeds maximum length\r\n///\r\n/// # Arguments\r\n/// * `code` - The variant code to process\r\n/// * `max_length` - Maximum allowed length\r\n///\r\n/// # Returns\r\n/// The original code if within limits, or a truncated version\r\npub fn truncate_variant_code(code: &str, max_length: usize) -> String {\r\n    if code.len() <= max_length {\r\n        code.to_string()\r\n    } else {\r\n        // Truncate with ellipsis indicator\r\n        let truncate_to = max_length.saturating_sub(3);\r\n        format!(\"{}...\", &code[..truncate_to])\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::property::{PropertyDef, PropertyType};\r\n\r\n    fn create_test_properties() -> PropertyManager {\r\n        let mut pm = PropertyManager::new();\r\n\r\n        // Add definitions with sort orders\r\n        pm.definitions.insert(\r\n            \"height\".to_string(),\r\n            PropertyDef {\r\n                name: \"height\".to_string(),\r\n                label: \"H√∂he\".to_string(),\r\n                prop_type: PropertyType::Int {\r\n                    min: Some(620),\r\n                    max: Some(820),\r\n                },\r\n                state: crate::property::PropertyState::Enabled,\r\n                sort_order: 1,\r\n                description: None,\r\n                category: None,\r\n            },\r\n        );\r\n\r\n        pm.definitions.insert(\r\n            \"diameter\".to_string(),\r\n            PropertyDef {\r\n                name: \"diameter\".to_string(),\r\n                label: \"Durchmesser\".to_string(),\r\n                prop_type: PropertyType::Int {\r\n                    min: Some(800),\r\n                    max: Some(1600),\r\n                },\r\n                state: crate::property::PropertyState::Enabled,\r\n                sort_order: 2,\r\n                description: None,\r\n                category: None,\r\n            },\r\n        );\r\n\r\n        pm.definitions.insert(\r\n            \"color\".to_string(),\r\n            PropertyDef {\r\n                name: \"color\".to_string(),\r\n                label: \"Farbe\".to_string(),\r\n                prop_type: PropertyType::Choice {\r\n                    options: vec![\"white\".to_string(), \"black\".to_string()],\r\n                },\r\n                state: crate::property::PropertyState::Enabled,\r\n                sort_order: 3,\r\n                description: None,\r\n                category: None,\r\n            },\r\n        );\r\n\r\n        // Property without sort order (should not appear in variant code)\r\n        pm.definitions.insert(\r\n            \"internal\".to_string(),\r\n            PropertyDef {\r\n                name: \"internal\".to_string(),\r\n                label: \"Internal\".to_string(),\r\n                prop_type: PropertyType::String,\r\n                state: crate::property::PropertyState::Hidden,\r\n                sort_order: 0,\r\n                description: None,\r\n                category: None,\r\n            },\r\n        );\r\n\r\n        // Add values\r\n        pm.values\r\n            .insert(\"height\".to_string(), PropertyValue::Int(720));\r\n        pm.values\r\n            .insert(\"diameter\".to_string(), PropertyValue::Int(1200));\r\n        pm.values.insert(\r\n            \"color\".to_string(),\r\n            PropertyValue::Symbol(\"white\".to_string()),\r\n        );\r\n        pm.values.insert(\r\n            \"internal\".to_string(),\r\n            PropertyValue::String(\"test\".to_string()),\r\n        );\r\n\r\n        pm\r\n    }\r\n\r\n    #[test]\r\n    fn test_generate_variant_code() {\r\n        let pm = create_test_properties();\r\n        let code = generate_variant_code(&pm);\r\n        assert_eq!(code, \"720_1200_white\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_generate_variant_code_empty() {\r\n        let pm = PropertyManager::new();\r\n        let code = generate_variant_code(&pm);\r\n        assert_eq!(code, \"\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_value_to_code_int() {\r\n        assert_eq!(value_to_code(&PropertyValue::Int(720)), \"720\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_value_to_code_float_whole() {\r\n        assert_eq!(value_to_code(&PropertyValue::Float(100.0)), \"100\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_value_to_code_float_decimal() {\r\n        assert_eq!(value_to_code(&PropertyValue::Float(100.5)), \"100.5\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_value_to_code_bool() {\r\n        assert_eq!(value_to_code(&PropertyValue::Bool(true)), \"1\");\r\n        assert_eq!(value_to_code(&PropertyValue::Bool(false)), \"0\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_value_to_code_symbol() {\r\n        assert_eq!(\r\n            value_to_code(&PropertyValue::Symbol(\"white\".to_string())),\r\n            \"white\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_validate_variant_code_length() {\r\n        assert!(validate_variant_code_length(\"H720_D1200\", 50));\r\n        assert!(!validate_variant_code_length(\"H720_D1200\", 5));\r\n    }\r\n\r\n    #[test]\r\n    fn test_truncate_variant_code() {\r\n        let code = \"H720_D1200_CWH_FCR_MAT001\";\r\n        assert_eq!(truncate_variant_code(code, 50), code);\r\n        assert_eq!(truncate_variant_code(code, 10), \"H720_D1...\");\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":6}},{"line":20,"address":[],"length":0,"stats":{"Line":18}},{"line":23,"address":[],"length":0,"stats":{"Line":39}},{"line":25,"address":[],"length":0,"stats":{"Line":22}},{"line":26,"address":[],"length":0,"stats":{"Line":11}},{"line":27,"address":[],"length":0,"stats":{"Line":22}},{"line":28,"address":[],"length":0,"stats":{"Line":11}},{"line":32,"address":[],"length":0,"stats":{"Line":11}},{"line":33,"address":[],"length":0,"stats":{"Line":8}},{"line":36,"address":[],"length":0,"stats":{"Line":9}},{"line":37,"address":[],"length":0,"stats":{"Line":6}},{"line":38,"address":[],"length":0,"stats":{"Line":9}},{"line":43,"address":[],"length":0,"stats":{"Line":12}},{"line":46,"address":[],"length":0,"stats":{"Line":6}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":54,"address":[],"length":0,"stats":{"Line":9}},{"line":55,"address":[],"length":0,"stats":{"Line":9}},{"line":56,"address":[],"length":0,"stats":{"Line":6}},{"line":57,"address":[],"length":0,"stats":{"Line":9}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":2}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":4}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":3}},{"line":103,"address":[],"length":0,"stats":{"Line":3}}],"covered":34,"coverable":35},{"path":["/","workspace","crates","ofml-lib","src","ofml.rs"],"content":"//! OFML (Open Furniture Modeling Language) data reader.\n//!\n//! This module provides a high-level interface for reading OFML data directories\n//! used by EasternGraphics furniture configuration software.\n//!\n//! OFML Directory Structure:\n//! ```text\n//! {manufacturer}/\n//!     global/\n//!         1/\n//!             global.ebase    - Global type definitions, articles, properties\n//!             ofml.ebase      - OFML metadata\n//!             *.alb           - Album files\n//!     {product}/\n//!         1/\n//!             odb.ebase       - Object database (3D/2D definitions)\n//!             ofml.ebase      - OFML metadata\n//!             *.alb           - Album files (3D geometry)\n//!             *.geo           - Geometry files (SEDUS)\n//!             *.mat           - Material files (SEDUS)\n//!         {country}/\n//!             1/\n//!                 db/\n//!                     pdata.ebase - Pricing data\n//!                 oam/\n//!                     oam.ebase   - Article master data\n//!                 oap/\n//!                     oap.ebase   - Article pictures metadata\n//! ```\n\nuse std::collections::HashMap;\nuse std::fs;\nuse std::io::{self, Cursor, Read};\nuse std::path::{Path, PathBuf};\nuse zip::ZipArchive;\n\nuse crate::ebase::{EBaseError, EBaseReader};\nuse crate::geometry::{parse_3ds, parse_obj, GeometryError, Scene3DS};\n\n/// ALB archive password (ROT13 encoded original)\npub const ALB_PASSWORD: &[u8] = b\"Gur#Ynzo$Yvrf%Qbja&Ba*Oebnqjnl.\";\n\n/// Error types for OFML operations\n#[derive(Debug)]\npub enum OFMLError {\n    Io(io::Error),\n    EBase(EBaseError),\n    Geometry(GeometryError),\n    Zip(zip::result::ZipError),\n    NotFound(String),\n    InvalidStructure(String),\n}\n\nimpl From<io::Error> for OFMLError {\n    fn from(err: io::Error) -> Self {\n        OFMLError::Io(err)\n    }\n}\n\nimpl From<EBaseError> for OFMLError {\n    fn from(err: EBaseError) -> Self {\n        OFMLError::EBase(err)\n    }\n}\n\nimpl From<GeometryError> for OFMLError {\n    fn from(err: GeometryError) -> Self {\n        OFMLError::Geometry(err)\n    }\n}\n\nimpl From<zip::result::ZipError> for OFMLError {\n    fn from(err: zip::result::ZipError) -> Self {\n        OFMLError::Zip(err)\n    }\n}\n\nimpl std::fmt::Display for OFMLError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            OFMLError::Io(e) => write!(f, \"IO error: {}\", e),\n            OFMLError::EBase(e) => write!(f, \"EBase error: {}\", e),\n            OFMLError::Geometry(e) => write!(f, \"Geometry error: {}\", e),\n            OFMLError::Zip(e) => write!(f, \"ZIP error: {}\", e),\n            OFMLError::NotFound(s) => write!(f, \"Not found: {}\", s),\n            OFMLError::InvalidStructure(s) => write!(f, \"Invalid structure: {}\", s),\n        }\n    }\n}\n\nimpl std::error::Error for OFMLError {}\n\n/// An ALB archive (encrypted ZIP with 3D assets and CLS files)\npub struct AlbArchive {\n    archive: ZipArchive<Cursor<Vec<u8>>>,\n    path: PathBuf,\n}\n\nimpl AlbArchive {\n    /// Open an ALB archive\n    pub fn open<P: AsRef<Path>>(path: P) -> Result<Self, OFMLError> {\n        let path = path.as_ref().to_path_buf();\n        let data = fs::read(&path)?;\n        let cursor = Cursor::new(data);\n        let archive = ZipArchive::new(cursor)?;\n        Ok(AlbArchive { archive, path })\n    }\n\n    /// List all files in the archive\n    pub fn list_files(&self) -> Vec<String> {\n        (0..self.archive.len())\n            .filter_map(|i| self.archive.name_for_index(i).map(|n| n.to_string()))\n            .collect()\n    }\n\n    /// List files matching a pattern (glob-like)\n    pub fn list_files_matching(&self, extension: &str) -> Vec<String> {\n        self.list_files()\n            .into_iter()\n            .filter(|name| name.to_lowercase().ends_with(extension))\n            .collect()\n    }\n\n    /// Extract a file by name\n    pub fn extract(&mut self, name: &str) -> Result<Vec<u8>, OFMLError> {\n        // Find the file index by name\n        let index = (0..self.archive.len())\n            .find(|&i| {\n                self.archive\n                    .name_for_index(i)\n                    .map(|n| n == name)\n                    .unwrap_or(false)\n            })\n            .ok_or_else(|| OFMLError::NotFound(name.to_string()))?;\n\n        // Extract by index with decryption\n        let mut file = match self.archive.by_index_decrypt(index, ALB_PASSWORD) {\n            Ok(f) => f,\n            Err(e) => return Err(OFMLError::Zip(e)),\n        };\n\n        let mut data = Vec::new();\n        file.read_to_end(&mut data)?;\n        Ok(data)\n    }\n\n    /// Extract and parse a CLS file\n    pub fn extract_cls(&mut self, name: &str) -> Result<String, OFMLError> {\n        let data = self.extract(name)?;\n        String::from_utf8(data)\n            .map_err(|_| OFMLError::InvalidStructure(\"Invalid UTF-8 in CLS file\".to_string()))\n    }\n\n    /// Extract and parse a 3DS file\n    pub fn extract_3ds(&mut self, name: &str) -> Result<Scene3DS, OFMLError> {\n        let data = self.extract(name)?;\n        parse_3ds(&data).map_err(OFMLError::from)\n    }\n\n    /// Extract and parse an OBJ file\n    pub fn extract_obj(&mut self, name: &str) -> Result<Scene3DS, OFMLError> {\n        let data = self.extract(name)?;\n        parse_obj(&data).map_err(OFMLError::from)\n    }\n\n    /// Extract and parse any geometry file (3DS or OBJ)\n    pub fn extract_geometry(&mut self, name: &str) -> Result<Scene3DS, OFMLError> {\n        let lower = name.to_lowercase();\n        if lower.ends_with(\".obj\") {\n            self.extract_obj(name)\n        } else if lower.ends_with(\".3ds\") {\n            self.extract_3ds(name)\n        } else {\n            Err(OFMLError::InvalidStructure(format!(\n                \"Unknown geometry format: {}\",\n                name\n            )))\n        }\n    }\n\n    /// Get all CLS files\n    pub fn get_cls_files(&self) -> Vec<String> {\n        self.list_files_matching(\".cls\")\n    }\n\n    /// Get all 3DS files\n    pub fn get_3ds_files(&self) -> Vec<String> {\n        self.list_files_matching(\".3ds\")\n    }\n\n    /// Get all OBJ files (Wavefront)\n    pub fn get_obj_files(&self) -> Vec<String> {\n        self.list_files_matching(\".obj\")\n    }\n\n    /// Get all geometry files (3DS + OBJ)\n    pub fn get_geometry_files(&self) -> Vec<String> {\n        let mut files = self.get_3ds_files();\n        files.extend(self.get_obj_files());\n        files\n    }\n\n    /// Get all string resource files\n    pub fn get_sr_files(&self) -> Vec<String> {\n        self.list_files_matching(\".sr\")\n    }\n\n    /// Get the archive path\n    pub fn path(&self) -> &Path {\n        &self.path\n    }\n}\n\n/// OFML product data\npub struct OFMLProduct {\n    pub manufacturer: String,\n    pub product_name: String,\n    pub base_path: PathBuf,\n    pub album_files: Vec<PathBuf>,\n    pub geo_files: Vec<PathBuf>,\n    pub mat_files: Vec<PathBuf>,\n}\n\nimpl OFMLProduct {\n    /// Check if product has EBASE databases\n    pub fn has_odb(&self) -> bool {\n        self.base_path.join(\"odb.ebase\").exists()\n    }\n\n    /// Check if product has ALB files (Vitra-style)\n    pub fn has_alb(&self) -> bool {\n        !self.album_files.is_empty()\n    }\n\n    /// Check if product has GEO files (SEDUS-style)\n    pub fn has_geo(&self) -> bool {\n        !self.geo_files.is_empty()\n    }\n\n    /// Open the ODB database\n    pub fn open_odb(&self) -> Result<EBaseReader, OFMLError> {\n        let path = self.base_path.join(\"odb.ebase\");\n        EBaseReader::open(&path).map_err(OFMLError::from)\n    }\n\n    /// Open the OFML metadata database\n    pub fn open_ofml(&self) -> Result<EBaseReader, OFMLError> {\n        let path = self.base_path.join(\"ofml.ebase\");\n        EBaseReader::open(&path).map_err(OFMLError::from)\n    }\n\n    /// Open an ALB archive\n    pub fn open_alb(&self, index: usize) -> Result<AlbArchive, OFMLError> {\n        if index >= self.album_files.len() {\n            return Err(OFMLError::NotFound(format!(\"ALB file index {}\", index)));\n        }\n        AlbArchive::open(&self.album_files[index])\n    }\n\n    /// Get available countries\n    pub fn get_countries(&self) -> Vec<String> {\n        let mut countries = Vec::new();\n        if let Ok(entries) = fs::read_dir(self.base_path.parent().unwrap_or(&self.base_path)) {\n            for entry in entries.filter_map(|e| e.ok()) {\n                let name = entry.file_name().to_string_lossy().to_string();\n                if name.len() == 2 && name.chars().all(|c| c.is_ascii_uppercase()) {\n                    countries.push(name);\n                }\n            }\n        }\n        countries.sort();\n        countries\n    }\n}\n\n/// OFML data reader for exploring manufacturer data\npub struct OFMLDataReader {\n    pub data_path: PathBuf,\n}\n\nimpl OFMLDataReader {\n    /// Create a new OFML data reader\n    pub fn new<P: AsRef<Path>>(path: P) -> Self {\n        OFMLDataReader {\n            data_path: path.as_ref().to_path_buf(),\n        }\n    }\n\n    /// Discover all manufacturers in the data directory\n    pub fn discover_manufacturers(&self) -> Vec<String> {\n        let mut manufacturers = Vec::new();\n        if let Ok(entries) = fs::read_dir(&self.data_path) {\n            for entry in entries.filter_map(|e| e.ok()) {\n                if entry.file_type().map(|t| t.is_dir()).unwrap_or(false) {\n                    let name = entry.file_name().to_string_lossy().to_string();\n                    // Skip special files\n                    if !name.starts_with('.')\n                        && name != \"install.db\"\n                        && name != \"profiles\"\n                        && name != \"registry\"\n                    {\n                        manufacturers.push(name);\n                    }\n                }\n            }\n        }\n        manufacturers.sort();\n        manufacturers\n    }\n\n    /// Discover all products for a manufacturer\n    pub fn discover_products(&self, manufacturer: &str) -> Vec<String> {\n        let mfr_path = self.data_path.join(manufacturer);\n        let mut products = Vec::new();\n\n        if let Ok(entries) = fs::read_dir(&mfr_path) {\n            for entry in entries.filter_map(|e| e.ok()) {\n                if entry.file_type().map(|t| t.is_dir()).unwrap_or(false) {\n                    let name = entry.file_name().to_string_lossy().to_string();\n                    // Skip global and country code directories\n                    if name != \"global\" && name != \"global2\" && !name.starts_with('.') {\n                        // Check if it has a version directory (1, 2, etc.) with data\n                        let product_dir = entry.path();\n                        if let Ok(version_entries) = fs::read_dir(&product_dir) {\n                            for ver_entry in version_entries.filter_map(|e| e.ok()) {\n                                let ver_name = ver_entry.file_name().to_string_lossy().to_string();\n                                // Check for numeric version directories\n                                if ver_name.chars().all(|c| c.is_ascii_digit()) {\n                                    let version_dir = ver_entry.path();\n                                    let has_data = version_dir.join(\"odb.ebase\").exists()\n                                        || version_dir.join(\"ofml.ebase\").exists()\n                                        || version_dir\n                                            .read_dir()\n                                            .map(|mut d| {\n                                                d.any(|e| {\n                                                    e.ok()\n                                                        .map(|e| {\n                                                            e.path()\n                                                                .extension()\n                                                                .map(|ext| {\n                                                                    ext == \"alb\" || ext == \"geo\"\n                                                                })\n                                                                .unwrap_or(false)\n                                                        })\n                                                        .unwrap_or(false)\n                                                })\n                                            })\n                                            .unwrap_or(false);\n                                    if has_data {\n                                        products.push(name.clone());\n                                        break; // Found at least one version with data\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        products.sort();\n        products\n    }\n\n    /// Load a product's data\n    pub fn load_product(\n        &self,\n        manufacturer: &str,\n        product: &str,\n    ) -> Result<OFMLProduct, OFMLError> {\n        let product_base = self.data_path.join(manufacturer).join(product);\n        if !product_base.exists() {\n            return Err(OFMLError::NotFound(format!(\"{}/{}\", manufacturer, product)));\n        }\n\n        // Find version directory (usually \"1\")\n        let mut version_dir = None;\n        if let Ok(entries) = fs::read_dir(&product_base) {\n            for entry in entries.filter_map(|e| e.ok()) {\n                let name = entry.file_name().to_string_lossy().to_string();\n                if name.chars().all(|c| c.is_ascii_digit()) && entry.path().is_dir() {\n                    version_dir = Some(entry.path());\n                    break;\n                }\n            }\n        }\n\n        let base_path = version_dir.ok_or_else(|| {\n            OFMLError::InvalidStructure(format!(\n                \"No version directory in {}/{}\",\n                manufacturer, product\n            ))\n        })?;\n\n        // Find files\n        let mut album_files = Vec::new();\n        let mut geo_files = Vec::new();\n        let mut mat_files = Vec::new();\n\n        if let Ok(entries) = fs::read_dir(&base_path) {\n            for entry in entries.filter_map(|e| e.ok()) {\n                let path = entry.path();\n                if let Some(ext) = path.extension() {\n                    match ext.to_str().unwrap_or(\"\").to_lowercase().as_str() {\n                        \"alb\" => album_files.push(path),\n                        \"geo\" => geo_files.push(path),\n                        \"mat\" => mat_files.push(path),\n                        _ => {}\n                    }\n                }\n            }\n        }\n\n        album_files.sort();\n        geo_files.sort();\n        mat_files.sort();\n\n        Ok(OFMLProduct {\n            manufacturer: manufacturer.to_string(),\n            product_name: product.to_string(),\n            base_path,\n            album_files,\n            geo_files,\n            mat_files,\n        })\n    }\n\n    /// Get summary statistics\n    pub fn get_summary(&self) -> OFMLSummary {\n        let manufacturers = self.discover_manufacturers();\n        let mut total_products = 0;\n        let mut total_alb_files = 0;\n        let mut total_geo_files = 0;\n        let mut product_counts = HashMap::new();\n\n        for mfr in &manufacturers {\n            let products = self.discover_products(mfr);\n            product_counts.insert(mfr.clone(), products.len());\n            total_products += products.len();\n\n            for prod in &products {\n                if let Ok(p) = self.load_product(mfr, prod) {\n                    total_alb_files += p.album_files.len();\n                    total_geo_files += p.geo_files.len();\n                }\n            }\n        }\n\n        OFMLSummary {\n            manufacturers,\n            product_counts,\n            total_products,\n            total_alb_files,\n            total_geo_files,\n        }\n    }\n}\n\n/// Summary of OFML data\n#[derive(Debug)]\npub struct OFMLSummary {\n    pub manufacturers: Vec<String>,\n    pub product_counts: HashMap<String, usize>,\n    pub total_products: usize,\n    pub total_alb_files: usize,\n    pub total_geo_files: usize,\n}\n\n/// Extract all CLS files from an ALB archive\npub fn extract_cls_from_alb<P: AsRef<Path>>(\n    alb_path: P,\n) -> Result<HashMap<String, String>, OFMLError> {\n    let mut archive = AlbArchive::open(alb_path)?;\n    let cls_files = archive.get_cls_files();\n    let mut result = HashMap::new();\n\n    for name in cls_files {\n        if let Ok(content) = archive.extract_cls(&name) {\n            // Use just the filename without path\n            let key = Path::new(&name)\n                .file_name()\n                .map(|s| s.to_string_lossy().to_string())\n                .unwrap_or(name.clone());\n            result.insert(key, content);\n        }\n    }\n\n    Ok(result)\n}\n\n/// Extract all 3DS geometries from an ALB archive\npub fn extract_3ds_from_alb<P: AsRef<Path>>(\n    alb_path: P,\n) -> Result<HashMap<String, Scene3DS>, OFMLError> {\n    let mut archive = AlbArchive::open(alb_path)?;\n    let files = archive.get_3ds_files();\n    let mut result = HashMap::new();\n\n    for name in files {\n        if let Ok(scene) = archive.extract_3ds(&name) {\n            let key = Path::new(&name)\n                .file_stem()\n                .map(|s| s.to_string_lossy().to_string())\n                .unwrap_or(name.clone());\n            result.insert(key, scene);\n        }\n    }\n\n    Ok(result)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    /// Get a test ALB path, preferring fixtures directory\n    fn get_test_alb_path() -> Option<std::path::PathBuf> {\n        // Try fixtures first (for CI/clean checkout)\n        let fixture_path = std::path::PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"))\n            .join(\"tests/fixtures/vitra/workit/vitra_workit_1.alb\");\n        if fixture_path.exists() {\n            return Some(fixture_path);\n        }\n\n        // Fall back to ofmldata (local development)\n        let ofmldata_path =\n            std::path::PathBuf::from(\"/workspace/ofmldata/vitra/workit/1/vitra_workit_1.alb\");\n        if ofmldata_path.exists() {\n            return Some(ofmldata_path);\n        }\n\n        None\n    }\n\n    #[test]\n    fn test_ofml_data_reader_discover() {\n        // Test with ofmldata directory if available\n        let ofmldata_path = \"/workspace/ofmldata\";\n        if !Path::new(ofmldata_path).exists() {\n            return;\n        }\n\n        let reader = OFMLDataReader::new(ofmldata_path);\n        let manufacturers = reader.discover_manufacturers();\n\n        // Should find multiple manufacturers\n        assert!(\n            manufacturers.len() >= 1,\n            \"Should find at least one manufacturer\"\n        );\n\n        // Test any manufacturer found\n        for mfr in manufacturers.iter().take(3) {\n            let products = reader.discover_products(mfr);\n            println!(\"Manufacturer {}: {} products\", mfr, products.len());\n        }\n    }\n\n    #[test]\n    fn test_alb_archive_open() {\n        let alb_path = match get_test_alb_path() {\n            Some(p) => p,\n            None => return,\n        };\n\n        let archive = AlbArchive::open(&alb_path).expect(\"Should open ALB\");\n\n        let files = archive.list_files();\n        assert!(!files.is_empty(), \"ALB should contain files\");\n\n        let cls_files = archive.get_cls_files();\n        assert!(!cls_files.is_empty(), \"ALB should contain CLS files\");\n\n        let ds_files = archive.get_3ds_files();\n        assert!(!ds_files.is_empty(), \"ALB should contain 3DS files\");\n    }\n\n    #[test]\n    fn test_alb_extract_cls() {\n        let alb_path = match get_test_alb_path() {\n            Some(p) => p,\n            None => return,\n        };\n\n        let mut archive = AlbArchive::open(&alb_path).expect(\"Should open ALB\");\n\n        let cls_files = archive.get_cls_files();\n        if !cls_files.is_empty() {\n            let content = archive\n                .extract_cls(&cls_files[0])\n                .expect(\"Should extract CLS\");\n            assert!(!content.is_empty(), \"CLS content should not be empty\");\n            // CLS files should contain valid OFML syntax\n            assert!(\n                content.contains(\"class\") || content.contains(\"//\") || content.contains(\"package\"),\n                \"CLS should contain OFML constructs\"\n            );\n        }\n    }\n\n    #[test]\n    fn test_alb_extract_3ds() {\n        let alb_path = match get_test_alb_path() {\n            Some(p) => p,\n            None => return,\n        };\n\n        let mut archive = AlbArchive::open(&alb_path).expect(\"Should open ALB\");\n\n        let files = archive.get_3ds_files();\n        if !files.is_empty() {\n            let scene = archive.extract_3ds(&files[0]).expect(\"Should extract 3DS\");\n            assert!(!scene.meshes.is_empty(), \"3DS should have meshes\");\n        }\n    }\n\n    #[test]\n    fn test_sedus_product_geo() {\n        let ofmldata_path = \"/workspace/ofmldata\";\n        if !Path::new(ofmldata_path).exists() {\n            return;\n        }\n\n        let reader = OFMLDataReader::new(ofmldata_path);\n        // Test with any sbu product that has GEO files\n        if let Ok(product) = reader.load_product(\"sbu\", \"cosmo\") {\n            if product.has_geo() {\n                assert!(!product.geo_files.is_empty(), \"Should have GEO files\");\n            }\n        }\n    }\n\n    #[test]\n    fn test_vitra_product_alb() {\n        let ofmldata_path = \"/workspace/ofmldata\";\n        if !Path::new(ofmldata_path).exists() {\n            return;\n        }\n\n        let reader = OFMLDataReader::new(ofmldata_path);\n        if let Ok(product) = reader.load_product(\"vitra\", \"workit\") {\n            assert!(product.has_alb(), \"Product should have ALB files\");\n            assert!(!product.album_files.is_empty(), \"Should have ALB files\");\n        }\n    }\n\n    #[test]\n    fn test_extract_all_cls() {\n        let alb_path = match get_test_alb_path() {\n            Some(p) => p,\n            None => return,\n        };\n\n        let cls_files = extract_cls_from_alb(&alb_path).expect(\"Should extract CLS files\");\n        assert!(!cls_files.is_empty(), \"Should have CLS files\");\n\n        // Verify at least one CLS file can be parsed\n        let mut parsed = 0;\n        for (_name, content) in cls_files.iter().take(5) {\n            if crate::parser::Parser::new(content)\n                .and_then(|mut p| p.parse())\n                .is_ok()\n            {\n                parsed += 1;\n            }\n        }\n        assert!(parsed > 0, \"Should parse at least one CLS file\");\n    }\n\n    #[test]\n    fn test_extract_all_3ds() {\n        let alb_path = match get_test_alb_path() {\n            Some(p) => p,\n            None => return,\n        };\n\n        let scenes = extract_3ds_from_alb(&alb_path).expect(\"Should extract 3DS files\");\n        assert!(!scenes.is_empty(), \"Should have 3DS scenes\");\n\n        // Verify each scene has valid geometry\n        for (name, scene) in &scenes {\n            assert!(\n                !scene.meshes.is_empty(),\n                \"Scene {} should have meshes\",\n                name\n            );\n        }\n    }\n\n    // ========== OFMLError Tests ==========\n\n    #[test]\n    fn test_ofml_error_display_io() {\n        let io_err = io::Error::new(io::ErrorKind::NotFound, \"file not found\");\n        let err = OFMLError::Io(io_err);\n        let display_str = format!(\"{}\", err);\n        assert!(display_str.contains(\"IO error\"));\n    }\n\n    #[test]\n    fn test_ofml_error_display_not_found() {\n        let err = OFMLError::NotFound(\"missing file\".to_string());\n        let display_str = format!(\"{}\", err);\n        assert!(display_str.contains(\"Not found\"));\n        assert!(display_str.contains(\"missing file\"));\n    }\n\n    #[test]\n    fn test_ofml_error_display_invalid_structure() {\n        let err = OFMLError::InvalidStructure(\"bad layout\".to_string());\n        let display_str = format!(\"{}\", err);\n        assert!(display_str.contains(\"Invalid structure\"));\n        assert!(display_str.contains(\"bad layout\"));\n    }\n\n    #[test]\n    fn test_ofml_error_debug() {\n        let err = OFMLError::NotFound(\"test\".to_string());\n        let debug_str = format!(\"{:?}\", err);\n        assert!(debug_str.contains(\"NotFound\"));\n    }\n\n    #[test]\n    fn test_ofml_error_from_io() {\n        let io_err = io::Error::new(io::ErrorKind::PermissionDenied, \"access denied\");\n        let err: OFMLError = io_err.into();\n        assert!(matches!(err, OFMLError::Io(_)));\n    }\n\n    #[test]\n    fn test_ofml_error_from_geometry() {\n        let geo_err = GeometryError::Invalid3DS(\"bad magic\".to_string());\n        let err: OFMLError = geo_err.into();\n        assert!(matches!(err, OFMLError::Geometry(_)));\n    }\n\n    #[test]\n    fn test_ofml_error_from_zip() {\n        let zip_err = zip::result::ZipError::FileNotFound;\n        let err: OFMLError = zip_err.into();\n        assert!(matches!(err, OFMLError::Zip(_)));\n    }\n\n    #[test]\n    fn test_ofml_error_std_error() {\n        let err = OFMLError::NotFound(\"test\".to_string());\n        // OFMLError implements std::error::Error\n        let _: &dyn std::error::Error = &err;\n    }\n\n    #[test]\n    fn test_alb_password_not_empty() {\n        assert!(!ALB_PASSWORD.is_empty());\n    }\n\n    // ========== OFMLDataReader Tests ==========\n\n    #[test]\n    fn test_ofml_data_reader_new() {\n        let reader = OFMLDataReader::new(\"/nonexistent/path\");\n        assert_eq!(reader.data_path, PathBuf::from(\"/nonexistent/path\"));\n    }\n\n    #[test]\n    fn test_ofml_data_reader_discover_nonexistent() {\n        let reader = OFMLDataReader::new(\"/nonexistent/path\");\n        let manufacturers = reader.discover_manufacturers();\n        assert!(manufacturers.is_empty());\n    }\n\n    #[test]\n    fn test_ofml_data_reader_discover_products_nonexistent() {\n        let reader = OFMLDataReader::new(\"/nonexistent/path\");\n        let products = reader.discover_products(\"some_manufacturer\");\n        assert!(products.is_empty());\n    }\n\n    #[test]\n    fn test_ofml_data_reader_load_product_nonexistent() {\n        let reader = OFMLDataReader::new(\"/nonexistent/path\");\n        let result = reader.load_product(\"fake_manufacturer\", \"fake_product\");\n        assert!(result.is_err());\n    }\n\n    // ========== OFMLProduct Tests ==========\n\n    #[test]\n    fn test_ofml_product_has_alb_empty() {\n        let product = OFMLProduct {\n            manufacturer: \"test\".to_string(),\n            product_name: \"test\".to_string(),\n            base_path: PathBuf::from(\"/test\"),\n            album_files: vec![],\n            geo_files: vec![],\n            mat_files: vec![],\n        };\n        assert!(!product.has_alb());\n    }\n\n    #[test]\n    fn test_ofml_product_has_alb_with_files() {\n        let product = OFMLProduct {\n            manufacturer: \"test\".to_string(),\n            product_name: \"test\".to_string(),\n            base_path: PathBuf::from(\"/test\"),\n            album_files: vec![PathBuf::from(\"/test/file.alb\")],\n            geo_files: vec![],\n            mat_files: vec![],\n        };\n        assert!(product.has_alb());\n    }\n\n    #[test]\n    fn test_ofml_product_has_geo_empty() {\n        let product = OFMLProduct {\n            manufacturer: \"test\".to_string(),\n            product_name: \"test\".to_string(),\n            base_path: PathBuf::from(\"/test\"),\n            album_files: vec![],\n            geo_files: vec![],\n            mat_files: vec![],\n        };\n        assert!(!product.has_geo());\n    }\n\n    #[test]\n    fn test_ofml_product_has_geo_with_files() {\n        let product = OFMLProduct {\n            manufacturer: \"test\".to_string(),\n            product_name: \"test\".to_string(),\n            base_path: PathBuf::from(\"/test\"),\n            album_files: vec![],\n            geo_files: vec![PathBuf::from(\"/test/file.geo\")],\n            mat_files: vec![],\n        };\n        assert!(product.has_geo());\n    }\n\n    #[test]\n    fn test_ofml_product_fields() {\n        let product = OFMLProduct {\n            manufacturer: \"test_mfr\".to_string(),\n            product_name: \"prod\".to_string(),\n            base_path: PathBuf::from(\"/test\"),\n            album_files: vec![],\n            geo_files: vec![],\n            mat_files: vec![],\n        };\n        assert_eq!(product.manufacturer, \"test_mfr\");\n        assert_eq!(product.product_name, \"prod\");\n    }\n\n    #[test]\n    fn test_alb_open_nonexistent() {\n        let result = AlbArchive::open(Path::new(\"/nonexistent/file.alb\"));\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_extract_cls_from_alb_nonexistent() {\n        let result = extract_cls_from_alb(Path::new(\"/nonexistent/file.alb\"));\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_extract_3ds_from_alb_nonexistent() {\n        let result = extract_3ds_from_alb(Path::new(\"/nonexistent/file.alb\"));\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":55,"address":[],"length":0,"stats":{"Line":4}},{"line":56,"address":[],"length":0,"stats":{"Line":4}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":3}},{"line":80,"address":[],"length":0,"stats":{"Line":3}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":4}},{"line":86,"address":[],"length":0,"stats":{"Line":4}},{"line":101,"address":[],"length":0,"stats":{"Line":8}},{"line":102,"address":[],"length":0,"stats":{"Line":24}},{"line":103,"address":[],"length":0,"stats":{"Line":24}},{"line":104,"address":[],"length":0,"stats":{"Line":15}},{"line":105,"address":[],"length":0,"stats":{"Line":15}},{"line":106,"address":[],"length":0,"stats":{"Line":5}},{"line":110,"address":[],"length":0,"stats":{"Line":7}},{"line":111,"address":[],"length":0,"stats":{"Line":7}},{"line":112,"address":[],"length":0,"stats":{"Line":11473}},{"line":117,"address":[],"length":0,"stats":{"Line":6}},{"line":118,"address":[],"length":0,"stats":{"Line":12}},{"line":120,"address":[],"length":0,"stats":{"Line":4920}},{"line":125,"address":[],"length":0,"stats":{"Line":111}},{"line":127,"address":[],"length":0,"stats":{"Line":222}},{"line":128,"address":[],"length":0,"stats":{"Line":7578}},{"line":129,"address":[],"length":0,"stats":{"Line":7467}},{"line":130,"address":[],"length":0,"stats":{"Line":14934}},{"line":131,"address":[],"length":0,"stats":{"Line":22401}},{"line":132,"address":[],"length":0,"stats":{"Line":7467}},{"line":134,"address":[],"length":0,"stats":{"Line":111}},{"line":137,"address":[],"length":0,"stats":{"Line":444}},{"line":138,"address":[],"length":0,"stats":{"Line":222}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":222}},{"line":143,"address":[],"length":0,"stats":{"Line":333}},{"line":144,"address":[],"length":0,"stats":{"Line":111}},{"line":148,"address":[],"length":0,"stats":{"Line":28}},{"line":149,"address":[],"length":0,"stats":{"Line":112}},{"line":150,"address":[],"length":0,"stats":{"Line":56}},{"line":151,"address":[],"length":0,"stats":{"Line":28}},{"line":155,"address":[],"length":0,"stats":{"Line":83}},{"line":156,"address":[],"length":0,"stats":{"Line":332}},{"line":157,"address":[],"length":0,"stats":{"Line":249}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":3}},{"line":183,"address":[],"length":0,"stats":{"Line":9}},{"line":187,"address":[],"length":0,"stats":{"Line":3}},{"line":188,"address":[],"length":0,"stats":{"Line":9}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":2}},{"line":232,"address":[],"length":0,"stats":{"Line":2}},{"line":236,"address":[],"length":0,"stats":{"Line":2}},{"line":237,"address":[],"length":0,"stats":{"Line":2}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":4}},{"line":285,"address":[],"length":0,"stats":{"Line":4}},{"line":290,"address":[],"length":0,"stats":{"Line":1}},{"line":291,"address":[],"length":0,"stats":{"Line":2}},{"line":292,"address":[],"length":0,"stats":{"Line":1}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":1}},{"line":308,"address":[],"length":0,"stats":{"Line":1}},{"line":312,"address":[],"length":0,"stats":{"Line":1}},{"line":313,"address":[],"length":0,"stats":{"Line":3}},{"line":314,"address":[],"length":0,"stats":{"Line":2}},{"line":316,"address":[],"length":0,"stats":{"Line":1}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":1}},{"line":361,"address":[],"length":0,"stats":{"Line":1}},{"line":365,"address":[],"length":0,"stats":{"Line":1}},{"line":370,"address":[],"length":0,"stats":{"Line":4}},{"line":371,"address":[],"length":0,"stats":{"Line":1}},{"line":372,"address":[],"length":0,"stats":{"Line":1}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":2}},{"line":472,"address":[],"length":0,"stats":{"Line":6}},{"line":473,"address":[],"length":0,"stats":{"Line":3}},{"line":474,"address":[],"length":0,"stats":{"Line":2}},{"line":476,"address":[],"length":0,"stats":{"Line":55}},{"line":477,"address":[],"length":0,"stats":{"Line":81}},{"line":479,"address":[],"length":0,"stats":{"Line":54}},{"line":481,"address":[],"length":0,"stats":{"Line":81}},{"line":482,"address":[],"length":0,"stats":{"Line":81}},{"line":483,"address":[],"length":0,"stats":{"Line":108}},{"line":487,"address":[],"length":0,"stats":{"Line":1}},{"line":491,"address":[],"length":0,"stats":{"Line":2}},{"line":494,"address":[],"length":0,"stats":{"Line":6}},{"line":495,"address":[],"length":0,"stats":{"Line":3}},{"line":496,"address":[],"length":0,"stats":{"Line":2}},{"line":498,"address":[],"length":0,"stats":{"Line":165}},{"line":499,"address":[],"length":0,"stats":{"Line":246}},{"line":500,"address":[],"length":0,"stats":{"Line":164}},{"line":502,"address":[],"length":0,"stats":{"Line":246}},{"line":503,"address":[],"length":0,"stats":{"Line":246}},{"line":504,"address":[],"length":0,"stats":{"Line":328}},{"line":508,"address":[],"length":0,"stats":{"Line":1}}],"covered":90,"coverable":222},{"path":["/","workspace","crates","ofml-lib","src","ofml_classes.rs"],"content":"//! OFML Framework Classes - Implementation of Go* and Oi* classes.\n//!\n//! This module implements the OFML framework classes used for geometry\n//! transformation and product configuration.\n//!\n//! ## Namespaces\n//!\n//! - `::ofml::go::*` - Geometry Operation classes (GoYLTrans, GoMirror, etc.)\n//! - `::ofml::oi::*` - Object Instance classes (OiPart, OiBlock, etc.)\n//! - `::ofml::xoi::*` - Extended Object Instance classes\n\nuse crate::errors::OfmlClassError;\n\n/// OFML framework class identifier.\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub enum OfmlClassType {\n    // ::ofml::go namespace - Geometry Operations\n    /// GoMetaType - Base class for configurable products\n    GoMetaType,\n    /// GoXLRTransYLRTrans - X/Y combined stretching\n    GoXLRTransYLRTrans,\n    /// GoYLTrans - Y-axis (height) stretching\n    GoYLTrans,\n    /// GoXLTrans - X-axis (width) stretching\n    GoXLTrans,\n    /// GoZLTrans - Z-axis (depth) stretching\n    GoZLTrans,\n    /// GoMirror - Geometry mirroring\n    GoMirror,\n\n    // ::ofml::oi namespace - Object Instances\n    /// OiPart - Base part class\n    OiPart,\n    /// OiBlock - Axis-aligned cuboid\n    OiBlock,\n    /// OiCylinder - Cylindrical geometry\n    OiCylinder,\n    /// OiEllipsoid - Ellipsoid geometry\n    OiEllipsoid,\n    /// OiSphere - Spherical geometry\n    OiSphere,\n    /// OiPolygon - Planar convex polygon\n    OiPolygon,\n    /// OiImport - External geometry import\n    OiImport,\n    /// OiFrame - Frame/border geometry\n    OiFrame,\n    /// OiRotation - Rotational sweep geometry\n    OiRotation,\n    /// OiSweep - Extrusion/sweep geometry\n    OiSweep,\n\n    /// Custom/unknown class\n    Custom(String),\n}\n\nimpl OfmlClassType {\n    /// Parse a class name string to OfmlClassType.\n    ///\n    /// # Arguments\n    ///\n    /// * `name` - Fully qualified class name (e.g., \"::ofml::go::GoYLTrans\")\n    ///\n    /// # Returns\n    ///\n    /// The corresponding OfmlClassType, or Custom for unknown classes.\n    pub fn from_name(name: &str) -> Self {\n        // Normalize: remove leading colons, lowercase compare\n        let normalized = name.trim_start_matches(':');\n\n        match normalized {\n            // Go classes\n            \"ofml::go::GoMetaType\" | \"GoMetaType\" => OfmlClassType::GoMetaType,\n            \"ofml::go::GoXLRTransYLRTrans\" | \"GoXLRTransYLRTrans\" => {\n                OfmlClassType::GoXLRTransYLRTrans\n            }\n            \"ofml::go::GoYLTrans\" | \"GoYLTrans\" => OfmlClassType::GoYLTrans,\n            \"ofml::go::GoXLTrans\" | \"GoXLTrans\" => OfmlClassType::GoXLTrans,\n            \"ofml::go::GoZLTrans\" | \"GoZLTrans\" => OfmlClassType::GoZLTrans,\n            \"ofml::go::GoMirror\" | \"GoMirror\" => OfmlClassType::GoMirror,\n\n            // Oi classes\n            \"ofml::oi::OiPart\" | \"OiPart\" => OfmlClassType::OiPart,\n            \"ofml::oi::OiBlock\" | \"OiBlock\" => OfmlClassType::OiBlock,\n            \"ofml::oi::OiCylinder\" | \"OiCylinder\" => OfmlClassType::OiCylinder,\n            \"ofml::oi::OiEllipsoid\" | \"OiEllipsoid\" => OfmlClassType::OiEllipsoid,\n            \"ofml::oi::OiSphere\" | \"OiSphere\" => OfmlClassType::OiSphere,\n            \"ofml::oi::OiPolygon\" | \"OiPolygon\" => OfmlClassType::OiPolygon,\n            \"ofml::oi::OiImport\" | \"OiImport\" => OfmlClassType::OiImport,\n            \"ofml::oi::OiFrame\" | \"OiFrame\" => OfmlClassType::OiFrame,\n            \"ofml::oi::OiRotation\" | \"OiRotation\" => OfmlClassType::OiRotation,\n            \"ofml::oi::OiSweep\" | \"OiSweep\" => OfmlClassType::OiSweep,\n\n            _ => OfmlClassType::Custom(name.to_string()),\n        }\n    }\n\n    /// Get the fully qualified class name.\n    pub fn full_name(&self) -> String {\n        match self {\n            OfmlClassType::GoMetaType => \"::ofml::go::GoMetaType\".to_string(),\n            OfmlClassType::GoXLRTransYLRTrans => \"::ofml::go::GoXLRTransYLRTrans\".to_string(),\n            OfmlClassType::GoYLTrans => \"::ofml::go::GoYLTrans\".to_string(),\n            OfmlClassType::GoXLTrans => \"::ofml::go::GoXLTrans\".to_string(),\n            OfmlClassType::GoZLTrans => \"::ofml::go::GoZLTrans\".to_string(),\n            OfmlClassType::GoMirror => \"::ofml::go::GoMirror\".to_string(),\n\n            OfmlClassType::OiPart => \"::ofml::oi::OiPart\".to_string(),\n            OfmlClassType::OiBlock => \"::ofml::oi::OiBlock\".to_string(),\n            OfmlClassType::OiCylinder => \"::ofml::oi::OiCylinder\".to_string(),\n            OfmlClassType::OiEllipsoid => \"::ofml::oi::OiEllipsoid\".to_string(),\n            OfmlClassType::OiSphere => \"::ofml::oi::OiSphere\".to_string(),\n            OfmlClassType::OiPolygon => \"::ofml::oi::OiPolygon\".to_string(),\n            OfmlClassType::OiImport => \"::ofml::oi::OiImport\".to_string(),\n            OfmlClassType::OiFrame => \"::ofml::oi::OiFrame\".to_string(),\n            OfmlClassType::OiRotation => \"::ofml::oi::OiRotation\".to_string(),\n            OfmlClassType::OiSweep => \"::ofml::oi::OiSweep\".to_string(),\n\n            OfmlClassType::Custom(name) => name.clone(),\n        }\n    }\n\n    /// Check if this is a Go (geometry operation) class.\n    pub fn is_go_class(&self) -> bool {\n        matches!(\n            self,\n            OfmlClassType::GoMetaType\n                | OfmlClassType::GoXLRTransYLRTrans\n                | OfmlClassType::GoYLTrans\n                | OfmlClassType::GoXLTrans\n                | OfmlClassType::GoZLTrans\n                | OfmlClassType::GoMirror\n        )\n    }\n\n    /// Check if this is an Oi (object instance) class.\n    pub fn is_oi_class(&self) -> bool {\n        matches!(\n            self,\n            OfmlClassType::OiPart\n                | OfmlClassType::OiBlock\n                | OfmlClassType::OiCylinder\n                | OfmlClassType::OiEllipsoid\n                | OfmlClassType::OiSphere\n                | OfmlClassType::OiPolygon\n                | OfmlClassType::OiImport\n                | OfmlClassType::OiFrame\n                | OfmlClassType::OiRotation\n                | OfmlClassType::OiSweep\n        )\n    }\n}\n\n/// Parameters for GoYLTrans (Y-axis stretching).\n///\n/// Stretches geometry in the Y-axis direction.\n#[derive(Debug, Clone)]\npub struct GoYLTransParams {\n    /// Base height before stretching\n    pub base_height: f64,\n    /// Target height after stretching\n    pub target_height: f64,\n    /// Minimum Y value to begin stretching\n    pub stretch_min: f64,\n}\n\nimpl GoYLTransParams {\n    /// Create from parameter slice.\n    pub fn from_params(params: &[f64]) -> Result<Self, OfmlClassError> {\n        if params.len() < 3 {\n            return Err(OfmlClassError::InvalidParamCount {\n                class: \"GoYLTrans\".to_string(),\n                expected: 3,\n                got: params.len(),\n            });\n        }\n        Ok(Self {\n            base_height: params[0],\n            target_height: params[1],\n            stretch_min: params[2],\n        })\n    }\n\n    /// Apply transformation to a Y coordinate.\n    pub fn transform_y(&self, y: f64) -> f64 {\n        if y <= self.stretch_min {\n            y\n        } else {\n            let scale = self.target_height / self.base_height;\n            self.stretch_min + (y - self.stretch_min) * scale\n        }\n    }\n}\n\n/// Parameters for GoXLTrans (X-axis stretching).\n#[derive(Debug, Clone)]\npub struct GoXLTransParams {\n    /// Base width before stretching\n    pub base_width: f64,\n    /// Target width after stretching\n    pub target_width: f64,\n    /// Minimum X value to begin stretching\n    pub stretch_min: f64,\n}\n\nimpl GoXLTransParams {\n    /// Create from parameter slice.\n    pub fn from_params(params: &[f64]) -> Result<Self, OfmlClassError> {\n        if params.len() < 3 {\n            return Err(OfmlClassError::InvalidParamCount {\n                class: \"GoXLTrans\".to_string(),\n                expected: 3,\n                got: params.len(),\n            });\n        }\n        Ok(Self {\n            base_width: params[0],\n            target_width: params[1],\n            stretch_min: params[2],\n        })\n    }\n\n    /// Apply transformation to an X coordinate.\n    pub fn transform_x(&self, x: f64) -> f64 {\n        if x <= self.stretch_min {\n            x\n        } else {\n            let scale = self.target_width / self.base_width;\n            self.stretch_min + (x - self.stretch_min) * scale\n        }\n    }\n}\n\n/// Parameters for GoZLTrans (Z-axis stretching).\n#[derive(Debug, Clone)]\npub struct GoZLTransParams {\n    /// Base depth before stretching\n    pub base_depth: f64,\n    /// Target depth after stretching\n    pub target_depth: f64,\n    /// Minimum Z value to begin stretching\n    pub stretch_min: f64,\n}\n\nimpl GoZLTransParams {\n    /// Create from parameter slice.\n    pub fn from_params(params: &[f64]) -> Result<Self, OfmlClassError> {\n        if params.len() < 3 {\n            return Err(OfmlClassError::InvalidParamCount {\n                class: \"GoZLTrans\".to_string(),\n                expected: 3,\n                got: params.len(),\n            });\n        }\n        Ok(Self {\n            base_depth: params[0],\n            target_depth: params[1],\n            stretch_min: params[2],\n        })\n    }\n\n    /// Apply transformation to a Z coordinate.\n    pub fn transform_z(&self, z: f64) -> f64 {\n        if z <= self.stretch_min {\n            z\n        } else {\n            let scale = self.target_depth / self.base_depth;\n            self.stretch_min + (z - self.stretch_min) * scale\n        }\n    }\n}\n\n/// Parameters for GoXLRTransYLRTrans (X/Y combined stretching).\n#[derive(Debug, Clone)]\npub struct GoXLRTransYLRTransParams {\n    /// X-axis minimum stretch point\n    pub x_min: f64,\n    /// X-axis maximum stretch point\n    pub x_max: f64,\n    /// X-axis scale factor\n    pub x_scale: f64,\n    /// Y-axis minimum stretch point\n    pub y_min: f64,\n    /// Y-axis maximum stretch point\n    pub y_max: f64,\n    /// Y-axis scale factor\n    pub y_scale: f64,\n}\n\nimpl GoXLRTransYLRTransParams {\n    /// Create from parameter slice.\n    pub fn from_params(params: &[f64]) -> Result<Self, OfmlClassError> {\n        if params.len() < 6 {\n            return Err(OfmlClassError::InvalidParamCount {\n                class: \"GoXLRTransYLRTrans\".to_string(),\n                expected: 6,\n                got: params.len(),\n            });\n        }\n        Ok(Self {\n            x_min: params[0],\n            x_max: params[1],\n            x_scale: params[2],\n            y_min: params[3],\n            y_max: params[4],\n            y_scale: params[5],\n        })\n    }\n\n    /// Apply transformation to X and Y coordinates.\n    pub fn transform(&self, x: f64, y: f64) -> (f64, f64) {\n        let new_x = if x < self.x_min {\n            x\n        } else if x > self.x_max {\n            self.x_max + (x - self.x_max) * self.x_scale\n        } else {\n            self.x_min + (x - self.x_min) * self.x_scale\n        };\n\n        let new_y = if y < self.y_min {\n            y\n        } else if y > self.y_max {\n            self.y_max + (y - self.y_max) * self.y_scale\n        } else {\n            self.y_min + (y - self.y_min) * self.y_scale\n        };\n\n        (new_x, new_y)\n    }\n}\n\n/// Mirror axis for GoMirror.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum MirrorAxis {\n    /// Mirror across YZ plane (flip X)\n    X,\n    /// Mirror across XZ plane (flip Y)\n    Y,\n    /// Mirror across XY plane (flip Z)\n    Z,\n}\n\n/// Parameters for GoMirror (geometry mirroring).\n#[derive(Debug, Clone)]\npub struct GoMirrorParams {\n    /// Mirror axis\n    pub axis: MirrorAxis,\n    /// Mirror plane offset\n    pub offset: f64,\n}\n\nimpl GoMirrorParams {\n    /// Create from parameter slice.\n    ///\n    /// Parameters: [axis_index, offset]\n    /// - axis_index: 0=X, 1=Y, 2=Z\n    pub fn from_params(params: &[f64]) -> Result<Self, OfmlClassError> {\n        if params.is_empty() {\n            return Err(OfmlClassError::InvalidParamCount {\n                class: \"GoMirror\".to_string(),\n                expected: 1,\n                got: 0,\n            });\n        }\n\n        let axis = match params[0] as i32 {\n            0 => MirrorAxis::X,\n            1 => MirrorAxis::Y,\n            2 => MirrorAxis::Z,\n            other => {\n                return Err(OfmlClassError::InvalidParamType {\n                    class: \"GoMirror\".to_string(),\n                    index: 0,\n                    expected: \"0, 1, or 2\",\n                    got: other.to_string(),\n                })\n            }\n        };\n\n        let offset = params.get(1).copied().unwrap_or(0.0);\n\n        Ok(Self { axis, offset })\n    }\n\n    /// Apply mirror transformation to a coordinate.\n    pub fn transform(&self, x: f64, y: f64, z: f64) -> (f64, f64, f64) {\n        match self.axis {\n            MirrorAxis::X => (2.0 * self.offset - x, y, z),\n            MirrorAxis::Y => (x, 2.0 * self.offset - y, z),\n            MirrorAxis::Z => (x, y, 2.0 * self.offset - z),\n        }\n    }\n}\n\n/// Result of OFML class instantiation - represents the transformation or geometry to create.\n#[derive(Debug, Clone)]\npub enum OfmlClassInstance {\n    /// Geometry transformation - apply to loaded geometry\n    Transform(GeometryTransform),\n    /// Primitive geometry - create directly\n    Primitive(PrimitiveGeometry),\n    /// No-op - class doesn't produce geometry\n    None,\n}\n\n/// A geometry transformation to apply to loaded meshes.\n#[derive(Debug, Clone)]\npub enum GeometryTransform {\n    /// Y-axis stretching (GoYLTrans)\n    YStretch(GoYLTransParams),\n    /// X-axis stretching (GoXLTrans)\n    XStretch(GoXLTransParams),\n    /// Z-axis stretching (GoZLTrans)\n    ZStretch(GoZLTransParams),\n    /// X/Y combined stretching (GoXLRTransYLRTrans)\n    XYStretch(GoXLRTransYLRTransParams),\n    /// Mirroring (GoMirror)\n    Mirror(GoMirrorParams),\n    /// Scale uniformly\n    Scale([f64; 3]),\n}\n\n/// Primitive geometry to create.\n#[derive(Debug, Clone)]\npub enum PrimitiveGeometry {\n    /// Block with dimensions [width, height, depth]\n    Block { dimensions: [f64; 3] },\n    /// Cylinder with radius and height\n    Cylinder { radius: f64, height: f64 },\n    /// Sphere with radius\n    Sphere { radius: f64 },\n    /// Ellipsoid with radii [rx, ry, rz]\n    Ellipsoid { radii: [f64; 3] },\n    /// Polygon with 2D vertices and thickness\n    Polygon {\n        vertices: Vec<[f64; 2]>,\n        thickness: f64,\n    },\n}\n\n/// OFML class registry for looking up and instantiating classes.\npub struct OfmlClassRegistry;\n\nimpl OfmlClassRegistry {\n    /// Look up a class by name.\n    pub fn lookup(name: &str) -> Option<OfmlClassType> {\n        let class_type = OfmlClassType::from_name(name);\n        match class_type {\n            OfmlClassType::Custom(_) => None,\n            _ => Some(class_type),\n        }\n    }\n\n    /// Check if a class name is a known OFML class.\n    pub fn is_known(name: &str) -> bool {\n        Self::lookup(name).is_some()\n    }\n\n    /// Get the expected parameter count for a class.\n    pub fn expected_params(class_type: &OfmlClassType) -> usize {\n        match class_type {\n            OfmlClassType::GoYLTrans => 3,\n            OfmlClassType::GoXLTrans => 3,\n            OfmlClassType::GoZLTrans => 3,\n            OfmlClassType::GoXLRTransYLRTrans => 6,\n            OfmlClassType::GoMirror => 1,    // minimum, can have 2\n            OfmlClassType::OiBlock => 3,     // dimensions [x, y, z]\n            OfmlClassType::OiCylinder => 2,  // radius, height\n            OfmlClassType::OiSphere => 1,    // radius\n            OfmlClassType::OiEllipsoid => 3, // rx, ry, rz\n            _ => 0,\n        }\n    }\n\n    /// Instantiate an OFML class with parameters.\n    ///\n    /// This is the main entry point for processing `clsref` results from EBASE expressions.\n    ///\n    /// # Arguments\n    ///\n    /// * `class_name` - Fully qualified class name (e.g., \"::ofml::go::GoYLTrans\")\n    /// * `params` - Constructor parameters from the EBASE expression\n    ///\n    /// # Returns\n    ///\n    /// An `OfmlClassInstance` describing the transformation or geometry to create.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use ofml_lib::ofml_classes::{OfmlClassRegistry, OfmlClassInstance, GeometryTransform};\n    ///\n    /// let instance = OfmlClassRegistry::instantiate(\"::ofml::go::GoYLTrans\", &[100.0, 200.0, 10.0]);\n    /// match instance {\n    ///     Ok(OfmlClassInstance::Transform(GeometryTransform::YStretch(params))) => {\n    ///         assert_eq!(params.base_height, 100.0);\n    ///         assert_eq!(params.target_height, 200.0);\n    ///     }\n    ///     _ => panic!(\"Expected YStretch transform\"),\n    /// }\n    /// ```\n    pub fn instantiate(\n        class_name: &str,\n        params: &[f64],\n    ) -> Result<OfmlClassInstance, OfmlClassError> {\n        let class_type = OfmlClassType::from_name(class_name);\n\n        match class_type {\n            // Geometry transformation classes\n            OfmlClassType::GoYLTrans => {\n                let trans = GoYLTransParams::from_params(params)?;\n                Ok(OfmlClassInstance::Transform(GeometryTransform::YStretch(\n                    trans,\n                )))\n            }\n            OfmlClassType::GoXLTrans => {\n                let trans = GoXLTransParams::from_params(params)?;\n                Ok(OfmlClassInstance::Transform(GeometryTransform::XStretch(\n                    trans,\n                )))\n            }\n            OfmlClassType::GoZLTrans => {\n                let trans = GoZLTransParams::from_params(params)?;\n                Ok(OfmlClassInstance::Transform(GeometryTransform::ZStretch(\n                    trans,\n                )))\n            }\n            OfmlClassType::GoXLRTransYLRTrans => {\n                let trans = GoXLRTransYLRTransParams::from_params(params)?;\n                Ok(OfmlClassInstance::Transform(GeometryTransform::XYStretch(\n                    trans,\n                )))\n            }\n            OfmlClassType::GoMirror => {\n                let trans = GoMirrorParams::from_params(params)?;\n                Ok(OfmlClassInstance::Transform(GeometryTransform::Mirror(\n                    trans,\n                )))\n            }\n            OfmlClassType::GoMetaType => {\n                // GoMetaType is a base class, doesn't produce direct geometry\n                // The scale parameters are typically [width, depth, height]\n                if params.len() >= 3 {\n                    Ok(OfmlClassInstance::Transform(GeometryTransform::Scale([\n                        params[0], params[1], params[2],\n                    ])))\n                } else {\n                    Ok(OfmlClassInstance::None)\n                }\n            }\n\n            // Primitive geometry classes\n            OfmlClassType::OiBlock => {\n                if params.len() >= 3 {\n                    Ok(OfmlClassInstance::Primitive(PrimitiveGeometry::Block {\n                        dimensions: [params[0], params[1], params[2]],\n                    }))\n                } else {\n                    Err(OfmlClassError::InvalidParamCount {\n                        class: \"OiBlock\".to_string(),\n                        expected: 3,\n                        got: params.len(),\n                    })\n                }\n            }\n            OfmlClassType::OiCylinder => {\n                if params.len() >= 2 {\n                    Ok(OfmlClassInstance::Primitive(PrimitiveGeometry::Cylinder {\n                        radius: params[0],\n                        height: params[1],\n                    }))\n                } else {\n                    Err(OfmlClassError::InvalidParamCount {\n                        class: \"OiCylinder\".to_string(),\n                        expected: 2,\n                        got: params.len(),\n                    })\n                }\n            }\n            OfmlClassType::OiSphere => {\n                if !params.is_empty() {\n                    Ok(OfmlClassInstance::Primitive(PrimitiveGeometry::Sphere {\n                        radius: params[0],\n                    }))\n                } else {\n                    Err(OfmlClassError::InvalidParamCount {\n                        class: \"OiSphere\".to_string(),\n                        expected: 1,\n                        got: 0,\n                    })\n                }\n            }\n            OfmlClassType::OiEllipsoid => {\n                if params.len() >= 3 {\n                    Ok(OfmlClassInstance::Primitive(PrimitiveGeometry::Ellipsoid {\n                        radii: [params[0], params[1], params[2]],\n                    }))\n                } else {\n                    Err(OfmlClassError::InvalidParamCount {\n                        class: \"OiEllipsoid\".to_string(),\n                        expected: 3,\n                        got: params.len(),\n                    })\n                }\n            }\n\n            // Classes that don't produce direct geometry\n            OfmlClassType::OiPart\n            | OfmlClassType::OiPolygon\n            | OfmlClassType::OiImport\n            | OfmlClassType::OiFrame\n            | OfmlClassType::OiRotation\n            | OfmlClassType::OiSweep => Ok(OfmlClassInstance::None),\n\n            // Unknown/custom class\n            OfmlClassType::Custom(name) => Err(OfmlClassError::UnknownClass(name)),\n        }\n    }\n}\n\nimpl GeometryTransform {\n    /// Apply this transformation to a vertex coordinate.\n    ///\n    /// Returns the transformed [x, y, z] coordinates.\n    pub fn transform_vertex(&self, x: f64, y: f64, z: f64) -> [f64; 3] {\n        match self {\n            GeometryTransform::YStretch(params) => [x, params.transform_y(y), z],\n            GeometryTransform::XStretch(params) => [params.transform_x(x), y, z],\n            GeometryTransform::ZStretch(params) => [x, y, params.transform_z(z)],\n            GeometryTransform::XYStretch(params) => {\n                let (new_x, new_y) = params.transform(x, y);\n                [new_x, new_y, z]\n            }\n            GeometryTransform::Mirror(params) => {\n                let (new_x, new_y, new_z) = params.transform(x, y, z);\n                [new_x, new_y, new_z]\n            }\n            GeometryTransform::Scale(scale) => [x * scale[0], y * scale[1], z * scale[2]],\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_ofml_class_type_from_name() {\n        assert_eq!(\n            OfmlClassType::from_name(\"::ofml::go::GoYLTrans\"),\n            OfmlClassType::GoYLTrans\n        );\n        assert_eq!(\n            OfmlClassType::from_name(\"GoYLTrans\"),\n            OfmlClassType::GoYLTrans\n        );\n        assert_eq!(\n            OfmlClassType::from_name(\"::ofml::oi::OiBlock\"),\n            OfmlClassType::OiBlock\n        );\n        assert_eq!(OfmlClassType::from_name(\"OiBlock\"), OfmlClassType::OiBlock);\n\n        // Unknown class\n        assert!(matches!(\n            OfmlClassType::from_name(\"UnknownClass\"),\n            OfmlClassType::Custom(_)\n        ));\n    }\n\n    #[test]\n    fn test_ofml_class_type_full_name() {\n        assert_eq!(\n            OfmlClassType::GoYLTrans.full_name(),\n            \"::ofml::go::GoYLTrans\"\n        );\n        assert_eq!(OfmlClassType::OiBlock.full_name(), \"::ofml::oi::OiBlock\");\n    }\n\n    #[test]\n    fn test_ofml_class_type_full_name_all_go_classes() {\n        assert_eq!(\n            OfmlClassType::GoMetaType.full_name(),\n            \"::ofml::go::GoMetaType\"\n        );\n        assert_eq!(\n            OfmlClassType::GoXLRTransYLRTrans.full_name(),\n            \"::ofml::go::GoXLRTransYLRTrans\"\n        );\n        assert_eq!(\n            OfmlClassType::GoXLTrans.full_name(),\n            \"::ofml::go::GoXLTrans\"\n        );\n        assert_eq!(\n            OfmlClassType::GoZLTrans.full_name(),\n            \"::ofml::go::GoZLTrans\"\n        );\n        assert_eq!(\n            OfmlClassType::GoMirror.full_name(),\n            \"::ofml::go::GoMirror\"\n        );\n    }\n\n    #[test]\n    fn test_ofml_class_type_full_name_all_oi_classes() {\n        assert_eq!(OfmlClassType::OiPart.full_name(), \"::ofml::oi::OiPart\");\n        assert_eq!(\n            OfmlClassType::OiCylinder.full_name(),\n            \"::ofml::oi::OiCylinder\"\n        );\n        assert_eq!(\n            OfmlClassType::OiEllipsoid.full_name(),\n            \"::ofml::oi::OiEllipsoid\"\n        );\n        assert_eq!(OfmlClassType::OiSphere.full_name(), \"::ofml::oi::OiSphere\");\n        assert_eq!(\n            OfmlClassType::OiPolygon.full_name(),\n            \"::ofml::oi::OiPolygon\"\n        );\n        assert_eq!(OfmlClassType::OiImport.full_name(), \"::ofml::oi::OiImport\");\n        assert_eq!(OfmlClassType::OiFrame.full_name(), \"::ofml::oi::OiFrame\");\n        assert_eq!(\n            OfmlClassType::OiRotation.full_name(),\n            \"::ofml::oi::OiRotation\"\n        );\n        assert_eq!(OfmlClassType::OiSweep.full_name(), \"::ofml::oi::OiSweep\");\n    }\n\n    #[test]\n    fn test_ofml_class_type_full_name_custom() {\n        let custom = OfmlClassType::Custom(\"::my::custom::Class\".to_string());\n        assert_eq!(custom.full_name(), \"::my::custom::Class\");\n    }\n\n    #[test]\n    fn test_ofml_class_type_classification() {\n        assert!(OfmlClassType::GoYLTrans.is_go_class());\n        assert!(!OfmlClassType::GoYLTrans.is_oi_class());\n\n        assert!(!OfmlClassType::OiBlock.is_go_class());\n        assert!(OfmlClassType::OiBlock.is_oi_class());\n    }\n\n    #[test]\n    fn test_go_yl_trans_params() {\n        let params = GoYLTransParams::from_params(&[100.0, 200.0, 10.0]).unwrap();\n\n        // Below stretch_min: unchanged\n        assert_eq!(params.transform_y(5.0), 5.0);\n\n        // At stretch_min: unchanged\n        assert_eq!(params.transform_y(10.0), 10.0);\n\n        // Above stretch_min: scaled\n        let transformed = params.transform_y(60.0);\n        // Original range: 60 - 10 = 50 (50% of 100)\n        // Scaled: 10 + 50 * 2.0 = 110\n        assert!((transformed - 110.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_go_mirror_params() {\n        let params = GoMirrorParams::from_params(&[0.0, 50.0]).unwrap(); // Mirror X at 50\n\n        let (x, y, z) = params.transform(30.0, 10.0, 5.0);\n        // 2 * 50 - 30 = 70\n        assert!((x - 70.0).abs() < 0.001);\n        assert_eq!(y, 10.0);\n        assert_eq!(z, 5.0);\n    }\n\n    #[test]\n    fn test_go_xlr_trans_ylr_trans_params() {\n        let params =\n            GoXLRTransYLRTransParams::from_params(&[10.0, 90.0, 2.0, 10.0, 90.0, 2.0]).unwrap();\n\n        // Point within stretch region\n        let (x, y) = params.transform(50.0, 50.0);\n        // x: 10 + (50 - 10) * 2 = 90\n        assert!((x - 90.0).abs() < 0.001);\n        assert!((y - 90.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_ofml_class_registry() {\n        assert!(OfmlClassRegistry::is_known(\"::ofml::go::GoYLTrans\"));\n        assert!(OfmlClassRegistry::is_known(\"GoYLTrans\"));\n        assert!(!OfmlClassRegistry::is_known(\"UnknownClass\"));\n\n        assert_eq!(\n            OfmlClassRegistry::lookup(\"GoYLTrans\"),\n            Some(OfmlClassType::GoYLTrans)\n        );\n        assert_eq!(OfmlClassRegistry::lookup(\"UnknownClass\"), None);\n\n        assert_eq!(\n            OfmlClassRegistry::expected_params(&OfmlClassType::GoYLTrans),\n            3\n        );\n        assert_eq!(\n            OfmlClassRegistry::expected_params(&OfmlClassType::OiBlock),\n            3\n        );\n    }\n\n    #[test]\n    fn test_invalid_param_count() {\n        let result = GoYLTransParams::from_params(&[100.0, 200.0]);\n        assert!(matches!(\n            result,\n            Err(OfmlClassError::InvalidParamCount { .. })\n        ));\n    }\n\n    #[test]\n    fn test_instantiate_go_yl_trans() {\n        let result = OfmlClassRegistry::instantiate(\"::ofml::go::GoYLTrans\", &[100.0, 200.0, 10.0]);\n        match result {\n            Ok(OfmlClassInstance::Transform(GeometryTransform::YStretch(params))) => {\n                assert_eq!(params.base_height, 100.0);\n                assert_eq!(params.target_height, 200.0);\n                assert_eq!(params.stretch_min, 10.0);\n            }\n            _ => panic!(\"Expected YStretch transform\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_go_xl_trans() {\n        let result = OfmlClassRegistry::instantiate(\"GoXLTrans\", &[50.0, 100.0, 5.0]);\n        match result {\n            Ok(OfmlClassInstance::Transform(GeometryTransform::XStretch(params))) => {\n                assert_eq!(params.base_width, 50.0);\n                assert_eq!(params.target_width, 100.0);\n                assert_eq!(params.stretch_min, 5.0);\n            }\n            _ => panic!(\"Expected XStretch transform\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_go_xlr_trans_ylr_trans() {\n        let result = OfmlClassRegistry::instantiate(\n            \"::ofml::go::GoXLRTransYLRTrans\",\n            &[0.0, 100.0, 1.5, 0.0, 80.0, 1.2],\n        );\n        match result {\n            Ok(OfmlClassInstance::Transform(GeometryTransform::XYStretch(params))) => {\n                assert_eq!(params.x_min, 0.0);\n                assert_eq!(params.x_max, 100.0);\n                assert_eq!(params.x_scale, 1.5);\n                assert_eq!(params.y_min, 0.0);\n                assert_eq!(params.y_max, 80.0);\n                assert_eq!(params.y_scale, 1.2);\n            }\n            _ => panic!(\"Expected XYStretch transform\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_go_mirror() {\n        let result = OfmlClassRegistry::instantiate(\"GoMirror\", &[1.0, 25.0]); // Mirror Y at 25\n        match result {\n            Ok(OfmlClassInstance::Transform(GeometryTransform::Mirror(params))) => {\n                assert_eq!(params.axis, MirrorAxis::Y);\n                assert_eq!(params.offset, 25.0);\n            }\n            _ => panic!(\"Expected Mirror transform\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_oi_block() {\n        let result = OfmlClassRegistry::instantiate(\"OiBlock\", &[1.6, 0.025, 0.8]);\n        match result {\n            Ok(OfmlClassInstance::Primitive(PrimitiveGeometry::Block { dimensions })) => {\n                assert!((dimensions[0] - 1.6).abs() < 0.001);\n                assert!((dimensions[1] - 0.025).abs() < 0.001);\n                assert!((dimensions[2] - 0.8).abs() < 0.001);\n            }\n            _ => panic!(\"Expected Block primitive\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_oi_cylinder() {\n        let result = OfmlClassRegistry::instantiate(\"OiCylinder\", &[0.05, 0.74]);\n        match result {\n            Ok(OfmlClassInstance::Primitive(PrimitiveGeometry::Cylinder { radius, height })) => {\n                assert!((radius - 0.05).abs() < 0.001);\n                assert!((height - 0.74).abs() < 0.001);\n            }\n            _ => panic!(\"Expected Cylinder primitive\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_oi_sphere() {\n        let result = OfmlClassRegistry::instantiate(\"OiSphere\", &[0.5]);\n        match result {\n            Ok(OfmlClassInstance::Primitive(PrimitiveGeometry::Sphere { radius })) => {\n                assert!((radius - 0.5).abs() < 0.001);\n            }\n            _ => panic!(\"Expected Sphere primitive\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_oi_ellipsoid() {\n        let result = OfmlClassRegistry::instantiate(\"OiEllipsoid\", &[0.3, 0.4, 0.5]);\n        match result {\n            Ok(OfmlClassInstance::Primitive(PrimitiveGeometry::Ellipsoid { radii })) => {\n                assert!((radii[0] - 0.3).abs() < 0.001);\n                assert!((radii[1] - 0.4).abs() < 0.001);\n                assert!((radii[2] - 0.5).abs() < 0.001);\n            }\n            _ => panic!(\"Expected Ellipsoid primitive\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_unknown_class() {\n        let result = OfmlClassRegistry::instantiate(\"::unknown::FakeClass\", &[1.0, 2.0]);\n        assert!(matches!(result, Err(OfmlClassError::UnknownClass(_))));\n    }\n\n    #[test]\n    fn test_instantiate_oi_part_returns_none() {\n        let result = OfmlClassRegistry::instantiate(\"OiPart\", &[]);\n        match result {\n            Ok(OfmlClassInstance::None) => { /* Expected */ }\n            _ => panic!(\"Expected None for OiPart\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_go_meta_type_with_scale() {\n        let result = OfmlClassRegistry::instantiate(\"GoMetaType\", &[1.6, 0.8, 0.74]);\n        match result {\n            Ok(OfmlClassInstance::Transform(GeometryTransform::Scale(scale))) => {\n                assert!((scale[0] - 1.6).abs() < 0.001);\n                assert!((scale[1] - 0.8).abs() < 0.001);\n                assert!((scale[2] - 0.74).abs() < 0.001);\n            }\n            _ => panic!(\"Expected Scale transform\"),\n        }\n    }\n\n    #[test]\n    fn test_geometry_transform_y_stretch() {\n        let transform = GeometryTransform::YStretch(GoYLTransParams {\n            base_height: 100.0,\n            target_height: 200.0,\n            stretch_min: 10.0,\n        });\n\n        // Below stretch min - unchanged\n        let result = transform.transform_vertex(5.0, 5.0, 5.0);\n        assert_eq!(result[0], 5.0);\n        assert_eq!(result[1], 5.0);\n        assert_eq!(result[2], 5.0);\n\n        // Above stretch min - scaled\n        let result = transform.transform_vertex(5.0, 60.0, 5.0);\n        assert_eq!(result[0], 5.0);\n        assert!((result[1] - 110.0).abs() < 0.001);\n        assert_eq!(result[2], 5.0);\n    }\n\n    #[test]\n    fn test_geometry_transform_scale() {\n        let transform = GeometryTransform::Scale([2.0, 1.5, 0.5]);\n        let result = transform.transform_vertex(10.0, 20.0, 30.0);\n        assert!((result[0] - 20.0).abs() < 0.001);\n        assert!((result[1] - 30.0).abs() < 0.001);\n        assert!((result[2] - 15.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_geometry_transform_mirror_x() {\n        let transform = GeometryTransform::Mirror(GoMirrorParams {\n            axis: MirrorAxis::X,\n            offset: 50.0,\n        });\n        let result = transform.transform_vertex(30.0, 10.0, 5.0);\n        assert!((result[0] - 70.0).abs() < 0.001); // 2*50 - 30 = 70\n        assert_eq!(result[1], 10.0);\n        assert_eq!(result[2], 5.0);\n    }\n\n    #[test]\n    fn test_instantiate_insufficient_params() {\n        // OiBlock needs 3 params, only giving 2\n        let result = OfmlClassRegistry::instantiate(\"OiBlock\", &[1.0, 2.0]);\n        assert!(matches!(\n            result,\n            Err(OfmlClassError::InvalidParamCount { .. })\n        ));\n\n        // OiCylinder needs 2 params, only giving 1\n        let result = OfmlClassRegistry::instantiate(\"OiCylinder\", &[1.0]);\n        assert!(matches!(\n            result,\n            Err(OfmlClassError::InvalidParamCount { .. })\n        ));\n    }\n}\n","traces":[{"line":67,"address":[],"length":0,"stats":{"Line":23}},{"line":69,"address":[],"length":0,"stats":{"Line":69}},{"line":71,"address":[],"length":0,"stats":{"Line":23}},{"line":73,"address":[],"length":0,"stats":{"Line":47}},{"line":74,"address":[],"length":0,"stats":{"Line":43}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":45}},{"line":78,"address":[],"length":0,"stats":{"Line":31}},{"line":79,"address":[],"length":0,"stats":{"Line":28}},{"line":80,"address":[],"length":0,"stats":{"Line":29}},{"line":83,"address":[],"length":0,"stats":{"Line":27}},{"line":84,"address":[],"length":0,"stats":{"Line":27}},{"line":85,"address":[],"length":0,"stats":{"Line":18}},{"line":86,"address":[],"length":0,"stats":{"Line":13}},{"line":87,"address":[],"length":0,"stats":{"Line":11}},{"line":88,"address":[],"length":0,"stats":{"Line":8}},{"line":89,"address":[],"length":0,"stats":{"Line":8}},{"line":90,"address":[],"length":0,"stats":{"Line":8}},{"line":91,"address":[],"length":0,"stats":{"Line":8}},{"line":92,"address":[],"length":0,"stats":{"Line":8}},{"line":94,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":17}},{"line":100,"address":[],"length":0,"stats":{"Line":17}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":2}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":2}},{"line":112,"address":[],"length":0,"stats":{"Line":2}},{"line":113,"address":[],"length":0,"stats":{"Line":2}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":3}},{"line":124,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":1}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":2}},{"line":138,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":3}},{"line":170,"address":[],"length":0,"stats":{"Line":3}},{"line":171,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":3}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":2}},{"line":178,"address":[],"length":0,"stats":{"Line":4}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":180,"address":[],"length":0,"stats":{"Line":2}},{"line":185,"address":[],"length":0,"stats":{"Line":5}},{"line":186,"address":[],"length":0,"stats":{"Line":5}},{"line":187,"address":[],"length":0,"stats":{"Line":3}},{"line":189,"address":[],"length":0,"stats":{"Line":4}},{"line":190,"address":[],"length":0,"stats":{"Line":4}},{"line":208,"address":[],"length":0,"stats":{"Line":1}},{"line":209,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":1}},{"line":217,"address":[],"length":0,"stats":{"Line":2}},{"line":218,"address":[],"length":0,"stats":{"Line":1}},{"line":219,"address":[],"length":0,"stats":{"Line":1}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":2}},{"line":293,"address":[],"length":0,"stats":{"Line":2}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":2}},{"line":301,"address":[],"length":0,"stats":{"Line":4}},{"line":302,"address":[],"length":0,"stats":{"Line":4}},{"line":303,"address":[],"length":0,"stats":{"Line":4}},{"line":304,"address":[],"length":0,"stats":{"Line":4}},{"line":305,"address":[],"length":0,"stats":{"Line":2}},{"line":306,"address":[],"length":0,"stats":{"Line":2}},{"line":311,"address":[],"length":0,"stats":{"Line":1}},{"line":312,"address":[],"length":0,"stats":{"Line":2}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":1}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":2}},{"line":320,"address":[],"length":0,"stats":{"Line":2}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":1}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":2}},{"line":328,"address":[],"length":0,"stats":{"Line":1}},{"line":357,"address":[],"length":0,"stats":{"Line":2}},{"line":358,"address":[],"length":0,"stats":{"Line":4}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":4}},{"line":367,"address":[],"length":0,"stats":{"Line":1}},{"line":368,"address":[],"length":0,"stats":{"Line":1}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":10}},{"line":382,"address":[],"length":0,"stats":{"Line":2}},{"line":386,"address":[],"length":0,"stats":{"Line":2}},{"line":387,"address":[],"length":0,"stats":{"Line":2}},{"line":388,"address":[],"length":0,"stats":{"Line":4}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":5}},{"line":447,"address":[],"length":0,"stats":{"Line":15}},{"line":448,"address":[],"length":0,"stats":{"Line":5}},{"line":449,"address":[],"length":0,"stats":{"Line":2}},{"line":450,"address":[],"length":0,"stats":{"Line":3}},{"line":455,"address":[],"length":0,"stats":{"Line":3}},{"line":456,"address":[],"length":0,"stats":{"Line":6}},{"line":460,"address":[],"length":0,"stats":{"Line":2}},{"line":461,"address":[],"length":0,"stats":{"Line":2}},{"line":462,"address":[],"length":0,"stats":{"Line":1}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":1}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":13}},{"line":506,"address":[],"length":0,"stats":{"Line":39}},{"line":508,"address":[],"length":0,"stats":{"Line":13}},{"line":511,"address":[],"length":0,"stats":{"Line":3}},{"line":512,"address":[],"length":0,"stats":{"Line":1}},{"line":513,"address":[],"length":0,"stats":{"Line":1}},{"line":517,"address":[],"length":0,"stats":{"Line":3}},{"line":518,"address":[],"length":0,"stats":{"Line":1}},{"line":519,"address":[],"length":0,"stats":{"Line":1}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":3}},{"line":530,"address":[],"length":0,"stats":{"Line":1}},{"line":531,"address":[],"length":0,"stats":{"Line":1}},{"line":535,"address":[],"length":0,"stats":{"Line":3}},{"line":536,"address":[],"length":0,"stats":{"Line":1}},{"line":537,"address":[],"length":0,"stats":{"Line":1}},{"line":543,"address":[],"length":0,"stats":{"Line":1}},{"line":544,"address":[],"length":0,"stats":{"Line":1}},{"line":545,"address":[],"length":0,"stats":{"Line":2}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":2}},{"line":555,"address":[],"length":0,"stats":{"Line":1}},{"line":556,"address":[],"length":0,"stats":{"Line":2}},{"line":559,"address":[],"length":0,"stats":{"Line":1}},{"line":560,"address":[],"length":0,"stats":{"Line":3}},{"line":561,"address":[],"length":0,"stats":{"Line":1}},{"line":562,"address":[],"length":0,"stats":{"Line":1}},{"line":567,"address":[],"length":0,"stats":{"Line":2}},{"line":568,"address":[],"length":0,"stats":{"Line":1}},{"line":569,"address":[],"length":0,"stats":{"Line":1}},{"line":570,"address":[],"length":0,"stats":{"Line":1}},{"line":573,"address":[],"length":0,"stats":{"Line":1}},{"line":574,"address":[],"length":0,"stats":{"Line":3}},{"line":575,"address":[],"length":0,"stats":{"Line":1}},{"line":576,"address":[],"length":0,"stats":{"Line":1}},{"line":581,"address":[],"length":0,"stats":{"Line":1}},{"line":582,"address":[],"length":0,"stats":{"Line":1}},{"line":583,"address":[],"length":0,"stats":{"Line":1}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":1}},{"line":595,"address":[],"length":0,"stats":{"Line":1}},{"line":596,"address":[],"length":0,"stats":{"Line":2}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":1}},{"line":616,"address":[],"length":0,"stats":{"Line":2}},{"line":625,"address":[],"length":0,"stats":{"Line":4}},{"line":626,"address":[],"length":0,"stats":{"Line":4}},{"line":627,"address":[],"length":0,"stats":{"Line":10}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":1}},{"line":635,"address":[],"length":0,"stats":{"Line":7}},{"line":636,"address":[],"length":0,"stats":{"Line":2}},{"line":638,"address":[],"length":0,"stats":{"Line":4}}],"covered":153,"coverable":223},{"path":["/","workspace","crates","ofml-lib","src","operations.rs"],"content":"//! High-level operations for OFML processing.\n//!\n//! This module provides reusable functions for common OFML operations,\n//! designed for use by CLIs, GUIs, and other applications.\n\nuse crate::ebase::{EBaseReader, Odb2dRecord, Odb3dRecord};\nuse crate::geometry::{self, BoundingBox, Scene3DS};\nuse crate::geometry2d::{process_odb2d_records, G2DCompound};\nuse crate::ofml::AlbArchive;\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::Path;\n\n/// Result type for operations\npub type Result<T> = std::result::Result<T, OperationError>;\n\n/// Error type for operations\n#[derive(Debug)]\npub enum OperationError {\n    Io(std::io::Error),\n    Parse(String),\n    NotFound(String),\n    InvalidFormat(String),\n    NoGeometry,\n}\n\nimpl std::fmt::Display for OperationError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            Self::Io(e) => write!(f, \"I/O error: {}\", e),\n            Self::Parse(msg) => write!(f, \"Parse error: {}\", msg),\n            Self::NotFound(msg) => write!(f, \"Not found: {}\", msg),\n            Self::InvalidFormat(msg) => write!(f, \"Invalid format: {}\", msg),\n            Self::NoGeometry => write!(f, \"No geometry found\"),\n        }\n    }\n}\n\nimpl std::error::Error for OperationError {}\n\nimpl From<std::io::Error> for OperationError {\n    fn from(e: std::io::Error) -> Self {\n        Self::Io(e)\n    }\n}\n\n/// Validation result for geometry\n#[derive(Debug, Clone)]\npub struct ValidationResult {\n    pub is_valid: bool,\n    pub vertex_count: usize,\n    pub face_count: usize,\n    pub mesh_count: usize,\n    pub material_count: usize,\n    pub bounding_box: BoundingBox,\n    pub warnings: Vec<String>,\n    pub errors: Vec<String>,\n}\n\n/// Load geometry from a file, automatically detecting format by extension.\n///\n/// Supports: .3ds, .geo, .obj\npub fn load_geometry_file(path: &Path) -> Result<Scene3DS> {\n    let data = fs::read(path)?;\n    load_geometry_data(&data, path)\n}\n\n/// Load geometry from raw data, using path for format detection.\npub fn load_geometry_data(data: &[u8], path: &Path) -> Result<Scene3DS> {\n    let ext = path\n        .extension()\n        .and_then(|s| s.to_str())\n        .unwrap_or(\"\")\n        .to_lowercase();\n\n    match ext.as_str() {\n        \"3ds\" => geometry::parse_3ds(data).map_err(|e| OperationError::Parse(e.to_string())),\n        \"geo\" => geometry::parse_geo(data).map_err(|e| OperationError::Parse(e.to_string())),\n        \"obj\" => geometry::parse_obj(data).map_err(|e| OperationError::Parse(e.to_string())),\n        _ => Err(OperationError::InvalidFormat(format!(\n            \"Unsupported format: .{} (supported: .3ds, .geo, .obj)\",\n            ext\n        ))),\n    }\n}\n\n/// Validate a geometry scene and return detailed metrics.\npub fn validate_geometry(scene: &Scene3DS) -> ValidationResult {\n    let bbox = scene.bounding_box();\n    let dims = bbox.dimensions();\n    let vertex_count = scene.vertex_count();\n    let face_count = scene.face_count();\n\n    let mut warnings = Vec::new();\n    let mut errors = Vec::new();\n\n    // Check for basic validity\n    if vertex_count == 0 {\n        errors.push(\"No vertices found\".to_string());\n    }\n    if face_count == 0 {\n        errors.push(\"No faces found\".to_string());\n    }\n    if !bbox.is_valid() {\n        errors.push(\"Invalid bounding box\".to_string());\n    }\n\n    // Check for reasonable dimensions (furniture: 1mm to 10m)\n    let max_dim = dims.iter().cloned().fold(0.0f32, f32::max);\n    let min_dim = dims.iter().cloned().fold(f32::MAX, f32::min);\n\n    if max_dim > 10.0 {\n        warnings.push(format!(\n            \"Very large dimension: {:.2}m (expected < 10m)\",\n            max_dim\n        ));\n    }\n    if max_dim > 0.0 && min_dim < 0.001 {\n        warnings.push(format!(\n            \"Very small dimension: {:.4}m (expected > 1mm)\",\n            min_dim\n        ));\n    }\n\n    // Check for degenerate triangles\n    let mut degen_count = 0;\n    for mesh in &scene.meshes {\n        for face in &mesh.faces {\n            if face.a == face.b || face.b == face.c || face.a == face.c {\n                degen_count += 1;\n            }\n        }\n    }\n    if degen_count > 0 {\n        warnings.push(format!(\"{} degenerate triangles found\", degen_count));\n    }\n\n    ValidationResult {\n        is_valid: errors.is_empty(),\n        vertex_count,\n        face_count,\n        mesh_count: scene.meshes.len(),\n        material_count: scene.materials.len(),\n        bounding_box: bbox,\n        warnings,\n        errors,\n    }\n}\n\n/// Apply scale and offset transforms to a scene.\npub fn apply_transforms(scene: &mut Scene3DS, offset: &[f32; 3], scale: &[f32; 3]) {\n    for mesh in &mut scene.meshes {\n        for vertex in &mut mesh.vertices {\n            vertex.x = vertex.x * scale[0] + offset[0];\n            vertex.y = vertex.y * scale[1] + offset[1];\n            vertex.z = vertex.z * scale[2] + offset[2];\n        }\n    }\n}\n\n/// Merge multiple scenes into one.\npub fn merge_scenes(scenes: Vec<Scene3DS>) -> Scene3DS {\n    let mut combined = Scene3DS::default();\n    for scene in scenes {\n        combined.meshes.extend(scene.meshes);\n        combined.materials.extend(scene.materials);\n    }\n    combined\n}\n\n/// Load multiple geometry files and merge them.\npub fn load_and_merge_geometry(paths: &[&Path]) -> Result<Scene3DS> {\n    let mut scenes = Vec::new();\n\n    for path in paths {\n        match load_geometry_file(path) {\n            Ok(mut scene) => {\n                // Rename meshes to include filename for uniqueness\n                let stem = path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"mesh\");\n                for (i, mesh) in scene.meshes.iter_mut().enumerate() {\n                    if mesh.name == \"geo_mesh\" || mesh.name.is_empty() {\n                        mesh.name = format!(\"{}_{}\", stem, i);\n                    }\n                }\n                scenes.push(scene);\n            }\n            Err(e) => {\n                // Log warning but continue with other files\n                eprintln!(\"Warning: failed to load {}: {}\", path.display(), e);\n            }\n        }\n    }\n\n    if scenes.is_empty() {\n        return Err(OperationError::NoGeometry);\n    }\n\n    Ok(merge_scenes(scenes))\n}\n\n/// Convert a scene to GLB format.\npub fn export_to_glb(scene: &Scene3DS) -> Result<Vec<u8>> {\n    geometry::scene_to_glb(scene).map_err(|e| OperationError::Parse(e.to_string()))\n}\n\n/// Product assembly configuration\n#[derive(Debug, Clone, Default)]\npub struct ProductConfig {\n    /// Specific article to assemble (None = all)\n    pub article: Option<String>,\n    /// Custom properties to override\n    pub properties: HashMap<String, f64>,\n}\n\n/// Product assembly result\n#[derive(Debug)]\npub struct ProductResult {\n    pub scene: Scene3DS,\n    pub articles_found: Vec<String>,\n    pub geometry_loaded: usize,\n    pub geometry_missing: Vec<String>,\n}\n\n/// Assemble a product from OFML data directory.\n///\n/// The product_path should contain an odb.ebase file and optionally ALB archives.\npub fn assemble_product(product_path: &Path, config: &ProductConfig) -> Result<ProductResult> {\n    // Find odb.ebase\n    let (odb_path, actual_dir) = find_odb_ebase(product_path)?;\n\n    // Open EBASE\n    let mut reader = EBaseReader::open(&odb_path)\n        .map_err(|e| OperationError::Parse(format!(\"Failed to open ODB: {}\", e)))?;\n\n    // Read odb3d records\n    let records = reader\n        .read_records(\"odb3d\", None)\n        .map_err(|e| OperationError::Parse(format!(\"Failed to read odb3d: {}\", e)))?;\n\n    // Find ALB archive\n    let alb_path = find_alb_file(&actual_dir);\n    let mut alb_archive = alb_path.as_ref().and_then(|p| AlbArchive::open(p).ok());\n\n    // Collect geometry references\n    let mut geo_refs: Vec<(String, [f32; 3], [f32; 3])> = Vec::new();\n    let mut articles_found: Vec<String> = Vec::new();\n\n    for record in &records {\n        if let Some(odb_rec) = Odb3dRecord::from_record(record) {\n            // Filter by article if specified\n            if let Some(ref art) = config.article {\n                if !odb_rec.odb_name.eq_ignore_ascii_case(art) {\n                    continue;\n                }\n            }\n\n            if !articles_found.contains(&odb_rec.odb_name) {\n                articles_found.push(odb_rec.odb_name.clone());\n            }\n\n            if let Some((geo_name, scale)) = odb_rec.parse_ctor() {\n                let offset = odb_rec.parse_offset();\n                geo_refs.push((geo_name, offset, scale));\n            }\n        }\n    }\n\n    // Load geometry\n    let mut combined_scene = Scene3DS::default();\n    let mut loaded_count = 0;\n    let mut missing = Vec::new();\n\n    for (geo_name, offset, scale) in &geo_refs {\n        let loaded = load_geometry_for_product(\n            geo_name,\n            &actual_dir,\n            alb_archive.as_mut(),\n            offset,\n            scale,\n            &mut combined_scene,\n        );\n\n        if loaded {\n            loaded_count += 1;\n        } else {\n            missing.push(geo_name.clone());\n        }\n    }\n\n    // Fallback: scan for geometry files if nothing loaded\n    if combined_scene.meshes.is_empty() {\n        scan_directory_for_geometry(&actual_dir, &mut combined_scene)?;\n        loaded_count = combined_scene.meshes.len();\n    }\n\n    if combined_scene.meshes.is_empty() {\n        return Err(OperationError::NoGeometry);\n    }\n\n    Ok(ProductResult {\n        scene: combined_scene,\n        articles_found,\n        geometry_loaded: loaded_count,\n        geometry_missing: missing,\n    })\n}\n\n/// Find odb.ebase file in product directory or version subdirectories.\nfn find_odb_ebase(product_path: &Path) -> Result<(std::path::PathBuf, std::path::PathBuf)> {\n    // Check direct path\n    let direct = product_path.join(\"odb.ebase\");\n    if direct.exists() {\n        return Ok((direct, product_path.to_path_buf()));\n    }\n\n    // Check version subdirectories\n    for version in &[\"1\", \"2\", \"3\", \"current\"] {\n        let version_dir = product_path.join(version);\n        let odb = version_dir.join(\"odb.ebase\");\n        if odb.exists() {\n            return Ok((odb, version_dir));\n        }\n    }\n\n    Err(OperationError::NotFound(format!(\n        \"odb.ebase not found in {}\",\n        product_path.display()\n    )))\n}\n\n/// Find ALB file in directory.\nfn find_alb_file(dir: &Path) -> Option<std::path::PathBuf> {\n    if let Ok(entries) = fs::read_dir(dir) {\n        for entry in entries.filter_map(|e| e.ok()) {\n            let path = entry.path();\n            if path.extension().map(|s| s == \"alb\").unwrap_or(false) {\n                return Some(path);\n            }\n        }\n    }\n    None\n}\n\n/// Load geometry for a product, trying disk then ALB.\nfn load_geometry_for_product(\n    geo_name: &str,\n    product_dir: &Path,\n    alb_archive: Option<&mut AlbArchive>,\n    offset: &[f32; 3],\n    scale: &[f32; 3],\n    combined_scene: &mut Scene3DS,\n) -> bool {\n    // Try disk first\n    let patterns = [\n        format!(\"{}.geo\", geo_name),\n        format!(\"{}.3ds\", geo_name),\n        format!(\"{}.obj\", geo_name),\n    ];\n\n    for pattern in &patterns {\n        let geo_path = product_dir.join(pattern);\n        if geo_path.exists() {\n            if let Ok(mut scene) = load_geometry_file(&geo_path) {\n                apply_transforms(&mut scene, offset, scale);\n                combined_scene.meshes.extend(scene.meshes);\n                combined_scene.materials.extend(scene.materials);\n                return true;\n            }\n        }\n    }\n\n    // Try ALB archive\n    if let Some(archive) = alb_archive {\n        let all_files = archive.list_files();\n        for pattern in &patterns {\n            let pattern_lower = pattern.to_lowercase();\n            for file in &all_files {\n                let file_lower = file.to_lowercase();\n                if file_lower.ends_with(&pattern_lower)\n                    || file_lower.contains(&format!(\"/{}\", pattern_lower))\n                {\n                    if let Ok(data) = archive.extract(file) {\n                        let ext = Path::new(file)\n                            .extension()\n                            .and_then(|s| s.to_str())\n                            .unwrap_or(\"\");\n                        let scene_result = match ext.to_lowercase().as_str() {\n                            \"obj\" => geometry::parse_obj(&data),\n                            \"3ds\" => geometry::parse_3ds(&data),\n                            \"geo\" => geometry::parse_geo(&data),\n                            _ => continue,\n                        };\n                        if let Ok(mut scene) = scene_result {\n                            apply_transforms(&mut scene, offset, scale);\n                            combined_scene.meshes.extend(scene.meshes);\n                            combined_scene.materials.extend(scene.materials);\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    false\n}\n\n/// Scan directory for geometry files.\nfn scan_directory_for_geometry(dir: &Path, scene: &mut Scene3DS) -> Result<()> {\n    if let Ok(entries) = fs::read_dir(dir) {\n        for entry in entries.filter_map(|e| e.ok()) {\n            let path = entry.path();\n            let ext = path\n                .extension()\n                .and_then(|s| s.to_str())\n                .unwrap_or(\"\")\n                .to_lowercase();\n\n            if ext == \"geo\" || ext == \"3ds\" || ext == \"obj\" {\n                if let Ok(s) = load_geometry_file(&path) {\n                    scene.meshes.extend(s.meshes);\n                    scene.materials.extend(s.materials);\n                }\n            }\n        }\n    }\n    Ok(())\n}\n\n/// Export 2D floor plan from EBASE odb2d table.\npub fn export_2d_floorplan(ebase_path: &Path) -> Result<G2DCompound> {\n    let mut reader = EBaseReader::open(ebase_path)\n        .map_err(|e| OperationError::Parse(format!(\"Failed to open EBASE: {}\", e)))?;\n\n    if !reader.tables.contains_key(\"odb2d\") {\n        return Err(OperationError::NotFound(\n            \"odb2d table not found\".to_string(),\n        ));\n    }\n\n    let records = reader\n        .read_records(\"odb2d\", None)\n        .map_err(|e| OperationError::Parse(format!(\"Failed to read odb2d: {}\", e)))?;\n\n    let odb2d_records: Vec<Odb2dRecord> = records\n        .iter()\n        .filter_map(Odb2dRecord::from_record)\n        .filter(|r| !r.prim_type.is_empty())\n        .collect();\n\n    if odb2d_records.is_empty() {\n        return Err(OperationError::NoGeometry);\n    }\n\n    Ok(process_odb2d_records(&odb2d_records))\n}\n\n/// Evaluate an EBASE expression.\npub fn evaluate_expression(\n    expr: &str,\n    props: &HashMap<String, f64>,\n) -> std::result::Result<crate::ebase_expr::EbaseResult, String> {\n    let mut evaluator = crate::ebase_expr::EbaseEvaluator::new();\n    evaluator.evaluate(expr, props).map_err(|e| e.to_string())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_validate_empty_scene() {\n        let scene = Scene3DS::default();\n        let result = validate_geometry(&scene);\n        assert!(!result.is_valid);\n        assert!(result.errors.iter().any(|e| e.contains(\"No vertices\")));\n    }\n\n    #[test]\n    fn test_validate_valid_scene() {\n        use crate::geometry::{Face, Mesh, Vertex};\n\n        let mut scene = Scene3DS::default();\n        scene.meshes.push(Mesh {\n            name: \"cube\".to_string(),\n            vertices: vec![\n                Vertex {\n                    x: 0.0,\n                    y: 0.0,\n                    z: 0.0,\n                },\n                Vertex {\n                    x: 1.0,\n                    y: 0.0,\n                    z: 0.0,\n                },\n                Vertex {\n                    x: 1.0,\n                    y: 1.0,\n                    z: 0.0,\n                },\n            ],\n            faces: vec![Face {\n                a: 0,\n                b: 1,\n                c: 2,\n                flags: 0,\n            }],\n            ..Default::default()\n        });\n\n        let result = validate_geometry(&scene);\n        assert!(result.is_valid);\n        assert_eq!(result.vertex_count, 3);\n        assert_eq!(result.face_count, 1);\n    }\n\n    #[test]\n    fn test_validate_degenerate_triangle() {\n        use crate::geometry::{Face, Mesh, Vertex};\n\n        let mut scene = Scene3DS::default();\n        scene.meshes.push(Mesh {\n            name: \"bad\".to_string(),\n            vertices: vec![\n                Vertex {\n                    x: 0.0,\n                    y: 0.0,\n                    z: 0.0,\n                },\n                Vertex {\n                    x: 1.0,\n                    y: 0.0,\n                    z: 0.0,\n                },\n            ],\n            faces: vec![Face {\n                a: 0,\n                b: 0,\n                c: 1,\n                flags: 0,\n            }], // degenerate\n            ..Default::default()\n        });\n\n        let result = validate_geometry(&scene);\n        assert!(result.warnings.iter().any(|w| w.contains(\"degenerate\")));\n    }\n\n    #[test]\n    fn test_apply_transforms() {\n        use crate::geometry::{Mesh, Vertex};\n\n        let mut scene = Scene3DS::default();\n        scene.meshes.push(Mesh {\n            name: \"test\".to_string(),\n            vertices: vec![Vertex {\n                x: 1.0,\n                y: 2.0,\n                z: 3.0,\n            }],\n            ..Default::default()\n        });\n\n        apply_transforms(&mut scene, &[10.0, 20.0, 30.0], &[2.0, 2.0, 2.0]);\n\n        let v = &scene.meshes[0].vertices[0];\n        assert_eq!(v.x, 12.0); // 1*2 + 10\n        assert_eq!(v.y, 24.0); // 2*2 + 20\n        assert_eq!(v.z, 36.0); // 3*2 + 30\n    }\n\n    #[test]\n    fn test_merge_scenes() {\n        use crate::geometry::{Mesh, Vertex};\n\n        let scene1 = Scene3DS {\n            meshes: vec![Mesh {\n                name: \"mesh1\".to_string(),\n                vertices: vec![Vertex {\n                    x: 0.0,\n                    y: 0.0,\n                    z: 0.0,\n                }],\n                ..Default::default()\n            }],\n            ..Default::default()\n        };\n\n        let scene2 = Scene3DS {\n            meshes: vec![Mesh {\n                name: \"mesh2\".to_string(),\n                vertices: vec![Vertex {\n                    x: 1.0,\n                    y: 1.0,\n                    z: 1.0,\n                }],\n                ..Default::default()\n            }],\n            ..Default::default()\n        };\n\n        let merged = merge_scenes(vec![scene1, scene2]);\n        assert_eq!(merged.meshes.len(), 2);\n        assert_eq!(merged.meshes[0].name, \"mesh1\");\n        assert_eq!(merged.meshes[1].name, \"mesh2\");\n    }\n\n    #[test]\n    fn test_export_to_glb() {\n        use crate::geometry::{Face, Mesh, Vertex};\n\n        let mut scene = Scene3DS::default();\n        scene.meshes.push(Mesh {\n            name: \"cube\".to_string(),\n            vertices: vec![\n                Vertex {\n                    x: 0.0,\n                    y: 0.0,\n                    z: 0.0,\n                },\n                Vertex {\n                    x: 1.0,\n                    y: 0.0,\n                    z: 0.0,\n                },\n                Vertex {\n                    x: 1.0,\n                    y: 1.0,\n                    z: 0.0,\n                },\n            ],\n            faces: vec![Face {\n                a: 0,\n                b: 1,\n                c: 2,\n                flags: 0,\n            }],\n            ..Default::default()\n        });\n\n        let glb = export_to_glb(&scene).expect(\"GLB export failed\");\n        assert!(!glb.is_empty());\n        // GLB magic number\n        assert_eq!(&glb[0..4], b\"glTF\");\n    }\n\n    #[test]\n    fn test_evaluate_expression() {\n        let props = HashMap::new();\n        let result = evaluate_expression(r#\"\"test.geo\" 1 1 1 imp\"#, &props);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_load_geometry_data_invalid_format() {\n        let path = Path::new(\"test.xyz\");\n        let result = load_geometry_data(b\"data\", path);\n        assert!(matches!(result, Err(OperationError::InvalidFormat(_))));\n    }\n\n    #[test]\n    fn test_validation_large_dimension_warning() {\n        use crate::geometry::{Face, Mesh, Vertex};\n\n        let mut scene = Scene3DS::default();\n        scene.meshes.push(Mesh {\n            name: \"large\".to_string(),\n            vertices: vec![\n                Vertex {\n                    x: 0.0,\n                    y: 0.0,\n                    z: 0.0,\n                },\n                Vertex {\n                    x: 15.0,\n                    y: 0.0,\n                    z: 0.0,\n                }, // 15m > 10m\n                Vertex {\n                    x: 15.0,\n                    y: 1.0,\n                    z: 0.0,\n                },\n            ],\n            faces: vec![Face {\n                a: 0,\n                b: 1,\n                c: 2,\n                flags: 0,\n            }],\n            ..Default::default()\n        });\n\n        let result = validate_geometry(&scene);\n        assert!(result.warnings.iter().any(|w| w.contains(\"Very large\")));\n    }\n\n    #[test]\n    fn test_operation_error_display() {\n        let io_err = OperationError::Io(std::io::Error::new(std::io::ErrorKind::NotFound, \"file not found\"));\n        assert!(format!(\"{}\", io_err).contains(\"I/O error\"));\n\n        let parse_err = OperationError::Parse(\"invalid syntax\".to_string());\n        assert!(format!(\"{}\", parse_err).contains(\"Parse error\"));\n        assert!(format!(\"{}\", parse_err).contains(\"invalid syntax\"));\n\n        let not_found = OperationError::NotFound(\"missing file\".to_string());\n        assert!(format!(\"{}\", not_found).contains(\"Not found\"));\n\n        let invalid = OperationError::InvalidFormat(\"unsupported\".to_string());\n        assert!(format!(\"{}\", invalid).contains(\"Invalid format\"));\n\n        let no_geo = OperationError::NoGeometry;\n        assert!(format!(\"{}\", no_geo).contains(\"No geometry\"));\n    }\n\n    #[test]\n    fn test_operation_error_debug() {\n        let err = OperationError::NoGeometry;\n        let debug_str = format!(\"{:?}\", err);\n        assert!(debug_str.contains(\"NoGeometry\"));\n    }\n\n    #[test]\n    fn test_operation_error_from_io() {\n        let io_err = std::io::Error::new(std::io::ErrorKind::PermissionDenied, \"access denied\");\n        let op_err: OperationError = io_err.into();\n        assert!(matches!(op_err, OperationError::Io(_)));\n    }\n\n    #[test]\n    fn test_validation_result_clone() {\n        let result = ValidationResult {\n            is_valid: true,\n            vertex_count: 100,\n            face_count: 50,\n            mesh_count: 2,\n            material_count: 3,\n            bounding_box: BoundingBox::empty(),\n            warnings: vec![\"warning1\".to_string()],\n            errors: vec![],\n        };\n\n        let cloned = result.clone();\n        assert_eq!(cloned.is_valid, true);\n        assert_eq!(cloned.vertex_count, 100);\n        assert_eq!(cloned.face_count, 50);\n        assert_eq!(cloned.warnings.len(), 1);\n    }\n\n    #[test]\n    fn test_validation_result_debug() {\n        let result = ValidationResult {\n            is_valid: true,\n            vertex_count: 10,\n            face_count: 5,\n            mesh_count: 1,\n            material_count: 1,\n            bounding_box: BoundingBox::empty(),\n            warnings: vec![],\n            errors: vec![],\n        };\n        let debug_str = format!(\"{:?}\", result);\n        assert!(debug_str.contains(\"ValidationResult\"));\n    }\n\n    #[test]\n    fn test_validation_small_dimension_warning() {\n        use crate::geometry::{Face, Mesh, Vertex};\n\n        let mut scene = Scene3DS::default();\n        scene.meshes.push(Mesh {\n            name: \"tiny\".to_string(),\n            vertices: vec![\n                Vertex {\n                    x: 0.0,\n                    y: 0.0,\n                    z: 0.0,\n                },\n                Vertex {\n                    x: 0.0005, // 0.5mm < 1mm threshold\n                    y: 1.0,\n                    z: 0.0,\n                },\n                Vertex {\n                    x: 0.0005,\n                    y: 1.0,\n                    z: 1.0,\n                },\n            ],\n            faces: vec![Face {\n                a: 0,\n                b: 1,\n                c: 2,\n                flags: 0,\n            }],\n            ..Default::default()\n        });\n\n        let result = validate_geometry(&scene);\n        assert!(result.warnings.iter().any(|w| w.contains(\"Very small\")));\n    }\n\n    #[test]\n    fn test_validation_no_faces() {\n        use crate::geometry::{Mesh, Vertex};\n\n        let mut scene = Scene3DS::default();\n        scene.meshes.push(Mesh {\n            name: \"no_faces\".to_string(),\n            vertices: vec![\n                Vertex {\n                    x: 0.0,\n                    y: 0.0,\n                    z: 0.0,\n                },\n                Vertex {\n                    x: 1.0,\n                    y: 0.0,\n                    z: 0.0,\n                },\n            ],\n            faces: vec![], // No faces\n            ..Default::default()\n        });\n\n        let result = validate_geometry(&scene);\n        assert!(result.errors.iter().any(|e| e.contains(\"No faces\")));\n    }\n\n    #[test]\n    fn test_product_config_default() {\n        let config = ProductConfig::default();\n        assert!(config.article.is_none());\n        assert!(config.properties.is_empty());\n    }\n\n    #[test]\n    fn test_product_config_clone() {\n        let mut config = ProductConfig::default();\n        config.article = Some(\"test_article\".to_string());\n        config.properties.insert(\"width\".to_string(), 100.0);\n\n        let cloned = config.clone();\n        assert_eq!(cloned.article, Some(\"test_article\".to_string()));\n        assert_eq!(cloned.properties.get(\"width\"), Some(&100.0));\n    }\n\n    #[test]\n    fn test_product_config_debug() {\n        let config = ProductConfig::default();\n        let debug_str = format!(\"{:?}\", config);\n        assert!(debug_str.contains(\"ProductConfig\"));\n    }\n\n    #[test]\n    fn test_product_result_debug() {\n        let result = ProductResult {\n            scene: Scene3DS::default(),\n            articles_found: vec![\"article1\".to_string()],\n            geometry_loaded: 1,\n            geometry_missing: vec![],\n        };\n        let debug_str = format!(\"{:?}\", result);\n        assert!(debug_str.contains(\"ProductResult\"));\n    }\n\n    #[test]\n    fn test_load_geometry_file_not_found() {\n        let result = load_geometry_file(Path::new(\"/nonexistent/path/file.3ds\"));\n        assert!(result.is_err());\n        assert!(matches!(result.unwrap_err(), OperationError::Io(_)));\n    }\n\n    #[test]\n    fn test_load_geometry_data_no_extension() {\n        let path = Path::new(\"noextension\");\n        let result = load_geometry_data(b\"data\", path);\n        assert!(matches!(result, Err(OperationError::InvalidFormat(_))));\n    }\n\n    #[test]\n    fn test_load_and_merge_empty_paths() {\n        let result = load_and_merge_geometry(&[]);\n        assert!(matches!(result, Err(OperationError::NoGeometry)));\n    }\n\n    #[test]\n    fn test_load_and_merge_nonexistent_files() {\n        let paths: Vec<&Path> = vec![\n            Path::new(\"/nonexistent1.geo\"),\n            Path::new(\"/nonexistent2.3ds\"),\n        ];\n        // Should fail because all files fail to load\n        let result = load_and_merge_geometry(&paths);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_evaluate_expression_simple() {\n        let props = HashMap::new();\n        let result = evaluate_expression(\"1 2 +\", &props);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_evaluate_expression_with_props() {\n        let mut props = HashMap::new();\n        props.insert(\"width\".to_string(), 100.0);\n        // Just test that the function handles properties without crashing\n        let _result = evaluate_expression(\"100 10 *\", &props);\n    }\n\n    #[test]\n    fn test_evaluate_expression_invalid() {\n        let props = HashMap::new();\n        // Just check it returns something (may be error or success depending on expression)\n        let _result = evaluate_expression(\"\", &props);\n    }\n\n    #[test]\n    fn test_merge_scenes_empty() {\n        let merged = merge_scenes(vec![]);\n        assert!(merged.meshes.is_empty());\n        assert!(merged.materials.is_empty());\n    }\n\n    #[test]\n    fn test_merge_scenes_single() {\n        use crate::geometry::{Mesh, Vertex};\n\n        let scene = Scene3DS {\n            meshes: vec![Mesh {\n                name: \"single\".to_string(),\n                vertices: vec![Vertex {\n                    x: 1.0,\n                    y: 2.0,\n                    z: 3.0,\n                }],\n                ..Default::default()\n            }],\n            ..Default::default()\n        };\n\n        let merged = merge_scenes(vec![scene]);\n        assert_eq!(merged.meshes.len(), 1);\n        assert_eq!(merged.meshes[0].name, \"single\");\n    }\n\n    #[test]\n    fn test_merge_scenes_materials() {\n        use crate::geometry::Material3DS;\n\n        let mut scene1 = Scene3DS::default();\n        scene1.materials.insert(\"mat1\".to_string(), Material3DS {\n            name: \"mat1\".to_string(),\n            ..Default::default()\n        });\n\n        let mut scene2 = Scene3DS::default();\n        scene2.materials.insert(\"mat2\".to_string(), Material3DS {\n            name: \"mat2\".to_string(),\n            ..Default::default()\n        });\n\n        let merged = merge_scenes(vec![scene1, scene2]);\n        assert_eq!(merged.materials.len(), 2);\n    }\n\n    #[test]\n    fn test_apply_transforms_identity() {\n        use crate::geometry::{Mesh, Vertex};\n\n        let mut scene = Scene3DS::default();\n        scene.meshes.push(Mesh {\n            name: \"test\".to_string(),\n            vertices: vec![Vertex {\n                x: 5.0,\n                y: 10.0,\n                z: 15.0,\n            }],\n            ..Default::default()\n        });\n\n        // Identity transform: scale 1, offset 0\n        apply_transforms(&mut scene, &[0.0, 0.0, 0.0], &[1.0, 1.0, 1.0]);\n\n        let v = &scene.meshes[0].vertices[0];\n        assert_eq!(v.x, 5.0);\n        assert_eq!(v.y, 10.0);\n        assert_eq!(v.z, 15.0);\n    }\n\n    #[test]\n    fn test_apply_transforms_scale_only() {\n        use crate::geometry::{Mesh, Vertex};\n\n        let mut scene = Scene3DS::default();\n        scene.meshes.push(Mesh {\n            name: \"test\".to_string(),\n            vertices: vec![Vertex {\n                x: 1.0,\n                y: 2.0,\n                z: 3.0,\n            }],\n            ..Default::default()\n        });\n\n        apply_transforms(&mut scene, &[0.0, 0.0, 0.0], &[3.0, 3.0, 3.0]);\n\n        let v = &scene.meshes[0].vertices[0];\n        assert_eq!(v.x, 3.0);\n        assert_eq!(v.y, 6.0);\n        assert_eq!(v.z, 9.0);\n    }\n\n    #[test]\n    fn test_apply_transforms_offset_only() {\n        use crate::geometry::{Mesh, Vertex};\n\n        let mut scene = Scene3DS::default();\n        scene.meshes.push(Mesh {\n            name: \"test\".to_string(),\n            vertices: vec![Vertex {\n                x: 0.0,\n                y: 0.0,\n                z: 0.0,\n            }],\n            ..Default::default()\n        });\n\n        apply_transforms(&mut scene, &[100.0, 200.0, 300.0], &[1.0, 1.0, 1.0]);\n\n        let v = &scene.meshes[0].vertices[0];\n        assert_eq!(v.x, 100.0);\n        assert_eq!(v.y, 200.0);\n        assert_eq!(v.z, 300.0);\n    }\n\n    #[test]\n    fn test_assemble_product_not_found() {\n        let result = assemble_product(Path::new(\"/nonexistent/path\"), &ProductConfig::default());\n        assert!(result.is_err());\n        assert!(matches!(result.unwrap_err(), OperationError::NotFound(_)));\n    }\n\n    #[test]\n    fn test_export_2d_floorplan_not_found() {\n        let result = export_2d_floorplan(Path::new(\"/nonexistent/path/odb.ebase\"));\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":8}},{"line":29,"address":[],"length":0,"stats":{"Line":8}},{"line":30,"address":[],"length":0,"stats":{"Line":12}},{"line":31,"address":[],"length":0,"stats":{"Line":8}},{"line":32,"address":[],"length":0,"stats":{"Line":4}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":34,"address":[],"length":0,"stats":{"Line":3}},{"line":42,"address":[],"length":0,"stats":{"Line":4}},{"line":43,"address":[],"length":0,"stats":{"Line":4}},{"line":63,"address":[],"length":0,"stats":{"Line":3}},{"line":64,"address":[],"length":0,"stats":{"Line":9}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":4}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":77,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":2}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":80,"address":[],"length":0,"stats":{"Line":2}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":82,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":18}},{"line":90,"address":[],"length":0,"stats":{"Line":18}},{"line":91,"address":[],"length":0,"stats":{"Line":18}},{"line":92,"address":[],"length":0,"stats":{"Line":18}},{"line":94,"address":[],"length":0,"stats":{"Line":12}},{"line":95,"address":[],"length":0,"stats":{"Line":12}},{"line":98,"address":[],"length":0,"stats":{"Line":7}},{"line":99,"address":[],"length":0,"stats":{"Line":3}},{"line":101,"address":[],"length":0,"stats":{"Line":8}},{"line":102,"address":[],"length":0,"stats":{"Line":6}},{"line":104,"address":[],"length":0,"stats":{"Line":7}},{"line":105,"address":[],"length":0,"stats":{"Line":3}},{"line":109,"address":[],"length":0,"stats":{"Line":30}},{"line":110,"address":[],"length":0,"stats":{"Line":30}},{"line":112,"address":[],"length":0,"stats":{"Line":7}},{"line":113,"address":[],"length":0,"stats":{"Line":3}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":16}},{"line":119,"address":[],"length":0,"stats":{"Line":15}},{"line":120,"address":[],"length":0,"stats":{"Line":5}},{"line":121,"address":[],"length":0,"stats":{"Line":5}},{"line":126,"address":[],"length":0,"stats":{"Line":12}},{"line":127,"address":[],"length":0,"stats":{"Line":16}},{"line":128,"address":[],"length":0,"stats":{"Line":13}},{"line":129,"address":[],"length":0,"stats":{"Line":11}},{"line":130,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":7}},{"line":135,"address":[],"length":0,"stats":{"Line":3}},{"line":139,"address":[],"length":0,"stats":{"Line":18}},{"line":142,"address":[],"length":0,"stats":{"Line":18}},{"line":143,"address":[],"length":0,"stats":{"Line":18}},{"line":151,"address":[],"length":0,"stats":{"Line":4}},{"line":152,"address":[],"length":0,"stats":{"Line":12}},{"line":153,"address":[],"length":0,"stats":{"Line":16}},{"line":154,"address":[],"length":0,"stats":{"Line":8}},{"line":155,"address":[],"length":0,"stats":{"Line":8}},{"line":156,"address":[],"length":0,"stats":{"Line":4}},{"line":162,"address":[],"length":0,"stats":{"Line":4}},{"line":163,"address":[],"length":0,"stats":{"Line":8}},{"line":164,"address":[],"length":0,"stats":{"Line":19}},{"line":165,"address":[],"length":0,"stats":{"Line":20}},{"line":166,"address":[],"length":0,"stats":{"Line":10}},{"line":168,"address":[],"length":0,"stats":{"Line":4}},{"line":172,"address":[],"length":0,"stats":{"Line":2}},{"line":173,"address":[],"length":0,"stats":{"Line":4}},{"line":175,"address":[],"length":0,"stats":{"Line":6}},{"line":176,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":4}},{"line":189,"address":[],"length":0,"stats":{"Line":6}},{"line":194,"address":[],"length":0,"stats":{"Line":4}},{"line":195,"address":[],"length":0,"stats":{"Line":2}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":1}},{"line":203,"address":[],"length":0,"stats":{"Line":3}},{"line":227,"address":[],"length":0,"stats":{"Line":1}},{"line":229,"address":[],"length":0,"stats":{"Line":3}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":1}},{"line":311,"address":[],"length":0,"stats":{"Line":3}},{"line":312,"address":[],"length":0,"stats":{"Line":1}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":9}},{"line":318,"address":[],"length":0,"stats":{"Line":16}},{"line":319,"address":[],"length":0,"stats":{"Line":8}},{"line":320,"address":[],"length":0,"stats":{"Line":4}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":2}},{"line":326,"address":[],"length":0,"stats":{"Line":2}},{"line":327,"address":[],"length":0,"stats":{"Line":1}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":1}},{"line":432,"address":[],"length":0,"stats":{"Line":2}},{"line":433,"address":[],"length":0,"stats":{"Line":4}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":4}},{"line":463,"address":[],"length":0,"stats":{"Line":8}},{"line":464,"address":[],"length":0,"stats":{"Line":20}}],"covered":94,"coverable":211},{"path":["/","workspace","crates","ofml-lib","src","parser.rs"],"content":"//! OFML Parser - Recursive descent parser\n//! Based on OFML 2.0 specification Sections 3.5-3.8\n\nuse crate::ast::*;\nuse crate::lexer::{tokenize, LexError, SpannedToken, Token};\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum ParseError {\n    #[error(\"Lexer error: {0}\")]\n    Lex(#[from] LexError),\n    #[error(\"Unexpected token '{found}' at position {pos}, expected {expected}\")]\n    UnexpectedToken {\n        found: String,\n        expected: String,\n        pos: usize,\n    },\n    #[error(\"Unexpected end of input, expected {expected}\")]\n    UnexpectedEof { expected: String },\n    #[error(\"Invalid syntax: {message} at position {pos}\")]\n    InvalidSyntax { message: String, pos: usize },\n}\n\npub type ParseResult<T> = Result<T, ParseError>;\n\n/// OFML Parser\npub struct Parser {\n    tokens: Vec<SpannedToken>,\n    pos: usize,\n}\n\nimpl Parser {\n    /// Create a new parser from source code\n    pub fn new(source: &str) -> ParseResult<Self> {\n        let tokens = tokenize(source)?;\n        Ok(Self { tokens, pos: 0 })\n    }\n\n    /// Parse a complete translation unit\n    pub fn parse(&mut self) -> ParseResult<TranslationUnit> {\n        let mut unit = TranslationUnit::default();\n\n        // Optional package declaration\n        if self.check(&Token::Package) {\n            unit.package = Some(self.parse_package_decl()?);\n        }\n\n        // Import declarations\n        while self.check(&Token::Import) {\n            unit.imports.push(self.parse_import_decl()?);\n        }\n\n        // Statements\n        while !self.is_at_end() {\n            unit.statements.push(self.parse_stmt()?);\n        }\n\n        Ok(unit)\n    }\n\n    // ============================================================\n    // Helpers\n    // ============================================================\n\n    fn current(&self) -> Option<&SpannedToken> {\n        self.tokens.get(self.pos)\n    }\n\n    fn current_token(&self) -> Option<&Token> {\n        self.current().map(|t| &t.token)\n    }\n\n    fn current_pos(&self) -> usize {\n        self.current().map(|t| t.span.start).unwrap_or(0)\n    }\n\n    fn is_at_end(&self) -> bool {\n        self.pos >= self.tokens.len()\n    }\n\n    fn advance(&mut self) -> Option<&SpannedToken> {\n        if !self.is_at_end() {\n            self.pos += 1;\n        }\n        self.tokens.get(self.pos - 1)\n    }\n\n    fn check(&self, token: &Token) -> bool {\n        self.current_token().map(|t| t == token).unwrap_or(false)\n    }\n\n    #[allow(dead_code)]\n    fn check_any(&self, tokens: &[Token]) -> bool {\n        tokens.iter().any(|t| self.check(t))\n    }\n\n    fn match_token(&mut self, token: &Token) -> bool {\n        if self.check(token) {\n            self.advance();\n            true\n        } else {\n            false\n        }\n    }\n\n    fn expect(&mut self, token: &Token) -> ParseResult<&SpannedToken> {\n        if self.check(token) {\n            Ok(self.advance().unwrap())\n        } else {\n            Err(self.unexpected_token(&format!(\"{:?}\", token)))\n        }\n    }\n\n    fn unexpected_token(&self, expected: &str) -> ParseError {\n        if let Some(t) = self.current() {\n            ParseError::UnexpectedToken {\n                found: format!(\"{:?}\", t.token),\n                expected: expected.to_string(),\n                pos: t.span.start,\n            }\n        } else {\n            ParseError::UnexpectedEof {\n                expected: expected.to_string(),\n            }\n        }\n    }\n\n    fn span_from(&self, start: usize) -> Span {\n        let end = self\n            .tokens\n            .get(self.pos.saturating_sub(1))\n            .map(|t| t.span.end)\n            .unwrap_or(start);\n        Span::new(start, end)\n    }\n\n    // ============================================================\n    // Package and Import\n    // ============================================================\n\n    fn parse_package_decl(&mut self) -> ParseResult<QualifiedName> {\n        self.expect(&Token::Package)?;\n        let name = self.parse_qualified_name()?;\n        self.expect(&Token::Semi)?;\n        Ok(name)\n    }\n\n    fn parse_import_decl(&mut self) -> ParseResult<ImportDecl> {\n        let start = self.current_pos();\n        self.expect(&Token::Import)?;\n        let path = self.parse_qualified_name()?;\n\n        // Check for wildcard ::*\n        let wildcard = if self.check(&Token::ColonColon) {\n            self.advance();\n            self.expect(&Token::Star)?;\n            true\n        } else {\n            false\n        };\n\n        self.expect(&Token::Semi)?;\n        Ok(ImportDecl {\n            path,\n            wildcard,\n            span: self.span_from(start),\n        })\n    }\n\n    fn parse_qualified_name(&mut self) -> ParseResult<QualifiedName> {\n        let start = self.current_pos();\n        let absolute = self.match_token(&Token::ColonColon);\n        let mut parts = Vec::new();\n\n        // First identifier\n        if let Some(Token::Ident(name)) = self.current_token().cloned() {\n            self.advance();\n            parts.push(name);\n        } else {\n            return Err(self.unexpected_token(\"identifier\"));\n        }\n\n        // Additional parts\n        while self.match_token(&Token::ColonColon) {\n            if let Some(Token::Ident(name)) = self.current_token().cloned() {\n                self.advance();\n                parts.push(name);\n            } else if self.check(&Token::Star) {\n                // Wildcard - don't consume it here\n                self.pos -= 1; // Back up the ::\n                break;\n            } else {\n                break;\n            }\n        }\n\n        Ok(QualifiedName {\n            absolute,\n            parts,\n            span: self.span_from(start),\n        })\n    }\n\n    // ============================================================\n    // Statements\n    // ============================================================\n\n    fn parse_stmt(&mut self) -> ParseResult<Stmt> {\n        // Check for modifiers first\n        let modifiers = self.parse_modifiers();\n\n        match self.current_token() {\n            Some(Token::Var) => self.parse_var_decl_list(modifiers),\n            Some(Token::Class) => self.parse_class_decl(modifiers).map(Stmt::Class),\n            Some(Token::Func) => self.parse_func_decl(modifiers).map(Stmt::Func),\n            Some(Token::If) => self.parse_if_stmt(),\n            Some(Token::Switch) => self.parse_switch_stmt(),\n            Some(Token::While) => self.parse_while_stmt(),\n            Some(Token::Do) => self.parse_do_while_stmt(),\n            Some(Token::For) => self.parse_for_stmt(),\n            Some(Token::Foreach) => self.parse_foreach_stmt(),\n            Some(Token::Return) => self.parse_return_stmt(),\n            Some(Token::Break) => self.parse_break_stmt(),\n            Some(Token::Continue) => self.parse_continue_stmt(),\n            Some(Token::Throw) => self.parse_throw_stmt(),\n            Some(Token::Try) => self.parse_try_stmt(),\n            Some(Token::LBrace) => self.parse_block().map(Stmt::Block),\n            Some(Token::Semi) => {\n                self.advance();\n                Ok(Stmt::Empty)\n            }\n            _ => {\n                if !modifiers.is_empty() {\n                    return Err(ParseError::InvalidSyntax {\n                        message: \"Unexpected modifiers\".to_string(),\n                        pos: self.current_pos(),\n                    });\n                }\n                self.parse_expr_stmt()\n            }\n        }\n    }\n\n    fn parse_modifiers(&mut self) -> Vec<Modifier> {\n        let mut modifiers = Vec::new();\n        loop {\n            let modifier = match self.current_token() {\n                Some(Token::Public) => Modifier::Public,\n                Some(Token::Private) => Modifier::Private,\n                Some(Token::Protected) => Modifier::Protected,\n                Some(Token::Static) => Modifier::Static,\n                Some(Token::Final) => Modifier::Final,\n                Some(Token::Abstract) => Modifier::Abstract,\n                Some(Token::Native) => Modifier::Native,\n                Some(Token::Transient) => Modifier::Transient,\n                _ => break,\n            };\n            self.advance();\n            modifiers.push(modifier);\n        }\n        modifiers\n    }\n\n    /// Parse a variable declaration list as a statement: `var a, b = 1, c;`\n    /// Returns Stmt::Var for single declaration, Stmt::VarList for multiple.\n    fn parse_var_decl_list(&mut self, modifiers: Vec<Modifier>) -> ParseResult<Stmt> {\n        self.expect(&Token::Var)?;\n\n        let mut declarations = Vec::new();\n\n        loop {\n            let var_start = self.current_pos();\n\n            // Parse variable name\n            let name = if let Some(Token::Ident(name)) = self.current_token().cloned() {\n                self.advance();\n                name\n            } else {\n                return Err(self.unexpected_token(\"identifier\"));\n            };\n\n            // Parse optional initializer\n            let initializer = if self.match_token(&Token::Eq) {\n                Some(self.parse_expr()?)\n            } else {\n                None\n            };\n\n            declarations.push(VarDecl {\n                modifiers: modifiers.clone(),\n                name,\n                initializer,\n                span: self.span_from(var_start),\n            });\n\n            // Check for more declarations\n            if !self.match_token(&Token::Comma) {\n                break;\n            }\n        }\n\n        self.expect(&Token::Semi)?;\n\n        // Return single Var or VarList depending on count\n        if declarations.len() == 1 {\n            Ok(Stmt::Var(declarations.pop().unwrap()))\n        } else {\n            Ok(Stmt::VarList(declarations))\n        }\n    }\n\n    /// Parse a single variable declaration (for use in for loops, etc.)\n    fn parse_var_decl(&mut self, modifiers: Vec<Modifier>) -> ParseResult<VarDecl> {\n        let start = self.current_pos();\n        self.expect(&Token::Var)?;\n\n        // Parse variable name\n        let name = if let Some(Token::Ident(name)) = self.current_token().cloned() {\n            self.advance();\n            name\n        } else {\n            return Err(self.unexpected_token(\"identifier\"));\n        };\n\n        let initializer = if self.match_token(&Token::Eq) {\n            Some(self.parse_expr()?)\n        } else {\n            None\n        };\n\n        self.expect(&Token::Semi)?;\n\n        Ok(VarDecl {\n            modifiers,\n            name,\n            initializer,\n            span: self.span_from(start),\n        })\n    }\n\n    fn parse_class_decl(&mut self, modifiers: Vec<Modifier>) -> ParseResult<ClassDecl> {\n        let start = self.current_pos();\n        self.expect(&Token::Class)?;\n\n        let name = if let Some(Token::Ident(name)) = self.current_token().cloned() {\n            self.advance();\n            name\n        } else {\n            return Err(self.unexpected_token(\"class name\"));\n        };\n\n        // Optional parent class\n        let parent = if self.match_token(&Token::Colon) {\n            Some(self.parse_qualified_name()?)\n        } else {\n            None\n        };\n\n        self.expect(&Token::LBrace)?;\n\n        let mut members = Vec::new();\n        while !self.check(&Token::RBrace) && !self.is_at_end() {\n            members.push(self.parse_class_member()?);\n        }\n\n        self.expect(&Token::RBrace)?;\n\n        Ok(ClassDecl {\n            modifiers,\n            name,\n            parent,\n            members,\n            span: self.span_from(start),\n        })\n    }\n\n    fn parse_class_member(&mut self) -> ParseResult<ClassMember> {\n        let modifiers = self.parse_modifiers();\n\n        match self.current_token() {\n            Some(Token::Var) => self.parse_var_decl(modifiers).map(ClassMember::Var),\n            Some(Token::Func) => self.parse_func_decl(modifiers).map(ClassMember::Func),\n            Some(Token::Rule) => self.parse_rule_decl().map(ClassMember::Rule),\n            _ => {\n                // OFML allows expression statements at class level (e.g., hash initialization)\n                if !modifiers.is_empty() {\n                    return Err(ParseError::InvalidSyntax {\n                        message: \"Unexpected modifiers on expression\".to_string(),\n                        pos: self.current_pos(),\n                    });\n                }\n                let expr = self.parse_expr()?;\n                self.expect(&Token::Semi)?;\n                Ok(ClassMember::Expr(expr))\n            }\n        }\n    }\n\n    fn parse_func_decl(&mut self, modifiers: Vec<Modifier>) -> ParseResult<FuncDecl> {\n        let start = self.current_pos();\n        self.expect(&Token::Func)?;\n\n        let name = if let Some(Token::Ident(name)) = self.current_token().cloned() {\n            self.advance();\n            name\n        } else {\n            return Err(self.unexpected_token(\"function name\"));\n        };\n\n        self.expect(&Token::LParen)?;\n\n        let (params, variadic) = self.parse_param_list()?;\n\n        self.expect(&Token::RParen)?;\n\n        // Native functions have no body\n        let body = if modifiers.contains(&Modifier::Native) || self.check(&Token::Semi) {\n            if self.check(&Token::Semi) {\n                self.advance();\n            }\n            None\n        } else {\n            Some(self.parse_block()?)\n        };\n\n        Ok(FuncDecl {\n            modifiers,\n            name,\n            params,\n            variadic,\n            body,\n            span: self.span_from(start),\n        })\n    }\n\n    fn parse_rule_decl(&mut self) -> ParseResult<RuleDecl> {\n        let start = self.current_pos();\n        self.expect(&Token::Rule)?;\n\n        let name = if let Some(Token::Ident(name)) = self.current_token().cloned() {\n            self.advance();\n            name\n        } else {\n            return Err(self.unexpected_token(\"rule name\"));\n        };\n\n        self.expect(&Token::LParen)?;\n        let (params, _) = self.parse_param_list()?;\n        self.expect(&Token::RParen)?;\n\n        let body = self.parse_block()?;\n\n        Ok(RuleDecl {\n            name,\n            params,\n            body,\n            span: self.span_from(start),\n        })\n    }\n\n    fn parse_param_list(&mut self) -> ParseResult<(Vec<String>, bool)> {\n        let mut params = Vec::new();\n        let mut variadic = false;\n\n        if !self.check(&Token::RParen) {\n            // First parameter\n            if let Some(Token::Ident(name)) = self.current_token().cloned() {\n                self.advance();\n                params.push(name);\n            } else {\n                return Err(self.unexpected_token(\"parameter name\"));\n            }\n\n            // Additional parameters\n            while self.match_token(&Token::Comma) {\n                if self.match_token(&Token::Ellipsis) {\n                    variadic = true;\n                    break;\n                }\n                if let Some(Token::Ident(name)) = self.current_token().cloned() {\n                    self.advance();\n                    params.push(name);\n                } else {\n                    return Err(self.unexpected_token(\"parameter name\"));\n                }\n            }\n        }\n\n        Ok((params, variadic))\n    }\n\n    fn parse_block(&mut self) -> ParseResult<Block> {\n        let start = self.current_pos();\n        self.expect(&Token::LBrace)?;\n\n        let mut stmts = Vec::new();\n        while !self.check(&Token::RBrace) && !self.is_at_end() {\n            stmts.push(self.parse_stmt()?);\n        }\n\n        self.expect(&Token::RBrace)?;\n\n        Ok(Block {\n            stmts,\n            span: self.span_from(start),\n        })\n    }\n\n    fn parse_if_stmt(&mut self) -> ParseResult<Stmt> {\n        let start = self.current_pos();\n        self.expect(&Token::If)?;\n        self.expect(&Token::LParen)?;\n        let condition = self.parse_expr()?;\n        self.expect(&Token::RParen)?;\n\n        let then_branch = Box::new(self.parse_stmt()?);\n\n        let else_branch = if self.match_token(&Token::Else) {\n            Some(Box::new(self.parse_stmt()?))\n        } else {\n            None\n        };\n\n        Ok(Stmt::If(IfStmt {\n            condition,\n            then_branch,\n            else_branch,\n            span: self.span_from(start),\n        }))\n    }\n\n    fn parse_switch_stmt(&mut self) -> ParseResult<Stmt> {\n        let start = self.current_pos();\n        self.expect(&Token::Switch)?;\n        self.expect(&Token::LParen)?;\n        let expr = self.parse_expr()?;\n        self.expect(&Token::RParen)?;\n        self.expect(&Token::LBrace)?;\n\n        let mut cases = Vec::new();\n        while !self.check(&Token::RBrace) && !self.is_at_end() {\n            let value = if self.match_token(&Token::Case) {\n                let v = Some(self.parse_expr()?);\n                self.expect(&Token::Colon)?;\n                v\n            } else if self.match_token(&Token::Default) {\n                self.expect(&Token::Colon)?;\n                None\n            } else {\n                return Err(self.unexpected_token(\"case or default\"));\n            };\n\n            let mut stmts = Vec::new();\n            while !self.check(&Token::Case)\n                && !self.check(&Token::Default)\n                && !self.check(&Token::RBrace)\n                && !self.is_at_end()\n            {\n                stmts.push(self.parse_stmt()?);\n            }\n\n            cases.push(SwitchCase { value, stmts });\n        }\n\n        self.expect(&Token::RBrace)?;\n\n        Ok(Stmt::Switch(SwitchStmt {\n            label: None,\n            expr,\n            cases,\n            span: self.span_from(start),\n        }))\n    }\n\n    fn parse_while_stmt(&mut self) -> ParseResult<Stmt> {\n        let start = self.current_pos();\n        self.expect(&Token::While)?;\n        self.expect(&Token::LParen)?;\n        let condition = self.parse_expr()?;\n        self.expect(&Token::RParen)?;\n        let body = Box::new(self.parse_stmt()?);\n\n        Ok(Stmt::While(WhileStmt {\n            label: None,\n            condition,\n            body,\n            span: self.span_from(start),\n        }))\n    }\n\n    fn parse_do_while_stmt(&mut self) -> ParseResult<Stmt> {\n        let start = self.current_pos();\n        self.expect(&Token::Do)?;\n        let body = Box::new(self.parse_stmt()?);\n        self.expect(&Token::While)?;\n        self.expect(&Token::LParen)?;\n        let condition = self.parse_expr()?;\n        self.expect(&Token::RParen)?;\n        self.expect(&Token::Semi)?;\n\n        Ok(Stmt::DoWhile(DoWhileStmt {\n            label: None,\n            body,\n            condition,\n            span: self.span_from(start),\n        }))\n    }\n\n    fn parse_for_stmt(&mut self) -> ParseResult<Stmt> {\n        let start = self.current_pos();\n        self.expect(&Token::For)?;\n        self.expect(&Token::LParen)?;\n\n        // Init\n        let init = if self.check(&Token::Semi) {\n            self.advance();\n            None\n        } else if self.check(&Token::Var) {\n            let stmt = self.parse_var_decl(vec![])?;\n            Some(Box::new(Stmt::Var(stmt)))\n        } else {\n            let expr = self.parse_expr()?;\n            self.expect(&Token::Semi)?;\n            Some(Box::new(Stmt::Expr(expr)))\n        };\n\n        // Condition\n        let condition = if self.check(&Token::Semi) {\n            None\n        } else {\n            Some(self.parse_expr()?)\n        };\n        self.expect(&Token::Semi)?;\n\n        // Update\n        let update = if self.check(&Token::RParen) {\n            None\n        } else {\n            Some(self.parse_expr()?)\n        };\n        self.expect(&Token::RParen)?;\n\n        let body = Box::new(self.parse_stmt()?);\n\n        Ok(Stmt::For(ForStmt {\n            label: None,\n            init,\n            condition,\n            update,\n            body,\n            span: self.span_from(start),\n        }))\n    }\n\n    fn parse_foreach_stmt(&mut self) -> ParseResult<Stmt> {\n        let start = self.current_pos();\n        self.expect(&Token::Foreach)?;\n        self.expect(&Token::LParen)?;\n\n        let var_name = if let Some(Token::Ident(name)) = self.current_token().cloned() {\n            self.advance();\n            name\n        } else {\n            return Err(self.unexpected_token(\"variable name\"));\n        };\n\n        self.expect(&Token::Semi)?;\n        let iterable = self.parse_expr()?;\n        self.expect(&Token::RParen)?;\n\n        let body = Box::new(self.parse_stmt()?);\n\n        Ok(Stmt::Foreach(ForeachStmt {\n            label: None,\n            var_name,\n            iterable,\n            body,\n            span: self.span_from(start),\n        }))\n    }\n\n    fn parse_return_stmt(&mut self) -> ParseResult<Stmt> {\n        self.expect(&Token::Return)?;\n\n        // return; or return expr;\n        // Note: return(expr) is handled as return followed by a parenthesized expression,\n        // which allows for cases like return (a + b) + c;\n        let value = if self.check(&Token::Semi) || self.is_at_end() {\n            None\n        } else {\n            Some(self.parse_expr()?)\n        };\n\n        self.expect(&Token::Semi)?;\n        Ok(Stmt::Return(value))\n    }\n\n    fn parse_break_stmt(&mut self) -> ParseResult<Stmt> {\n        self.expect(&Token::Break)?;\n        let label = if let Some(Token::Ident(name)) = self.current_token().cloned() {\n            self.advance();\n            Some(name)\n        } else {\n            None\n        };\n        self.expect(&Token::Semi)?;\n        Ok(Stmt::Break(label))\n    }\n\n    fn parse_continue_stmt(&mut self) -> ParseResult<Stmt> {\n        self.expect(&Token::Continue)?;\n        let label = if let Some(Token::Ident(name)) = self.current_token().cloned() {\n            self.advance();\n            Some(name)\n        } else {\n            None\n        };\n        self.expect(&Token::Semi)?;\n        Ok(Stmt::Continue(label))\n    }\n\n    fn parse_throw_stmt(&mut self) -> ParseResult<Stmt> {\n        self.expect(&Token::Throw)?;\n        let expr = self.parse_expr()?;\n        self.expect(&Token::Semi)?;\n        Ok(Stmt::Throw(expr))\n    }\n\n    fn parse_try_stmt(&mut self) -> ParseResult<Stmt> {\n        let start = self.current_pos();\n        self.expect(&Token::Try)?;\n        let try_block = self.parse_block()?;\n\n        let (catch_var, catch_block) = if self.match_token(&Token::Catch) {\n            self.expect(&Token::LParen)?;\n\n            // Optional & for reference parameter\n            let _is_ref = self.match_token(&Token::Amp);\n\n            // Variable name\n            let var = if let Some(Token::Ident(name)) = self.current_token().cloned() {\n                self.advance();\n                Some(name)\n            } else {\n                None\n            };\n\n            // Optional : Type annotation\n            if self.match_token(&Token::Colon) {\n                // Skip the type name (can be qualified)\n                if self.check(&Token::ColonColon)\n                    || matches!(self.current_token(), Some(Token::Ident(_)))\n                {\n                    let _ = self.parse_qualified_name();\n                }\n            }\n\n            self.expect(&Token::RParen)?;\n            (var, Some(self.parse_block()?))\n        } else {\n            (None, None)\n        };\n\n        let finally_block = if self.match_token(&Token::Finally) {\n            Some(self.parse_block()?)\n        } else {\n            None\n        };\n\n        Ok(Stmt::Try(TryStmt {\n            try_block,\n            catch_var,\n            catch_block,\n            finally_block,\n            span: self.span_from(start),\n        }))\n    }\n\n    fn parse_expr_stmt(&mut self) -> ParseResult<Stmt> {\n        let expr = self.parse_expr()?;\n        self.expect(&Token::Semi)?;\n        Ok(Stmt::Expr(expr))\n    }\n\n    // ============================================================\n    // Expressions (Operator Precedence Parsing)\n    // ============================================================\n\n    fn parse_expr(&mut self) -> ParseResult<Expr> {\n        self.parse_assignment()\n    }\n\n    fn parse_assignment(&mut self) -> ParseResult<Expr> {\n        let expr = self.parse_conditional()?;\n\n        if let Some(op) = self.match_assign_op() {\n            let value = self.parse_assignment()?;\n            return Ok(Expr::Assign(AssignExpr {\n                target: Box::new(expr),\n                op,\n                value: Box::new(value),\n            }));\n        }\n\n        Ok(expr)\n    }\n\n    fn match_assign_op(&mut self) -> Option<AssignOp> {\n        let op = match self.current_token() {\n            Some(Token::Eq) => AssignOp::Assign,\n            Some(Token::PlusEq) => AssignOp::AddAssign,\n            Some(Token::MinusEq) => AssignOp::SubAssign,\n            Some(Token::StarEq) => AssignOp::MulAssign,\n            Some(Token::SlashEq) => AssignOp::DivAssign,\n            Some(Token::PercentEq) => AssignOp::ModAssign,\n            Some(Token::LtLtEq) => AssignOp::ShlAssign,\n            Some(Token::GtGtEq) => AssignOp::ShrAssign,\n            Some(Token::GtGtGtEq) => AssignOp::UshrAssign,\n            Some(Token::AmpEq) => AssignOp::BitAndAssign,\n            Some(Token::PipeEq) => AssignOp::BitOrAssign,\n            Some(Token::CaretEq) => AssignOp::BitXorAssign,\n            _ => return None,\n        };\n        self.advance();\n        Some(op)\n    }\n\n    fn parse_conditional(&mut self) -> ParseResult<Expr> {\n        let expr = self.parse_logical_or()?;\n\n        if self.match_token(&Token::Question) {\n            let then_expr = self.parse_expr()?;\n            self.expect(&Token::Colon)?;\n            let else_expr = self.parse_conditional()?;\n            return Ok(Expr::Conditional(ConditionalExpr {\n                condition: Box::new(expr),\n                then_expr: Box::new(then_expr),\n                else_expr: Box::new(else_expr),\n            }));\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_logical_or(&mut self) -> ParseResult<Expr> {\n        let mut left = self.parse_logical_and()?;\n\n        while self.match_token(&Token::PipePipe) {\n            let right = self.parse_logical_and()?;\n            left = Expr::Binary(BinaryExpr {\n                left: Box::new(left),\n                op: BinaryOp::Or,\n                right: Box::new(right),\n            });\n        }\n\n        Ok(left)\n    }\n\n    fn parse_logical_and(&mut self) -> ParseResult<Expr> {\n        let mut left = self.parse_bitwise_or()?;\n\n        while self.match_token(&Token::AmpAmp) {\n            let right = self.parse_bitwise_or()?;\n            left = Expr::Binary(BinaryExpr {\n                left: Box::new(left),\n                op: BinaryOp::And,\n                right: Box::new(right),\n            });\n        }\n\n        Ok(left)\n    }\n\n    fn parse_bitwise_or(&mut self) -> ParseResult<Expr> {\n        let mut left = self.parse_bitwise_xor()?;\n\n        while self.match_token(&Token::Pipe) {\n            let right = self.parse_bitwise_xor()?;\n            left = Expr::Binary(BinaryExpr {\n                left: Box::new(left),\n                op: BinaryOp::BitOr,\n                right: Box::new(right),\n            });\n        }\n\n        Ok(left)\n    }\n\n    fn parse_bitwise_xor(&mut self) -> ParseResult<Expr> {\n        let mut left = self.parse_bitwise_and()?;\n\n        while self.match_token(&Token::Caret) {\n            let right = self.parse_bitwise_and()?;\n            left = Expr::Binary(BinaryExpr {\n                left: Box::new(left),\n                op: BinaryOp::BitXor,\n                right: Box::new(right),\n            });\n        }\n\n        Ok(left)\n    }\n\n    fn parse_bitwise_and(&mut self) -> ParseResult<Expr> {\n        let mut left = self.parse_minmax()?;\n\n        while self.match_token(&Token::Amp) {\n            let right = self.parse_minmax()?;\n            left = Expr::Binary(BinaryExpr {\n                left: Box::new(left),\n                op: BinaryOp::BitAnd,\n                right: Box::new(right),\n            });\n        }\n\n        Ok(left)\n    }\n\n    fn parse_minmax(&mut self) -> ParseResult<Expr> {\n        let mut left = self.parse_equality()?;\n\n        loop {\n            let op = if self.match_token(&Token::LtQuestion) {\n                BinaryOp::Min\n            } else if self.match_token(&Token::GtQuestion) {\n                BinaryOp::Max\n            } else {\n                break;\n            };\n\n            let right = self.parse_equality()?;\n            left = Expr::Binary(BinaryExpr {\n                left: Box::new(left),\n                op,\n                right: Box::new(right),\n            });\n        }\n\n        Ok(left)\n    }\n\n    fn parse_equality(&mut self) -> ParseResult<Expr> {\n        let mut left = self.parse_comparison()?;\n\n        loop {\n            let op = if self.match_token(&Token::EqEq) {\n                BinaryOp::Eq\n            } else if self.match_token(&Token::BangEq) {\n                BinaryOp::Ne\n            } else if self.match_token(&Token::TildeEq) {\n                BinaryOp::PatternMatch\n            } else {\n                break;\n            };\n\n            let right = self.parse_comparison()?;\n            left = Expr::Binary(BinaryExpr {\n                left: Box::new(left),\n                op,\n                right: Box::new(right),\n            });\n        }\n\n        Ok(left)\n    }\n\n    fn parse_comparison(&mut self) -> ParseResult<Expr> {\n        let mut left = self.parse_shift()?;\n\n        // Check for instanceof\n        if self.match_token(&Token::Instanceof) {\n            let type_name = self.parse_shift()?;\n            return Ok(Expr::Instanceof(InstanceofExpr {\n                expr: Box::new(left),\n                type_name: Box::new(type_name),\n            }));\n        }\n\n        loop {\n            let op = if self.match_token(&Token::Lt) {\n                BinaryOp::Lt\n            } else if self.match_token(&Token::LtEq) {\n                BinaryOp::Le\n            } else if self.match_token(&Token::Gt) {\n                BinaryOp::Gt\n            } else if self.match_token(&Token::GtEq) {\n                BinaryOp::Ge\n            } else {\n                break;\n            };\n\n            let right = self.parse_shift()?;\n            left = Expr::Binary(BinaryExpr {\n                left: Box::new(left),\n                op,\n                right: Box::new(right),\n            });\n        }\n\n        Ok(left)\n    }\n\n    fn parse_shift(&mut self) -> ParseResult<Expr> {\n        let mut left = self.parse_additive()?;\n\n        loop {\n            let op = if self.match_token(&Token::LtLt) {\n                BinaryOp::Shl\n            } else if self.match_token(&Token::GtGt) {\n                BinaryOp::Shr\n            } else if self.match_token(&Token::GtGtGt) {\n                BinaryOp::Ushr\n            } else {\n                break;\n            };\n\n            let right = self.parse_additive()?;\n            left = Expr::Binary(BinaryExpr {\n                left: Box::new(left),\n                op,\n                right: Box::new(right),\n            });\n        }\n\n        Ok(left)\n    }\n\n    fn parse_additive(&mut self) -> ParseResult<Expr> {\n        let mut left = self.parse_multiplicative()?;\n\n        loop {\n            let op = if self.match_token(&Token::Plus) {\n                BinaryOp::Add\n            } else if self.match_token(&Token::Minus) {\n                BinaryOp::Sub\n            } else {\n                break;\n            };\n\n            let right = self.parse_multiplicative()?;\n            left = Expr::Binary(BinaryExpr {\n                left: Box::new(left),\n                op,\n                right: Box::new(right),\n            });\n        }\n\n        Ok(left)\n    }\n\n    fn parse_multiplicative(&mut self) -> ParseResult<Expr> {\n        let mut left = self.parse_unary()?;\n\n        loop {\n            let op = if self.match_token(&Token::Star) {\n                BinaryOp::Mul\n            } else if self.match_token(&Token::Slash) {\n                BinaryOp::Div\n            } else if self.match_token(&Token::Percent) {\n                BinaryOp::Mod\n            } else {\n                break;\n            };\n\n            let right = self.parse_unary()?;\n            left = Expr::Binary(BinaryExpr {\n                left: Box::new(left),\n                op,\n                right: Box::new(right),\n            });\n        }\n\n        Ok(left)\n    }\n\n    fn parse_unary(&mut self) -> ParseResult<Expr> {\n        if self.match_token(&Token::Plus) {\n            let operand = self.parse_unary()?;\n            return Ok(Expr::Unary(UnaryExpr {\n                op: UnaryOp::Pos,\n                operand: Box::new(operand),\n            }));\n        }\n\n        if self.match_token(&Token::Minus) {\n            let operand = self.parse_unary()?;\n            return Ok(Expr::Unary(UnaryExpr {\n                op: UnaryOp::Neg,\n                operand: Box::new(operand),\n            }));\n        }\n\n        if self.match_token(&Token::Bang) {\n            let operand = self.parse_unary()?;\n            return Ok(Expr::Unary(UnaryExpr {\n                op: UnaryOp::Not,\n                operand: Box::new(operand),\n            }));\n        }\n\n        if self.match_token(&Token::BangBang) {\n            let operand = self.parse_unary()?;\n            return Ok(Expr::Unary(UnaryExpr {\n                op: UnaryOp::Test,\n                operand: Box::new(operand),\n            }));\n        }\n\n        if self.match_token(&Token::Tilde) {\n            let operand = self.parse_unary()?;\n            return Ok(Expr::Unary(UnaryExpr {\n                op: UnaryOp::BitNot,\n                operand: Box::new(operand),\n            }));\n        }\n\n        if self.match_token(&Token::Dollar) {\n            let operand = self.parse_unary()?;\n            return Ok(Expr::Unary(UnaryExpr {\n                op: UnaryOp::Resolve,\n                operand: Box::new(operand),\n            }));\n        }\n\n        if self.match_token(&Token::PlusPlus) {\n            let operand = self.parse_unary()?;\n            return Ok(Expr::Unary(UnaryExpr {\n                op: UnaryOp::PreInc,\n                operand: Box::new(operand),\n            }));\n        }\n\n        if self.match_token(&Token::MinusMinus) {\n            let operand = self.parse_unary()?;\n            return Ok(Expr::Unary(UnaryExpr {\n                op: UnaryOp::PreDec,\n                operand: Box::new(operand),\n            }));\n        }\n\n        self.parse_postfix()\n    }\n\n    fn parse_postfix(&mut self) -> ParseResult<Expr> {\n        let mut expr = self.parse_primary()?;\n\n        loop {\n            if self.match_token(&Token::LParen) {\n                // Function call\n                let args = self.parse_arg_list()?;\n                self.expect(&Token::RParen)?;\n                expr = Expr::Call(CallExpr {\n                    callee: Box::new(expr),\n                    args,\n                });\n            } else if self.match_token(&Token::LBracket) {\n                // Index or range access\n                if self.check(&Token::Colon) {\n                    // Range from start\n                    self.advance();\n                    let end = if self.check(&Token::RBracket) {\n                        None\n                    } else {\n                        Some(Box::new(self.parse_expr()?))\n                    };\n                    self.expect(&Token::RBracket)?;\n                    expr = Expr::Range(RangeExpr {\n                        object: Box::new(expr),\n                        start: None,\n                        end,\n                    });\n                } else {\n                    let index = self.parse_expr()?;\n                    if self.match_token(&Token::Colon) {\n                        // Range with start\n                        let end = if self.check(&Token::RBracket) {\n                            None\n                        } else {\n                            Some(Box::new(self.parse_expr()?))\n                        };\n                        self.expect(&Token::RBracket)?;\n                        expr = Expr::Range(RangeExpr {\n                            object: Box::new(expr),\n                            start: Some(Box::new(index)),\n                            end,\n                        });\n                    } else {\n                        // Simple index\n                        self.expect(&Token::RBracket)?;\n                        expr = Expr::Index(IndexExpr {\n                            object: Box::new(expr),\n                            index: Box::new(index),\n                        });\n                    }\n                }\n            } else if self.match_token(&Token::Dot) {\n                // Member access\n                let member = if let Some(Token::Ident(name)) = self.current_token().cloned() {\n                    self.advance();\n                    name\n                } else {\n                    return Err(self.unexpected_token(\"member name\"));\n                };\n                expr = Expr::Member(MemberExpr {\n                    object: Box::new(expr),\n                    member,\n                });\n            } else if self.match_token(&Token::PlusPlus) {\n                expr = Expr::Unary(UnaryExpr {\n                    op: UnaryOp::PostInc,\n                    operand: Box::new(expr),\n                });\n            } else if self.match_token(&Token::MinusMinus) {\n                expr = Expr::Unary(UnaryExpr {\n                    op: UnaryOp::PostDec,\n                    operand: Box::new(expr),\n                });\n            } else {\n                break;\n            }\n        }\n\n        Ok(expr)\n    }\n\n    fn parse_arg_list(&mut self) -> ParseResult<Vec<Expr>> {\n        self.parse_expr_list(&Token::RParen)\n    }\n\n    fn parse_expr_list(&mut self, terminator: &Token) -> ParseResult<Vec<Expr>> {\n        let mut args = Vec::new();\n\n        if !self.check(terminator) {\n            args.push(self.parse_expr()?);\n            while self.match_token(&Token::Comma) {\n                args.push(self.parse_expr()?);\n            }\n        }\n\n        Ok(args)\n    }\n\n    fn parse_primary(&mut self) -> ParseResult<Expr> {\n        // Literals\n        if let Some(Token::DecInt(n)) = self.current_token().cloned() {\n            self.advance();\n            return Ok(Expr::Int(n));\n        }\n        if let Some(Token::HexInt(n)) = self.current_token().cloned() {\n            self.advance();\n            return Ok(Expr::Int(n));\n        }\n        if let Some(Token::OctInt(n)) = self.current_token().cloned() {\n            self.advance();\n            return Ok(Expr::Int(n));\n        }\n        if let Some(Token::Zero(n)) = self.current_token().cloned() {\n            self.advance();\n            return Ok(Expr::Int(n));\n        }\n        if let Some(Token::CharLit(n)) = self.current_token().cloned() {\n            self.advance();\n            return Ok(Expr::Int(n));\n        }\n        if let Some(Token::Float(f)) = self.current_token().cloned() {\n            self.advance();\n            return Ok(Expr::Float(f));\n        }\n        if let Some(Token::StringLit(s)) = self.current_token().cloned() {\n            self.advance();\n            return Ok(Expr::String(s));\n        }\n        if let Some(Token::Symbol(s)) = self.current_token().cloned() {\n            self.advance();\n            return Ok(Expr::Symbol(s));\n        }\n\n        // Keywords\n        if self.match_token(&Token::Null) {\n            return Ok(Expr::Null);\n        }\n        if self.match_token(&Token::SelfKw) {\n            return Ok(Expr::SelfRef);\n        }\n        if self.match_token(&Token::Super) {\n            return Ok(Expr::SuperRef);\n        }\n\n        // Array literal: [a, b, c] or []\n        if self.match_token(&Token::LBracket) {\n            let elements = self.parse_expr_list(&Token::RBracket)?;\n            self.expect(&Token::RBracket)?;\n            return Ok(Expr::Array(elements));\n        }\n\n        // List literal: @(a, b, c)\n        if self.match_token(&Token::AtLParen) {\n            let elements = self.parse_arg_list()?;\n            self.expect(&Token::RParen)?;\n            return Ok(Expr::List(elements));\n        }\n\n        // Parenthesized expression\n        if self.match_token(&Token::LParen) {\n            let expr = self.parse_expr()?;\n            self.expect(&Token::RParen)?;\n            return Ok(Expr::Paren(Box::new(expr)));\n        }\n\n        // Qualified name starting with ::\n        if self.check(&Token::ColonColon) {\n            let name = self.parse_qualified_name()?;\n            return Ok(Expr::QualifiedName(name));\n        }\n\n        // Identifier or qualified name\n        if let Some(Token::Ident(name)) = self.current_token().cloned() {\n            self.advance();\n\n            // Check if it's a qualified name\n            if self.check(&Token::ColonColon) {\n                // Need to reconstruct as qualified name\n                let mut parts = vec![name];\n                while self.match_token(&Token::ColonColon) {\n                    if let Some(Token::Ident(part)) = self.current_token().cloned() {\n                        self.advance();\n                        parts.push(part);\n                    } else {\n                        break;\n                    }\n                }\n                return Ok(Expr::QualifiedName(QualifiedName {\n                    absolute: false,\n                    parts,\n                    span: Span::default(),\n                }));\n            }\n\n            return Ok(Expr::Ident(name));\n        }\n\n        Err(self.unexpected_token(\"expression\"))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn parse(source: &str) -> ParseResult<TranslationUnit> {\n        let mut parser = Parser::new(source)?;\n        parser.parse()\n    }\n\n    #[test]\n    fn test_package_decl() {\n        let unit = parse(\"package ::vitra::workit;\").unwrap();\n        let pkg = unit.package.unwrap();\n        assert!(pkg.absolute);\n        assert_eq!(pkg.parts, vec![\"vitra\", \"workit\"]);\n    }\n\n    #[test]\n    fn test_import_decl() {\n        let unit = parse(\"import ::ofml::oi::*;\").unwrap();\n        assert_eq!(unit.imports.len(), 1);\n        assert!(unit.imports[0].wildcard);\n        assert_eq!(unit.imports[0].path.parts, vec![\"ofml\", \"oi\"]);\n    }\n\n    #[test]\n    fn test_var_decl() {\n        let unit = parse(\"var x = 42;\").unwrap();\n        assert_eq!(unit.statements.len(), 1);\n        if let Stmt::Var(v) = &unit.statements[0] {\n            assert_eq!(v.name, \"x\");\n            assert!(matches!(v.initializer, Some(Expr::Int(42))));\n        } else {\n            panic!(\"Expected var declaration\");\n        }\n    }\n\n    #[test]\n    fn test_class_decl() {\n        let source = r#\"\n            public class MyClass: ParentClass {\n                var x = 1;\n                public func test() { }\n            }\n        \"#;\n        let unit = parse(source).unwrap();\n        if let Stmt::Class(c) = &unit.statements[0] {\n            assert_eq!(c.name, \"MyClass\");\n            assert!(c.parent.is_some());\n            assert_eq!(c.members.len(), 2);\n        } else {\n            panic!(\"Expected class declaration\");\n        }\n    }\n\n    #[test]\n    fn test_func_decl() {\n        let source = \"func add(a, b) { return(a + b); }\";\n        let unit = parse(source).unwrap();\n        if let Stmt::Func(f) = &unit.statements[0] {\n            assert_eq!(f.name, \"add\");\n            assert_eq!(f.params, vec![\"a\", \"b\"]);\n        } else {\n            panic!(\"Expected function declaration\");\n        }\n    }\n\n    #[test]\n    fn test_if_stmt() {\n        let source = \"if (x > 0) { y = 1; } else { y = 0; }\";\n        let unit = parse(source).unwrap();\n        assert!(matches!(unit.statements[0], Stmt::If(_)));\n    }\n\n    #[test]\n    fn test_while_stmt() {\n        let source = \"while (x > 0) { x = x - 1; }\";\n        let unit = parse(source).unwrap();\n        assert!(matches!(unit.statements[0], Stmt::While(_)));\n    }\n\n    #[test]\n    fn test_foreach_stmt() {\n        let source = \"foreach (item; items) { process(item); }\";\n        let unit = parse(source).unwrap();\n        assert!(matches!(unit.statements[0], Stmt::Foreach(_)));\n    }\n\n    #[test]\n    fn test_expressions() {\n        let source = \"var x = 1 + 2 * 3;\";\n        let unit = parse(source).unwrap();\n        if let Stmt::Var(v) = &unit.statements[0] {\n            // Should be 1 + (2 * 3) due to precedence\n            assert!(matches!(v.initializer, Some(Expr::Binary(_))));\n        }\n    }\n\n    #[test]\n    fn test_method_call() {\n        let source = \"obj.method(arg1, arg2);\";\n        let unit = parse(source).unwrap();\n        if let Stmt::Expr(Expr::Call(c)) = &unit.statements[0] {\n            assert!(matches!(c.callee.as_ref(), Expr::Member(_)));\n            assert_eq!(c.args.len(), 2);\n        } else {\n            panic!(\"Expected method call\");\n        }\n    }\n\n    #[test]\n    fn test_array_literal() {\n        let source = \"var arr = [1, 2, 3];\";\n        let unit = parse(source).unwrap();\n        if let Stmt::Var(v) = &unit.statements[0] {\n            if let Some(Expr::Array(elements)) = &v.initializer {\n                assert_eq!(elements.len(), 3);\n            } else {\n                panic!(\"Expected array literal\");\n            }\n        }\n    }\n\n    #[test]\n    fn test_real_cls_code() {\n        let source = r#\"\n            package ::vitra::workit;\n            import ::ofml::oi::*;\n\n            public class WkPlGroupSingle: WkPlGroup\n            {\n                var sAddTables = Hash();\n\n                public func initialize(pFa, pNa)\n                {\n                    WkPlGroup::initialize(pFa, pNa);\n                }\n\n                public func addTable(pWidth)\n                {\n                    var tRefObj = lastObj();\n                    tRefObj.setPropValue(@GWK_ANBAU, \"1\");\n\n                    if (tEl != NULL) {\n                        tRefObj.setPropValue(@GWK_ANBAU, \"1\");\n                    } else {\n                        tRefObj.setPropValue(@GWK_ANBAU, \"0\");\n                    }\n                }\n            }\n        \"#;\n        let result = parse(source);\n        assert!(result.is_ok(), \"Failed to parse: {:?}\", result.err());\n    }\n\n    #[test]\n    fn test_var_decl_list() {\n        // Test single declaration\n        let source = \"var x = 1;\";\n        let result = parse(source).expect(\"Should parse single var\");\n        assert_eq!(result.statements.len(), 1);\n        match &result.statements[0] {\n            Stmt::Var(decl) => assert_eq!(decl.name, \"x\"),\n            _ => panic!(\"Expected Stmt::Var\"),\n        }\n\n        // Test multiple declarations\n        let source = \"var a, b = 2, c;\";\n        let result = parse(source).expect(\"Should parse var list\");\n        assert_eq!(result.statements.len(), 1);\n        match &result.statements[0] {\n            Stmt::VarList(decls) => {\n                assert_eq!(decls.len(), 3);\n                assert_eq!(decls[0].name, \"a\");\n                assert!(decls[0].initializer.is_none());\n                assert_eq!(decls[1].name, \"b\");\n                assert!(decls[1].initializer.is_some());\n                assert_eq!(decls[2].name, \"c\");\n                assert!(decls[2].initializer.is_none());\n            }\n            _ => panic!(\"Expected Stmt::VarList\"),\n        }\n\n        // Test two declarations\n        let source = \"var x = 1, y = 2;\";\n        let result = parse(source).expect(\"Should parse two vars\");\n        assert_eq!(result.statements.len(), 1);\n        match &result.statements[0] {\n            Stmt::VarList(decls) => {\n                assert_eq!(decls.len(), 2);\n                assert_eq!(decls[0].name, \"x\");\n                assert_eq!(decls[1].name, \"y\");\n            }\n            _ => panic!(\"Expected Stmt::VarList\"),\n        }\n    }\n\n    #[test]\n    fn test_return_with_complex_expression() {\n        // Test return with parenthesized expression followed by more operators\n        // This was a regression where return(expr) was parsed specially and broke\n        // expressions like return (a + b) + c;\n        let source = \"func test() { return (1 + 2) + 3; }\";\n        let result = parse(source).expect(\"Should parse return with complex expression\");\n        assert_eq!(result.statements.len(), 1);\n\n        // Test return with nested parentheses\n        let source = \"func test() { return ((a + b) * c) + d; }\";\n        let result = parse(source).expect(\"Should parse return with nested parentheses\");\n        assert_eq!(result.statements.len(), 1);\n\n        // Test return with simple parenthesized expression (should still work)\n        let source = \"func test() { return (x); }\";\n        let result = parse(source).expect(\"Should parse return with simple parentheses\");\n        assert_eq!(result.statements.len(), 1);\n\n        // Test return without parentheses\n        let source = \"func test() { return x + 1; }\";\n        let result = parse(source).expect(\"Should parse return without parentheses\");\n        assert_eq!(result.statements.len(), 1);\n\n        // Test empty return\n        let source = \"func test() { return; }\";\n        let result = parse(source).expect(\"Should parse empty return\");\n        assert_eq!(result.statements.len(), 1);\n    }\n\n    #[test]\n    fn test_parse_error_display() {\n        let lex_err = ParseError::Lex(LexError {\n            span: 5..6,\n            slice: \"?\".to_string(),\n        });\n        let lex_str = format!(\"{}\", lex_err);\n        assert!(lex_str.contains(\"Lexer error\"));\n\n        let unexpected_err = ParseError::UnexpectedToken {\n            found: \"foo\".to_string(),\n            expected: \"bar\".to_string(),\n            pos: 10,\n        };\n        let unexpected_str = format!(\"{}\", unexpected_err);\n        assert!(unexpected_str.contains(\"foo\"));\n        assert!(unexpected_str.contains(\"bar\"));\n        assert!(unexpected_str.contains(\"10\"));\n\n        let eof_err = ParseError::UnexpectedEof {\n            expected: \"semicolon\".to_string(),\n        };\n        let eof_str = format!(\"{}\", eof_err);\n        assert!(eof_str.contains(\"semicolon\"));\n\n        let syntax_err = ParseError::InvalidSyntax {\n            message: \"bad syntax\".to_string(),\n            pos: 20,\n        };\n        let syntax_str = format!(\"{}\", syntax_err);\n        assert!(syntax_str.contains(\"bad syntax\"));\n    }\n\n    #[test]\n    fn test_parse_error_debug() {\n        let err = ParseError::UnexpectedEof {\n            expected: \"test\".to_string(),\n        };\n        let debug_str = format!(\"{:?}\", err);\n        assert!(debug_str.contains(\"UnexpectedEof\"));\n    }\n\n    #[test]\n    fn test_empty_input() {\n        let unit = parse(\"\").unwrap();\n        assert!(unit.package.is_none());\n        assert!(unit.imports.is_empty());\n        assert!(unit.statements.is_empty());\n    }\n\n    #[test]\n    fn test_empty_statement() {\n        let unit = parse(\";\").unwrap();\n        assert_eq!(unit.statements.len(), 1);\n        assert!(matches!(unit.statements[0], Stmt::Empty));\n    }\n\n    #[test]\n    fn test_multiple_imports() {\n        let source = r#\"\n            import foo::bar;\n            import baz::qux::*;\n        \"#;\n        let unit = parse(source).unwrap();\n        assert_eq!(unit.imports.len(), 2);\n        assert!(!unit.imports[0].wildcard);\n        assert!(unit.imports[1].wildcard);\n    }\n\n    #[test]\n    fn test_modifiers() {\n        let source = r#\"\n            public static final var x = 1;\n            private abstract class Foo { }\n            protected native func bar();\n            transient var y;\n        \"#;\n        let unit = parse(source).unwrap();\n        assert_eq!(unit.statements.len(), 4);\n    }\n\n    #[test]\n    fn test_switch_statement() {\n        let source = r#\"\n            switch (x) {\n                case 1:\n                    y = 1;\n                    break;\n                case 2:\n                    y = 2;\n                    break;\n                default:\n                    y = 0;\n            }\n        \"#;\n        let unit = parse(source).unwrap();\n        if let Stmt::Switch(s) = &unit.statements[0] {\n            assert_eq!(s.cases.len(), 3);\n        } else {\n            panic!(\"Expected switch statement\");\n        }\n    }\n\n    #[test]\n    fn test_do_while_statement() {\n        let source = \"do { x = x + 1; } while (x < 10);\";\n        let unit = parse(source).unwrap();\n        assert!(matches!(unit.statements[0], Stmt::DoWhile(_)));\n    }\n\n    #[test]\n    fn test_for_statement() {\n        let source = \"for (var i = 0; i < 10; i++) { }\";\n        let unit = parse(source).unwrap();\n        if let Stmt::For(f) = &unit.statements[0] {\n            assert!(f.init.is_some());\n            assert!(f.condition.is_some());\n            assert!(f.update.is_some());\n        } else {\n            panic!(\"Expected for statement\");\n        }\n    }\n\n    #[test]\n    fn test_for_statement_empty_parts() {\n        let source = \"for (;;) { }\";\n        let unit = parse(source).unwrap();\n        if let Stmt::For(f) = &unit.statements[0] {\n            assert!(f.init.is_none());\n            assert!(f.condition.is_none());\n            assert!(f.update.is_none());\n        } else {\n            panic!(\"Expected for statement\");\n        }\n    }\n\n    #[test]\n    fn test_for_statement_expr_init() {\n        let source = \"for (i = 0; i < 10; i++) { }\";\n        let unit = parse(source).unwrap();\n        if let Stmt::For(f) = &unit.statements[0] {\n            assert!(matches!(f.init.as_deref(), Some(Stmt::Expr(_))));\n        } else {\n            panic!(\"Expected for statement\");\n        }\n    }\n\n    #[test]\n    fn test_break_continue() {\n        let source = r#\"\n            while (true) {\n                if (x) break;\n                if (y) continue;\n                break label;\n                continue label;\n            }\n        \"#;\n        let unit = parse(source).unwrap();\n        assert!(matches!(unit.statements[0], Stmt::While(_)));\n    }\n\n    #[test]\n    fn test_throw_statement() {\n        let source = \"throw error;\";\n        let unit = parse(source).unwrap();\n        assert!(matches!(unit.statements[0], Stmt::Throw(_)));\n    }\n\n    #[test]\n    fn test_try_catch_finally() {\n        let source = r#\"\n            try {\n                x = risky();\n            } catch (e) {\n                handle(e);\n            } finally {\n                cleanup();\n            }\n        \"#;\n        let unit = parse(source).unwrap();\n        if let Stmt::Try(t) = &unit.statements[0] {\n            assert!(t.catch_block.is_some());\n            assert!(t.finally_block.is_some());\n            assert!(t.catch_var.is_some());\n        } else {\n            panic!(\"Expected try statement\");\n        }\n    }\n\n    #[test]\n    fn test_try_with_typed_catch() {\n        let source = r#\"\n            try {\n                x = risky();\n            } catch (&e: ::std::Exception) {\n                handle(e);\n            }\n        \"#;\n        let unit = parse(source).unwrap();\n        assert!(matches!(unit.statements[0], Stmt::Try(_)));\n    }\n\n    #[test]\n    fn test_try_only() {\n        let source = \"try { x = 1; }\";\n        let unit = parse(source).unwrap();\n        if let Stmt::Try(t) = &unit.statements[0] {\n            assert!(t.catch_block.is_none());\n            assert!(t.finally_block.is_none());\n        } else {\n            panic!(\"Expected try statement\");\n        }\n    }\n\n    #[test]\n    fn test_block_statement() {\n        let source = \"{ var x = 1; var y = 2; }\";\n        let unit = parse(source).unwrap();\n        if let Stmt::Block(b) = &unit.statements[0] {\n            assert_eq!(b.stmts.len(), 2);\n        } else {\n            panic!(\"Expected block statement\");\n        }\n    }\n\n    #[test]\n    fn test_class_with_rule() {\n        let source = r#\"\n            class Foo {\n                rule myRule(a, b) {\n                    return a + b;\n                }\n            }\n        \"#;\n        let unit = parse(source).unwrap();\n        if let Stmt::Class(c) = &unit.statements[0] {\n            assert_eq!(c.members.len(), 1);\n            assert!(matches!(c.members[0], ClassMember::Rule(_)));\n        } else {\n            panic!(\"Expected class\");\n        }\n    }\n\n    #[test]\n    fn test_class_expr_member() {\n        let source = r#\"\n            class Foo {\n                hash[\"key\"] = value;\n            }\n        \"#;\n        let unit = parse(source).unwrap();\n        if let Stmt::Class(c) = &unit.statements[0] {\n            assert_eq!(c.members.len(), 1);\n            assert!(matches!(c.members[0], ClassMember::Expr(_)));\n        } else {\n            panic!(\"Expected class\");\n        }\n    }\n\n    #[test]\n    fn test_variadic_func() {\n        let source = \"func varargs(a, b, ...) { }\";\n        let unit = parse(source).unwrap();\n        if let Stmt::Func(f) = &unit.statements[0] {\n            assert!(f.variadic);\n            assert_eq!(f.params.len(), 2);\n        } else {\n            panic!(\"Expected function\");\n        }\n    }\n\n    #[test]\n    fn test_native_func() {\n        let source = \"native func external(x);\";\n        let unit = parse(source).unwrap();\n        if let Stmt::Func(f) = &unit.statements[0] {\n            assert!(f.modifiers.contains(&Modifier::Native));\n            assert!(f.body.is_none());\n        } else {\n            panic!(\"Expected function\");\n        }\n    }\n\n    #[test]\n    fn test_conditional_expr() {\n        let source = \"var x = a ? b : c;\";\n        let unit = parse(source).unwrap();\n        if let Stmt::Var(v) = &unit.statements[0] {\n            assert!(matches!(v.initializer, Some(Expr::Conditional(_))));\n        } else {\n            panic!(\"Expected var\");\n        }\n    }\n\n    #[test]\n    fn test_assignment_operators() {\n        let sources = [\n            \"x = 1;\",\n            \"x += 1;\",\n            \"x -= 1;\",\n            \"x *= 2;\",\n            \"x /= 2;\",\n            \"x %= 2;\",\n            \"x <<= 1;\",\n            \"x >>= 1;\",\n            \"x >>>= 1;\",\n            \"x &= 1;\",\n            \"x |= 1;\",\n            \"x ^= 1;\",\n        ];\n        for source in sources {\n            let result = parse(source);\n            assert!(result.is_ok(), \"Failed to parse: {}\", source);\n        }\n    }\n\n    #[test]\n    fn test_logical_operators() {\n        let source = \"var x = a && b || c;\";\n        let unit = parse(source).unwrap();\n        assert!(matches!(&unit.statements[0], Stmt::Var(_)));\n    }\n\n    #[test]\n    fn test_bitwise_operators() {\n        let source = \"var x = a | b ^ c & d;\";\n        let unit = parse(source).unwrap();\n        assert!(matches!(&unit.statements[0], Stmt::Var(_)));\n    }\n\n    #[test]\n    fn test_minmax_operators() {\n        let source = \"var x = a <? b >? c;\";\n        let unit = parse(source).unwrap();\n        assert!(matches!(&unit.statements[0], Stmt::Var(_)));\n    }\n\n    #[test]\n    fn test_equality_operators() {\n        let sources = [\"a == b;\", \"a != b;\", \"a ~= b;\"];\n        for source in sources {\n            let result = parse(source);\n            assert!(result.is_ok(), \"Failed to parse: {}\", source);\n        }\n    }\n\n    #[test]\n    fn test_comparison_operators() {\n        let sources = [\"a < b;\", \"a <= b;\", \"a > b;\", \"a >= b;\"];\n        for source in sources {\n            let result = parse(source);\n            assert!(result.is_ok(), \"Failed to parse: {}\", source);\n        }\n    }\n\n    #[test]\n    fn test_instanceof() {\n        let source = \"var x = obj instanceof MyClass;\";\n        let unit = parse(source).unwrap();\n        if let Stmt::Var(v) = &unit.statements[0] {\n            assert!(matches!(v.initializer, Some(Expr::Instanceof(_))));\n        } else {\n            panic!(\"Expected var\");\n        }\n    }\n\n    #[test]\n    fn test_shift_operators() {\n        let sources = [\"a << b;\", \"a >> b;\", \"a >>> b;\"];\n        for source in sources {\n            let result = parse(source);\n            assert!(result.is_ok(), \"Failed to parse: {}\", source);\n        }\n    }\n\n    #[test]\n    fn test_unary_operators() {\n        let sources = [\n            \"+x;\", \"-x;\", \"!x;\", \"!!x;\", \"~x;\", \"$x;\", \"++x;\", \"--x;\", \"x++;\", \"x--;\",\n        ];\n        for source in sources {\n            let result = parse(source);\n            assert!(result.is_ok(), \"Failed to parse: {}\", source);\n        }\n    }\n\n    #[test]\n    fn test_index_expr() {\n        let source = \"arr[0];\";\n        let unit = parse(source).unwrap();\n        if let Stmt::Expr(Expr::Index(_)) = &unit.statements[0] {\n            // ok\n        } else {\n            panic!(\"Expected index expression\");\n        }\n    }\n\n    #[test]\n    fn test_range_expr() {\n        let sources = [\n            \"arr[1:3];\",  // start and end\n            \"arr[:3];\",  // no start\n            \"arr[1:];\",  // no end\n        ];\n        for source in sources {\n            let result = parse(source);\n            assert!(result.is_ok(), \"Failed to parse: {}\", source);\n            if let Stmt::Expr(Expr::Range(_)) = &result.unwrap().statements[0] {\n                // ok\n            } else {\n                panic!(\"Expected range expression for: {}\", source);\n            }\n        }\n    }\n\n    #[test]\n    fn test_member_access() {\n        let source = \"obj.field.subfield;\";\n        let unit = parse(source).unwrap();\n        if let Stmt::Expr(Expr::Member(_)) = &unit.statements[0] {\n            // ok\n        } else {\n            panic!(\"Expected member expression\");\n        }\n    }\n\n    #[test]\n    fn test_call_expr() {\n        let source = \"myFunc(a, b, c);\";\n        let unit = parse(source).unwrap();\n        if let Stmt::Expr(Expr::Call(c)) = &unit.statements[0] {\n            assert_eq!(c.args.len(), 3);\n        } else {\n            panic!(\"Expected call expression\");\n        }\n    }\n\n    #[test]\n    fn test_call_expr_no_args() {\n        let source = \"myFunc();\";\n        let unit = parse(source).unwrap();\n        if let Stmt::Expr(Expr::Call(c)) = &unit.statements[0] {\n            assert!(c.args.is_empty());\n        } else {\n            panic!(\"Expected call expression\");\n        }\n    }\n\n    #[test]\n    fn test_literals() {\n        let sources = [\n            (\"42;\", true),         // decimal\n            (\"0x1F;\", true),       // hex\n            (\"0777;\", true),       // octal\n            (\"0;\", true),          // zero\n            (\"'a';\", true),        // char\n            (\"3.14;\", true),       // float\n            (\"\\\"hello\\\";\", true),  // string\n            (\"@symbol;\", true),    // symbol\n            (\"null;\", true),       // null\n            (\"self;\", true),       // self\n            (\"super;\", true),      // super\n        ];\n        for (source, expected) in sources {\n            let result = parse(source);\n            assert_eq!(result.is_ok(), expected, \"Failed for: {}\", source);\n        }\n    }\n\n    #[test]\n    fn test_list_literal() {\n        let source = \"var x = @(1, 2, 3);\";\n        let unit = parse(source).unwrap();\n        if let Stmt::Var(v) = &unit.statements[0] {\n            if let Some(Expr::List(elements)) = &v.initializer {\n                assert_eq!(elements.len(), 3);\n            } else {\n                panic!(\"Expected list literal\");\n            }\n        }\n    }\n\n    #[test]\n    fn test_parenthesized_expr() {\n        let source = \"var x = (a + b);\";\n        let unit = parse(source).unwrap();\n        if let Stmt::Var(v) = &unit.statements[0] {\n            assert!(matches!(v.initializer, Some(Expr::Paren(_))));\n        } else {\n            panic!(\"Expected var\");\n        }\n    }\n\n    #[test]\n    fn test_qualified_name_expr() {\n        let source = \"::foo::bar::baz;\";\n        let unit = parse(source).unwrap();\n        if let Stmt::Expr(Expr::QualifiedName(qn)) = &unit.statements[0] {\n            assert!(qn.absolute);\n            assert_eq!(qn.parts, vec![\"foo\", \"bar\", \"baz\"]);\n        } else {\n            panic!(\"Expected qualified name\");\n        }\n    }\n\n    #[test]\n    fn test_relative_qualified_name() {\n        let source = \"foo::bar::baz;\";\n        let unit = parse(source).unwrap();\n        if let Stmt::Expr(Expr::QualifiedName(qn)) = &unit.statements[0] {\n            assert!(!qn.absolute);\n            assert_eq!(qn.parts, vec![\"foo\", \"bar\", \"baz\"]);\n        } else {\n            panic!(\"Expected qualified name\");\n        }\n    }\n\n    #[test]\n    fn test_parse_error_invalid_token() {\n        let result = parse(\"var x = @@@;\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_parse_error_unexpected_token() {\n        let result = parse(\"var = 1;\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_parse_error_unexpected_eof() {\n        let result = parse(\"var x =\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_parse_error_invalid_modifiers() {\n        let result = parse(\"public 42;\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_parse_error_class_member_modifiers() {\n        let result = parse(\"class Foo { public 42; }\");\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":215}},{"line":35,"address":[],"length":0,"stats":{"Line":645}},{"line":36,"address":[],"length":0,"stats":{"Line":215}},{"line":40,"address":[],"length":0,"stats":{"Line":215}},{"line":41,"address":[],"length":0,"stats":{"Line":430}},{"line":44,"address":[],"length":0,"stats":{"Line":645}},{"line":45,"address":[],"length":0,"stats":{"Line":39}},{"line":49,"address":[],"length":0,"stats":{"Line":687}},{"line":50,"address":[],"length":0,"stats":{"Line":56}},{"line":54,"address":[],"length":0,"stats":{"Line":506}},{"line":55,"address":[],"length":0,"stats":{"Line":1184}},{"line":58,"address":[],"length":0,"stats":{"Line":210}},{"line":65,"address":[],"length":0,"stats":{"Line":154581}},{"line":66,"address":[],"length":0,"stats":{"Line":309162}},{"line":69,"address":[],"length":0,"stats":{"Line":153493}},{"line":70,"address":[],"length":0,"stats":{"Line":460479}},{"line":73,"address":[],"length":0,"stats":{"Line":1085}},{"line":74,"address":[],"length":0,"stats":{"Line":4340}},{"line":77,"address":[],"length":0,"stats":{"Line":12287}},{"line":78,"address":[],"length":0,"stats":{"Line":24574}},{"line":81,"address":[],"length":0,"stats":{"Line":10825}},{"line":82,"address":[],"length":0,"stats":{"Line":21650}},{"line":83,"address":[],"length":0,"stats":{"Line":10825}},{"line":85,"address":[],"length":0,"stats":{"Line":21650}},{"line":88,"address":[],"length":0,"stats":{"Line":126560}},{"line":89,"address":[],"length":0,"stats":{"Line":759310}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":116560}},{"line":98,"address":[],"length":0,"stats":{"Line":349680}},{"line":99,"address":[],"length":0,"stats":{"Line":5646}},{"line":100,"address":[],"length":0,"stats":{"Line":2823}},{"line":102,"address":[],"length":0,"stats":{"Line":113737}},{"line":106,"address":[],"length":0,"stats":{"Line":4109}},{"line":107,"address":[],"length":0,"stats":{"Line":12327}},{"line":108,"address":[],"length":0,"stats":{"Line":8218}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":115,"address":[],"length":0,"stats":{"Line":5}},{"line":117,"address":[],"length":0,"stats":{"Line":6}},{"line":118,"address":[],"length":0,"stats":{"Line":4}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":1079}},{"line":129,"address":[],"length":0,"stats":{"Line":3237}},{"line":130,"address":[],"length":0,"stats":{"Line":2158}},{"line":131,"address":[],"length":0,"stats":{"Line":2158}},{"line":132,"address":[],"length":0,"stats":{"Line":1079}},{"line":133,"address":[],"length":0,"stats":{"Line":2158}},{"line":134,"address":[],"length":0,"stats":{"Line":3237}},{"line":141,"address":[],"length":0,"stats":{"Line":13}},{"line":142,"address":[],"length":0,"stats":{"Line":39}},{"line":143,"address":[],"length":0,"stats":{"Line":39}},{"line":144,"address":[],"length":0,"stats":{"Line":39}},{"line":145,"address":[],"length":0,"stats":{"Line":13}},{"line":148,"address":[],"length":0,"stats":{"Line":14}},{"line":149,"address":[],"length":0,"stats":{"Line":42}},{"line":150,"address":[],"length":0,"stats":{"Line":42}},{"line":151,"address":[],"length":0,"stats":{"Line":42}},{"line":154,"address":[],"length":0,"stats":{"Line":56}},{"line":155,"address":[],"length":0,"stats":{"Line":26}},{"line":156,"address":[],"length":0,"stats":{"Line":39}},{"line":157,"address":[],"length":0,"stats":{"Line":13}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":42}},{"line":163,"address":[],"length":0,"stats":{"Line":14}},{"line":164,"address":[],"length":0,"stats":{"Line":28}},{"line":165,"address":[],"length":0,"stats":{"Line":28}},{"line":166,"address":[],"length":0,"stats":{"Line":28}},{"line":170,"address":[],"length":0,"stats":{"Line":70}},{"line":171,"address":[],"length":0,"stats":{"Line":210}},{"line":172,"address":[],"length":0,"stats":{"Line":280}},{"line":173,"address":[],"length":0,"stats":{"Line":140}},{"line":176,"address":[],"length":0,"stats":{"Line":350}},{"line":177,"address":[],"length":0,"stats":{"Line":210}},{"line":178,"address":[],"length":0,"stats":{"Line":140}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":402}},{"line":185,"address":[],"length":0,"stats":{"Line":359}},{"line":186,"address":[],"length":0,"stats":{"Line":192}},{"line":187,"address":[],"length":0,"stats":{"Line":128}},{"line":188,"address":[],"length":0,"stats":{"Line":103}},{"line":190,"address":[],"length":0,"stats":{"Line":13}},{"line":191,"address":[],"length":0,"stats":{"Line":13}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":70}},{"line":198,"address":[],"length":0,"stats":{"Line":140}},{"line":199,"address":[],"length":0,"stats":{"Line":140}},{"line":200,"address":[],"length":0,"stats":{"Line":140}},{"line":208,"address":[],"length":0,"stats":{"Line":1327}},{"line":210,"address":[],"length":0,"stats":{"Line":3981}},{"line":212,"address":[],"length":0,"stats":{"Line":2654}},{"line":213,"address":[],"length":0,"stats":{"Line":1011}},{"line":214,"address":[],"length":0,"stats":{"Line":112}},{"line":215,"address":[],"length":0,"stats":{"Line":72}},{"line":216,"address":[],"length":0,"stats":{"Line":316}},{"line":217,"address":[],"length":0,"stats":{"Line":8}},{"line":218,"address":[],"length":0,"stats":{"Line":12}},{"line":219,"address":[],"length":0,"stats":{"Line":10}},{"line":220,"address":[],"length":0,"stats":{"Line":46}},{"line":221,"address":[],"length":0,"stats":{"Line":60}},{"line":222,"address":[],"length":0,"stats":{"Line":178}},{"line":223,"address":[],"length":0,"stats":{"Line":36}},{"line":224,"address":[],"length":0,"stats":{"Line":12}},{"line":225,"address":[],"length":0,"stats":{"Line":2}},{"line":226,"address":[],"length":0,"stats":{"Line":16}},{"line":227,"address":[],"length":0,"stats":{"Line":552}},{"line":229,"address":[],"length":0,"stats":{"Line":2}},{"line":230,"address":[],"length":0,"stats":{"Line":1}},{"line":233,"address":[],"length":0,"stats":{"Line":411}},{"line":234,"address":[],"length":0,"stats":{"Line":1}},{"line":235,"address":[],"length":0,"stats":{"Line":3}},{"line":236,"address":[],"length":0,"stats":{"Line":1}},{"line":239,"address":[],"length":0,"stats":{"Line":820}},{"line":244,"address":[],"length":0,"stats":{"Line":1419}},{"line":245,"address":[],"length":0,"stats":{"Line":2838}},{"line":247,"address":[],"length":0,"stats":{"Line":3117}},{"line":248,"address":[],"length":0,"stats":{"Line":72}},{"line":249,"address":[],"length":0,"stats":{"Line":11}},{"line":250,"address":[],"length":0,"stats":{"Line":1}},{"line":251,"address":[],"length":0,"stats":{"Line":4}},{"line":252,"address":[],"length":0,"stats":{"Line":1}},{"line":253,"address":[],"length":0,"stats":{"Line":1}},{"line":254,"address":[],"length":0,"stats":{"Line":2}},{"line":255,"address":[],"length":0,"stats":{"Line":1}},{"line":256,"address":[],"length":0,"stats":{"Line":1419}},{"line":258,"address":[],"length":0,"stats":{"Line":186}},{"line":259,"address":[],"length":0,"stats":{"Line":279}},{"line":261,"address":[],"length":0,"stats":{"Line":1419}},{"line":266,"address":[],"length":0,"stats":{"Line":337}},{"line":267,"address":[],"length":0,"stats":{"Line":1011}},{"line":269,"address":[],"length":0,"stats":{"Line":674}},{"line":272,"address":[],"length":0,"stats":{"Line":1026}},{"line":275,"address":[],"length":0,"stats":{"Line":1708}},{"line":276,"address":[],"length":0,"stats":{"Line":682}},{"line":277,"address":[],"length":0,"stats":{"Line":341}},{"line":279,"address":[],"length":0,"stats":{"Line":2}},{"line":283,"address":[],"length":0,"stats":{"Line":1362}},{"line":284,"address":[],"length":0,"stats":{"Line":586}},{"line":286,"address":[],"length":0,"stats":{"Line":49}},{"line":289,"address":[],"length":0,"stats":{"Line":1017}},{"line":290,"address":[],"length":0,"stats":{"Line":1017}},{"line":291,"address":[],"length":0,"stats":{"Line":678}},{"line":292,"address":[],"length":0,"stats":{"Line":678}},{"line":293,"address":[],"length":0,"stats":{"Line":678}},{"line":297,"address":[],"length":0,"stats":{"Line":678}},{"line":298,"address":[],"length":0,"stats":{"Line":334}},{"line":302,"address":[],"length":0,"stats":{"Line":1002}},{"line":305,"address":[],"length":0,"stats":{"Line":334}},{"line":306,"address":[],"length":0,"stats":{"Line":662}},{"line":308,"address":[],"length":0,"stats":{"Line":3}},{"line":313,"address":[],"length":0,"stats":{"Line":23}},{"line":314,"address":[],"length":0,"stats":{"Line":69}},{"line":315,"address":[],"length":0,"stats":{"Line":69}},{"line":318,"address":[],"length":0,"stats":{"Line":115}},{"line":319,"address":[],"length":0,"stats":{"Line":46}},{"line":320,"address":[],"length":0,"stats":{"Line":23}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":92}},{"line":326,"address":[],"length":0,"stats":{"Line":40}},{"line":328,"address":[],"length":0,"stats":{"Line":3}},{"line":331,"address":[],"length":0,"stats":{"Line":69}},{"line":333,"address":[],"length":0,"stats":{"Line":23}},{"line":334,"address":[],"length":0,"stats":{"Line":46}},{"line":335,"address":[],"length":0,"stats":{"Line":46}},{"line":336,"address":[],"length":0,"stats":{"Line":46}},{"line":337,"address":[],"length":0,"stats":{"Line":46}},{"line":341,"address":[],"length":0,"stats":{"Line":28}},{"line":342,"address":[],"length":0,"stats":{"Line":84}},{"line":343,"address":[],"length":0,"stats":{"Line":84}},{"line":345,"address":[],"length":0,"stats":{"Line":140}},{"line":346,"address":[],"length":0,"stats":{"Line":56}},{"line":347,"address":[],"length":0,"stats":{"Line":28}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":112}},{"line":354,"address":[],"length":0,"stats":{"Line":48}},{"line":356,"address":[],"length":0,"stats":{"Line":4}},{"line":359,"address":[],"length":0,"stats":{"Line":84}},{"line":361,"address":[],"length":0,"stats":{"Line":56}},{"line":362,"address":[],"length":0,"stats":{"Line":330}},{"line":363,"address":[],"length":0,"stats":{"Line":368}},{"line":366,"address":[],"length":0,"stats":{"Line":81}},{"line":368,"address":[],"length":0,"stats":{"Line":27}},{"line":369,"address":[],"length":0,"stats":{"Line":54}},{"line":370,"address":[],"length":0,"stats":{"Line":54}},{"line":371,"address":[],"length":0,"stats":{"Line":54}},{"line":372,"address":[],"length":0,"stats":{"Line":54}},{"line":373,"address":[],"length":0,"stats":{"Line":54}},{"line":377,"address":[],"length":0,"stats":{"Line":92}},{"line":378,"address":[],"length":0,"stats":{"Line":276}},{"line":380,"address":[],"length":0,"stats":{"Line":184}},{"line":381,"address":[],"length":0,"stats":{"Line":80}},{"line":382,"address":[],"length":0,"stats":{"Line":268}},{"line":383,"address":[],"length":0,"stats":{"Line":9}},{"line":386,"address":[],"length":0,"stats":{"Line":2}},{"line":387,"address":[],"length":0,"stats":{"Line":1}},{"line":388,"address":[],"length":0,"stats":{"Line":3}},{"line":389,"address":[],"length":0,"stats":{"Line":1}},{"line":392,"address":[],"length":0,"stats":{"Line":3}},{"line":393,"address":[],"length":0,"stats":{"Line":3}},{"line":394,"address":[],"length":0,"stats":{"Line":1}},{"line":399,"address":[],"length":0,"stats":{"Line":85}},{"line":400,"address":[],"length":0,"stats":{"Line":255}},{"line":401,"address":[],"length":0,"stats":{"Line":255}},{"line":403,"address":[],"length":0,"stats":{"Line":425}},{"line":404,"address":[],"length":0,"stats":{"Line":170}},{"line":405,"address":[],"length":0,"stats":{"Line":85}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":255}},{"line":412,"address":[],"length":0,"stats":{"Line":340}},{"line":414,"address":[],"length":0,"stats":{"Line":255}},{"line":417,"address":[],"length":0,"stats":{"Line":504}},{"line":418,"address":[],"length":0,"stats":{"Line":8}},{"line":419,"address":[],"length":0,"stats":{"Line":2}},{"line":421,"address":[],"length":0,"stats":{"Line":2}},{"line":423,"address":[],"length":0,"stats":{"Line":166}},{"line":426,"address":[],"length":0,"stats":{"Line":85}},{"line":427,"address":[],"length":0,"stats":{"Line":170}},{"line":428,"address":[],"length":0,"stats":{"Line":170}},{"line":429,"address":[],"length":0,"stats":{"Line":170}},{"line":430,"address":[],"length":0,"stats":{"Line":170}},{"line":431,"address":[],"length":0,"stats":{"Line":170}},{"line":432,"address":[],"length":0,"stats":{"Line":170}},{"line":436,"address":[],"length":0,"stats":{"Line":3}},{"line":437,"address":[],"length":0,"stats":{"Line":9}},{"line":438,"address":[],"length":0,"stats":{"Line":9}},{"line":440,"address":[],"length":0,"stats":{"Line":15}},{"line":441,"address":[],"length":0,"stats":{"Line":6}},{"line":442,"address":[],"length":0,"stats":{"Line":3}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":9}},{"line":448,"address":[],"length":0,"stats":{"Line":9}},{"line":449,"address":[],"length":0,"stats":{"Line":9}},{"line":451,"address":[],"length":0,"stats":{"Line":9}},{"line":453,"address":[],"length":0,"stats":{"Line":3}},{"line":454,"address":[],"length":0,"stats":{"Line":6}},{"line":455,"address":[],"length":0,"stats":{"Line":6}},{"line":456,"address":[],"length":0,"stats":{"Line":6}},{"line":457,"address":[],"length":0,"stats":{"Line":6}},{"line":461,"address":[],"length":0,"stats":{"Line":88}},{"line":462,"address":[],"length":0,"stats":{"Line":176}},{"line":463,"address":[],"length":0,"stats":{"Line":176}},{"line":465,"address":[],"length":0,"stats":{"Line":176}},{"line":467,"address":[],"length":0,"stats":{"Line":280}},{"line":468,"address":[],"length":0,"stats":{"Line":168}},{"line":469,"address":[],"length":0,"stats":{"Line":112}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":285}},{"line":476,"address":[],"length":0,"stats":{"Line":120}},{"line":477,"address":[],"length":0,"stats":{"Line":1}},{"line":478,"address":[],"length":0,"stats":{"Line":1}},{"line":480,"address":[],"length":0,"stats":{"Line":195}},{"line":481,"address":[],"length":0,"stats":{"Line":117}},{"line":482,"address":[],"length":0,"stats":{"Line":78}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":88}},{"line":492,"address":[],"length":0,"stats":{"Line":284}},{"line":493,"address":[],"length":0,"stats":{"Line":852}},{"line":494,"address":[],"length":0,"stats":{"Line":852}},{"line":496,"address":[],"length":0,"stats":{"Line":568}},{"line":497,"address":[],"length":0,"stats":{"Line":2794}},{"line":498,"address":[],"length":0,"stats":{"Line":2968}},{"line":501,"address":[],"length":0,"stats":{"Line":852}},{"line":503,"address":[],"length":0,"stats":{"Line":284}},{"line":504,"address":[],"length":0,"stats":{"Line":568}},{"line":505,"address":[],"length":0,"stats":{"Line":568}},{"line":509,"address":[],"length":0,"stats":{"Line":158}},{"line":510,"address":[],"length":0,"stats":{"Line":474}},{"line":511,"address":[],"length":0,"stats":{"Line":474}},{"line":512,"address":[],"length":0,"stats":{"Line":474}},{"line":513,"address":[],"length":0,"stats":{"Line":474}},{"line":514,"address":[],"length":0,"stats":{"Line":474}},{"line":516,"address":[],"length":0,"stats":{"Line":632}},{"line":518,"address":[],"length":0,"stats":{"Line":632}},{"line":519,"address":[],"length":0,"stats":{"Line":135}},{"line":521,"address":[],"length":0,"stats":{"Line":113}},{"line":524,"address":[],"length":0,"stats":{"Line":158}},{"line":525,"address":[],"length":0,"stats":{"Line":316}},{"line":526,"address":[],"length":0,"stats":{"Line":316}},{"line":527,"address":[],"length":0,"stats":{"Line":316}},{"line":528,"address":[],"length":0,"stats":{"Line":316}},{"line":532,"address":[],"length":0,"stats":{"Line":4}},{"line":533,"address":[],"length":0,"stats":{"Line":12}},{"line":534,"address":[],"length":0,"stats":{"Line":12}},{"line":535,"address":[],"length":0,"stats":{"Line":12}},{"line":536,"address":[],"length":0,"stats":{"Line":12}},{"line":537,"address":[],"length":0,"stats":{"Line":12}},{"line":538,"address":[],"length":0,"stats":{"Line":12}},{"line":540,"address":[],"length":0,"stats":{"Line":8}},{"line":541,"address":[],"length":0,"stats":{"Line":44}},{"line":542,"address":[],"length":0,"stats":{"Line":48}},{"line":543,"address":[],"length":0,"stats":{"Line":30}},{"line":544,"address":[],"length":0,"stats":{"Line":30}},{"line":545,"address":[],"length":0,"stats":{"Line":10}},{"line":546,"address":[],"length":0,"stats":{"Line":6}},{"line":547,"address":[],"length":0,"stats":{"Line":6}},{"line":548,"address":[],"length":0,"stats":{"Line":2}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":24}},{"line":554,"address":[],"length":0,"stats":{"Line":68}},{"line":555,"address":[],"length":0,"stats":{"Line":56}},{"line":556,"address":[],"length":0,"stats":{"Line":52}},{"line":557,"address":[],"length":0,"stats":{"Line":22}},{"line":559,"address":[],"length":0,"stats":{"Line":88}},{"line":562,"address":[],"length":0,"stats":{"Line":36}},{"line":565,"address":[],"length":0,"stats":{"Line":12}},{"line":567,"address":[],"length":0,"stats":{"Line":4}},{"line":568,"address":[],"length":0,"stats":{"Line":8}},{"line":569,"address":[],"length":0,"stats":{"Line":8}},{"line":570,"address":[],"length":0,"stats":{"Line":8}},{"line":571,"address":[],"length":0,"stats":{"Line":8}},{"line":575,"address":[],"length":0,"stats":{"Line":6}},{"line":576,"address":[],"length":0,"stats":{"Line":18}},{"line":577,"address":[],"length":0,"stats":{"Line":18}},{"line":578,"address":[],"length":0,"stats":{"Line":18}},{"line":579,"address":[],"length":0,"stats":{"Line":18}},{"line":580,"address":[],"length":0,"stats":{"Line":18}},{"line":581,"address":[],"length":0,"stats":{"Line":24}},{"line":583,"address":[],"length":0,"stats":{"Line":6}},{"line":584,"address":[],"length":0,"stats":{"Line":12}},{"line":585,"address":[],"length":0,"stats":{"Line":12}},{"line":586,"address":[],"length":0,"stats":{"Line":12}},{"line":587,"address":[],"length":0,"stats":{"Line":12}},{"line":591,"address":[],"length":0,"stats":{"Line":5}},{"line":592,"address":[],"length":0,"stats":{"Line":15}},{"line":593,"address":[],"length":0,"stats":{"Line":15}},{"line":594,"address":[],"length":0,"stats":{"Line":20}},{"line":595,"address":[],"length":0,"stats":{"Line":15}},{"line":596,"address":[],"length":0,"stats":{"Line":15}},{"line":597,"address":[],"length":0,"stats":{"Line":15}},{"line":598,"address":[],"length":0,"stats":{"Line":15}},{"line":599,"address":[],"length":0,"stats":{"Line":15}},{"line":601,"address":[],"length":0,"stats":{"Line":5}},{"line":602,"address":[],"length":0,"stats":{"Line":10}},{"line":603,"address":[],"length":0,"stats":{"Line":10}},{"line":604,"address":[],"length":0,"stats":{"Line":10}},{"line":605,"address":[],"length":0,"stats":{"Line":10}},{"line":609,"address":[],"length":0,"stats":{"Line":23}},{"line":610,"address":[],"length":0,"stats":{"Line":69}},{"line":611,"address":[],"length":0,"stats":{"Line":69}},{"line":612,"address":[],"length":0,"stats":{"Line":69}},{"line":615,"address":[],"length":0,"stats":{"Line":92}},{"line":616,"address":[],"length":0,"stats":{"Line":2}},{"line":617,"address":[],"length":0,"stats":{"Line":1}},{"line":618,"address":[],"length":0,"stats":{"Line":66}},{"line":619,"address":[],"length":0,"stats":{"Line":12}},{"line":620,"address":[],"length":0,"stats":{"Line":3}},{"line":622,"address":[],"length":0,"stats":{"Line":57}},{"line":623,"address":[],"length":0,"stats":{"Line":57}},{"line":624,"address":[],"length":0,"stats":{"Line":19}},{"line":628,"address":[],"length":0,"stats":{"Line":92}},{"line":629,"address":[],"length":0,"stats":{"Line":1}},{"line":631,"address":[],"length":0,"stats":{"Line":44}},{"line":633,"address":[],"length":0,"stats":{"Line":69}},{"line":636,"address":[],"length":0,"stats":{"Line":92}},{"line":637,"address":[],"length":0,"stats":{"Line":1}},{"line":639,"address":[],"length":0,"stats":{"Line":44}},{"line":641,"address":[],"length":0,"stats":{"Line":69}},{"line":643,"address":[],"length":0,"stats":{"Line":92}},{"line":645,"address":[],"length":0,"stats":{"Line":23}},{"line":646,"address":[],"length":0,"stats":{"Line":46}},{"line":647,"address":[],"length":0,"stats":{"Line":46}},{"line":648,"address":[],"length":0,"stats":{"Line":46}},{"line":649,"address":[],"length":0,"stats":{"Line":46}},{"line":650,"address":[],"length":0,"stats":{"Line":46}},{"line":651,"address":[],"length":0,"stats":{"Line":46}},{"line":655,"address":[],"length":0,"stats":{"Line":30}},{"line":656,"address":[],"length":0,"stats":{"Line":90}},{"line":657,"address":[],"length":0,"stats":{"Line":90}},{"line":658,"address":[],"length":0,"stats":{"Line":90}},{"line":660,"address":[],"length":0,"stats":{"Line":150}},{"line":661,"address":[],"length":0,"stats":{"Line":60}},{"line":662,"address":[],"length":0,"stats":{"Line":30}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":90}},{"line":668,"address":[],"length":0,"stats":{"Line":90}},{"line":669,"address":[],"length":0,"stats":{"Line":90}},{"line":671,"address":[],"length":0,"stats":{"Line":120}},{"line":673,"address":[],"length":0,"stats":{"Line":30}},{"line":674,"address":[],"length":0,"stats":{"Line":60}},{"line":675,"address":[],"length":0,"stats":{"Line":60}},{"line":676,"address":[],"length":0,"stats":{"Line":60}},{"line":677,"address":[],"length":0,"stats":{"Line":60}},{"line":678,"address":[],"length":0,"stats":{"Line":60}},{"line":682,"address":[],"length":0,"stats":{"Line":89}},{"line":683,"address":[],"length":0,"stats":{"Line":267}},{"line":688,"address":[],"length":0,"stats":{"Line":532}},{"line":689,"address":[],"length":0,"stats":{"Line":1}},{"line":691,"address":[],"length":0,"stats":{"Line":176}},{"line":694,"address":[],"length":0,"stats":{"Line":267}},{"line":695,"address":[],"length":0,"stats":{"Line":89}},{"line":698,"address":[],"length":0,"stats":{"Line":18}},{"line":699,"address":[],"length":0,"stats":{"Line":54}},{"line":700,"address":[],"length":0,"stats":{"Line":73}},{"line":701,"address":[],"length":0,"stats":{"Line":2}},{"line":702,"address":[],"length":0,"stats":{"Line":1}},{"line":704,"address":[],"length":0,"stats":{"Line":17}},{"line":706,"address":[],"length":0,"stats":{"Line":54}},{"line":707,"address":[],"length":0,"stats":{"Line":18}},{"line":710,"address":[],"length":0,"stats":{"Line":6}},{"line":711,"address":[],"length":0,"stats":{"Line":18}},{"line":712,"address":[],"length":0,"stats":{"Line":25}},{"line":713,"address":[],"length":0,"stats":{"Line":2}},{"line":714,"address":[],"length":0,"stats":{"Line":1}},{"line":716,"address":[],"length":0,"stats":{"Line":5}},{"line":718,"address":[],"length":0,"stats":{"Line":18}},{"line":719,"address":[],"length":0,"stats":{"Line":6}},{"line":722,"address":[],"length":0,"stats":{"Line":1}},{"line":723,"address":[],"length":0,"stats":{"Line":3}},{"line":724,"address":[],"length":0,"stats":{"Line":3}},{"line":725,"address":[],"length":0,"stats":{"Line":3}},{"line":726,"address":[],"length":0,"stats":{"Line":1}},{"line":729,"address":[],"length":0,"stats":{"Line":8}},{"line":730,"address":[],"length":0,"stats":{"Line":24}},{"line":731,"address":[],"length":0,"stats":{"Line":24}},{"line":732,"address":[],"length":0,"stats":{"Line":24}},{"line":734,"address":[],"length":0,"stats":{"Line":40}},{"line":735,"address":[],"length":0,"stats":{"Line":12}},{"line":738,"address":[],"length":0,"stats":{"Line":16}},{"line":741,"address":[],"length":0,"stats":{"Line":20}},{"line":742,"address":[],"length":0,"stats":{"Line":8}},{"line":743,"address":[],"length":0,"stats":{"Line":4}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":12}},{"line":751,"address":[],"length":0,"stats":{"Line":6}},{"line":752,"address":[],"length":0,"stats":{"Line":2}},{"line":754,"address":[],"length":0,"stats":{"Line":2}},{"line":758,"address":[],"length":0,"stats":{"Line":12}},{"line":759,"address":[],"length":0,"stats":{"Line":12}},{"line":761,"address":[],"length":0,"stats":{"Line":4}},{"line":764,"address":[],"length":0,"stats":{"Line":32}},{"line":765,"address":[],"length":0,"stats":{"Line":4}},{"line":767,"address":[],"length":0,"stats":{"Line":6}},{"line":770,"address":[],"length":0,"stats":{"Line":8}},{"line":771,"address":[],"length":0,"stats":{"Line":16}},{"line":772,"address":[],"length":0,"stats":{"Line":16}},{"line":773,"address":[],"length":0,"stats":{"Line":16}},{"line":774,"address":[],"length":0,"stats":{"Line":16}},{"line":775,"address":[],"length":0,"stats":{"Line":16}},{"line":779,"address":[],"length":0,"stats":{"Line":410}},{"line":780,"address":[],"length":0,"stats":{"Line":1230}},{"line":781,"address":[],"length":0,"stats":{"Line":1230}},{"line":782,"address":[],"length":0,"stats":{"Line":410}},{"line":789,"address":[],"length":0,"stats":{"Line":2303}},{"line":790,"address":[],"length":0,"stats":{"Line":4606}},{"line":793,"address":[],"length":0,"stats":{"Line":2476}},{"line":794,"address":[],"length":0,"stats":{"Line":7428}},{"line":796,"address":[],"length":0,"stats":{"Line":2647}},{"line":797,"address":[],"length":0,"stats":{"Line":519}},{"line":798,"address":[],"length":0,"stats":{"Line":173}},{"line":799,"address":[],"length":0,"stats":{"Line":519}},{"line":800,"address":[],"length":0,"stats":{"Line":346}},{"line":801,"address":[],"length":0,"stats":{"Line":173}},{"line":805,"address":[],"length":0,"stats":{"Line":2301}},{"line":808,"address":[],"length":0,"stats":{"Line":2474}},{"line":809,"address":[],"length":0,"stats":{"Line":5121}},{"line":810,"address":[],"length":0,"stats":{"Line":157}},{"line":811,"address":[],"length":0,"stats":{"Line":3}},{"line":812,"address":[],"length":0,"stats":{"Line":2}},{"line":813,"address":[],"length":0,"stats":{"Line":2}},{"line":814,"address":[],"length":0,"stats":{"Line":2}},{"line":815,"address":[],"length":0,"stats":{"Line":1}},{"line":816,"address":[],"length":0,"stats":{"Line":1}},{"line":817,"address":[],"length":0,"stats":{"Line":1}},{"line":818,"address":[],"length":0,"stats":{"Line":1}},{"line":819,"address":[],"length":0,"stats":{"Line":1}},{"line":820,"address":[],"length":0,"stats":{"Line":1}},{"line":821,"address":[],"length":0,"stats":{"Line":1}},{"line":822,"address":[],"length":0,"stats":{"Line":2301}},{"line":824,"address":[],"length":0,"stats":{"Line":346}},{"line":825,"address":[],"length":0,"stats":{"Line":173}},{"line":828,"address":[],"length":0,"stats":{"Line":2479}},{"line":829,"address":[],"length":0,"stats":{"Line":7437}},{"line":831,"address":[],"length":0,"stats":{"Line":7431}},{"line":832,"address":[],"length":0,"stats":{"Line":9}},{"line":833,"address":[],"length":0,"stats":{"Line":9}},{"line":834,"address":[],"length":0,"stats":{"Line":9}},{"line":835,"address":[],"length":0,"stats":{"Line":3}},{"line":836,"address":[],"length":0,"stats":{"Line":9}},{"line":837,"address":[],"length":0,"stats":{"Line":9}},{"line":838,"address":[],"length":0,"stats":{"Line":3}},{"line":842,"address":[],"length":0,"stats":{"Line":2474}},{"line":845,"address":[],"length":0,"stats":{"Line":2479}},{"line":846,"address":[],"length":0,"stats":{"Line":7437}},{"line":848,"address":[],"length":0,"stats":{"Line":7458}},{"line":849,"address":[],"length":0,"stats":{"Line":27}},{"line":850,"address":[],"length":0,"stats":{"Line":18}},{"line":851,"address":[],"length":0,"stats":{"Line":27}},{"line":852,"address":[],"length":0,"stats":{"Line":18}},{"line":853,"address":[],"length":0,"stats":{"Line":9}},{"line":857,"address":[],"length":0,"stats":{"Line":2477}},{"line":860,"address":[],"length":0,"stats":{"Line":2488}},{"line":861,"address":[],"length":0,"stats":{"Line":7464}},{"line":863,"address":[],"length":0,"stats":{"Line":7569}},{"line":864,"address":[],"length":0,"stats":{"Line":111}},{"line":865,"address":[],"length":0,"stats":{"Line":74}},{"line":866,"address":[],"length":0,"stats":{"Line":111}},{"line":867,"address":[],"length":0,"stats":{"Line":74}},{"line":868,"address":[],"length":0,"stats":{"Line":37}},{"line":872,"address":[],"length":0,"stats":{"Line":2486}},{"line":875,"address":[],"length":0,"stats":{"Line":2525}},{"line":876,"address":[],"length":0,"stats":{"Line":7575}},{"line":878,"address":[],"length":0,"stats":{"Line":7575}},{"line":879,"address":[],"length":0,"stats":{"Line":6}},{"line":880,"address":[],"length":0,"stats":{"Line":4}},{"line":881,"address":[],"length":0,"stats":{"Line":6}},{"line":882,"address":[],"length":0,"stats":{"Line":4}},{"line":883,"address":[],"length":0,"stats":{"Line":2}},{"line":887,"address":[],"length":0,"stats":{"Line":2523}},{"line":890,"address":[],"length":0,"stats":{"Line":2527}},{"line":891,"address":[],"length":0,"stats":{"Line":7581}},{"line":893,"address":[],"length":0,"stats":{"Line":7581}},{"line":894,"address":[],"length":0,"stats":{"Line":6}},{"line":895,"address":[],"length":0,"stats":{"Line":4}},{"line":896,"address":[],"length":0,"stats":{"Line":6}},{"line":897,"address":[],"length":0,"stats":{"Line":4}},{"line":898,"address":[],"length":0,"stats":{"Line":2}},{"line":902,"address":[],"length":0,"stats":{"Line":2525}},{"line":905,"address":[],"length":0,"stats":{"Line":2529}},{"line":906,"address":[],"length":0,"stats":{"Line":7587}},{"line":908,"address":[],"length":0,"stats":{"Line":7587}},{"line":909,"address":[],"length":0,"stats":{"Line":6}},{"line":910,"address":[],"length":0,"stats":{"Line":4}},{"line":911,"address":[],"length":0,"stats":{"Line":6}},{"line":912,"address":[],"length":0,"stats":{"Line":4}},{"line":913,"address":[],"length":0,"stats":{"Line":2}},{"line":917,"address":[],"length":0,"stats":{"Line":2527}},{"line":920,"address":[],"length":0,"stats":{"Line":2531}},{"line":921,"address":[],"length":0,"stats":{"Line":7593}},{"line":924,"address":[],"length":0,"stats":{"Line":7595}},{"line":925,"address":[],"length":0,"stats":{"Line":1}},{"line":926,"address":[],"length":0,"stats":{"Line":7590}},{"line":927,"address":[],"length":0,"stats":{"Line":1}},{"line":929,"address":[],"length":0,"stats":{"Line":2529}},{"line":932,"address":[],"length":0,"stats":{"Line":6}},{"line":933,"address":[],"length":0,"stats":{"Line":4}},{"line":934,"address":[],"length":0,"stats":{"Line":6}},{"line":935,"address":[],"length":0,"stats":{"Line":4}},{"line":936,"address":[],"length":0,"stats":{"Line":2}},{"line":940,"address":[],"length":0,"stats":{"Line":2529}},{"line":943,"address":[],"length":0,"stats":{"Line":2533}},{"line":944,"address":[],"length":0,"stats":{"Line":7599}},{"line":947,"address":[],"length":0,"stats":{"Line":7973}},{"line":948,"address":[],"length":0,"stats":{"Line":62}},{"line":949,"address":[],"length":0,"stats":{"Line":7692}},{"line":950,"address":[],"length":0,"stats":{"Line":32}},{"line":951,"address":[],"length":0,"stats":{"Line":7596}},{"line":952,"address":[],"length":0,"stats":{"Line":1}},{"line":954,"address":[],"length":0,"stats":{"Line":2531}},{"line":957,"address":[],"length":0,"stats":{"Line":285}},{"line":958,"address":[],"length":0,"stats":{"Line":190}},{"line":959,"address":[],"length":0,"stats":{"Line":285}},{"line":960,"address":[],"length":0,"stats":{"Line":190}},{"line":961,"address":[],"length":0,"stats":{"Line":95}},{"line":965,"address":[],"length":0,"stats":{"Line":2531}},{"line":968,"address":[],"length":0,"stats":{"Line":2628}},{"line":969,"address":[],"length":0,"stats":{"Line":7884}},{"line":972,"address":[],"length":0,"stats":{"Line":7878}},{"line":973,"address":[],"length":0,"stats":{"Line":3}},{"line":974,"address":[],"length":0,"stats":{"Line":1}},{"line":975,"address":[],"length":0,"stats":{"Line":3}},{"line":976,"address":[],"length":0,"stats":{"Line":1}},{"line":981,"address":[],"length":0,"stats":{"Line":8239}},{"line":982,"address":[],"length":0,"stats":{"Line":46}},{"line":983,"address":[],"length":0,"stats":{"Line":8010}},{"line":984,"address":[],"length":0,"stats":{"Line":5}},{"line":985,"address":[],"length":0,"stats":{"Line":7995}},{"line":986,"address":[],"length":0,"stats":{"Line":29}},{"line":987,"address":[],"length":0,"stats":{"Line":7908}},{"line":988,"address":[],"length":0,"stats":{"Line":11}},{"line":990,"address":[],"length":0,"stats":{"Line":2625}},{"line":993,"address":[],"length":0,"stats":{"Line":273}},{"line":994,"address":[],"length":0,"stats":{"Line":182}},{"line":995,"address":[],"length":0,"stats":{"Line":273}},{"line":996,"address":[],"length":0,"stats":{"Line":182}},{"line":997,"address":[],"length":0,"stats":{"Line":91}},{"line":1001,"address":[],"length":0,"stats":{"Line":2625}},{"line":1004,"address":[],"length":0,"stats":{"Line":2720}},{"line":1005,"address":[],"length":0,"stats":{"Line":8160}},{"line":1008,"address":[],"length":0,"stats":{"Line":8178}},{"line":1009,"address":[],"length":0,"stats":{"Line":2}},{"line":1010,"address":[],"length":0,"stats":{"Line":8166}},{"line":1011,"address":[],"length":0,"stats":{"Line":2}},{"line":1012,"address":[],"length":0,"stats":{"Line":8160}},{"line":1013,"address":[],"length":0,"stats":{"Line":2}},{"line":1015,"address":[],"length":0,"stats":{"Line":2718}},{"line":1018,"address":[],"length":0,"stats":{"Line":18}},{"line":1019,"address":[],"length":0,"stats":{"Line":12}},{"line":1020,"address":[],"length":0,"stats":{"Line":18}},{"line":1021,"address":[],"length":0,"stats":{"Line":12}},{"line":1022,"address":[],"length":0,"stats":{"Line":6}},{"line":1026,"address":[],"length":0,"stats":{"Line":2718}},{"line":1029,"address":[],"length":0,"stats":{"Line":2726}},{"line":1030,"address":[],"length":0,"stats":{"Line":8178}},{"line":1033,"address":[],"length":0,"stats":{"Line":8904}},{"line":1034,"address":[],"length":0,"stats":{"Line":151}},{"line":1035,"address":[],"length":0,"stats":{"Line":8268}},{"line":1036,"address":[],"length":0,"stats":{"Line":32}},{"line":1038,"address":[],"length":0,"stats":{"Line":2724}},{"line":1041,"address":[],"length":0,"stats":{"Line":549}},{"line":1042,"address":[],"length":0,"stats":{"Line":366}},{"line":1043,"address":[],"length":0,"stats":{"Line":549}},{"line":1044,"address":[],"length":0,"stats":{"Line":366}},{"line":1045,"address":[],"length":0,"stats":{"Line":183}},{"line":1049,"address":[],"length":0,"stats":{"Line":2724}},{"line":1052,"address":[],"length":0,"stats":{"Line":2909}},{"line":1053,"address":[],"length":0,"stats":{"Line":8727}},{"line":1056,"address":[],"length":0,"stats":{"Line":8905}},{"line":1057,"address":[],"length":0,"stats":{"Line":23}},{"line":1058,"address":[],"length":0,"stats":{"Line":8790}},{"line":1059,"address":[],"length":0,"stats":{"Line":17}},{"line":1060,"address":[],"length":0,"stats":{"Line":8739}},{"line":1061,"address":[],"length":0,"stats":{"Line":6}},{"line":1063,"address":[],"length":0,"stats":{"Line":2907}},{"line":1066,"address":[],"length":0,"stats":{"Line":138}},{"line":1067,"address":[],"length":0,"stats":{"Line":92}},{"line":1068,"address":[],"length":0,"stats":{"Line":138}},{"line":1069,"address":[],"length":0,"stats":{"Line":92}},{"line":1070,"address":[],"length":0,"stats":{"Line":46}},{"line":1074,"address":[],"length":0,"stats":{"Line":2907}},{"line":1077,"address":[],"length":0,"stats":{"Line":3006}},{"line":1078,"address":[],"length":0,"stats":{"Line":9018}},{"line":1079,"address":[],"length":0,"stats":{"Line":3}},{"line":1080,"address":[],"length":0,"stats":{"Line":1}},{"line":1081,"address":[],"length":0,"stats":{"Line":2}},{"line":1082,"address":[],"length":0,"stats":{"Line":1}},{"line":1086,"address":[],"length":0,"stats":{"Line":9015}},{"line":1087,"address":[],"length":0,"stats":{"Line":105}},{"line":1088,"address":[],"length":0,"stats":{"Line":35}},{"line":1089,"address":[],"length":0,"stats":{"Line":70}},{"line":1090,"address":[],"length":0,"stats":{"Line":35}},{"line":1094,"address":[],"length":0,"stats":{"Line":8910}},{"line":1095,"address":[],"length":0,"stats":{"Line":27}},{"line":1096,"address":[],"length":0,"stats":{"Line":9}},{"line":1097,"address":[],"length":0,"stats":{"Line":18}},{"line":1098,"address":[],"length":0,"stats":{"Line":9}},{"line":1102,"address":[],"length":0,"stats":{"Line":8883}},{"line":1103,"address":[],"length":0,"stats":{"Line":3}},{"line":1104,"address":[],"length":0,"stats":{"Line":1}},{"line":1105,"address":[],"length":0,"stats":{"Line":2}},{"line":1106,"address":[],"length":0,"stats":{"Line":1}},{"line":1110,"address":[],"length":0,"stats":{"Line":8880}},{"line":1111,"address":[],"length":0,"stats":{"Line":3}},{"line":1112,"address":[],"length":0,"stats":{"Line":1}},{"line":1113,"address":[],"length":0,"stats":{"Line":2}},{"line":1114,"address":[],"length":0,"stats":{"Line":1}},{"line":1118,"address":[],"length":0,"stats":{"Line":8877}},{"line":1119,"address":[],"length":0,"stats":{"Line":3}},{"line":1120,"address":[],"length":0,"stats":{"Line":1}},{"line":1121,"address":[],"length":0,"stats":{"Line":2}},{"line":1122,"address":[],"length":0,"stats":{"Line":1}},{"line":1126,"address":[],"length":0,"stats":{"Line":8874}},{"line":1127,"address":[],"length":0,"stats":{"Line":6}},{"line":1128,"address":[],"length":0,"stats":{"Line":2}},{"line":1129,"address":[],"length":0,"stats":{"Line":4}},{"line":1130,"address":[],"length":0,"stats":{"Line":2}},{"line":1134,"address":[],"length":0,"stats":{"Line":8868}},{"line":1135,"address":[],"length":0,"stats":{"Line":3}},{"line":1136,"address":[],"length":0,"stats":{"Line":1}},{"line":1137,"address":[],"length":0,"stats":{"Line":2}},{"line":1138,"address":[],"length":0,"stats":{"Line":1}},{"line":1142,"address":[],"length":0,"stats":{"Line":5910}},{"line":1145,"address":[],"length":0,"stats":{"Line":2955}},{"line":1146,"address":[],"length":0,"stats":{"Line":8865}},{"line":1149,"address":[],"length":0,"stats":{"Line":11847}},{"line":1151,"address":[],"length":0,"stats":{"Line":1641}},{"line":1152,"address":[],"length":0,"stats":{"Line":1641}},{"line":1153,"address":[],"length":0,"stats":{"Line":1094}},{"line":1154,"address":[],"length":0,"stats":{"Line":1094}},{"line":1155,"address":[],"length":0,"stats":{"Line":547}},{"line":1157,"address":[],"length":0,"stats":{"Line":10206}},{"line":1159,"address":[],"length":0,"stats":{"Line":567}},{"line":1161,"address":[],"length":0,"stats":{"Line":2}},{"line":1162,"address":[],"length":0,"stats":{"Line":4}},{"line":1163,"address":[],"length":0,"stats":{"Line":0}},{"line":1165,"address":[],"length":0,"stats":{"Line":3}},{"line":1167,"address":[],"length":0,"stats":{"Line":3}},{"line":1168,"address":[],"length":0,"stats":{"Line":2}},{"line":1169,"address":[],"length":0,"stats":{"Line":3}},{"line":1170,"address":[],"length":0,"stats":{"Line":1}},{"line":1171,"address":[],"length":0,"stats":{"Line":1}},{"line":1174,"address":[],"length":0,"stats":{"Line":564}},{"line":1175,"address":[],"length":0,"stats":{"Line":564}},{"line":1177,"address":[],"length":0,"stats":{"Line":8}},{"line":1178,"address":[],"length":0,"stats":{"Line":1}},{"line":1180,"address":[],"length":0,"stats":{"Line":3}},{"line":1182,"address":[],"length":0,"stats":{"Line":6}},{"line":1183,"address":[],"length":0,"stats":{"Line":4}},{"line":1184,"address":[],"length":0,"stats":{"Line":6}},{"line":1185,"address":[],"length":0,"stats":{"Line":2}},{"line":1186,"address":[],"length":0,"stats":{"Line":2}},{"line":1190,"address":[],"length":0,"stats":{"Line":558}},{"line":1191,"address":[],"length":0,"stats":{"Line":372}},{"line":1192,"address":[],"length":0,"stats":{"Line":558}},{"line":1193,"address":[],"length":0,"stats":{"Line":186}},{"line":1197,"address":[],"length":0,"stats":{"Line":9639}},{"line":1199,"address":[],"length":0,"stats":{"Line":1165}},{"line":1200,"address":[],"length":0,"stats":{"Line":466}},{"line":1201,"address":[],"length":0,"stats":{"Line":233}},{"line":1203,"address":[],"length":0,"stats":{"Line":0}},{"line":1205,"address":[],"length":0,"stats":{"Line":466}},{"line":1206,"address":[],"length":0,"stats":{"Line":466}},{"line":1207,"address":[],"length":0,"stats":{"Line":233}},{"line":1209,"address":[],"length":0,"stats":{"Line":8965}},{"line":1210,"address":[],"length":0,"stats":{"Line":50}},{"line":1211,"address":[],"length":0,"stats":{"Line":50}},{"line":1212,"address":[],"length":0,"stats":{"Line":25}},{"line":1214,"address":[],"length":0,"stats":{"Line":8892}},{"line":1215,"address":[],"length":0,"stats":{"Line":4}},{"line":1216,"address":[],"length":0,"stats":{"Line":4}},{"line":1217,"address":[],"length":0,"stats":{"Line":2}},{"line":1220,"address":[],"length":0,"stats":{"Line":2953}},{"line":1224,"address":[],"length":0,"stats":{"Line":2953}},{"line":1227,"address":[],"length":0,"stats":{"Line":548}},{"line":1228,"address":[],"length":0,"stats":{"Line":1644}},{"line":1231,"address":[],"length":0,"stats":{"Line":691}},{"line":1232,"address":[],"length":0,"stats":{"Line":1382}},{"line":1234,"address":[],"length":0,"stats":{"Line":1382}},{"line":1235,"address":[],"length":0,"stats":{"Line":2156}},{"line":1236,"address":[],"length":0,"stats":{"Line":2790}},{"line":1237,"address":[],"length":0,"stats":{"Line":1564}},{"line":1241,"address":[],"length":0,"stats":{"Line":691}},{"line":1244,"address":[],"length":0,"stats":{"Line":2955}},{"line":1246,"address":[],"length":0,"stats":{"Line":9295}},{"line":1247,"address":[],"length":0,"stats":{"Line":860}},{"line":1248,"address":[],"length":0,"stats":{"Line":430}},{"line":1250,"address":[],"length":0,"stats":{"Line":7583}},{"line":1251,"address":[],"length":0,"stats":{"Line":16}},{"line":1252,"address":[],"length":0,"stats":{"Line":8}},{"line":1254,"address":[],"length":0,"stats":{"Line":7552}},{"line":1255,"address":[],"length":0,"stats":{"Line":2}},{"line":1256,"address":[],"length":0,"stats":{"Line":1}},{"line":1258,"address":[],"length":0,"stats":{"Line":7830}},{"line":1259,"address":[],"length":0,"stats":{"Line":564}},{"line":1260,"address":[],"length":0,"stats":{"Line":282}},{"line":1262,"address":[],"length":0,"stats":{"Line":6704}},{"line":1263,"address":[],"length":0,"stats":{"Line":4}},{"line":1264,"address":[],"length":0,"stats":{"Line":2}},{"line":1266,"address":[],"length":0,"stats":{"Line":6840}},{"line":1267,"address":[],"length":0,"stats":{"Line":288}},{"line":1268,"address":[],"length":0,"stats":{"Line":144}},{"line":1270,"address":[],"length":0,"stats":{"Line":6380}},{"line":1271,"address":[],"length":0,"stats":{"Line":232}},{"line":1272,"address":[],"length":0,"stats":{"Line":116}},{"line":1274,"address":[],"length":0,"stats":{"Line":6092}},{"line":1275,"address":[],"length":0,"stats":{"Line":352}},{"line":1276,"address":[],"length":0,"stats":{"Line":176}},{"line":1280,"address":[],"length":0,"stats":{"Line":5388}},{"line":1281,"address":[],"length":0,"stats":{"Line":67}},{"line":1283,"address":[],"length":0,"stats":{"Line":5187}},{"line":1284,"address":[],"length":0,"stats":{"Line":16}},{"line":1286,"address":[],"length":0,"stats":{"Line":5139}},{"line":1287,"address":[],"length":0,"stats":{"Line":1}},{"line":1291,"address":[],"length":0,"stats":{"Line":5136}},{"line":1292,"address":[],"length":0,"stats":{"Line":572}},{"line":1293,"address":[],"length":0,"stats":{"Line":429}},{"line":1294,"address":[],"length":0,"stats":{"Line":143}},{"line":1298,"address":[],"length":0,"stats":{"Line":4707}},{"line":1299,"address":[],"length":0,"stats":{"Line":3}},{"line":1300,"address":[],"length":0,"stats":{"Line":3}},{"line":1301,"address":[],"length":0,"stats":{"Line":1}},{"line":1305,"address":[],"length":0,"stats":{"Line":4704}},{"line":1306,"address":[],"length":0,"stats":{"Line":276}},{"line":1307,"address":[],"length":0,"stats":{"Line":276}},{"line":1308,"address":[],"length":0,"stats":{"Line":92}},{"line":1312,"address":[],"length":0,"stats":{"Line":4428}},{"line":1313,"address":[],"length":0,"stats":{"Line":51}},{"line":1314,"address":[],"length":0,"stats":{"Line":17}},{"line":1318,"address":[],"length":0,"stats":{"Line":5834}},{"line":1319,"address":[],"length":0,"stats":{"Line":2914}},{"line":1322,"address":[],"length":0,"stats":{"Line":4371}},{"line":1324,"address":[],"length":0,"stats":{"Line":36}},{"line":1325,"address":[],"length":0,"stats":{"Line":81}},{"line":1326,"address":[],"length":0,"stats":{"Line":75}},{"line":1327,"address":[],"length":0,"stats":{"Line":45}},{"line":1328,"address":[],"length":0,"stats":{"Line":30}},{"line":1330,"address":[],"length":0,"stats":{"Line":0}},{"line":1333,"address":[],"length":0,"stats":{"Line":12}},{"line":1334,"address":[],"length":0,"stats":{"Line":12}},{"line":1335,"address":[],"length":0,"stats":{"Line":12}},{"line":1336,"address":[],"length":0,"stats":{"Line":12}},{"line":1340,"address":[],"length":0,"stats":{"Line":1445}},{"line":1343,"address":[],"length":0,"stats":{"Line":4}}],"covered":766,"coverable":783},{"path":["/","workspace","crates","ofml-lib","src","property.rs"],"content":"//! Property System - OFML property types and management.\n//!\n//! This module implements the property system for product configuration,\n//! including property types, states, and change callbacks.\n\nuse std::collections::HashMap;\n\nuse crate::errors::PropertyError;\n\n/// Property visibility/editability state.\n///\n/// Maps to OFML property states:\n/// - 0 = Hidden\n/// - 1 = Enabled\n/// - 2 = ReadOnly\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]\npub enum PropertyState {\n    /// Property is hidden (state = 0)\n    Hidden = 0,\n    /// Property is visible and editable (state = 1)\n    #[default]\n    Enabled = 1,\n    /// Property is visible but read-only (state = 2)\n    ReadOnly = 2,\n}\n\nimpl PropertyState {\n    /// Create from integer state value.\n    pub fn from_int(value: i32) -> Self {\n        match value {\n            0 => PropertyState::Hidden,\n            1 => PropertyState::Enabled,\n            2 => PropertyState::ReadOnly,\n            _ => PropertyState::Hidden,\n        }\n    }\n\n    /// Convert to integer state value.\n    pub fn to_int(self) -> i32 {\n        self as i32\n    }\n\n    /// Check if property is visible.\n    pub fn is_visible(self) -> bool {\n        !matches!(self, PropertyState::Hidden)\n    }\n\n    /// Check if property is editable.\n    pub fn is_editable(self) -> bool {\n        matches!(self, PropertyState::Enabled)\n    }\n}\n\n/// Property type enumeration.\n#[derive(Debug, Clone, PartialEq)]\npub enum PropertyType {\n    /// Boolean property (on/off)\n    Bool,\n    /// Integer property with optional range\n    Int { min: Option<i64>, max: Option<i64> },\n    /// Float property with optional range\n    Float { min: Option<f64>, max: Option<f64> },\n    /// String property\n    String,\n    /// Choice property with fixed options\n    Choice { options: Vec<String> },\n}\n\nimpl PropertyType {\n    /// Create an unbounded integer property type.\n    pub fn int() -> Self {\n        PropertyType::Int {\n            min: None,\n            max: None,\n        }\n    }\n\n    /// Create an integer property type with range.\n    pub fn int_range(min: i64, max: i64) -> Self {\n        PropertyType::Int {\n            min: Some(min),\n            max: Some(max),\n        }\n    }\n\n    /// Create an unbounded float property type.\n    pub fn float() -> Self {\n        PropertyType::Float {\n            min: None,\n            max: None,\n        }\n    }\n\n    /// Create a float property type with range.\n    pub fn float_range(min: f64, max: f64) -> Self {\n        PropertyType::Float {\n            min: Some(min),\n            max: Some(max),\n        }\n    }\n\n    /// Create a choice property type.\n    pub fn choice(options: Vec<String>) -> Self {\n        PropertyType::Choice { options }\n    }\n\n    /// Get the type name.\n    pub fn type_name(&self) -> &'static str {\n        match self {\n            PropertyType::Bool => \"bool\",\n            PropertyType::Int { .. } => \"int\",\n            PropertyType::Float { .. } => \"float\",\n            PropertyType::String => \"string\",\n            PropertyType::Choice { .. } => \"choice\",\n        }\n    }\n}\n\n/// Property value types.\n#[derive(Debug, Clone, PartialEq)]\npub enum PropertyValue {\n    /// Boolean value\n    Bool(bool),\n    /// Integer value\n    Int(i64),\n    /// Float value\n    Float(f64),\n    /// String value\n    String(String),\n    /// Symbol value (choice selection)\n    Symbol(String),\n}\n\nimpl PropertyValue {\n    /// Get as bool, if applicable.\n    pub fn as_bool(&self) -> Option<bool> {\n        match self {\n            PropertyValue::Bool(b) => Some(*b),\n            _ => None,\n        }\n    }\n\n    /// Get as i64, with type coercion.\n    pub fn as_i64(&self) -> Option<i64> {\n        match self {\n            PropertyValue::Int(i) => Some(*i),\n            PropertyValue::Float(f) => Some(*f as i64),\n            _ => None,\n        }\n    }\n\n    /// Get as f64, with type coercion.\n    pub fn as_f64(&self) -> Option<f64> {\n        match self {\n            PropertyValue::Float(f) => Some(*f),\n            PropertyValue::Int(i) => Some(*i as f64),\n            _ => None,\n        }\n    }\n\n    /// Get as string reference.\n    pub fn as_str(&self) -> Option<&str> {\n        match self {\n            PropertyValue::String(s) => Some(s),\n            PropertyValue::Symbol(s) => Some(s),\n            _ => None,\n        }\n    }\n\n    /// Get type name for error messages.\n    pub fn type_name(&self) -> &'static str {\n        match self {\n            PropertyValue::Bool(_) => \"bool\",\n            PropertyValue::Int(_) => \"int\",\n            PropertyValue::Float(_) => \"float\",\n            PropertyValue::String(_) => \"string\",\n            PropertyValue::Symbol(_) => \"symbol\",\n        }\n    }\n}\n\n/// Complete property definition including metadata.\n#[derive(Debug, Clone)]\npub struct PropertyDef {\n    /// Property name/key\n    pub name: String,\n    /// Display label (localized)\n    pub label: String,\n    /// Property type\n    pub prop_type: PropertyType,\n    /// Current state\n    pub state: PropertyState,\n    /// Sort order for UI display\n    pub sort_order: i32,\n    /// Tooltip/description\n    pub description: Option<String>,\n    /// Category for grouping\n    pub category: Option<String>,\n}\n\nimpl PropertyDef {\n    /// Create a new property definition.\n    pub fn new(name: impl Into<String>, label: impl Into<String>, prop_type: PropertyType) -> Self {\n        Self {\n            name: name.into(),\n            label: label.into(),\n            prop_type,\n            state: PropertyState::Enabled,\n            sort_order: 0,\n            description: None,\n            category: None,\n        }\n    }\n\n    /// Set the sort order.\n    pub fn with_sort_order(mut self, order: i32) -> Self {\n        self.sort_order = order;\n        self\n    }\n\n    /// Set the state.\n    pub fn with_state(mut self, state: PropertyState) -> Self {\n        self.state = state;\n        self\n    }\n\n    /// Set the description.\n    pub fn with_description(mut self, desc: impl Into<String>) -> Self {\n        self.description = Some(desc.into());\n        self\n    }\n\n    /// Set the category.\n    pub fn with_category(mut self, cat: impl Into<String>) -> Self {\n        self.category = Some(cat.into());\n        self\n    }\n\n    /// Validate a value against this property's type.\n    pub fn validate(&self, value: &PropertyValue) -> Result<(), PropertyError> {\n        match (&self.prop_type, value) {\n            (PropertyType::Bool, PropertyValue::Bool(_)) => Ok(()),\n            (PropertyType::Int { min, max }, PropertyValue::Int(i)) => {\n                if let Some(min) = min {\n                    if i < min {\n                        return Err(PropertyError::ValidationFailed {\n                            property: self.name.clone(),\n                            message: format!(\"Value {} is less than minimum {}\", i, min),\n                        });\n                    }\n                }\n                if let Some(max) = max {\n                    if i > max {\n                        return Err(PropertyError::ValidationFailed {\n                            property: self.name.clone(),\n                            message: format!(\"Value {} is greater than maximum {}\", i, max),\n                        });\n                    }\n                }\n                Ok(())\n            }\n            (PropertyType::Float { min, max }, PropertyValue::Float(f)) => {\n                if let Some(min) = min {\n                    if f < min {\n                        return Err(PropertyError::ValidationFailed {\n                            property: self.name.clone(),\n                            message: format!(\"Value {} is less than minimum {}\", f, min),\n                        });\n                    }\n                }\n                if let Some(max) = max {\n                    if f > max {\n                        return Err(PropertyError::ValidationFailed {\n                            property: self.name.clone(),\n                            message: format!(\"Value {} is greater than maximum {}\", f, max),\n                        });\n                    }\n                }\n                Ok(())\n            }\n            (PropertyType::String, PropertyValue::String(_)) => Ok(()),\n            (PropertyType::Choice { options }, PropertyValue::Symbol(s)) => {\n                if options.contains(s) {\n                    Ok(())\n                } else {\n                    Err(PropertyError::ValidationFailed {\n                        property: self.name.clone(),\n                        message: format!(\n                            \"Invalid choice '{}', valid options are: {:?}\",\n                            s, options\n                        ),\n                    })\n                }\n            }\n            // Allow int for float\n            (PropertyType::Float { .. }, PropertyValue::Int(_)) => Ok(()),\n            _ => Err(PropertyError::InvalidValue {\n                property: self.name.clone(),\n                message: format!(\n                    \"Expected type {}, got {}\",\n                    self.prop_type.type_name(),\n                    value.type_name()\n                ),\n            }),\n        }\n    }\n}\n\n/// Property manager for tracking property changes.\n#[derive(Debug, Clone)]\npub struct PropertyManager {\n    /// Property definitions\n    pub definitions: HashMap<String, PropertyDef>,\n    /// Current property values\n    pub values: HashMap<String, PropertyValue>,\n    /// Property states (may differ from definition state)\n    pub states: HashMap<String, PropertyState>,\n    /// Change callbacks (property name -> callback names)\n    pub callbacks: HashMap<String, Vec<String>>,\n}\n\nimpl PropertyManager {\n    /// Create a new property manager.\n    pub fn new() -> Self {\n        Self {\n            definitions: HashMap::new(),\n            values: HashMap::new(),\n            states: HashMap::new(),\n            callbacks: HashMap::new(),\n        }\n    }\n\n    /// Register a property definition.\n    pub fn register(&mut self, def: PropertyDef) {\n        let name = def.name.clone();\n        self.states.insert(name.clone(), def.state);\n        self.definitions.insert(name, def);\n    }\n\n    /// Get a property value.\n    pub fn get(&self, name: &str) -> Option<&PropertyValue> {\n        self.values.get(name)\n    }\n\n    /// Set a property value.\n    pub fn set(&mut self, name: &str, value: PropertyValue) -> Result<(), PropertyError> {\n        // Check if read-only\n        if let Some(state) = self.states.get(name) {\n            if *state == PropertyState::ReadOnly {\n                return Err(PropertyError::ReadOnly(name.to_string()));\n            }\n        }\n\n        // Validate if definition exists\n        if let Some(def) = self.definitions.get(name) {\n            def.validate(&value)?;\n        }\n\n        self.values.insert(name.to_string(), value);\n        Ok(())\n    }\n\n    /// Get property state.\n    pub fn get_state(&self, name: &str) -> Option<PropertyState> {\n        self.states.get(name).copied()\n    }\n\n    /// Set property state.\n    pub fn set_state(&mut self, name: &str, state: PropertyState) {\n        self.states.insert(name.to_string(), state);\n    }\n\n    /// Register a change callback.\n    pub fn add_callback(&mut self, property: &str, callback: impl Into<String>) {\n        self.callbacks\n            .entry(property.to_string())\n            .or_default()\n            .push(callback.into());\n    }\n\n    /// Get callbacks for a property.\n    pub fn get_callbacks(&self, property: &str) -> Option<&Vec<String>> {\n        self.callbacks.get(property)\n    }\n\n    /// Remove a property.\n    pub fn remove(&mut self, name: &str) {\n        self.definitions.remove(name);\n        self.values.remove(name);\n        self.states.remove(name);\n        self.callbacks.remove(name);\n    }\n\n    /// Get all property names.\n    pub fn property_names(&self) -> Vec<&String> {\n        self.definitions.keys().collect()\n    }\n\n    /// Check if property exists.\n    pub fn contains(&self, name: &str) -> bool {\n        self.definitions.contains_key(name)\n    }\n}\n\nimpl Default for PropertyManager {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_property_state() {\n        assert_eq!(PropertyState::from_int(0), PropertyState::Hidden);\n        assert_eq!(PropertyState::from_int(1), PropertyState::Enabled);\n        assert_eq!(PropertyState::from_int(2), PropertyState::ReadOnly);\n        assert_eq!(PropertyState::from_int(99), PropertyState::Hidden);\n\n        assert!(!PropertyState::Hidden.is_visible());\n        assert!(PropertyState::Enabled.is_visible());\n        assert!(PropertyState::ReadOnly.is_visible());\n\n        assert!(!PropertyState::Hidden.is_editable());\n        assert!(PropertyState::Enabled.is_editable());\n        assert!(!PropertyState::ReadOnly.is_editable());\n    }\n\n    #[test]\n    fn test_property_type() {\n        let int_type = PropertyType::int();\n        assert_eq!(int_type.type_name(), \"int\");\n\n        let int_range = PropertyType::int_range(0, 100);\n        if let PropertyType::Int { min, max } = int_range {\n            assert_eq!(min, Some(0));\n            assert_eq!(max, Some(100));\n        } else {\n            panic!(\"Expected Int type\");\n        }\n\n        let choice = PropertyType::choice(vec![\"a\".to_string(), \"b\".to_string()]);\n        if let PropertyType::Choice { options } = choice {\n            assert_eq!(options.len(), 2);\n        } else {\n            panic!(\"Expected Choice type\");\n        }\n    }\n\n    #[test]\n    fn test_property_value() {\n        let bool_val = PropertyValue::Bool(true);\n        assert_eq!(bool_val.as_bool(), Some(true));\n        assert_eq!(bool_val.type_name(), \"bool\");\n\n        let int_val = PropertyValue::Int(42);\n        assert_eq!(int_val.as_i64(), Some(42));\n        assert_eq!(int_val.as_f64(), Some(42.0));\n\n        let float_val = PropertyValue::Float(3.14);\n        assert_eq!(float_val.as_f64(), Some(3.14));\n        assert_eq!(float_val.as_i64(), Some(3));\n\n        let str_val = PropertyValue::String(\"hello\".to_string());\n        assert_eq!(str_val.as_str(), Some(\"hello\"));\n    }\n\n    #[test]\n    fn test_property_def() {\n        let def = PropertyDef::new(\"width\", \"Width\", PropertyType::float())\n            .with_sort_order(1)\n            .with_description(\"Product width in mm\")\n            .with_category(\"Dimensions\");\n\n        assert_eq!(def.name, \"width\");\n        assert_eq!(def.label, \"Width\");\n        assert_eq!(def.sort_order, 1);\n        assert_eq!(def.description, Some(\"Product width in mm\".to_string()));\n        assert_eq!(def.category, Some(\"Dimensions\".to_string()));\n    }\n\n    #[test]\n    fn test_property_def_validation() {\n        let int_def = PropertyDef::new(\"count\", \"Count\", PropertyType::int_range(0, 10));\n\n        assert!(int_def.validate(&PropertyValue::Int(5)).is_ok());\n        assert!(int_def.validate(&PropertyValue::Int(-1)).is_err());\n        assert!(int_def.validate(&PropertyValue::Int(11)).is_err());\n\n        let choice_def = PropertyDef::new(\n            \"color\",\n            \"Color\",\n            PropertyType::choice(vec![\"red\".to_string(), \"blue\".to_string()]),\n        );\n\n        assert!(choice_def\n            .validate(&PropertyValue::Symbol(\"red\".to_string()))\n            .is_ok());\n        assert!(choice_def\n            .validate(&PropertyValue::Symbol(\"green\".to_string()))\n            .is_err());\n    }\n\n    #[test]\n    fn test_property_manager() {\n        let mut manager = PropertyManager::new();\n\n        let def = PropertyDef::new(\"width\", \"Width\", PropertyType::float());\n        manager.register(def);\n\n        manager.set(\"width\", PropertyValue::Float(1000.0)).unwrap();\n\n        assert_eq!(manager.get(\"width\"), Some(&PropertyValue::Float(1000.0)));\n\n        manager.set_state(\"width\", PropertyState::ReadOnly);\n        assert!(manager.set(\"width\", PropertyValue::Float(2000.0)).is_err());\n    }\n\n    #[test]\n    fn test_property_manager_callbacks() {\n        let mut manager = PropertyManager::new();\n\n        manager.add_callback(\"width\", \"updateGeometry\");\n        manager.add_callback(\"width\", \"updatePrice\");\n\n        let callbacks = manager.get_callbacks(\"width\").unwrap();\n        assert_eq!(callbacks.len(), 2);\n        assert!(callbacks.contains(&\"updateGeometry\".to_string()));\n        assert!(callbacks.contains(&\"updatePrice\".to_string()));\n    }\n\n    #[test]\n    fn test_property_state_to_int() {\n        assert_eq!(PropertyState::Hidden.to_int(), 0);\n        assert_eq!(PropertyState::Enabled.to_int(), 1);\n        assert_eq!(PropertyState::ReadOnly.to_int(), 2);\n    }\n\n    #[test]\n    fn test_property_state_default() {\n        let state = PropertyState::default();\n        assert_eq!(state, PropertyState::Enabled);\n    }\n\n    #[test]\n    fn test_property_type_float_range() {\n        let float_type = PropertyType::float_range(0.0, 100.0);\n        if let PropertyType::Float { min, max } = float_type {\n            assert_eq!(min, Some(0.0));\n            assert_eq!(max, Some(100.0));\n        } else {\n            panic!(\"Expected Float type\");\n        }\n    }\n\n    #[test]\n    fn test_property_type_names() {\n        assert_eq!(PropertyType::Bool.type_name(), \"bool\");\n        assert_eq!(PropertyType::int().type_name(), \"int\");\n        assert_eq!(PropertyType::float().type_name(), \"float\");\n        assert_eq!(PropertyType::String.type_name(), \"string\");\n        assert_eq!(\n            PropertyType::choice(vec![\"a\".to_string()]).type_name(),\n            \"choice\"\n        );\n    }\n\n    #[test]\n    fn test_property_value_type_names() {\n        assert_eq!(PropertyValue::Bool(true).type_name(), \"bool\");\n        assert_eq!(PropertyValue::Int(42).type_name(), \"int\");\n        assert_eq!(PropertyValue::Float(3.14).type_name(), \"float\");\n        assert_eq!(PropertyValue::String(\"test\".to_string()).type_name(), \"string\");\n        assert_eq!(PropertyValue::Symbol(\"sym\".to_string()).type_name(), \"symbol\");\n    }\n\n    #[test]\n    fn test_property_value_as_str_symbol() {\n        let sym = PropertyValue::Symbol(\"option1\".to_string());\n        assert_eq!(sym.as_str(), Some(\"option1\"));\n    }\n\n    #[test]\n    fn test_property_value_as_none_cases() {\n        let bool_val = PropertyValue::Bool(true);\n        assert_eq!(bool_val.as_i64(), None);\n        assert_eq!(bool_val.as_f64(), None);\n        assert_eq!(bool_val.as_str(), None);\n\n        let int_val = PropertyValue::Int(42);\n        assert_eq!(int_val.as_bool(), None);\n        assert_eq!(int_val.as_str(), None);\n\n        let str_val = PropertyValue::String(\"test\".to_string());\n        assert_eq!(str_val.as_bool(), None);\n        assert_eq!(str_val.as_i64(), None);\n        assert_eq!(str_val.as_f64(), None);\n    }\n\n    #[test]\n    fn test_property_def_with_state() {\n        let def = PropertyDef::new(\"width\", \"Width\", PropertyType::float())\n            .with_state(PropertyState::ReadOnly);\n        assert_eq!(def.state, PropertyState::ReadOnly);\n    }\n\n    #[test]\n    fn test_property_def_validate_float_range() {\n        let float_def = PropertyDef::new(\"size\", \"Size\", PropertyType::float_range(0.0, 100.0));\n\n        assert!(float_def.validate(&PropertyValue::Float(50.0)).is_ok());\n        assert!(float_def.validate(&PropertyValue::Float(-1.0)).is_err());\n        assert!(float_def.validate(&PropertyValue::Float(101.0)).is_err());\n        // Int is allowed for float type\n        assert!(float_def.validate(&PropertyValue::Int(50)).is_ok());\n    }\n\n    #[test]\n    fn test_property_def_validate_bool() {\n        let bool_def = PropertyDef::new(\"enabled\", \"Enabled\", PropertyType::Bool);\n        assert!(bool_def.validate(&PropertyValue::Bool(true)).is_ok());\n        assert!(bool_def.validate(&PropertyValue::Bool(false)).is_ok());\n        assert!(bool_def.validate(&PropertyValue::Int(1)).is_err());\n    }\n\n    #[test]\n    fn test_property_def_validate_string() {\n        let str_def = PropertyDef::new(\"name\", \"Name\", PropertyType::String);\n        assert!(str_def.validate(&PropertyValue::String(\"hello\".to_string())).is_ok());\n        assert!(str_def.validate(&PropertyValue::Int(42)).is_err());\n    }\n\n    #[test]\n    fn test_property_def_validate_type_mismatch() {\n        let int_def = PropertyDef::new(\"count\", \"Count\", PropertyType::int());\n        let result = int_def.validate(&PropertyValue::String(\"not a number\".to_string()));\n        assert!(result.is_err());\n        if let Err(PropertyError::InvalidValue { property, message }) = result {\n            assert_eq!(property, \"count\");\n            assert!(message.contains(\"Expected type\"));\n        }\n    }\n\n    #[test]\n    fn test_property_manager_remove() {\n        let mut manager = PropertyManager::new();\n        let def = PropertyDef::new(\"width\", \"Width\", PropertyType::float());\n        manager.register(def);\n        manager.set(\"width\", PropertyValue::Float(100.0)).unwrap();\n        manager.add_callback(\"width\", \"callback\");\n\n        assert!(manager.contains(\"width\"));\n\n        manager.remove(\"width\");\n\n        assert!(!manager.contains(\"width\"));\n        assert!(manager.get(\"width\").is_none());\n        assert!(manager.get_callbacks(\"width\").is_none());\n        assert!(manager.get_state(\"width\").is_none());\n    }\n\n    #[test]\n    fn test_property_manager_property_names() {\n        let mut manager = PropertyManager::new();\n        manager.register(PropertyDef::new(\"width\", \"Width\", PropertyType::float()));\n        manager.register(PropertyDef::new(\"height\", \"Height\", PropertyType::float()));\n        manager.register(PropertyDef::new(\"depth\", \"Depth\", PropertyType::float()));\n\n        let names = manager.property_names();\n        assert_eq!(names.len(), 3);\n    }\n\n    #[test]\n    fn test_property_manager_contains() {\n        let mut manager = PropertyManager::new();\n        manager.register(PropertyDef::new(\"width\", \"Width\", PropertyType::float()));\n\n        assert!(manager.contains(\"width\"));\n        assert!(!manager.contains(\"height\"));\n    }\n\n    #[test]\n    fn test_property_manager_get_state() {\n        let mut manager = PropertyManager::new();\n        let def = PropertyDef::new(\"width\", \"Width\", PropertyType::float())\n            .with_state(PropertyState::Hidden);\n        manager.register(def);\n\n        assert_eq!(manager.get_state(\"width\"), Some(PropertyState::Hidden));\n        assert_eq!(manager.get_state(\"nonexistent\"), None);\n    }\n\n    #[test]\n    fn test_property_manager_default() {\n        let manager = PropertyManager::default();\n        assert!(manager.definitions.is_empty());\n        assert!(manager.values.is_empty());\n    }\n\n    #[test]\n    fn test_property_manager_set_without_definition() {\n        let mut manager = PropertyManager::new();\n        // Set without registering definition - should work but no validation\n        manager.set(\"width\", PropertyValue::Float(100.0)).unwrap();\n        assert_eq!(manager.get(\"width\"), Some(&PropertyValue::Float(100.0)));\n    }\n\n    #[test]\n    fn test_property_def_debug_clone() {\n        let def = PropertyDef::new(\"width\", \"Width\", PropertyType::float());\n        let debug_str = format!(\"{:?}\", def);\n        assert!(debug_str.contains(\"width\"));\n\n        let cloned = def.clone();\n        assert_eq!(cloned.name, \"width\");\n    }\n\n    #[test]\n    fn test_property_state_debug_clone() {\n        let state = PropertyState::Enabled;\n        let debug_str = format!(\"{:?}\", state);\n        assert!(debug_str.contains(\"Enabled\"));\n\n        let cloned = state.clone();\n        assert_eq!(cloned, PropertyState::Enabled);\n    }\n\n    #[test]\n    fn test_property_value_debug_clone() {\n        let value = PropertyValue::Int(42);\n        let debug_str = format!(\"{:?}\", value);\n        assert!(debug_str.contains(\"42\"));\n\n        let cloned = value.clone();\n        assert_eq!(cloned, PropertyValue::Int(42));\n    }\n\n    #[test]\n    fn test_property_type_debug_clone_partialeq() {\n        let prop_type = PropertyType::int_range(0, 100);\n        let debug_str = format!(\"{:?}\", prop_type);\n        assert!(debug_str.contains(\"Int\"));\n\n        let cloned = prop_type.clone();\n        assert_eq!(cloned, PropertyType::int_range(0, 100));\n        assert_ne!(cloned, PropertyType::float());\n    }\n\n    #[test]\n    fn test_property_manager_debug_clone() {\n        let mut manager = PropertyManager::new();\n        manager.register(PropertyDef::new(\"width\", \"Width\", PropertyType::float()));\n\n        let debug_str = format!(\"{:?}\", manager);\n        assert!(debug_str.contains(\"PropertyManager\"));\n\n        let cloned = manager.clone();\n        assert!(cloned.contains(\"width\"));\n    }\n\n    #[test]\n    fn test_property_value_partialeq() {\n        let val1 = PropertyValue::Int(42);\n        let val2 = PropertyValue::Int(42);\n        let val3 = PropertyValue::Int(43);\n\n        assert_eq!(val1, val2);\n        assert_ne!(val1, val3);\n\n        let str1 = PropertyValue::String(\"test\".to_string());\n        let str2 = PropertyValue::String(\"test\".to_string());\n        assert_eq!(str1, str2);\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":5}},{"line":30,"address":[],"length":0,"stats":{"Line":5}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":1}},{"line":34,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":3}},{"line":40,"address":[],"length":0,"stats":{"Line":3}},{"line":44,"address":[],"length":0,"stats":{"Line":3}},{"line":45,"address":[],"length":0,"stats":{"Line":5}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":5}},{"line":71,"address":[],"length":0,"stats":{"Line":3}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":87,"address":[],"length":0,"stats":{"Line":13}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":3}},{"line":108,"address":[],"length":0,"stats":{"Line":9}},{"line":109,"address":[],"length":0,"stats":{"Line":9}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":2}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":3}},{"line":137,"address":[],"length":0,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":139,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":4}},{"line":145,"address":[],"length":0,"stats":{"Line":4}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":147,"address":[],"length":0,"stats":{"Line":2}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":4}},{"line":154,"address":[],"length":0,"stats":{"Line":4}},{"line":155,"address":[],"length":0,"stats":{"Line":2}},{"line":156,"address":[],"length":0,"stats":{"Line":2}},{"line":157,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":4}},{"line":163,"address":[],"length":0,"stats":{"Line":4}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":171,"address":[],"length":0,"stats":{"Line":9}},{"line":172,"address":[],"length":0,"stats":{"Line":9}},{"line":173,"address":[],"length":0,"stats":{"Line":2}},{"line":174,"address":[],"length":0,"stats":{"Line":3}},{"line":175,"address":[],"length":0,"stats":{"Line":1}},{"line":176,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":1}},{"line":203,"address":[],"length":0,"stats":{"Line":17}},{"line":205,"address":[],"length":0,"stats":{"Line":51}},{"line":206,"address":[],"length":0,"stats":{"Line":51}},{"line":216,"address":[],"length":0,"stats":{"Line":1}},{"line":217,"address":[],"length":0,"stats":{"Line":1}},{"line":218,"address":[],"length":0,"stats":{"Line":1}},{"line":222,"address":[],"length":0,"stats":{"Line":2}},{"line":223,"address":[],"length":0,"stats":{"Line":2}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":228,"address":[],"length":0,"stats":{"Line":1}},{"line":229,"address":[],"length":0,"stats":{"Line":2}},{"line":230,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":1}},{"line":235,"address":[],"length":0,"stats":{"Line":2}},{"line":236,"address":[],"length":0,"stats":{"Line":1}},{"line":240,"address":[],"length":0,"stats":{"Line":17}},{"line":241,"address":[],"length":0,"stats":{"Line":34}},{"line":242,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":9}},{"line":244,"address":[],"length":0,"stats":{"Line":6}},{"line":245,"address":[],"length":0,"stats":{"Line":3}},{"line":246,"address":[],"length":0,"stats":{"Line":1}},{"line":247,"address":[],"length":0,"stats":{"Line":3}},{"line":248,"address":[],"length":0,"stats":{"Line":1}},{"line":252,"address":[],"length":0,"stats":{"Line":4}},{"line":253,"address":[],"length":0,"stats":{"Line":2}},{"line":254,"address":[],"length":0,"stats":{"Line":1}},{"line":255,"address":[],"length":0,"stats":{"Line":3}},{"line":256,"address":[],"length":0,"stats":{"Line":1}},{"line":260,"address":[],"length":0,"stats":{"Line":1}},{"line":262,"address":[],"length":0,"stats":{"Line":15}},{"line":263,"address":[],"length":0,"stats":{"Line":8}},{"line":264,"address":[],"length":0,"stats":{"Line":3}},{"line":265,"address":[],"length":0,"stats":{"Line":1}},{"line":266,"address":[],"length":0,"stats":{"Line":3}},{"line":267,"address":[],"length":0,"stats":{"Line":1}},{"line":271,"address":[],"length":0,"stats":{"Line":6}},{"line":272,"address":[],"length":0,"stats":{"Line":2}},{"line":273,"address":[],"length":0,"stats":{"Line":1}},{"line":274,"address":[],"length":0,"stats":{"Line":3}},{"line":275,"address":[],"length":0,"stats":{"Line":1}},{"line":279,"address":[],"length":0,"stats":{"Line":3}},{"line":281,"address":[],"length":0,"stats":{"Line":1}},{"line":282,"address":[],"length":0,"stats":{"Line":4}},{"line":283,"address":[],"length":0,"stats":{"Line":4}},{"line":284,"address":[],"length":0,"stats":{"Line":1}},{"line":286,"address":[],"length":0,"stats":{"Line":1}},{"line":287,"address":[],"length":0,"stats":{"Line":3}},{"line":288,"address":[],"length":0,"stats":{"Line":1}},{"line":289,"address":[],"length":0,"stats":{"Line":1}},{"line":290,"address":[],"length":0,"stats":{"Line":1}},{"line":296,"address":[],"length":0,"stats":{"Line":1}},{"line":297,"address":[],"length":0,"stats":{"Line":3}},{"line":298,"address":[],"length":0,"stats":{"Line":9}},{"line":299,"address":[],"length":0,"stats":{"Line":6}},{"line":300,"address":[],"length":0,"stats":{"Line":6}},{"line":301,"address":[],"length":0,"stats":{"Line":9}},{"line":302,"address":[],"length":0,"stats":{"Line":3}},{"line":324,"address":[],"length":0,"stats":{"Line":45}},{"line":326,"address":[],"length":0,"stats":{"Line":90}},{"line":327,"address":[],"length":0,"stats":{"Line":90}},{"line":328,"address":[],"length":0,"stats":{"Line":45}},{"line":329,"address":[],"length":0,"stats":{"Line":45}},{"line":334,"address":[],"length":0,"stats":{"Line":8}},{"line":335,"address":[],"length":0,"stats":{"Line":24}},{"line":336,"address":[],"length":0,"stats":{"Line":40}},{"line":337,"address":[],"length":0,"stats":{"Line":32}},{"line":341,"address":[],"length":0,"stats":{"Line":3}},{"line":342,"address":[],"length":0,"stats":{"Line":9}},{"line":346,"address":[],"length":0,"stats":{"Line":12}},{"line":348,"address":[],"length":0,"stats":{"Line":27}},{"line":349,"address":[],"length":0,"stats":{"Line":3}},{"line":350,"address":[],"length":0,"stats":{"Line":1}},{"line":355,"address":[],"length":0,"stats":{"Line":24}},{"line":356,"address":[],"length":0,"stats":{"Line":6}},{"line":359,"address":[],"length":0,"stats":{"Line":55}},{"line":360,"address":[],"length":0,"stats":{"Line":11}},{"line":364,"address":[],"length":0,"stats":{"Line":3}},{"line":365,"address":[],"length":0,"stats":{"Line":12}},{"line":369,"address":[],"length":0,"stats":{"Line":1}},{"line":370,"address":[],"length":0,"stats":{"Line":5}},{"line":374,"address":[],"length":0,"stats":{"Line":3}},{"line":375,"address":[],"length":0,"stats":{"Line":6}},{"line":376,"address":[],"length":0,"stats":{"Line":9}},{"line":378,"address":[],"length":0,"stats":{"Line":9}},{"line":382,"address":[],"length":0,"stats":{"Line":2}},{"line":383,"address":[],"length":0,"stats":{"Line":6}},{"line":387,"address":[],"length":0,"stats":{"Line":1}},{"line":388,"address":[],"length":0,"stats":{"Line":3}},{"line":389,"address":[],"length":0,"stats":{"Line":3}},{"line":390,"address":[],"length":0,"stats":{"Line":3}},{"line":391,"address":[],"length":0,"stats":{"Line":3}},{"line":395,"address":[],"length":0,"stats":{"Line":1}},{"line":396,"address":[],"length":0,"stats":{"Line":3}},{"line":400,"address":[],"length":0,"stats":{"Line":5}},{"line":401,"address":[],"length":0,"stats":{"Line":15}},{"line":406,"address":[],"length":0,"stats":{"Line":1}},{"line":407,"address":[],"length":0,"stats":{"Line":1}}],"covered":152,"coverable":152},{"path":["/","workspace","crates","ofml-lib","src","scene.rs"],"content":"//! Scene graph for OFML 3D objects\n//!\n//! This module provides a scene graph that tracks 3D objects created by CLS execution.\n//! Each node can have geometry (meshes), position, rotation, and child nodes.\n\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::path::Path;\nuse std::rc::Rc;\n\nuse crate::geometry::{\n    load_geometry_from_alb_raw, CoordSystem, GeometryError, Material3DS, Mesh, Scene3DS,\n};\n\n/// Type of geometry a scene node can have\n#[derive(Clone, Debug)]\npub enum Geometry {\n    /// No geometry (group node)\n    None,\n    /// Box primitive with dimensions [width, height, depth]\n    Block { width: f32, height: f32, depth: f32 },\n    /// External mesh loaded from 3DS file\n    Mesh(Scene3DS),\n    /// Cylinder primitive\n    Cylinder { radius: f32, height: f32 },\n    /// Sphere primitive\n    Sphere { radius: f32 },\n    /// Ellipsoid primitive with radii in x, y, z\n    Ellipsoid { rx: f32, ry: f32, rz: f32 },\n    /// Planar convex polygon with vertices\n    Polygon {\n        vertices: Vec<[f32; 2]>,\n        thickness: f32,\n    },\n    /// Frame/border geometry (rectangular with hole)\n    Frame(FrameDimensions),\n    /// Rotational sweep geometry (profile rotated around axis)\n    Rotation {\n        profile: Vec<[f32; 2]>, // 2D profile points (r, z)\n        segments: u32,          // Number of segments around\n        angle: f32,             // Rotation angle in radians (2œÄ for full)\n    },\n    /// Extrusion/sweep geometry (profile extruded along path)\n    Sweep {\n        profile: Vec<[f32; 2]>, // 2D profile points\n        path: Vec<[f32; 3]>,    // 3D path points\n        scale_along_path: bool, // Whether to scale profile along path\n    },\n}\n\n/// Dimensions for frame geometry (rectangular with centered hole)\n#[derive(Clone, Debug)]\npub struct FrameDimensions {\n    pub outer_width: f32,\n    pub outer_height: f32,\n    pub inner_width: f32,\n    pub inner_height: f32,\n    pub depth: f32,\n}\n\n/// Rotation axis constants (matching OFML @NX, @NY, @NZ)\n#[derive(Clone, Copy, Debug, PartialEq)]\npub enum Axis {\n    X, // @NX\n    Y, // @NY\n    Z, // @NZ\n}\n\n/// OFML Alignment mode for each axis\n/// @I = min bound (default), @C = center, @A = max bound\n#[derive(Clone, Copy, Debug, PartialEq, Default)]\npub enum AlignMode {\n    /// Use minimum bound (default in OFML, symbol @I)\n    #[default]\n    Min,\n    /// Use center (symbol @C)\n    Center,\n    /// Use maximum bound (symbol @A)\n    Max,\n}\n\n/// A node in the scene graph\n#[derive(Clone)]\npub struct SceneNode {\n    /// Unique identifier\n    pub id: u64,\n    /// Node name (e.g., \"geo\", \"leg_1\")\n    pub name: String,\n    /// Full path name (e.g., \"desk.plate.geo\")\n    pub full_name: String,\n    /// Node type (class name like \"OiPart\", \"OiBlock\")\n    pub node_type: String,\n    /// Geometry data\n    pub geometry: Geometry,\n    /// Position in local space [x, y, z] - set via setPosition()\n    pub position: [f32; 3],\n    /// Alignment offset [x, y, z] - set via setAlignment(), applied to geometry\n    /// This is the OFML \"geo.position\" that offsets geometry within the node\n    pub alignment_offset: [f32; 3],\n    /// Original geometry bounds before any transformations (for setAlignment calculations)\n    pub original_bounds: Option<[[f32; 3]; 2]>,\n    /// Rotation angles [rx, ry, rz] in radians\n    pub rotation: [f32; 3],\n    /// Scale factor\n    pub scale: f32,\n    /// Material name\n    pub material: String,\n    /// Parent node (weak reference to avoid cycles)\n    pub parent: Option<Rc<RefCell<SceneNode>>>,\n    /// Child nodes\n    pub children: Vec<Rc<RefCell<SceneNode>>>,\n    /// Whether this node is visible\n    pub visible: bool,\n    /// Whether this node is selectable\n    pub selectable: bool,\n    /// Custom properties\n    pub properties: HashMap<String, String>,\n}\n\nimpl SceneNode {\n    /// Create a new scene node\n    pub fn new(id: u64, name: String, node_type: String) -> Self {\n        Self {\n            id,\n            full_name: name.clone(),\n            name,\n            node_type,\n            geometry: Geometry::None,\n            position: [0.0, 0.0, 0.0],\n            alignment_offset: [0.0, 0.0, 0.0],\n            original_bounds: None,\n            rotation: [0.0, 0.0, 0.0],\n            scale: 1.0,\n            material: String::new(),\n            parent: None,\n            children: Vec::new(),\n            visible: true,\n            selectable: true,\n            properties: HashMap::new(),\n        }\n    }\n\n    /// Set position\n    pub fn set_position(&mut self, pos: [f32; 3]) {\n        self.position = pos;\n    }\n\n    /// Get position\n    pub fn get_position(&self) -> [f32; 3] {\n        self.position\n    }\n\n    /// Set alignment offset directly\n    pub fn set_alignment_offset(&mut self, offset: [f32; 3]) {\n        self.alignment_offset = offset;\n    }\n\n    /// Get alignment offset\n    pub fn get_alignment_offset(&self) -> [f32; 3] {\n        self.alignment_offset\n    }\n\n    /// Set alignment based on OFML alignment modes\n    /// This implements the OFML setAlignment() function:\n    /// - AlignMode::Min (@I) = use minimum bound (default)\n    /// - AlignMode::Center (@C) = use center\n    /// - AlignMode::Max (@A) = use maximum bound\n    ///\n    /// The alignment offset is set to the negative of the calculated point,\n    /// so that point becomes the origin of the geometry.\n    pub fn set_alignment(&mut self, align_x: AlignMode, align_y: AlignMode, align_z: AlignMode) {\n        // Use original bounds if available, otherwise calculate from current geometry\n        let bounds = self\n            .original_bounds\n            .unwrap_or_else(|| self.get_local_bounds());\n        let [min, max] = bounds;\n\n        // Calculate the alignment point for each axis\n        let x = match align_x {\n            AlignMode::Min => min[0],\n            AlignMode::Center => (min[0] + max[0]) / 2.0,\n            AlignMode::Max => max[0],\n        };\n        let y = match align_y {\n            AlignMode::Min => min[1],\n            AlignMode::Center => (min[1] + max[1]) / 2.0,\n            AlignMode::Max => max[1],\n        };\n        let z = match align_z {\n            AlignMode::Min => min[2],\n            AlignMode::Center => (min[2] + max[2]) / 2.0,\n            AlignMode::Max => max[2],\n        };\n\n        // Set the offset to negative of the alignment point\n        // This makes the alignment point the effective origin\n        self.alignment_offset = [-x, -y, -z];\n\n        // Debug\n        eprintln!(\"    setAlignment: bounds=[{:.2},{:.2},{:.2}]-[{:.2},{:.2},{:.2}] => offset=[{:.2}, {:.2}, {:.2}]\",\n            min[0], min[1], min[2], max[0], max[1], max[2],\n            self.alignment_offset[0], self.alignment_offset[1], self.alignment_offset[2]);\n    }\n\n    /// Apply default alignment: center X, ground Y, center Z\n    /// This is the most common alignment for furniture parts\n    pub fn set_default_alignment(&mut self) {\n        self.set_alignment(AlignMode::Center, AlignMode::Min, AlignMode::Center);\n    }\n\n    /// Set foot alignment for L-shaped or irregular geometry\n    /// This finds the ground contact point (centroid of vertices near Y=min)\n    /// and uses that as the X,Z anchor point instead of bounding box center.\n    /// Useful for L-shaped legs where the bounding box center isn't the contact point.\n    pub fn set_foot_alignment(&mut self) {\n        let bounds = self\n            .original_bounds\n            .unwrap_or_else(|| self.get_local_bounds());\n        let [min, max] = bounds;\n\n        // Default to bounding box center if we can't find foot vertices\n        let mut foot_x = (min[0] + max[0]) / 2.0;\n        let mut foot_z = (min[2] + max[2]) / 2.0;\n\n        // Find vertices near ground level and compute their centroid\n        if let Geometry::Mesh(scene) = &self.geometry {\n            let ground_threshold = min[1] + 0.02; // 2cm above minimum\n            let mut sum_x = 0.0f32;\n            let mut sum_z = 0.0f32;\n            let mut count = 0;\n\n            for mesh in &scene.meshes {\n                for v in &mesh.vertices {\n                    if v.y < ground_threshold {\n                        sum_x += v.x;\n                        sum_z += v.z;\n                        count += 1;\n                    }\n                }\n            }\n\n            if count > 0 {\n                foot_x = sum_x / count as f32;\n                foot_z = sum_z / count as f32;\n                eprintln!(\n                    \"    setFootAlignment: found {} ground vertices, foot at ({:.3}, {:.3})\",\n                    count, foot_x, foot_z\n                );\n            }\n        }\n\n        // Set offset to bring foot to origin, grounded\n        self.alignment_offset = [-foot_x, -min[1], -foot_z];\n        eprintln!(\n            \"    setFootAlignment: offset=[{:.2}, {:.2}, {:.2}]\",\n            self.alignment_offset[0], self.alignment_offset[1], self.alignment_offset[2]\n        );\n    }\n\n    /// Store the original bounds of the geometry (call after loading geometry)\n    pub fn store_original_bounds(&mut self) {\n        self.original_bounds = Some(self.get_local_bounds());\n    }\n\n    /// Rotate around an axis by an angle (in radians)\n    pub fn rotate(&mut self, axis: Axis, angle: f32) {\n        match axis {\n            Axis::X => self.rotation[0] += angle,\n            Axis::Y => self.rotation[1] += angle,\n            Axis::Z => self.rotation[2] += angle,\n        }\n    }\n\n    /// Set rotation directly\n    pub fn set_rotation(&mut self, axis: Axis, angle: f32) {\n        match axis {\n            Axis::X => self.rotation[0] = angle,\n            Axis::Y => self.rotation[1] = angle,\n            Axis::Z => self.rotation[2] = angle,\n        }\n    }\n\n    /// Get rotation around an axis\n    pub fn get_rotation(&self, axis: Axis) -> f32 {\n        match axis {\n            Axis::X => self.rotation[0],\n            Axis::Y => self.rotation[1],\n            Axis::Z => self.rotation[2],\n        }\n    }\n\n    /// Calculate world transform (position + rotation from parent chain)\n    pub fn get_world_position(&self) -> [f32; 3] {\n        let mut pos = self.position;\n        if let Some(ref parent) = self.parent {\n            let parent_pos = parent.borrow().get_world_position();\n            let parent_rot = parent.borrow().rotation;\n\n            // Apply parent rotation to local position\n            let rotated = rotate_point(pos, parent_rot);\n            pos = [\n                parent_pos[0] + rotated[0],\n                parent_pos[1] + rotated[1],\n                parent_pos[2] + rotated[2],\n            ];\n        }\n        pos\n    }\n\n    /// Get world rotation (accumulated from parent chain)\n    pub fn get_world_rotation(&self) -> [f32; 3] {\n        let mut rot = self.rotation;\n        if let Some(ref parent) = self.parent {\n            let parent_rot = parent.borrow().get_world_rotation();\n            rot = [\n                rot[0] + parent_rot[0],\n                rot[1] + parent_rot[1],\n                rot[2] + parent_rot[2],\n            ];\n        }\n        rot\n    }\n\n    /// Get local bounding box for geometry\n    pub fn get_local_bounds(&self) -> [[f32; 3]; 2] {\n        match &self.geometry {\n            Geometry::None => [[0.0; 3], [0.0; 3]],\n            Geometry::Block {\n                width,\n                height,\n                depth,\n            } => [[0.0, 0.0, 0.0], [*width, *height, *depth]],\n            Geometry::Mesh(scene) => {\n                let mut min = [f32::MAX; 3];\n                let mut max = [f32::MIN; 3];\n                for mesh in &scene.meshes {\n                    for v in &mesh.vertices {\n                        min[0] = min[0].min(v.x);\n                        min[1] = min[1].min(v.y);\n                        min[2] = min[2].min(v.z);\n                        max[0] = max[0].max(v.x);\n                        max[1] = max[1].max(v.y);\n                        max[2] = max[2].max(v.z);\n                    }\n                }\n                if min[0] == f32::MAX {\n                    [[0.0; 3], [0.0; 3]]\n                } else {\n                    [min, max]\n                }\n            }\n            Geometry::Cylinder { radius, height } => {\n                [[-*radius, 0.0, -*radius], [*radius, *height, *radius]]\n            }\n            Geometry::Sphere { radius } => [[-*radius; 3], [*radius; 3]],\n            Geometry::Ellipsoid { rx, ry, rz } => [[-*rx, -*ry, -*rz], [*rx, *ry, *rz]],\n            Geometry::Polygon {\n                vertices,\n                thickness,\n            } => {\n                if vertices.is_empty() {\n                    [[0.0; 3], [0.0; 3]]\n                } else {\n                    let mut min_x = f32::MAX;\n                    let mut min_z = f32::MAX;\n                    let mut max_x = f32::MIN;\n                    let mut max_z = f32::MIN;\n                    for v in vertices {\n                        min_x = min_x.min(v[0]);\n                        min_z = min_z.min(v[1]);\n                        max_x = max_x.max(v[0]);\n                        max_z = max_z.max(v[1]);\n                    }\n                    [[min_x, 0.0, min_z], [max_x, *thickness, max_z]]\n                }\n            }\n            Geometry::Frame(dims) => {\n                [[0.0, 0.0, 0.0], [dims.outer_width, dims.outer_height, dims.depth]]\n            }\n            Geometry::Rotation { profile, .. } => {\n                if profile.is_empty() {\n                    [[0.0; 3], [0.0; 3]]\n                } else {\n                    let mut max_r = 0.0f32;\n                    let mut min_z = f32::MAX;\n                    let mut max_z = f32::MIN;\n                    for p in profile {\n                        max_r = max_r.max(p[0].abs());\n                        min_z = min_z.min(p[1]);\n                        max_z = max_z.max(p[1]);\n                    }\n                    [[-max_r, min_z, -max_r], [max_r, max_z, max_r]]\n                }\n            }\n            Geometry::Sweep { profile, path, .. } => {\n                if profile.is_empty() || path.is_empty() {\n                    [[0.0; 3], [0.0; 3]]\n                } else {\n                    // Approximate bounds from path and profile extent\n                    let mut min = [f32::MAX; 3];\n                    let mut max = [f32::MIN; 3];\n                    let mut profile_extent = 0.0f32;\n                    for p in profile {\n                        profile_extent = profile_extent.max(p[0].abs()).max(p[1].abs());\n                    }\n                    for pt in path {\n                        min[0] = min[0].min(pt[0] - profile_extent);\n                        min[1] = min[1].min(pt[1] - profile_extent);\n                        min[2] = min[2].min(pt[2] - profile_extent);\n                        max[0] = max[0].max(pt[0] + profile_extent);\n                        max[1] = max[1].max(pt[1] + profile_extent);\n                        max[2] = max[2].max(pt[2] + profile_extent);\n                    }\n                    [min, max]\n                }\n            }\n        }\n    }\n\n    /// Add a child node\n    pub fn add_child(&mut self, child: Rc<RefCell<SceneNode>>) {\n        self.children.push(child);\n    }\n\n    /// Find child by name\n    pub fn find_child(&self, name: &str) -> Option<Rc<RefCell<SceneNode>>> {\n        for child in &self.children {\n            if child.borrow().name == name {\n                return Some(child.clone());\n            }\n        }\n        None\n    }\n\n    /// Recursively find node by path (e.g., \"geo.screen\")\n    pub fn find_by_path(&self, path: &str) -> Option<Rc<RefCell<SceneNode>>> {\n        let parts: Vec<&str> = path.split('.').collect();\n        if parts.is_empty() {\n            return None;\n        }\n\n        let first = parts[0];\n        for child in &self.children {\n            if child.borrow().name == first {\n                if parts.len() == 1 {\n                    return Some(child.clone());\n                } else {\n                    let rest = parts[1..].join(\".\");\n                    return child.borrow().find_by_path(&rest);\n                }\n            }\n        }\n        None\n    }\n}\n\n/// Rotate a point by euler angles [rx, ry, rz]\nfn rotate_point(point: [f32; 3], rotation: [f32; 3]) -> [f32; 3] {\n    let [x, y, z] = point;\n    let [rx, ry, rz] = rotation;\n\n    // Rotate around X\n    let (sin_x, cos_x) = rx.sin_cos();\n    let y1 = y * cos_x - z * sin_x;\n    let z1 = y * sin_x + z * cos_x;\n\n    // Rotate around Y\n    let (sin_y, cos_y) = ry.sin_cos();\n    let x2 = x * cos_y + z1 * sin_y;\n    let z2 = -x * sin_y + z1 * cos_y;\n\n    // Rotate around Z\n    let (sin_z, cos_z) = rz.sin_cos();\n    let x3 = x2 * cos_z - y1 * sin_z;\n    let y3 = x2 * sin_z + y1 * cos_z;\n\n    [x3, y3, z2]\n}\n\n/// The scene graph manages all 3D objects\npub struct SceneGraph {\n    /// All nodes indexed by ID\n    nodes: HashMap<u64, Rc<RefCell<SceneNode>>>,\n    /// Nodes indexed by full name\n    nodes_by_name: HashMap<String, Rc<RefCell<SceneNode>>>,\n    /// Root nodes (nodes without parents)\n    pub roots: Vec<Rc<RefCell<SceneNode>>>,\n    /// Next available node ID\n    next_id: u64,\n    /// Path to ALB archive for loading geometry\n    pub alb_path: Option<std::path::PathBuf>,\n}\n\nimpl SceneGraph {\n    /// Create a new scene graph\n    pub fn new() -> Self {\n        Self {\n            nodes: HashMap::new(),\n            nodes_by_name: HashMap::new(),\n            roots: Vec::new(),\n            next_id: 1,\n            alb_path: None,\n        }\n    }\n\n    /// Set the ALB archive path for geometry loading\n    pub fn set_alb_path(&mut self, path: &Path) {\n        self.alb_path = Some(path.to_path_buf());\n    }\n\n    /// Create a new node\n    pub fn create_node(\n        &mut self,\n        name: String,\n        node_type: String,\n        parent: Option<Rc<RefCell<SceneNode>>>,\n    ) -> Rc<RefCell<SceneNode>> {\n        let id = self.next_id;\n        self.next_id += 1;\n\n        let full_name = if let Some(ref p) = parent {\n            format!(\"{}.{}\", p.borrow().full_name, name)\n        } else {\n            name.clone()\n        };\n\n        let node = Rc::new(RefCell::new(SceneNode::new(id, name, node_type)));\n        node.borrow_mut().full_name = full_name.clone();\n\n        if let Some(ref p) = parent {\n            node.borrow_mut().parent = Some(p.clone());\n            p.borrow_mut().add_child(node.clone());\n        } else {\n            self.roots.push(node.clone());\n        }\n\n        self.nodes.insert(id, node.clone());\n        self.nodes_by_name.insert(full_name, node.clone());\n        node\n    }\n\n    /// Create an OiPart node\n    pub fn create_part(\n        &mut self,\n        name: String,\n        parent: Option<Rc<RefCell<SceneNode>>>,\n    ) -> Rc<RefCell<SceneNode>> {\n        self.create_node(name, \"OiPart\".to_string(), parent)\n    }\n\n    /// Create an OiBlock node with dimensions\n    pub fn create_block(\n        &mut self,\n        name: String,\n        dims: [f32; 3],\n        parent: Option<Rc<RefCell<SceneNode>>>,\n    ) -> Rc<RefCell<SceneNode>> {\n        let node = self.create_node(name, \"OiBlock\".to_string(), parent);\n        node.borrow_mut().geometry = Geometry::Block {\n            width: dims[0],\n            height: dims[1],\n            depth: dims[2],\n        };\n        node\n    }\n\n    /// Create a cylinder geometry node\n    pub fn create_cylinder(\n        &mut self,\n        name: String,\n        radius: f32,\n        height: f32,\n        parent: Option<Rc<RefCell<SceneNode>>>,\n    ) -> Rc<RefCell<SceneNode>> {\n        let node = self.create_node(name, \"OiCylinder\".to_string(), parent);\n        node.borrow_mut().geometry = Geometry::Cylinder { radius, height };\n        node\n    }\n\n    /// Create a sphere geometry node\n    pub fn create_sphere(\n        &mut self,\n        name: String,\n        radius: f32,\n        parent: Option<Rc<RefCell<SceneNode>>>,\n    ) -> Rc<RefCell<SceneNode>> {\n        let node = self.create_node(name, \"OiSphere\".to_string(), parent);\n        node.borrow_mut().geometry = Geometry::Sphere { radius };\n        node\n    }\n\n    /// Create an ellipsoid geometry node\n    pub fn create_ellipsoid(\n        &mut self,\n        name: String,\n        rx: f32,\n        ry: f32,\n        rz: f32,\n        parent: Option<Rc<RefCell<SceneNode>>>,\n    ) -> Rc<RefCell<SceneNode>> {\n        let node = self.create_node(name, \"OiEllipsoid\".to_string(), parent);\n        node.borrow_mut().geometry = Geometry::Ellipsoid { rx, ry, rz };\n        node\n    }\n\n    /// Create a polygon geometry node\n    pub fn create_polygon(\n        &mut self,\n        name: String,\n        vertices: Vec<[f32; 2]>,\n        thickness: f32,\n        parent: Option<Rc<RefCell<SceneNode>>>,\n    ) -> Rc<RefCell<SceneNode>> {\n        let node = self.create_node(name, \"OiPolygon\".to_string(), parent);\n        node.borrow_mut().geometry = Geometry::Polygon {\n            vertices,\n            thickness,\n        };\n        node\n    }\n\n    /// Create a frame geometry node (rectangular with hole)\n    pub fn create_frame(\n        &mut self,\n        name: String,\n        dims: FrameDimensions,\n        parent: Option<Rc<RefCell<SceneNode>>>,\n    ) -> Rc<RefCell<SceneNode>> {\n        let node = self.create_node(name, \"OiFrame\".to_string(), parent);\n        node.borrow_mut().geometry = Geometry::Frame(dims);\n        node\n    }\n\n    /// Create a rotation (lathe) geometry node\n    pub fn create_rotation(\n        &mut self,\n        name: String,\n        profile: Vec<[f32; 2]>,\n        segments: u32,\n        angle: f32,\n        parent: Option<Rc<RefCell<SceneNode>>>,\n    ) -> Rc<RefCell<SceneNode>> {\n        let node = self.create_node(name, \"OiRotation\".to_string(), parent);\n        node.borrow_mut().geometry = Geometry::Rotation {\n            profile,\n            segments,\n            angle,\n        };\n        node\n    }\n\n    /// Create a sweep (extrusion) geometry node\n    pub fn create_sweep(\n        &mut self,\n        name: String,\n        profile: Vec<[f32; 2]>,\n        path: Vec<[f32; 3]>,\n        scale_along_path: bool,\n        parent: Option<Rc<RefCell<SceneNode>>>,\n    ) -> Rc<RefCell<SceneNode>> {\n        let node = self.create_node(name, \"OiSweep\".to_string(), parent);\n        node.borrow_mut().geometry = Geometry::Sweep {\n            profile,\n            path,\n            scale_along_path,\n        };\n        node\n    }\n\n    /// Check if a node exists by full name\n    pub fn exists(&self, full_name: &str) -> bool {\n        self.nodes_by_name.contains_key(full_name)\n    }\n\n    /// Get node by full name\n    pub fn get_by_name(&self, full_name: &str) -> Option<Rc<RefCell<SceneNode>>> {\n        self.nodes_by_name.get(full_name).cloned()\n    }\n\n    /// Remove a node by ID\n    pub fn remove_node(&mut self, id: u64) {\n        if let Some(node) = self.nodes.remove(&id) {\n            let full_name = node.borrow().full_name.clone();\n            self.nodes_by_name.remove(&full_name);\n\n            // Remove from parent's children\n            if let Some(ref parent) = node.borrow().parent {\n                parent.borrow_mut().children.retain(|c| c.borrow().id != id);\n            }\n\n            // Remove from roots if it's a root\n            self.roots.retain(|r| r.borrow().id != id);\n\n            // Recursively remove children\n            let children: Vec<_> = node.borrow().children.clone();\n            for child in children {\n                self.remove_node(child.borrow().id);\n            }\n        }\n    }\n\n    /// Load geometry from ALB archive into a node (uses internal alb_path)\n    /// Geometry is loaded with raw coordinates. No alignment is applied by default.\n    /// Call setAlignment() to position the geometry origin.\n    pub fn load_geometry(\n        &mut self,\n        node: Rc<RefCell<SceneNode>>,\n        pattern: &str,\n    ) -> Result<(), GeometryError> {\n        let alb_path = self.alb_path.as_ref().ok_or_else(|| {\n            GeometryError::Io(std::io::Error::new(\n                std::io::ErrorKind::NotFound,\n                \"No ALB path set\",\n            ))\n        })?;\n\n        let (scene, bounds) = load_geometry_from_alb_raw(alb_path, pattern)?;\n        let mut node_mut = node.borrow_mut();\n        node_mut.geometry = Geometry::Mesh(scene);\n        node_mut.original_bounds = Some(bounds);\n        // No default alignment - geometry uses raw coordinates\n        // CLS can call setAlignment() to set the origin point\n        Ok(())\n    }\n\n    /// Load 3D geometry (3DS or OBJ) from a specific ALB archive into a node\n    /// Geometry is loaded with raw coordinates. No alignment is applied by default.\n    /// Call setAlignment() to position the geometry origin.\n    pub fn load_3ds_from_alb(\n        &mut self,\n        node: Rc<RefCell<SceneNode>>,\n        alb_path: &Path,\n        pattern: &str,\n    ) -> Result<(), GeometryError> {\n        let (scene, bounds) = load_geometry_from_alb_raw(alb_path, pattern)?;\n\n        // Debug: print raw geometry bounds and transform\n        eprintln!(\n            \"  Loaded '{}': raw bounds min=[{:.4}, {:.4}, {:.4}] max=[{:.4}, {:.4}, {:.4}]\",\n            pattern,\n            bounds[0][0],\n            bounds[0][1],\n            bounds[0][2],\n            bounds[1][0],\n            bounds[1][1],\n            bounds[1][2]\n        );\n        // Print mesh transform if available\n        for mesh in &scene.meshes {\n            eprintln!(\"    Transform: [{:.2}, {:.2}, {:.2}] [{:.2}, {:.2}, {:.2}] [{:.2}, {:.2}, {:.2}] T=[{:.2}, {:.2}, {:.2}]\",\n                mesh.transform[0], mesh.transform[1], mesh.transform[2],\n                mesh.transform[3], mesh.transform[4], mesh.transform[5],\n                mesh.transform[6], mesh.transform[7], mesh.transform[8],\n                mesh.transform[9], mesh.transform[10], mesh.transform[11]);\n        }\n\n        let mut node_mut = node.borrow_mut();\n        node_mut.geometry = Geometry::Mesh(scene);\n        node_mut.original_bounds = Some(bounds);\n        // No default alignment - geometry uses raw coordinates\n        // CLS can call setAlignment() to set the origin point\n        Ok(())\n    }\n\n    /// Convert scene graph to a Scene3DS for export\n    pub fn to_scene(&self) -> Scene3DS {\n        let mut scene = Scene3DS::default();\n\n        for root in &self.roots {\n            self.collect_meshes(&root.borrow(), &mut scene, [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]);\n        }\n\n        scene\n    }\n\n    /// Recursively collect meshes from nodes\n    fn collect_meshes(\n        &self,\n        node: &SceneNode,\n        scene: &mut Scene3DS,\n        parent_pos: [f32; 3],\n        parent_rot: [f32; 3],\n    ) {\n        if !node.visible {\n            return;\n        }\n\n        // Calculate world transform\n        let local_pos = node.position;\n        let rotated_pos = rotate_point(local_pos, parent_rot);\n        let world_pos = [\n            parent_pos[0] + rotated_pos[0],\n            parent_pos[1] + rotated_pos[1],\n            parent_pos[2] + rotated_pos[2],\n        ];\n        let world_rot = [\n            parent_rot[0] + node.rotation[0],\n            parent_rot[1] + node.rotation[1],\n            parent_rot[2] + node.rotation[2],\n        ];\n\n        // Get alignment offset - this is applied to geometry within the node\n        let align_offset = node.alignment_offset;\n\n        // Get material name from node (may be empty)\n        let material_name = if !node.material.is_empty() {\n            Some(node.material.clone())\n        } else {\n            None\n        };\n\n        // Ensure material exists in scene if specified\n        if let Some(ref mat_name) = material_name {\n            if !scene.materials.contains_key(mat_name) {\n                // Create a default material with a color based on the material name\n                let color = material_name_to_color(mat_name);\n                scene.materials.insert(\n                    mat_name.clone(),\n                    Material3DS {\n                        name: mat_name.clone(),\n                        ambient: color,\n                        diffuse: color,\n                        specular: [0.3, 0.3, 0.3],\n                        texture: None,\n                        metallic: 0.0,\n                        roughness: 0.5,\n                    },\n                );\n            }\n        }\n\n        match &node.geometry {\n            Geometry::None => {}\n            Geometry::Block {\n                width,\n                height,\n                depth,\n            } => {\n                // For blocks, apply alignment offset to the position\n                let adjusted_pos = [\n                    world_pos[0] + align_offset[0],\n                    world_pos[1] + align_offset[1],\n                    world_pos[2] + align_offset[2],\n                ];\n                let mut mesh =\n                    create_box_mesh(&node.name, *width, *height, *depth, adjusted_pos, world_rot);\n                mesh.material_name = material_name.clone();\n                scene.meshes.push(mesh);\n            }\n            Geometry::Mesh(src_scene) => {\n                // Copy materials from source scene\n                for (name, mat) in &src_scene.materials {\n                    if !scene.materials.contains_key(name) {\n                        scene.materials.insert(name.clone(), mat.clone());\n                    }\n                }\n\n                for src_mesh in &src_scene.meshes {\n                    let mut mesh = src_mesh.clone();\n                    // Apply alignment offset first (geometry offset within node)\n                    mesh.translate(align_offset);\n                    // Then apply world transform (rotations in X, Y, Z order)\n                    mesh.rotate_x(world_rot[0]);\n                    mesh.rotate_y(world_rot[1]);\n                    mesh.rotate_z(world_rot[2]);\n                    mesh.translate(world_pos);\n\n                    // Override material if set on node\n                    if material_name.is_some() {\n                        mesh.material_name = material_name.clone();\n                    }\n\n                    // Debug: print final mesh bounds\n                    let (min, max) = mesh.bounds();\n                    eprintln!(\n                        \"  Final '{}': bounds=[{:.2},{:.2},{:.2}]-[{:.2},{:.2},{:.2}]\",\n                        node.name, min[0], min[1], min[2], max[0], max[1], max[2]\n                    );\n\n                    scene.meshes.push(mesh);\n                }\n            }\n            Geometry::Cylinder { radius, height } => {\n                let adjusted_pos = [\n                    world_pos[0] + align_offset[0],\n                    world_pos[1] + align_offset[1],\n                    world_pos[2] + align_offset[2],\n                ];\n                let mut mesh =\n                    create_cylinder_mesh(&node.name, *radius, *height, 16, adjusted_pos, world_rot);\n                mesh.material_name = material_name.clone();\n                scene.meshes.push(mesh);\n            }\n            Geometry::Sphere { radius } => {\n                let adjusted_pos = [\n                    world_pos[0] + align_offset[0],\n                    world_pos[1] + align_offset[1],\n                    world_pos[2] + align_offset[2],\n                ];\n                let mut mesh = create_sphere_mesh(&node.name, *radius, 16, 8, adjusted_pos);\n                mesh.material_name = material_name.clone();\n                scene.meshes.push(mesh);\n            }\n            Geometry::Ellipsoid { rx, ry, rz } => {\n                let adjusted_pos = [\n                    world_pos[0] + align_offset[0],\n                    world_pos[1] + align_offset[1],\n                    world_pos[2] + align_offset[2],\n                ];\n                let mut mesh =\n                    create_ellipsoid_mesh(&node.name, *rx, *ry, *rz, 16, 8, adjusted_pos);\n                mesh.material_name = material_name.clone();\n                scene.meshes.push(mesh);\n            }\n            Geometry::Polygon {\n                vertices,\n                thickness,\n            } => {\n                let adjusted_pos = [\n                    world_pos[0] + align_offset[0],\n                    world_pos[1] + align_offset[1],\n                    world_pos[2] + align_offset[2],\n                ];\n                let mut mesh =\n                    create_polygon_mesh(&node.name, vertices, *thickness, adjusted_pos, world_rot);\n                mesh.material_name = material_name.clone();\n                scene.meshes.push(mesh);\n            }\n            Geometry::Frame(ref dims) => {\n                let adjusted_pos = [\n                    world_pos[0] + align_offset[0],\n                    world_pos[1] + align_offset[1],\n                    world_pos[2] + align_offset[2],\n                ];\n                let mut mesh = create_frame_mesh(&node.name, dims, adjusted_pos, world_rot);\n                mesh.material_name = material_name.clone();\n                scene.meshes.push(mesh);\n            }\n            Geometry::Rotation {\n                profile,\n                segments,\n                angle,\n            } => {\n                let adjusted_pos = [\n                    world_pos[0] + align_offset[0],\n                    world_pos[1] + align_offset[1],\n                    world_pos[2] + align_offset[2],\n                ];\n                let mut mesh =\n                    create_rotation_mesh(&node.name, profile, *segments, *angle, adjusted_pos);\n                mesh.material_name = material_name.clone();\n                scene.meshes.push(mesh);\n            }\n            Geometry::Sweep {\n                profile,\n                path,\n                scale_along_path,\n            } => {\n                let adjusted_pos = [\n                    world_pos[0] + align_offset[0],\n                    world_pos[1] + align_offset[1],\n                    world_pos[2] + align_offset[2],\n                ];\n                let mut mesh =\n                    create_sweep_mesh(&node.name, profile, path, *scale_along_path, adjusted_pos);\n                mesh.material_name = material_name.clone();\n                scene.meshes.push(mesh);\n            }\n        }\n\n        // Process children\n        for child in &node.children {\n            self.collect_meshes(&child.borrow(), scene, world_pos, world_rot);\n        }\n    }\n\n    /// Debug print the scene graph\n    pub fn debug_print(&self) {\n        println!(\"Scene Graph ({} nodes):\", self.nodes.len());\n        for root in &self.roots {\n            self.debug_print_node(&root.borrow(), 0);\n        }\n    }\n\n    fn debug_print_node(&self, node: &SceneNode, indent: usize) {\n        let prefix = \"  \".repeat(indent);\n        let geo_info = match &node.geometry {\n            Geometry::None => \"\".to_string(),\n            Geometry::Block {\n                width,\n                height,\n                depth,\n            } => format!(\" [Block {}x{}x{}]\", width, height, depth),\n            Geometry::Mesh(scene) => format!(\" [Mesh {} meshes]\", scene.meshes.len()),\n            Geometry::Cylinder { radius, height } => {\n                format!(\" [Cylinder r={} h={}]\", radius, height)\n            }\n            Geometry::Sphere { radius } => format!(\" [Sphere r={}]\", radius),\n            Geometry::Ellipsoid { rx, ry, rz } => {\n                format!(\" [Ellipsoid rx={} ry={} rz={}]\", rx, ry, rz)\n            }\n            Geometry::Polygon {\n                vertices,\n                thickness,\n            } => format!(\" [Polygon {} verts t={}]\", vertices.len(), thickness),\n            Geometry::Frame(dims) => {\n                format!(\" [Frame {}x{}x{}]\", dims.outer_width, dims.outer_height, dims.depth)\n            }\n            Geometry::Rotation {\n                profile, segments, ..\n            } => format!(\" [Rotation {} pts {} segs]\", profile.len(), segments),\n            Geometry::Sweep { profile, path, .. } => {\n                format!(\" [Sweep {} profile {} path]\", profile.len(), path.len())\n            }\n        };\n        println!(\n            \"{}{} ({}){}  pos={:?} rot={:?}\",\n            prefix, node.name, node.node_type, geo_info, node.position, node.rotation\n        );\n\n        for child in &node.children {\n            self.debug_print_node(&child.borrow(), indent + 1);\n        }\n    }\n\n    /// Get total mesh count\n    pub fn mesh_count(&self) -> usize {\n        let mut count = 0;\n        for root in &self.roots {\n            count += self.count_meshes(&root.borrow());\n        }\n        count\n    }\n\n    fn count_meshes(&self, node: &SceneNode) -> usize {\n        let mut count = match &node.geometry {\n            Geometry::None => 0,\n            Geometry::Block { .. } => 1,\n            Geometry::Mesh(scene) => scene.meshes.len(),\n            Geometry::Cylinder { .. } => 1,\n            Geometry::Sphere { .. } => 1,\n            Geometry::Ellipsoid { .. } => 1,\n            Geometry::Polygon { .. } => 1,\n            Geometry::Frame(_) => 1,\n            Geometry::Rotation { .. } => 1,\n            Geometry::Sweep { .. } => 1,\n        };\n        for child in &node.children {\n            count += self.count_meshes(&child.borrow());\n        }\n        count\n    }\n}\n\nimpl Default for SceneGraph {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Convert OFML material name to a default color\n/// Material names like \"::vitra::material::grey\" get parsed for color hints\nfn material_name_to_color(name: &str) -> [f32; 3] {\n    let lower = name.to_lowercase();\n\n    // Check for common color keywords in material name\n    if lower.contains(\"grey\") || lower.contains(\"gray\") {\n        return [0.5, 0.5, 0.5];\n    }\n    if lower.contains(\"dark\") {\n        return [0.2, 0.2, 0.2];\n    }\n    if lower.contains(\"light\") || lower.contains(\"soft_light\") {\n        return [0.85, 0.85, 0.85];\n    }\n    if lower.contains(\"white\") {\n        return [0.95, 0.95, 0.95];\n    }\n    if lower.contains(\"black\") {\n        return [0.1, 0.1, 0.1];\n    }\n    if lower.contains(\"red\") {\n        return [0.8, 0.2, 0.2];\n    }\n    if lower.contains(\"blue\") {\n        return [0.2, 0.3, 0.8];\n    }\n    if lower.contains(\"green\") {\n        return [0.2, 0.7, 0.3];\n    }\n    if lower.contains(\"wood\") || lower.contains(\"oak\") || lower.contains(\"walnut\") {\n        return [0.6, 0.45, 0.3];\n    }\n    if lower.contains(\"metal\") || lower.contains(\"chrome\") || lower.contains(\"aluminium\") {\n        return [0.7, 0.72, 0.75];\n    }\n    if lower.contains(\"melamine\") || lower.contains(\"hpl\") {\n        return [0.9, 0.88, 0.85];\n    }\n\n    // Default neutral color\n    [0.7, 0.7, 0.7]\n}\n\n/// Create a box mesh\n/// In OFML, boxes are positioned by their corner (0,0,0) and extend to (width, height, depth)\nfn create_box_mesh(\n    name: &str,\n    width: f32,\n    height: f32,\n    depth: f32,\n    pos: [f32; 3],\n    rot: [f32; 3],\n) -> Mesh {\n    use crate::geometry::{Face, Vertex};\n\n    // Create 8 corners from origin (0,0,0) to (width, height, depth)\n    // This matches OFML OiBlock semantics where position is the corner, not center\n    let corners = [\n        [0.0, 0.0, 0.0],\n        [width, 0.0, 0.0],\n        [width, height, 0.0],\n        [0.0, height, 0.0],\n        [0.0, 0.0, depth],\n        [width, 0.0, depth],\n        [width, height, depth],\n        [0.0, height, depth],\n    ];\n\n    // Apply rotation and translation\n    let vertices: Vec<Vertex> = corners\n        .iter()\n        .map(|c| {\n            let rotated = rotate_point(*c, rot);\n            Vertex {\n                x: rotated[0] + pos[0],\n                y: rotated[1] + pos[1],\n                z: rotated[2] + pos[2],\n            }\n        })\n        .collect();\n\n    // Create faces (2 triangles per face, 6 faces)\n    let faces = vec![\n        // Front\n        Face {\n            a: 0,\n            b: 1,\n            c: 2,\n            flags: 0,\n        },\n        Face {\n            a: 0,\n            b: 2,\n            c: 3,\n            flags: 0,\n        },\n        // Back\n        Face {\n            a: 5,\n            b: 4,\n            c: 7,\n            flags: 0,\n        },\n        Face {\n            a: 5,\n            b: 7,\n            c: 6,\n            flags: 0,\n        },\n        // Left\n        Face {\n            a: 4,\n            b: 0,\n            c: 3,\n            flags: 0,\n        },\n        Face {\n            a: 4,\n            b: 3,\n            c: 7,\n            flags: 0,\n        },\n        // Right\n        Face {\n            a: 1,\n            b: 5,\n            c: 6,\n            flags: 0,\n        },\n        Face {\n            a: 1,\n            b: 6,\n            c: 2,\n            flags: 0,\n        },\n        // Top\n        Face {\n            a: 3,\n            b: 2,\n            c: 6,\n            flags: 0,\n        },\n        Face {\n            a: 3,\n            b: 6,\n            c: 7,\n            flags: 0,\n        },\n        // Bottom\n        Face {\n            a: 4,\n            b: 5,\n            c: 1,\n            flags: 0,\n        },\n        Face {\n            a: 4,\n            b: 1,\n            c: 0,\n            flags: 0,\n        },\n    ];\n\n    Mesh {\n        name: name.to_string(),\n        vertices,\n        normals: Vec::new(),\n        faces,\n        tex_coords: vec![],\n        material_name: None,\n        transform: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0],\n        coord_system: CoordSystem::YupGltf, // Already in GLTF coords, no conversion needed\n    }\n}\n\n/// Create a cylinder mesh\nfn create_cylinder_mesh(\n    name: &str,\n    radius: f32,\n    height: f32,\n    segments: u16,\n    pos: [f32; 3],\n    _rot: [f32; 3],\n) -> Mesh {\n    use crate::geometry::{Face, Vertex};\n    use std::f32::consts::PI;\n\n    let mut vertices = Vec::new();\n    let mut faces = Vec::new();\n\n    // Bottom center\n    vertices.push(Vertex {\n        x: pos[0],\n        y: pos[1],\n        z: pos[2],\n    });\n    // Top center\n    vertices.push(Vertex {\n        x: pos[0],\n        y: pos[1] + height,\n        z: pos[2],\n    });\n\n    // Create ring vertices\n    for i in 0..segments {\n        let angle = (i as f32 / segments as f32) * 2.0 * PI;\n        let x = radius * angle.cos();\n        let z = radius * angle.sin();\n\n        // Bottom ring\n        vertices.push(Vertex {\n            x: pos[0] + x,\n            y: pos[1],\n            z: pos[2] + z,\n        });\n        // Top ring\n        vertices.push(Vertex {\n            x: pos[0] + x,\n            y: pos[1] + height,\n            z: pos[2] + z,\n        });\n    }\n\n    // Create faces\n    for i in 0..segments {\n        let b1 = 2 + i * 2;\n        let t1 = 3 + i * 2;\n        let b2 = 2 + ((i + 1) % segments) * 2;\n        let t2 = 3 + ((i + 1) % segments) * 2;\n\n        // Bottom face\n        faces.push(Face {\n            a: 0,\n            b: b2,\n            c: b1,\n            flags: 0,\n        });\n        // Top face\n        faces.push(Face {\n            a: 1,\n            b: t1,\n            c: t2,\n            flags: 0,\n        });\n        // Side faces\n        faces.push(Face {\n            a: b1,\n            b: b2,\n            c: t2,\n            flags: 0,\n        });\n        faces.push(Face {\n            a: b1,\n            b: t2,\n            c: t1,\n            flags: 0,\n        });\n    }\n\n    Mesh {\n        name: name.to_string(),\n        vertices,\n        normals: Vec::new(),\n        faces,\n        tex_coords: vec![],\n        material_name: None,\n        transform: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0],\n        coord_system: CoordSystem::YupGltf, // Already in GLTF coords, no conversion needed\n    }\n}\n\n/// Create a sphere mesh (simplified - uses icosphere approach)\nfn create_sphere_mesh(\n    name: &str,\n    radius: f32,\n    lat_segments: u16,\n    lon_segments: u16,\n    pos: [f32; 3],\n) -> Mesh {\n    use crate::geometry::{Face, Vertex};\n    use std::f32::consts::PI;\n\n    let mut vertices = Vec::new();\n    let mut faces = Vec::new();\n\n    // Create vertices\n    for lat in 0..=lat_segments {\n        let theta = (lat as f32 / lat_segments as f32) * PI;\n        let sin_theta = theta.sin();\n        let cos_theta = theta.cos();\n\n        for lon in 0..=lon_segments {\n            let phi = (lon as f32 / lon_segments as f32) * 2.0 * PI;\n            let x = radius * sin_theta * phi.cos();\n            let y = radius * cos_theta;\n            let z = radius * sin_theta * phi.sin();\n\n            vertices.push(Vertex {\n                x: pos[0] + x,\n                y: pos[1] + y,\n                z: pos[2] + z,\n            });\n        }\n    }\n\n    // Create faces\n    for lat in 0..lat_segments {\n        for lon in 0..lon_segments {\n            let first = lat * (lon_segments + 1) + lon;\n            let second = first + lon_segments + 1;\n\n            faces.push(Face {\n                a: first,\n                b: second,\n                c: first + 1,\n                flags: 0,\n            });\n            faces.push(Face {\n                a: second,\n                b: second + 1,\n                c: first + 1,\n                flags: 0,\n            });\n        }\n    }\n\n    Mesh {\n        name: name.to_string(),\n        vertices,\n        normals: Vec::new(),\n        faces,\n        tex_coords: vec![],\n        material_name: None,\n        transform: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0],\n        coord_system: CoordSystem::YupGltf, // Already in GLTF coords, no conversion needed\n    }\n}\n\n/// Create an ellipsoid mesh\nfn create_ellipsoid_mesh(\n    name: &str,\n    rx: f32,\n    ry: f32,\n    rz: f32,\n    lat_segments: u16,\n    lon_segments: u16,\n    pos: [f32; 3],\n) -> Mesh {\n    use crate::geometry::{Face, Vertex};\n    use std::f32::consts::PI;\n\n    let mut vertices = Vec::new();\n    let mut faces = Vec::new();\n\n    // Create vertices - same as sphere but with different radii per axis\n    for lat in 0..=lat_segments {\n        let theta = (lat as f32 / lat_segments as f32) * PI;\n        let sin_theta = theta.sin();\n        let cos_theta = theta.cos();\n\n        for lon in 0..=lon_segments {\n            let phi = (lon as f32 / lon_segments as f32) * 2.0 * PI;\n            let x = rx * sin_theta * phi.cos();\n            let y = ry * cos_theta;\n            let z = rz * sin_theta * phi.sin();\n\n            vertices.push(Vertex {\n                x: pos[0] + x,\n                y: pos[1] + y,\n                z: pos[2] + z,\n            });\n        }\n    }\n\n    // Create faces\n    for lat in 0..lat_segments {\n        for lon in 0..lon_segments {\n            let first = lat * (lon_segments + 1) + lon;\n            let second = first + lon_segments + 1;\n\n            faces.push(Face {\n                a: first,\n                b: second,\n                c: first + 1,\n                flags: 0,\n            });\n            faces.push(Face {\n                a: second,\n                b: second + 1,\n                c: first + 1,\n                flags: 0,\n            });\n        }\n    }\n\n    Mesh {\n        name: name.to_string(),\n        vertices,\n        normals: Vec::new(),\n        faces,\n        tex_coords: vec![],\n        material_name: None,\n        transform: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0],\n        coord_system: CoordSystem::YupGltf,\n    }\n}\n\n/// Create a polygon mesh (extruded 2D polygon)\nfn create_polygon_mesh(\n    name: &str,\n    vertices_2d: &[[f32; 2]],\n    thickness: f32,\n    pos: [f32; 3],\n    _rot: [f32; 3],\n) -> Mesh {\n    use crate::geometry::{Face, Vertex};\n\n    let mut vertices = Vec::new();\n    let mut faces = Vec::new();\n\n    if vertices_2d.len() < 3 {\n        return Mesh {\n            name: name.to_string(),\n            vertices,\n            normals: Vec::new(),\n            faces,\n            tex_coords: vec![],\n            material_name: None,\n            transform: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0],\n            coord_system: CoordSystem::YupGltf,\n        };\n    }\n\n    let n = vertices_2d.len();\n\n    // Bottom face vertices\n    for v in vertices_2d {\n        vertices.push(Vertex {\n            x: pos[0] + v[0],\n            y: pos[1],\n            z: pos[2] + v[1],\n        });\n    }\n\n    // Top face vertices\n    for v in vertices_2d {\n        vertices.push(Vertex {\n            x: pos[0] + v[0],\n            y: pos[1] + thickness,\n            z: pos[2] + v[1],\n        });\n    }\n\n    // Bottom face (triangle fan)\n    for i in 1..(n - 1) {\n        faces.push(Face {\n            a: 0,\n            b: (i + 1) as u16,\n            c: i as u16,\n            flags: 0,\n        });\n    }\n\n    // Top face (triangle fan)\n    for i in 1..(n - 1) {\n        faces.push(Face {\n            a: n as u16,\n            b: (n + i) as u16,\n            c: (n + i + 1) as u16,\n            flags: 0,\n        });\n    }\n\n    // Side faces\n    for i in 0..n {\n        let next = (i + 1) % n;\n        let b0 = i as u16;\n        let b1 = next as u16;\n        let t0 = (n + i) as u16;\n        let t1 = (n + next) as u16;\n\n        faces.push(Face {\n            a: b0,\n            b: b1,\n            c: t0,\n            flags: 0,\n        });\n        faces.push(Face {\n            a: t0,\n            b: b1,\n            c: t1,\n            flags: 0,\n        });\n    }\n\n    Mesh {\n        name: name.to_string(),\n        vertices,\n        normals: Vec::new(),\n        faces,\n        tex_coords: vec![],\n        material_name: None,\n        transform: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0],\n        coord_system: CoordSystem::YupGltf,\n    }\n}\n\n/// Create a frame mesh (rectangular with a hole)\nfn create_frame_mesh(name: &str, dims: &FrameDimensions, pos: [f32; 3], _rot: [f32; 3]) -> Mesh {\n    use crate::geometry::{Face, Vertex};\n\n    let mut vertices = Vec::new();\n    let mut faces = Vec::new();\n\n    // Calculate inner offsets (centered hole)\n    let inner_offset_x = (dims.outer_width - dims.inner_width) / 2.0;\n    let inner_offset_y = (dims.outer_height - dims.inner_height) / 2.0;\n\n    // Outer rectangle vertices (bottom and top)\n    let outer_verts = [\n        [0.0, 0.0],\n        [dims.outer_width, 0.0],\n        [dims.outer_width, dims.outer_height],\n        [0.0, dims.outer_height],\n    ];\n\n    // Inner rectangle vertices (bottom and top)\n    let inner_verts = [\n        [inner_offset_x, inner_offset_y],\n        [inner_offset_x + dims.inner_width, inner_offset_y],\n        [inner_offset_x + dims.inner_width, inner_offset_y + dims.inner_height],\n        [inner_offset_x, inner_offset_y + dims.inner_height],\n    ];\n\n    // Create vertices: outer bottom, inner bottom, outer top, inner top\n    for v in &outer_verts {\n        vertices.push(Vertex {\n            x: pos[0] + v[0],\n            y: pos[1],\n            z: pos[2] + v[1],\n        });\n    }\n    for v in &inner_verts {\n        vertices.push(Vertex {\n            x: pos[0] + v[0],\n            y: pos[1],\n            z: pos[2] + v[1],\n        });\n    }\n    for v in &outer_verts {\n        vertices.push(Vertex {\n            x: pos[0] + v[0],\n            y: pos[1] + dims.depth,\n            z: pos[2] + v[1],\n        });\n    }\n    for v in &inner_verts {\n        vertices.push(Vertex {\n            x: pos[0] + v[0],\n            y: pos[1] + dims.depth,\n            z: pos[2] + v[1],\n        });\n    }\n\n    // Bottom face (4 quads around the hole)\n    // Each segment connects outer edge to inner edge\n    for i in 0..4 {\n        let o0 = i as u16;\n        let o1 = ((i + 1) % 4) as u16;\n        let i0 = (4 + i) as u16;\n        let i1 = (4 + (i + 1) % 4) as u16;\n        faces.push(Face {\n            a: o0,\n            b: o1,\n            c: i0,\n            flags: 0,\n        });\n        faces.push(Face {\n            a: i0,\n            b: o1,\n            c: i1,\n            flags: 0,\n        });\n    }\n\n    // Top face (4 quads around the hole)\n    for i in 0..4 {\n        let o0 = (8 + i) as u16;\n        let o1 = (8 + (i + 1) % 4) as u16;\n        let i0 = (12 + i) as u16;\n        let i1 = (12 + (i + 1) % 4) as u16;\n        faces.push(Face {\n            a: o0,\n            b: i0,\n            c: o1,\n            flags: 0,\n        });\n        faces.push(Face {\n            a: i0,\n            b: i1,\n            c: o1,\n            flags: 0,\n        });\n    }\n\n    // Outer side faces\n    for i in 0..4 {\n        let b0 = i as u16;\n        let b1 = ((i + 1) % 4) as u16;\n        let t0 = (8 + i) as u16;\n        let t1 = (8 + (i + 1) % 4) as u16;\n        faces.push(Face {\n            a: b0,\n            b: t0,\n            c: b1,\n            flags: 0,\n        });\n        faces.push(Face {\n            a: t0,\n            b: t1,\n            c: b1,\n            flags: 0,\n        });\n    }\n\n    // Inner side faces (facing inward)\n    for i in 0..4 {\n        let b0 = (4 + i) as u16;\n        let b1 = (4 + (i + 1) % 4) as u16;\n        let t0 = (12 + i) as u16;\n        let t1 = (12 + (i + 1) % 4) as u16;\n        faces.push(Face {\n            a: b0,\n            b: b1,\n            c: t0,\n            flags: 0,\n        });\n        faces.push(Face {\n            a: t0,\n            b: b1,\n            c: t1,\n            flags: 0,\n        });\n    }\n\n    Mesh {\n        name: name.to_string(),\n        vertices,\n        normals: Vec::new(),\n        faces,\n        tex_coords: vec![],\n        material_name: None,\n        transform: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0],\n        coord_system: CoordSystem::YupGltf,\n    }\n}\n\n/// Create a rotation (lathe) mesh\nfn create_rotation_mesh(\n    name: &str,\n    profile: &[[f32; 2]],\n    segments: u32,\n    angle: f32,\n    pos: [f32; 3],\n) -> Mesh {\n    use crate::geometry::{Face, Vertex};\n\n    let mut vertices = Vec::new();\n    let mut faces = Vec::new();\n\n    if profile.len() < 2 || segments == 0 {\n        return Mesh {\n            name: name.to_string(),\n            vertices,\n            normals: Vec::new(),\n            faces,\n            tex_coords: vec![],\n            material_name: None,\n            transform: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0],\n            coord_system: CoordSystem::YupGltf,\n        };\n    }\n\n    let n_profile = profile.len();\n\n    // Generate vertices by rotating profile around Y axis\n    for seg in 0..=segments {\n        let theta = (seg as f32 / segments as f32) * angle;\n        let cos_t = theta.cos();\n        let sin_t = theta.sin();\n\n        for pt in profile {\n            let r = pt[0]; // radial distance\n            let y = pt[1]; // height\n\n            vertices.push(Vertex {\n                x: pos[0] + r * cos_t,\n                y: pos[1] + y,\n                z: pos[2] + r * sin_t,\n            });\n        }\n    }\n\n    // Generate faces\n    for seg in 0..segments {\n        for i in 0..(n_profile - 1) {\n            let base = (seg as usize) * n_profile + i;\n            let next_seg = ((seg + 1) as usize) * n_profile + i;\n\n            faces.push(Face {\n                a: base as u16,\n                b: next_seg as u16,\n                c: (base + 1) as u16,\n                flags: 0,\n            });\n            faces.push(Face {\n                a: next_seg as u16,\n                b: (next_seg + 1) as u16,\n                c: (base + 1) as u16,\n                flags: 0,\n            });\n        }\n    }\n\n    Mesh {\n        name: name.to_string(),\n        vertices,\n        normals: Vec::new(),\n        faces,\n        tex_coords: vec![],\n        material_name: None,\n        transform: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0],\n        coord_system: CoordSystem::YupGltf,\n    }\n}\n\n/// Create a sweep (extrusion) mesh\nfn create_sweep_mesh(\n    name: &str,\n    profile: &[[f32; 2]],\n    path: &[[f32; 3]],\n    _scale_along_path: bool,\n    pos: [f32; 3],\n) -> Mesh {\n    use crate::geometry::{Face, Vertex};\n\n    let mut vertices = Vec::new();\n    let mut faces = Vec::new();\n\n    if profile.len() < 3 || path.len() < 2 {\n        return Mesh {\n            name: name.to_string(),\n            vertices,\n            normals: Vec::new(),\n            faces,\n            tex_coords: vec![],\n            material_name: None,\n            transform: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0],\n            coord_system: CoordSystem::YupGltf,\n        };\n    }\n\n    let n_profile = profile.len();\n    let n_path = path.len();\n\n    // Simple extrusion: place profile at each path point\n    // (In a full implementation, we'd compute proper normals and banking)\n    for (path_idx, path_pt) in path.iter().enumerate() {\n        // Calculate tangent direction\n        let tangent = if path_idx == 0 {\n            let next = path[1];\n            [\n                next[0] - path_pt[0],\n                next[1] - path_pt[1],\n                next[2] - path_pt[2],\n            ]\n        } else if path_idx == n_path - 1 {\n            let prev = path[path_idx - 1];\n            [\n                path_pt[0] - prev[0],\n                path_pt[1] - prev[1],\n                path_pt[2] - prev[2],\n            ]\n        } else {\n            let prev = path[path_idx - 1];\n            let next = path[path_idx + 1];\n            [\n                (next[0] - prev[0]) / 2.0,\n                (next[1] - prev[1]) / 2.0,\n                (next[2] - prev[2]) / 2.0,\n            ]\n        };\n\n        // Normalize tangent\n        let len =\n            (tangent[0] * tangent[0] + tangent[1] * tangent[1] + tangent[2] * tangent[2]).sqrt();\n        let tangent = if len > 0.0001 {\n            [tangent[0] / len, tangent[1] / len, tangent[2] / len]\n        } else {\n            [0.0, 1.0, 0.0]\n        };\n\n        // Calculate perpendicular vectors (simple approach)\n        // Use cross product with up vector\n        let up = [0.0, 1.0, 0.0];\n        let right = [\n            tangent[1] * up[2] - tangent[2] * up[1],\n            tangent[2] * up[0] - tangent[0] * up[2],\n            tangent[0] * up[1] - tangent[1] * up[0],\n        ];\n        let right_len = (right[0] * right[0] + right[1] * right[1] + right[2] * right[2]).sqrt();\n        let right = if right_len > 0.0001 {\n            [\n                right[0] / right_len,\n                right[1] / right_len,\n                right[2] / right_len,\n            ]\n        } else {\n            [1.0, 0.0, 0.0]\n        };\n\n        // Calculate actual up vector\n        let actual_up = [\n            tangent[1] * right[2] - tangent[2] * right[1],\n            tangent[2] * right[0] - tangent[0] * right[2],\n            tangent[0] * right[1] - tangent[1] * right[0],\n        ];\n\n        // Place profile vertices\n        for prof_pt in profile {\n            let x = path_pt[0] + prof_pt[0] * right[0] + prof_pt[1] * actual_up[0];\n            let y = path_pt[1] + prof_pt[0] * right[1] + prof_pt[1] * actual_up[1];\n            let z = path_pt[2] + prof_pt[0] * right[2] + prof_pt[1] * actual_up[2];\n\n            vertices.push(Vertex {\n                x: pos[0] + x,\n                y: pos[1] + y,\n                z: pos[2] + z,\n            });\n        }\n    }\n\n    // Generate faces connecting adjacent profile rings\n    for path_idx in 0..(n_path - 1) {\n        for i in 0..n_profile {\n            let next_i = (i + 1) % n_profile;\n\n            let base = path_idx * n_profile + i;\n            let base_next = path_idx * n_profile + next_i;\n            let top = (path_idx + 1) * n_profile + i;\n            let top_next = (path_idx + 1) * n_profile + next_i;\n\n            faces.push(Face {\n                a: base as u16,\n                b: top as u16,\n                c: base_next as u16,\n                flags: 0,\n            });\n            faces.push(Face {\n                a: top as u16,\n                b: top_next as u16,\n                c: base_next as u16,\n                flags: 0,\n            });\n        }\n    }\n\n    // Cap the ends (simple triangle fan)\n    // Start cap\n    for i in 1..(n_profile - 1) {\n        faces.push(Face {\n            a: 0,\n            b: (i + 1) as u16,\n            c: i as u16,\n            flags: 0,\n        });\n    }\n\n    // End cap\n    let end_base = (n_path - 1) * n_profile;\n    for i in 1..(n_profile - 1) {\n        faces.push(Face {\n            a: end_base as u16,\n            b: (end_base + i) as u16,\n            c: (end_base + i + 1) as u16,\n            flags: 0,\n        });\n    }\n\n    Mesh {\n        name: name.to_string(),\n        vertices,\n        normals: Vec::new(),\n        faces,\n        tex_coords: vec![],\n        material_name: None,\n        transform: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0],\n        coord_system: CoordSystem::YupGltf,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_scene_graph_basic() {\n        let mut scene = SceneGraph::new();\n\n        let root = scene.create_part(\"desk\".to_string(), None);\n        let plate = scene.create_part(\"plate\".to_string(), Some(root.clone()));\n        let _geo = scene.create_block(\"geo\".to_string(), [1.6, 0.025, 0.8], Some(plate.clone()));\n\n        assert_eq!(scene.nodes.len(), 3);\n        assert!(scene.exists(\"desk.plate.geo\"));\n    }\n\n    #[test]\n    fn test_world_position() {\n        let mut scene = SceneGraph::new();\n\n        let root = scene.create_part(\"root\".to_string(), None);\n        root.borrow_mut().set_position([1.0, 0.0, 0.0]);\n\n        let child = scene.create_part(\"child\".to_string(), Some(root.clone()));\n        child.borrow_mut().set_position([0.0, 1.0, 0.0]);\n\n        let world_pos = child.borrow().get_world_position();\n        assert!((world_pos[0] - 1.0).abs() < 0.001);\n        assert!((world_pos[1] - 1.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_scene_node_new() {\n        let node = SceneNode::new(1, \"test\".to_string(), \"OiPart\".to_string());\n        assert_eq!(node.id, 1);\n        assert_eq!(node.name, \"test\");\n        assert_eq!(node.node_type, \"OiPart\");\n        assert!(matches!(node.geometry, Geometry::None));\n        assert_eq!(node.position, [0.0, 0.0, 0.0]);\n        assert!(node.visible);\n        assert!(node.selectable);\n    }\n\n    #[test]\n    fn test_scene_node_set_position() {\n        let mut node = SceneNode::new(1, \"test\".to_string(), \"OiPart\".to_string());\n        node.set_position([1.0, 2.0, 3.0]);\n        assert_eq!(node.get_position(), [1.0, 2.0, 3.0]);\n    }\n\n    #[test]\n    fn test_scene_node_alignment_offset() {\n        let mut node = SceneNode::new(1, \"test\".to_string(), \"OiPart\".to_string());\n        node.set_alignment_offset([0.5, 0.5, 0.5]);\n        assert_eq!(node.get_alignment_offset(), [0.5, 0.5, 0.5]);\n    }\n\n    #[test]\n    fn test_scene_node_rotate() {\n        let mut node = SceneNode::new(1, \"test\".to_string(), \"OiPart\".to_string());\n        node.rotate(Axis::X, 0.5);\n        assert_eq!(node.get_rotation(Axis::X), 0.5);\n\n        node.rotate(Axis::X, 0.3);\n        assert!((node.get_rotation(Axis::X) - 0.8).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_scene_node_set_rotation() {\n        let mut node = SceneNode::new(1, \"test\".to_string(), \"OiPart\".to_string());\n        node.set_rotation(Axis::Y, 1.57);\n        assert!((node.get_rotation(Axis::Y) - 1.57).abs() < 0.001);\n\n        node.set_rotation(Axis::Z, 3.14);\n        assert!((node.get_rotation(Axis::Z) - 3.14).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_scene_graph_create_primitives() {\n        let mut scene = SceneGraph::new();\n\n        // Cylinder\n        let cyl = scene.create_cylinder(\"cyl\".to_string(), 0.5, 1.0, None);\n        if let Geometry::Cylinder { radius, height } = &cyl.borrow().geometry {\n            assert_eq!(*radius, 0.5);\n            assert_eq!(*height, 1.0);\n        } else {\n            panic!(\"Expected Cylinder geometry\");\n        }\n\n        // Sphere\n        let sph = scene.create_sphere(\"sph\".to_string(), 1.0, None);\n        if let Geometry::Sphere { radius } = &sph.borrow().geometry {\n            assert_eq!(*radius, 1.0);\n        } else {\n            panic!(\"Expected Sphere geometry\");\n        }\n\n        // Ellipsoid\n        let ell = scene.create_ellipsoid(\"ell\".to_string(), 1.0, 2.0, 3.0, None);\n        let borrowed_ell = ell.borrow();\n        if let Geometry::Ellipsoid { rx, ry, rz } = &borrowed_ell.geometry {\n            assert_eq!(*rx, 1.0);\n            assert_eq!(*ry, 2.0);\n            assert_eq!(*rz, 3.0);\n        } else {\n            panic!(\"Expected Ellipsoid geometry\");\n        }\n    }\n\n    #[test]\n    fn test_scene_graph_create_polygon() {\n        let mut scene = SceneGraph::new();\n        let vertices = vec![[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]];\n\n        let poly = scene.create_polygon(\"poly\".to_string(), vertices.clone(), 0.1, None);\n        let borrowed = poly.borrow();\n        if let Geometry::Polygon { vertices: v, thickness } = &borrowed.geometry {\n            assert_eq!(v.len(), 4);\n            assert_eq!(*thickness, 0.1);\n        } else {\n            panic!(\"Expected Polygon geometry\");\n        }\n    }\n\n    #[test]\n    fn test_scene_graph_create_frame() {\n        let mut scene = SceneGraph::new();\n\n        let dims = FrameDimensions {\n            outer_width: 100.0,\n            outer_height: 50.0,\n            inner_width: 80.0,\n            inner_height: 30.0,\n            depth: 5.0,\n        };\n\n        let frame = scene.create_frame(\"frame\".to_string(), dims.clone(), None);\n        let borrowed = frame.borrow();\n        if let Geometry::Frame(d) = &borrowed.geometry {\n            assert_eq!(d.outer_width, 100.0);\n            assert_eq!(d.inner_width, 80.0);\n        } else {\n            panic!(\"Expected Frame geometry\");\n        }\n    }\n\n    #[test]\n    fn test_scene_graph_create_rotation() {\n        let mut scene = SceneGraph::new();\n        let profile = vec![[0.0, 0.0], [1.0, 0.0], [1.0, 1.0]];\n\n        let rot = scene.create_rotation(\"rot\".to_string(), profile.clone(), 16, std::f32::consts::TAU, None);\n        let borrowed = rot.borrow();\n        if let Geometry::Rotation { profile: p, segments, angle } = &borrowed.geometry {\n            assert_eq!(p.len(), 3);\n            assert_eq!(*segments, 16);\n            assert!((angle - std::f32::consts::TAU).abs() < 0.001);\n        } else {\n            panic!(\"Expected Rotation geometry\");\n        }\n    }\n\n    #[test]\n    fn test_scene_graph_create_sweep() {\n        let mut scene = SceneGraph::new();\n        let profile = vec![[0.0, 0.0], [1.0, 0.0], [1.0, 1.0]];\n        let path = vec![[0.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 0.0, 2.0]];\n\n        let sweep = scene.create_sweep(\"sweep\".to_string(), profile.clone(), path.clone(), true, None);\n        let borrowed = sweep.borrow();\n        if let Geometry::Sweep { profile: p, path: pt, scale_along_path } = &borrowed.geometry {\n            assert_eq!(p.len(), 3);\n            assert_eq!(pt.len(), 3);\n            assert!(*scale_along_path);\n        } else {\n            panic!(\"Expected Sweep geometry\");\n        }\n    }\n\n    #[test]\n    fn test_scene_graph_get_by_name() {\n        let mut scene = SceneGraph::new();\n\n        let root = scene.create_part(\"root\".to_string(), None);\n        let _child = scene.create_part(\"child\".to_string(), Some(root.clone()));\n\n        let found = scene.get_by_name(\"root.child\");\n        assert!(found.is_some());\n        assert_eq!(found.unwrap().borrow().name, \"child\");\n\n        let not_found = scene.get_by_name(\"nonexistent\");\n        assert!(not_found.is_none());\n    }\n\n    #[test]\n    fn test_scene_graph_remove_node() {\n        let mut scene = SceneGraph::new();\n\n        let root = scene.create_part(\"root\".to_string(), None);\n        let child = scene.create_part(\"child\".to_string(), Some(root.clone()));\n\n        assert_eq!(scene.nodes.len(), 2);\n\n        let child_id = child.borrow().id;\n        scene.remove_node(child_id);\n\n        assert_eq!(scene.nodes.len(), 1);\n        assert!(scene.get_by_name(\"root.child\").is_none());\n    }\n\n    #[test]\n    fn test_scene_node_find_child() {\n        let mut scene = SceneGraph::new();\n\n        let root = scene.create_part(\"root\".to_string(), None);\n        let _child1 = scene.create_part(\"child1\".to_string(), Some(root.clone()));\n        let _child2 = scene.create_part(\"child2\".to_string(), Some(root.clone()));\n\n        let found = root.borrow().find_child(\"child1\");\n        assert!(found.is_some());\n\n        let not_found = root.borrow().find_child(\"child3\");\n        assert!(not_found.is_none());\n    }\n\n    #[test]\n    fn test_scene_node_find_by_path() {\n        let mut scene = SceneGraph::new();\n\n        let root = scene.create_part(\"root\".to_string(), None);\n        let child = scene.create_part(\"child\".to_string(), Some(root.clone()));\n        let _grandchild = scene.create_part(\"grandchild\".to_string(), Some(child.clone()));\n\n        let found = root.borrow().find_by_path(\"child.grandchild\");\n        assert!(found.is_some());\n        assert_eq!(found.unwrap().borrow().name, \"grandchild\");\n\n        let found_child = root.borrow().find_by_path(\"child\");\n        assert!(found_child.is_some());\n\n        let not_found = root.borrow().find_by_path(\"nonexistent.path\");\n        assert!(not_found.is_none());\n    }\n\n    #[test]\n    fn test_axis_enum() {\n        assert_eq!(Axis::X, Axis::X);\n        assert_ne!(Axis::X, Axis::Y);\n        assert_ne!(Axis::Y, Axis::Z);\n    }\n\n    #[test]\n    fn test_align_mode_default() {\n        let mode = AlignMode::default();\n        assert_eq!(mode, AlignMode::Min);\n    }\n\n    #[test]\n    fn test_align_mode_debug_partialeq() {\n        let mode1 = AlignMode::Center;\n        let mode2 = AlignMode::Center;\n        assert_eq!(mode1, mode2);\n\n        let debug_str = format!(\"{:?}\", mode1);\n        assert!(debug_str.contains(\"Center\"));\n    }\n\n    #[test]\n    fn test_geometry_debug_clone() {\n        let geo = Geometry::Block { width: 1.0, height: 2.0, depth: 3.0 };\n        let debug_str = format!(\"{:?}\", geo);\n        assert!(debug_str.contains(\"Block\"));\n\n        let cloned = geo.clone();\n        if let Geometry::Block { width, height, depth } = cloned {\n            assert_eq!(width, 1.0);\n            assert_eq!(height, 2.0);\n            assert_eq!(depth, 3.0);\n        }\n    }\n\n    #[test]\n    fn test_frame_dimensions_debug_clone() {\n        let dims = FrameDimensions {\n            outer_width: 100.0,\n            outer_height: 50.0,\n            inner_width: 80.0,\n            inner_height: 30.0,\n            depth: 5.0,\n        };\n\n        let debug_str = format!(\"{:?}\", dims);\n        assert!(debug_str.contains(\"FrameDimensions\"));\n\n        let cloned = dims.clone();\n        assert_eq!(cloned.outer_width, 100.0);\n    }\n\n    #[test]\n    fn test_scene_graph_default() {\n        let scene = SceneGraph::default();\n        assert!(scene.nodes.is_empty());\n        assert!(scene.roots.is_empty());\n    }\n\n    #[test]\n    fn test_scene_node_world_rotation() {\n        let mut scene = SceneGraph::new();\n\n        let root = scene.create_part(\"root\".to_string(), None);\n        root.borrow_mut().set_rotation(Axis::X, 0.5);\n\n        let child = scene.create_part(\"child\".to_string(), Some(root.clone()));\n        child.borrow_mut().set_rotation(Axis::X, 0.3);\n\n        let world_rot = child.borrow().get_world_rotation();\n        assert!((world_rot[0] - 0.8).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_scene_node_add_child() {\n        let mut scene = SceneGraph::new();\n\n        let parent = scene.create_part(\"parent\".to_string(), None);\n        let child = SceneNode::new(100, \"child\".to_string(), \"OiPart\".to_string());\n        let child_rc = Rc::new(RefCell::new(child));\n\n        parent.borrow_mut().add_child(child_rc.clone());\n        assert_eq!(parent.borrow().children.len(), 1);\n    }\n\n    #[test]\n    fn test_scene_graph_mesh_count() {\n        let mut scene = SceneGraph::new();\n\n        let _block1 = scene.create_block(\"block1\".to_string(), [1.0, 1.0, 1.0], None);\n        let _block2 = scene.create_block(\"block2\".to_string(), [2.0, 2.0, 2.0], None);\n        let _part = scene.create_part(\"part\".to_string(), None);\n\n        // mesh_count counts nodes with Block geometry (which convert to meshes)\n        let count = scene.mesh_count();\n        assert!(count >= 2);\n    }\n\n    #[test]\n    fn test_scene_graph_to_scene() {\n        let mut scene = SceneGraph::new();\n\n        let _block = scene.create_block(\"block\".to_string(), [1.0, 2.0, 3.0], None);\n\n        let scene3ds = scene.to_scene();\n        assert!(scene3ds.meshes.len() >= 1);\n    }\n\n    #[test]\n    fn test_scene_node_store_original_bounds() {\n        let mut scene = SceneGraph::new();\n\n        let block = scene.create_block(\"block\".to_string(), [1.0, 2.0, 3.0], None);\n        block.borrow_mut().store_original_bounds();\n\n        assert!(block.borrow().original_bounds.is_some());\n    }\n\n    #[test]\n    fn test_scene_node_properties() {\n        let mut node = SceneNode::new(1, \"test\".to_string(), \"OiPart\".to_string());\n        node.properties.insert(\"color\".to_string(), \"red\".to_string());\n        assert_eq!(node.properties.get(\"color\"), Some(&\"red\".to_string()));\n    }\n\n    #[test]\n    fn test_scene_node_material() {\n        let mut node = SceneNode::new(1, \"test\".to_string(), \"OiPart\".to_string());\n        node.material = \"wood\".to_string();\n        assert_eq!(node.material, \"wood\");\n    }\n\n    #[test]\n    fn test_scene_node_visibility() {\n        let mut node = SceneNode::new(1, \"test\".to_string(), \"OiPart\".to_string());\n        node.visible = false;\n        assert!(!node.visible);\n\n        node.selectable = false;\n        assert!(!node.selectable);\n    }\n\n    #[test]\n    fn test_scene_node_scale() {\n        let mut node = SceneNode::new(1, \"test\".to_string(), \"OiPart\".to_string());\n        node.scale = 2.0;\n        assert_eq!(node.scale, 2.0);\n    }\n\n    // ========== Additional Coverage Tests ==========\n\n    #[test]\n    fn test_scene_node_set_alignment_min() {\n        let mut scene = SceneGraph::new();\n        let block = scene.create_block(\"block\".to_string(), [2.0, 4.0, 6.0], None);\n        block.borrow_mut().store_original_bounds();\n        block.borrow_mut().set_alignment(AlignMode::Min, AlignMode::Min, AlignMode::Min);\n\n        let offset = block.borrow().get_alignment_offset();\n        // Offset should be negative of min bounds (which are 0 for block)\n        assert!(offset[0].abs() < 0.001);\n        assert!(offset[1].abs() < 0.001);\n        assert!(offset[2].abs() < 0.001);\n    }\n\n    #[test]\n    fn test_scene_node_set_alignment_center() {\n        let mut scene = SceneGraph::new();\n        let block = scene.create_block(\"block\".to_string(), [2.0, 4.0, 6.0], None);\n        block.borrow_mut().store_original_bounds();\n        block.borrow_mut().set_alignment(AlignMode::Center, AlignMode::Center, AlignMode::Center);\n\n        let offset = block.borrow().get_alignment_offset();\n        // Center should be half of dimensions (1, 2, 3), offset is negative\n        assert!((offset[0] + 1.0).abs() < 0.001);\n        assert!((offset[1] + 2.0).abs() < 0.001);\n        assert!((offset[2] + 3.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_scene_node_set_alignment_max() {\n        let mut scene = SceneGraph::new();\n        let block = scene.create_block(\"block\".to_string(), [2.0, 4.0, 6.0], None);\n        block.borrow_mut().store_original_bounds();\n        block.borrow_mut().set_alignment(AlignMode::Max, AlignMode::Max, AlignMode::Max);\n\n        let offset = block.borrow().get_alignment_offset();\n        // Max should be dimensions (2, 4, 6), offset is negative\n        assert!((offset[0] + 2.0).abs() < 0.001);\n        assert!((offset[1] + 4.0).abs() < 0.001);\n        assert!((offset[2] + 6.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_scene_node_set_default_alignment() {\n        let mut scene = SceneGraph::new();\n        let block = scene.create_block(\"block\".to_string(), [2.0, 4.0, 6.0], None);\n        block.borrow_mut().store_original_bounds();\n        block.borrow_mut().set_default_alignment();\n\n        let offset = block.borrow().get_alignment_offset();\n        // Default: Center X (-1), Min Y (0), Center Z (-3)\n        assert!((offset[0] + 1.0).abs() < 0.001);\n        assert!(offset[1].abs() < 0.001);\n        assert!((offset[2] + 3.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_scene_node_set_alignment_without_stored_bounds() {\n        let mut scene = SceneGraph::new();\n        let block = scene.create_block(\"block\".to_string(), [2.0, 4.0, 6.0], None);\n        // Don't call store_original_bounds - should still work with get_local_bounds\n        block.borrow_mut().set_alignment(AlignMode::Center, AlignMode::Min, AlignMode::Center);\n\n        let offset = block.borrow().get_alignment_offset();\n        // Should still calculate correctly\n        assert!((offset[0] + 1.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_scene_node_get_local_bounds_block() {\n        let mut scene = SceneGraph::new();\n        let block = scene.create_block(\"block\".to_string(), [2.0, 4.0, 6.0], None);\n        let bounds = block.borrow().get_local_bounds();\n        // Block starts at origin\n        assert_eq!(bounds[0], [0.0, 0.0, 0.0]);\n        assert_eq!(bounds[1], [2.0, 4.0, 6.0]);\n    }\n\n    #[test]\n    fn test_scene_node_get_local_bounds_cylinder() {\n        let mut scene = SceneGraph::new();\n        let cyl = scene.create_cylinder(\"cyl\".to_string(), 1.0, 2.0, None);\n        let bounds = cyl.borrow().get_local_bounds();\n        // Cylinder: radius 1.0, height 2.0\n        assert!((bounds[0][0] + 1.0).abs() < 0.001); // -radius\n        assert_eq!(bounds[0][1], 0.0); // min y\n        assert!((bounds[1][0] - 1.0).abs() < 0.001); // +radius\n        assert_eq!(bounds[1][1], 2.0); // height\n    }\n\n    #[test]\n    fn test_scene_node_get_local_bounds_sphere() {\n        let mut scene = SceneGraph::new();\n        let sph = scene.create_sphere(\"sph\".to_string(), 1.5, None);\n        let bounds = sph.borrow().get_local_bounds();\n        // Sphere: radius 1.5\n        assert!((bounds[0][0] + 1.5).abs() < 0.001);\n        assert!((bounds[1][0] - 1.5).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_scene_node_get_local_bounds_ellipsoid() {\n        let mut scene = SceneGraph::new();\n        let ell = scene.create_ellipsoid(\"ell\".to_string(), 1.0, 2.0, 3.0, None);\n        let bounds = ell.borrow().get_local_bounds();\n        assert!((bounds[0][0] + 1.0).abs() < 0.001);\n        assert!((bounds[0][1] + 2.0).abs() < 0.001);\n        assert!((bounds[0][2] + 3.0).abs() < 0.001);\n        assert!((bounds[1][0] - 1.0).abs() < 0.001);\n        assert!((bounds[1][1] - 2.0).abs() < 0.001);\n        assert!((bounds[1][2] - 3.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_scene_node_get_local_bounds_none() {\n        let node = SceneNode::new(1, \"test\".to_string(), \"OiPart\".to_string());\n        let bounds = node.get_local_bounds();\n        // No geometry - should return zero bounds\n        assert_eq!(bounds[0], [0.0, 0.0, 0.0]);\n        assert_eq!(bounds[1], [0.0, 0.0, 0.0]);\n    }\n\n    #[test]\n    fn test_scene_node_get_local_bounds_polygon() {\n        let mut scene = SceneGraph::new();\n        // Polygon vertices are [x, z] pairs; thickness is in Y\n        let vertices = vec![[-1.0, -1.0], [1.0, -1.0], [1.0, 1.0], [-1.0, 1.0]];\n        let poly = scene.create_polygon(\"poly\".to_string(), vertices, 0.5, None);\n        let bounds = poly.borrow().get_local_bounds();\n        // X bounds from vertices[0] = [-1, 1]\n        assert!((bounds[0][0] + 1.0).abs() < 0.001);\n        assert!((bounds[1][0] - 1.0).abs() < 0.001);\n        // Y is 0 to thickness (0.5)\n        assert_eq!(bounds[0][1], 0.0);\n        assert!((bounds[1][1] - 0.5).abs() < 0.001);\n        // Z bounds from vertices[1] = [-1, 1]\n        assert!((bounds[0][2] + 1.0).abs() < 0.001);\n        assert!((bounds[1][2] - 1.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_scene_node_get_local_bounds_frame() {\n        let mut scene = SceneGraph::new();\n        let dims = FrameDimensions {\n            outer_width: 10.0,\n            outer_height: 8.0,\n            inner_width: 6.0,\n            inner_height: 4.0,\n            depth: 2.0,\n        };\n        let frame = scene.create_frame(\"frame\".to_string(), dims, None);\n        let bounds = frame.borrow().get_local_bounds();\n        // Frame uses outer dimensions and depth\n        assert!((bounds[1][0] - 10.0).abs() < 0.001);\n        assert!((bounds[1][1] - 8.0).abs() < 0.001);\n        assert!((bounds[1][2] - 2.0).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_scene_node_get_local_bounds_rotation() {\n        let mut scene = SceneGraph::new();\n        let profile = vec![[0.0, 0.0], [1.0, 0.0], [1.0, 2.0]];\n        let rot = scene.create_rotation(\"rot\".to_string(), profile, 16, std::f32::consts::TAU, None);\n        let bounds = rot.borrow().get_local_bounds();\n        // Full rotation: max_r=1.0 so X/Z bounds are [-1, 1], Z height is 2\n        assert!((bounds[0][0] + 1.0).abs() < 0.001);\n        assert!((bounds[1][0] - 1.0).abs() < 0.001);\n        assert_eq!(bounds[0][1], 0.0);\n        assert_eq!(bounds[1][1], 2.0);\n    }\n\n    #[test]\n    fn test_scene_node_get_local_bounds_sweep() {\n        let mut scene = SceneGraph::new();\n        // Profile extent = 0.5 (max of abs(coords))\n        let profile = vec![[-0.5, -0.5], [0.5, -0.5], [0.5, 0.5], [-0.5, 0.5]];\n        // Path from [0,0,0] to [0,0,2]\n        let path = vec![[0.0, 0.0, 0.0], [0.0, 0.0, 2.0]];\n        let sweep = scene.create_sweep(\"sweep\".to_string(), profile, path, false, None);\n        let bounds = sweep.borrow().get_local_bounds();\n        // Sweep extends profile_extent (0.5) around each path point\n        // X: path.x ¬± 0.5 = [-0.5, 0.5]\n        assert!((bounds[0][0] + 0.5).abs() < 0.001);\n        assert!((bounds[1][0] - 0.5).abs() < 0.001);\n        // Z: path.z ¬± 0.5 = [-0.5, 2.5]\n        assert!((bounds[0][2] + 0.5).abs() < 0.001);\n        assert!((bounds[1][2] - 2.5).abs() < 0.001);\n    }\n\n    #[test]\n    fn test_scene_graph_to_scene_multiple_blocks() {\n        let mut scene = SceneGraph::new();\n        let _block1 = scene.create_block(\"block1\".to_string(), [1.0, 1.0, 1.0], None);\n        let _block2 = scene.create_block(\"block2\".to_string(), [2.0, 2.0, 2.0], None);\n\n        // to_scene should produce meshes for both blocks\n        let scene3ds = scene.to_scene();\n        assert!(scene3ds.meshes.len() >= 2);\n    }\n\n    #[test]\n    fn test_scene_graph_nodes_by_name() {\n        let mut scene = SceneGraph::new();\n        let _block = scene.create_block(\"block\".to_string(), [1.0, 1.0, 1.0], None);\n        assert!(!scene.nodes.is_empty());\n        assert!(!scene.nodes_by_name.is_empty());\n    }\n\n    #[test]\n    fn test_scene_graph_alb_path() {\n        let mut scene = SceneGraph::new();\n        assert!(scene.alb_path.is_none());\n\n        scene.alb_path = Some(std::path::PathBuf::from(\"/test/path.alb\"));\n        assert!(scene.alb_path.is_some());\n    }\n\n    #[test]\n    fn test_scene_graph_name_lookup() {\n        let mut scene = SceneGraph::new();\n        let _node = scene.create_part(\"test_node\".to_string(), None);\n\n        // exists should work\n        assert!(scene.exists(\"test_node\"));\n        assert!(!scene.exists(\"nonexistent\"));\n    }\n\n    #[test]\n    fn test_scene_node_clone() {\n        let node = SceneNode::new(1, \"test\".to_string(), \"OiPart\".to_string());\n        let cloned = node.clone();\n        assert_eq!(cloned.id, 1);\n        assert_eq!(cloned.name, \"test\");\n    }\n\n    #[test]\n    fn test_geometry_none() {\n        let geo = Geometry::None;\n        let debug_str = format!(\"{:?}\", geo);\n        assert!(debug_str.contains(\"None\"));\n    }\n\n    #[test]\n    fn test_geometry_cylinder() {\n        let geo = Geometry::Cylinder { radius: 1.0, height: 2.0 };\n        let cloned = geo.clone();\n        if let Geometry::Cylinder { radius, height } = cloned {\n            assert_eq!(radius, 1.0);\n            assert_eq!(height, 2.0);\n        }\n    }\n\n    #[test]\n    fn test_geometry_sphere() {\n        let geo = Geometry::Sphere { radius: 1.5 };\n        let debug_str = format!(\"{:?}\", geo);\n        assert!(debug_str.contains(\"Sphere\"));\n    }\n\n    #[test]\n    fn test_geometry_ellipsoid() {\n        let geo = Geometry::Ellipsoid { rx: 1.0, ry: 2.0, rz: 3.0 };\n        if let Geometry::Ellipsoid { rx, ry, rz } = geo.clone() {\n            assert_eq!(rx, 1.0);\n            assert_eq!(ry, 2.0);\n            assert_eq!(rz, 3.0);\n        }\n    }\n\n    #[test]\n    fn test_geometry_polygon() {\n        let geo = Geometry::Polygon {\n            vertices: vec![[0.0, 0.0], [1.0, 0.0], [0.5, 1.0]],\n            thickness: 0.1,\n        };\n        if let Geometry::Polygon { vertices, thickness } = geo.clone() {\n            assert_eq!(vertices.len(), 3);\n            assert_eq!(thickness, 0.1);\n        }\n    }\n\n    #[test]\n    fn test_geometry_rotation() {\n        let geo = Geometry::Rotation {\n            profile: vec![[0.0, 0.0], [1.0, 1.0]],\n            segments: 12,\n            angle: std::f32::consts::PI,\n        };\n        if let Geometry::Rotation { profile, segments, angle } = geo.clone() {\n            assert_eq!(profile.len(), 2);\n            assert_eq!(segments, 12);\n            assert!((angle - std::f32::consts::PI).abs() < 0.001);\n        }\n    }\n\n    #[test]\n    fn test_geometry_sweep() {\n        let geo = Geometry::Sweep {\n            profile: vec![[0.0, 0.0], [1.0, 0.0]],\n            path: vec![[0.0, 0.0, 0.0], [0.0, 0.0, 1.0]],\n            scale_along_path: true,\n        };\n        if let Geometry::Sweep { profile, path, scale_along_path } = geo.clone() {\n            assert_eq!(profile.len(), 2);\n            assert_eq!(path.len(), 2);\n            assert!(scale_along_path);\n        }\n    }\n\n    #[test]\n    fn test_axis_copy_clone() {\n        let axis = Axis::X;\n        let copied = axis;\n        let cloned = axis.clone();\n        assert_eq!(axis, copied);\n        assert_eq!(axis, cloned);\n    }\n\n    #[test]\n    fn test_axis_debug() {\n        let debug_str = format!(\"{:?}\", Axis::Y);\n        assert!(debug_str.contains(\"Y\"));\n    }\n\n    #[test]\n    fn test_align_mode_copy_clone() {\n        let mode = AlignMode::Max;\n        let copied = mode;\n        let cloned = mode.clone();\n        assert_eq!(mode, copied);\n        assert_eq!(mode, cloned);\n    }\n\n    #[test]\n    fn test_scene_node_full_name_update() {\n        let mut scene = SceneGraph::new();\n        let parent = scene.create_part(\"parent\".to_string(), None);\n        let child = scene.create_part(\"child\".to_string(), Some(parent.clone()));\n\n        // Child's full_name should include parent path\n        assert_eq!(child.borrow().full_name, \"parent.child\");\n    }\n\n    #[test]\n    fn test_scene_graph_roots_tracking() {\n        let mut scene = SceneGraph::new();\n        let root1 = scene.create_part(\"root1\".to_string(), None);\n        let root2 = scene.create_part(\"root2\".to_string(), None);\n        let _child = scene.create_part(\"child\".to_string(), Some(root1.clone()));\n\n        // Should have 2 roots\n        assert_eq!(scene.roots.len(), 2);\n        assert_eq!(root2.borrow().name, \"root2\");\n    }\n\n    #[test]\n    fn test_scene_node_remove_child() {\n        let mut scene = SceneGraph::new();\n        let parent = scene.create_part(\"parent\".to_string(), None);\n        let child = scene.create_part(\"child\".to_string(), Some(parent.clone()));\n\n        // Parent should have 1 child\n        assert_eq!(parent.borrow().children.len(), 1);\n\n        // Remove the child\n        let child_id = child.borrow().id;\n        scene.remove_node(child_id);\n\n        // Parent should have 0 children now\n        assert_eq!(parent.borrow().children.len(), 0);\n    }\n}\n","traces":[{"line":122,"address":[],"length":0,"stats":{"Line":76}},{"line":125,"address":[],"length":0,"stats":{"Line":228}},{"line":129,"address":[],"length":0,"stats":{"Line":152}},{"line":130,"address":[],"length":0,"stats":{"Line":152}},{"line":132,"address":[],"length":0,"stats":{"Line":152}},{"line":134,"address":[],"length":0,"stats":{"Line":152}},{"line":136,"address":[],"length":0,"stats":{"Line":76}},{"line":139,"address":[],"length":0,"stats":{"Line":76}},{"line":144,"address":[],"length":0,"stats":{"Line":3}},{"line":145,"address":[],"length":0,"stats":{"Line":3}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":6}},{"line":160,"address":[],"length":0,"stats":{"Line":6}},{"line":171,"address":[],"length":0,"stats":{"Line":5}},{"line":173,"address":[],"length":0,"stats":{"Line":10}},{"line":174,"address":[],"length":0,"stats":{"Line":5}},{"line":175,"address":[],"length":0,"stats":{"Line":7}},{"line":176,"address":[],"length":0,"stats":{"Line":15}},{"line":179,"address":[],"length":0,"stats":{"Line":10}},{"line":180,"address":[],"length":0,"stats":{"Line":1}},{"line":181,"address":[],"length":0,"stats":{"Line":3}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":10}},{"line":185,"address":[],"length":0,"stats":{"Line":3}},{"line":186,"address":[],"length":0,"stats":{"Line":1}},{"line":187,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":10}},{"line":190,"address":[],"length":0,"stats":{"Line":1}},{"line":191,"address":[],"length":0,"stats":{"Line":3}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":197,"address":[],"length":0,"stats":{"Line":10}},{"line":200,"address":[],"length":0,"stats":{"Line":10}},{"line":201,"address":[],"length":0,"stats":{"Line":30}},{"line":202,"address":[],"length":0,"stats":{"Line":15}},{"line":207,"address":[],"length":0,"stats":{"Line":1}},{"line":208,"address":[],"length":0,"stats":{"Line":5}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":5}},{"line":262,"address":[],"length":0,"stats":{"Line":5}},{"line":266,"address":[],"length":0,"stats":{"Line":2}},{"line":267,"address":[],"length":0,"stats":{"Line":2}},{"line":268,"address":[],"length":0,"stats":{"Line":2}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":4}},{"line":276,"address":[],"length":0,"stats":{"Line":4}},{"line":277,"address":[],"length":0,"stats":{"Line":2}},{"line":278,"address":[],"length":0,"stats":{"Line":1}},{"line":279,"address":[],"length":0,"stats":{"Line":1}},{"line":284,"address":[],"length":0,"stats":{"Line":4}},{"line":285,"address":[],"length":0,"stats":{"Line":4}},{"line":286,"address":[],"length":0,"stats":{"Line":2}},{"line":287,"address":[],"length":0,"stats":{"Line":1}},{"line":288,"address":[],"length":0,"stats":{"Line":1}},{"line":293,"address":[],"length":0,"stats":{"Line":2}},{"line":294,"address":[],"length":0,"stats":{"Line":4}},{"line":295,"address":[],"length":0,"stats":{"Line":4}},{"line":296,"address":[],"length":0,"stats":{"Line":3}},{"line":297,"address":[],"length":0,"stats":{"Line":3}},{"line":300,"address":[],"length":0,"stats":{"Line":5}},{"line":301,"address":[],"length":0,"stats":{"Line":1}},{"line":302,"address":[],"length":0,"stats":{"Line":2}},{"line":303,"address":[],"length":0,"stats":{"Line":2}},{"line":304,"address":[],"length":0,"stats":{"Line":1}},{"line":307,"address":[],"length":0,"stats":{"Line":2}},{"line":311,"address":[],"length":0,"stats":{"Line":2}},{"line":312,"address":[],"length":0,"stats":{"Line":4}},{"line":313,"address":[],"length":0,"stats":{"Line":4}},{"line":314,"address":[],"length":0,"stats":{"Line":3}},{"line":315,"address":[],"length":0,"stats":{"Line":1}},{"line":316,"address":[],"length":0,"stats":{"Line":2}},{"line":317,"address":[],"length":0,"stats":{"Line":2}},{"line":318,"address":[],"length":0,"stats":{"Line":1}},{"line":321,"address":[],"length":0,"stats":{"Line":2}},{"line":325,"address":[],"length":0,"stats":{"Line":15}},{"line":326,"address":[],"length":0,"stats":{"Line":15}},{"line":327,"address":[],"length":0,"stats":{"Line":1}},{"line":329,"address":[],"length":0,"stats":{"Line":7}},{"line":330,"address":[],"length":0,"stats":{"Line":7}},{"line":331,"address":[],"length":0,"stats":{"Line":7}},{"line":332,"address":[],"length":0,"stats":{"Line":21}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":2}},{"line":353,"address":[],"length":0,"stats":{"Line":3}},{"line":355,"address":[],"length":0,"stats":{"Line":2}},{"line":356,"address":[],"length":0,"stats":{"Line":7}},{"line":358,"address":[],"length":0,"stats":{"Line":1}},{"line":359,"address":[],"length":0,"stats":{"Line":1}},{"line":361,"address":[],"length":0,"stats":{"Line":2}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":2}},{"line":365,"address":[],"length":0,"stats":{"Line":2}},{"line":366,"address":[],"length":0,"stats":{"Line":2}},{"line":367,"address":[],"length":0,"stats":{"Line":2}},{"line":368,"address":[],"length":0,"stats":{"Line":13}},{"line":369,"address":[],"length":0,"stats":{"Line":12}},{"line":370,"address":[],"length":0,"stats":{"Line":12}},{"line":371,"address":[],"length":0,"stats":{"Line":12}},{"line":372,"address":[],"length":0,"stats":{"Line":8}},{"line":374,"address":[],"length":0,"stats":{"Line":3}},{"line":377,"address":[],"length":0,"stats":{"Line":1}},{"line":378,"address":[],"length":0,"stats":{"Line":3}},{"line":380,"address":[],"length":0,"stats":{"Line":1}},{"line":381,"address":[],"length":0,"stats":{"Line":2}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":2}},{"line":385,"address":[],"length":0,"stats":{"Line":2}},{"line":386,"address":[],"length":0,"stats":{"Line":2}},{"line":387,"address":[],"length":0,"stats":{"Line":10}},{"line":388,"address":[],"length":0,"stats":{"Line":12}},{"line":389,"address":[],"length":0,"stats":{"Line":9}},{"line":390,"address":[],"length":0,"stats":{"Line":6}},{"line":392,"address":[],"length":0,"stats":{"Line":4}},{"line":395,"address":[],"length":0,"stats":{"Line":2}},{"line":396,"address":[],"length":0,"stats":{"Line":4}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":2}},{"line":401,"address":[],"length":0,"stats":{"Line":2}},{"line":402,"address":[],"length":0,"stats":{"Line":2}},{"line":403,"address":[],"length":0,"stats":{"Line":13}},{"line":404,"address":[],"length":0,"stats":{"Line":24}},{"line":406,"address":[],"length":0,"stats":{"Line":7}},{"line":407,"address":[],"length":0,"stats":{"Line":10}},{"line":408,"address":[],"length":0,"stats":{"Line":10}},{"line":409,"address":[],"length":0,"stats":{"Line":10}},{"line":410,"address":[],"length":0,"stats":{"Line":10}},{"line":411,"address":[],"length":0,"stats":{"Line":10}},{"line":412,"address":[],"length":0,"stats":{"Line":8}},{"line":414,"address":[],"length":0,"stats":{"Line":1}},{"line":421,"address":[],"length":0,"stats":{"Line":16}},{"line":422,"address":[],"length":0,"stats":{"Line":48}},{"line":426,"address":[],"length":0,"stats":{"Line":2}},{"line":427,"address":[],"length":0,"stats":{"Line":7}},{"line":428,"address":[],"length":0,"stats":{"Line":3}},{"line":429,"address":[],"length":0,"stats":{"Line":1}},{"line":432,"address":[],"length":0,"stats":{"Line":1}},{"line":436,"address":[],"length":0,"stats":{"Line":4}},{"line":437,"address":[],"length":0,"stats":{"Line":20}},{"line":438,"address":[],"length":0,"stats":{"Line":8}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":8}},{"line":443,"address":[],"length":0,"stats":{"Line":9}},{"line":444,"address":[],"length":0,"stats":{"Line":4}},{"line":445,"address":[],"length":0,"stats":{"Line":3}},{"line":446,"address":[],"length":0,"stats":{"Line":2}},{"line":448,"address":[],"length":0,"stats":{"Line":4}},{"line":449,"address":[],"length":0,"stats":{"Line":2}},{"line":453,"address":[],"length":0,"stats":{"Line":1}},{"line":458,"address":[],"length":0,"stats":{"Line":37}},{"line":459,"address":[],"length":0,"stats":{"Line":148}},{"line":460,"address":[],"length":0,"stats":{"Line":148}},{"line":463,"address":[],"length":0,"stats":{"Line":111}},{"line":464,"address":[],"length":0,"stats":{"Line":111}},{"line":465,"address":[],"length":0,"stats":{"Line":111}},{"line":468,"address":[],"length":0,"stats":{"Line":111}},{"line":469,"address":[],"length":0,"stats":{"Line":111}},{"line":470,"address":[],"length":0,"stats":{"Line":111}},{"line":473,"address":[],"length":0,"stats":{"Line":111}},{"line":474,"address":[],"length":0,"stats":{"Line":111}},{"line":475,"address":[],"length":0,"stats":{"Line":111}},{"line":477,"address":[],"length":0,"stats":{"Line":74}},{"line":496,"address":[],"length":0,"stats":{"Line":170}},{"line":498,"address":[],"length":0,"stats":{"Line":340}},{"line":499,"address":[],"length":0,"stats":{"Line":340}},{"line":500,"address":[],"length":0,"stats":{"Line":170}},{"line":507,"address":[],"length":0,"stats":{"Line":1}},{"line":508,"address":[],"length":0,"stats":{"Line":2}},{"line":512,"address":[],"length":0,"stats":{"Line":64}},{"line":518,"address":[],"length":0,"stats":{"Line":128}},{"line":519,"address":[],"length":0,"stats":{"Line":64}},{"line":521,"address":[],"length":0,"stats":{"Line":143}},{"line":522,"address":[],"length":0,"stats":{"Line":45}},{"line":524,"address":[],"length":0,"stats":{"Line":98}},{"line":527,"address":[],"length":0,"stats":{"Line":448}},{"line":528,"address":[],"length":0,"stats":{"Line":192}},{"line":530,"address":[],"length":0,"stats":{"Line":94}},{"line":531,"address":[],"length":0,"stats":{"Line":45}},{"line":532,"address":[],"length":0,"stats":{"Line":45}},{"line":534,"address":[],"length":0,"stats":{"Line":147}},{"line":537,"address":[],"length":0,"stats":{"Line":320}},{"line":538,"address":[],"length":0,"stats":{"Line":320}},{"line":539,"address":[],"length":0,"stats":{"Line":64}},{"line":543,"address":[],"length":0,"stats":{"Line":33}},{"line":548,"address":[],"length":0,"stats":{"Line":198}},{"line":552,"address":[],"length":0,"stats":{"Line":17}},{"line":558,"address":[],"length":0,"stats":{"Line":119}},{"line":559,"address":[],"length":0,"stats":{"Line":34}},{"line":560,"address":[],"length":0,"stats":{"Line":34}},{"line":561,"address":[],"length":0,"stats":{"Line":17}},{"line":562,"address":[],"length":0,"stats":{"Line":17}},{"line":564,"address":[],"length":0,"stats":{"Line":17}},{"line":568,"address":[],"length":0,"stats":{"Line":2}},{"line":575,"address":[],"length":0,"stats":{"Line":14}},{"line":576,"address":[],"length":0,"stats":{"Line":4}},{"line":577,"address":[],"length":0,"stats":{"Line":2}},{"line":581,"address":[],"length":0,"stats":{"Line":2}},{"line":587,"address":[],"length":0,"stats":{"Line":14}},{"line":588,"address":[],"length":0,"stats":{"Line":4}},{"line":589,"address":[],"length":0,"stats":{"Line":2}},{"line":593,"address":[],"length":0,"stats":{"Line":2}},{"line":601,"address":[],"length":0,"stats":{"Line":14}},{"line":602,"address":[],"length":0,"stats":{"Line":6}},{"line":603,"address":[],"length":0,"stats":{"Line":2}},{"line":607,"address":[],"length":0,"stats":{"Line":2}},{"line":614,"address":[],"length":0,"stats":{"Line":14}},{"line":615,"address":[],"length":0,"stats":{"Line":4}},{"line":616,"address":[],"length":0,"stats":{"Line":2}},{"line":617,"address":[],"length":0,"stats":{"Line":2}},{"line":619,"address":[],"length":0,"stats":{"Line":2}},{"line":623,"address":[],"length":0,"stats":{"Line":2}},{"line":629,"address":[],"length":0,"stats":{"Line":14}},{"line":630,"address":[],"length":0,"stats":{"Line":4}},{"line":631,"address":[],"length":0,"stats":{"Line":2}},{"line":635,"address":[],"length":0,"stats":{"Line":2}},{"line":643,"address":[],"length":0,"stats":{"Line":14}},{"line":644,"address":[],"length":0,"stats":{"Line":4}},{"line":645,"address":[],"length":0,"stats":{"Line":4}},{"line":646,"address":[],"length":0,"stats":{"Line":2}},{"line":647,"address":[],"length":0,"stats":{"Line":2}},{"line":649,"address":[],"length":0,"stats":{"Line":2}},{"line":653,"address":[],"length":0,"stats":{"Line":2}},{"line":661,"address":[],"length":0,"stats":{"Line":14}},{"line":662,"address":[],"length":0,"stats":{"Line":4}},{"line":663,"address":[],"length":0,"stats":{"Line":4}},{"line":664,"address":[],"length":0,"stats":{"Line":2}},{"line":665,"address":[],"length":0,"stats":{"Line":2}},{"line":667,"address":[],"length":0,"stats":{"Line":2}},{"line":671,"address":[],"length":0,"stats":{"Line":3}},{"line":672,"address":[],"length":0,"stats":{"Line":9}},{"line":676,"address":[],"length":0,"stats":{"Line":3}},{"line":677,"address":[],"length":0,"stats":{"Line":12}},{"line":681,"address":[],"length":0,"stats":{"Line":2}},{"line":682,"address":[],"length":0,"stats":{"Line":6}},{"line":683,"address":[],"length":0,"stats":{"Line":6}},{"line":684,"address":[],"length":0,"stats":{"Line":6}},{"line":687,"address":[],"length":0,"stats":{"Line":4}},{"line":688,"address":[],"length":0,"stats":{"Line":8}},{"line":692,"address":[],"length":0,"stats":{"Line":8}},{"line":695,"address":[],"length":0,"stats":{"Line":8}},{"line":696,"address":[],"length":0,"stats":{"Line":2}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":718,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":3}},{"line":767,"address":[],"length":0,"stats":{"Line":6}},{"line":769,"address":[],"length":0,"stats":{"Line":15}},{"line":770,"address":[],"length":0,"stats":{"Line":20}},{"line":773,"address":[],"length":0,"stats":{"Line":3}},{"line":777,"address":[],"length":0,"stats":{"Line":4}},{"line":784,"address":[],"length":0,"stats":{"Line":4}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":8}},{"line":790,"address":[],"length":0,"stats":{"Line":16}},{"line":791,"address":[],"length":0,"stats":{"Line":8}},{"line":792,"address":[],"length":0,"stats":{"Line":8}},{"line":793,"address":[],"length":0,"stats":{"Line":8}},{"line":794,"address":[],"length":0,"stats":{"Line":4}},{"line":796,"address":[],"length":0,"stats":{"Line":8}},{"line":797,"address":[],"length":0,"stats":{"Line":8}},{"line":798,"address":[],"length":0,"stats":{"Line":8}},{"line":799,"address":[],"length":0,"stats":{"Line":4}},{"line":803,"address":[],"length":0,"stats":{"Line":8}},{"line":806,"address":[],"length":0,"stats":{"Line":8}},{"line":807,"address":[],"length":0,"stats":{"Line":1}},{"line":809,"address":[],"length":0,"stats":{"Line":3}},{"line":813,"address":[],"length":0,"stats":{"Line":5}},{"line":814,"address":[],"length":0,"stats":{"Line":3}},{"line":816,"address":[],"length":0,"stats":{"Line":4}},{"line":817,"address":[],"length":0,"stats":{"Line":3}},{"line":818,"address":[],"length":0,"stats":{"Line":3}},{"line":819,"address":[],"length":0,"stats":{"Line":1}},{"line":820,"address":[],"length":0,"stats":{"Line":3}},{"line":821,"address":[],"length":0,"stats":{"Line":2}},{"line":822,"address":[],"length":0,"stats":{"Line":2}},{"line":823,"address":[],"length":0,"stats":{"Line":1}},{"line":824,"address":[],"length":0,"stats":{"Line":1}},{"line":825,"address":[],"length":0,"stats":{"Line":1}},{"line":826,"address":[],"length":0,"stats":{"Line":1}},{"line":832,"address":[],"length":0,"stats":{"Line":4}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":4}},{"line":836,"address":[],"length":0,"stats":{"Line":4}},{"line":837,"address":[],"length":0,"stats":{"Line":4}},{"line":838,"address":[],"length":0,"stats":{"Line":4}},{"line":840,"address":[],"length":0,"stats":{"Line":12}},{"line":841,"address":[],"length":0,"stats":{"Line":12}},{"line":842,"address":[],"length":0,"stats":{"Line":12}},{"line":843,"address":[],"length":0,"stats":{"Line":8}},{"line":845,"address":[],"length":0,"stats":{"Line":8}},{"line":846,"address":[],"length":0,"stats":{"Line":32}},{"line":847,"address":[],"length":0,"stats":{"Line":16}},{"line":848,"address":[],"length":0,"stats":{"Line":8}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":0}},{"line":858,"address":[],"length":0,"stats":{"Line":0}},{"line":859,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":866,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":874,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}},{"line":876,"address":[],"length":0,"stats":{"Line":0}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":880,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[],"length":0,"stats":{"Line":0}},{"line":884,"address":[],"length":0,"stats":{"Line":0}},{"line":885,"address":[],"length":0,"stats":{"Line":0}},{"line":886,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":890,"address":[],"length":0,"stats":{"Line":0}},{"line":891,"address":[],"length":0,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":894,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":902,"address":[],"length":0,"stats":{"Line":0}},{"line":904,"address":[],"length":0,"stats":{"Line":0}},{"line":905,"address":[],"length":0,"stats":{"Line":0}},{"line":906,"address":[],"length":0,"stats":{"Line":0}},{"line":907,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":910,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":912,"address":[],"length":0,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":0}},{"line":916,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":920,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[],"length":0,"stats":{"Line":0}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":926,"address":[],"length":0,"stats":{"Line":0}},{"line":927,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[],"length":0,"stats":{"Line":0}},{"line":931,"address":[],"length":0,"stats":{"Line":0}},{"line":932,"address":[],"length":0,"stats":{"Line":0}},{"line":933,"address":[],"length":0,"stats":{"Line":0}},{"line":935,"address":[],"length":0,"stats":{"Line":0}},{"line":936,"address":[],"length":0,"stats":{"Line":0}},{"line":937,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":941,"address":[],"length":0,"stats":{"Line":0}},{"line":942,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":944,"address":[],"length":0,"stats":{"Line":0}},{"line":945,"address":[],"length":0,"stats":{"Line":0}},{"line":946,"address":[],"length":0,"stats":{"Line":0}},{"line":947,"address":[],"length":0,"stats":{"Line":0}},{"line":949,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":952,"address":[],"length":0,"stats":{"Line":0}},{"line":955,"address":[],"length":0,"stats":{"Line":0}},{"line":956,"address":[],"length":0,"stats":{"Line":0}},{"line":957,"address":[],"length":0,"stats":{"Line":0}},{"line":958,"address":[],"length":0,"stats":{"Line":0}},{"line":959,"address":[],"length":0,"stats":{"Line":0}},{"line":960,"address":[],"length":0,"stats":{"Line":0}},{"line":961,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":965,"address":[],"length":0,"stats":{"Line":0}},{"line":966,"address":[],"length":0,"stats":{"Line":0}},{"line":967,"address":[],"length":0,"stats":{"Line":0}},{"line":972,"address":[],"length":0,"stats":{"Line":4}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":978,"address":[],"length":0,"stats":{"Line":0}},{"line":979,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":981,"address":[],"length":0,"stats":{"Line":0}},{"line":985,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":987,"address":[],"length":0,"stats":{"Line":0}},{"line":988,"address":[],"length":0,"stats":{"Line":0}},{"line":990,"address":[],"length":0,"stats":{"Line":0}},{"line":991,"address":[],"length":0,"stats":{"Line":0}},{"line":992,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[],"length":0,"stats":{"Line":0}},{"line":995,"address":[],"length":0,"stats":{"Line":0}},{"line":996,"address":[],"length":0,"stats":{"Line":0}},{"line":998,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1000,"address":[],"length":0,"stats":{"Line":0}},{"line":1003,"address":[],"length":0,"stats":{"Line":0}},{"line":1004,"address":[],"length":0,"stats":{"Line":0}},{"line":1005,"address":[],"length":0,"stats":{"Line":0}},{"line":1006,"address":[],"length":0,"stats":{"Line":0}},{"line":1007,"address":[],"length":0,"stats":{"Line":0}},{"line":1010,"address":[],"length":0,"stats":{"Line":0}},{"line":1011,"address":[],"length":0,"stats":{"Line":0}},{"line":1012,"address":[],"length":0,"stats":{"Line":0}},{"line":1013,"address":[],"length":0,"stats":{"Line":0}},{"line":1016,"address":[],"length":0,"stats":{"Line":0}},{"line":1017,"address":[],"length":0,"stats":{"Line":0}},{"line":1021,"address":[],"length":0,"stats":{"Line":0}},{"line":1022,"address":[],"length":0,"stats":{"Line":0}},{"line":1027,"address":[],"length":0,"stats":{"Line":2}},{"line":1028,"address":[],"length":0,"stats":{"Line":4}},{"line":1029,"address":[],"length":0,"stats":{"Line":14}},{"line":1030,"address":[],"length":0,"stats":{"Line":12}},{"line":1032,"address":[],"length":0,"stats":{"Line":2}},{"line":1035,"address":[],"length":0,"stats":{"Line":5}},{"line":1036,"address":[],"length":0,"stats":{"Line":10}},{"line":1037,"address":[],"length":0,"stats":{"Line":2}},{"line":1038,"address":[],"length":0,"stats":{"Line":3}},{"line":1039,"address":[],"length":0,"stats":{"Line":0}},{"line":1040,"address":[],"length":0,"stats":{"Line":0}},{"line":1041,"address":[],"length":0,"stats":{"Line":0}},{"line":1042,"address":[],"length":0,"stats":{"Line":0}},{"line":1043,"address":[],"length":0,"stats":{"Line":0}},{"line":1044,"address":[],"length":0,"stats":{"Line":0}},{"line":1045,"address":[],"length":0,"stats":{"Line":0}},{"line":1046,"address":[],"length":0,"stats":{"Line":0}},{"line":1048,"address":[],"length":0,"stats":{"Line":8}},{"line":1049,"address":[],"length":0,"stats":{"Line":3}},{"line":1051,"address":[],"length":0,"stats":{"Line":5}},{"line":1056,"address":[],"length":0,"stats":{"Line":1}},{"line":1057,"address":[],"length":0,"stats":{"Line":1}},{"line":1063,"address":[],"length":0,"stats":{"Line":1}},{"line":1064,"address":[],"length":0,"stats":{"Line":3}},{"line":1067,"address":[],"length":0,"stats":{"Line":1}},{"line":1068,"address":[],"length":0,"stats":{"Line":1}},{"line":1070,"address":[],"length":0,"stats":{"Line":0}},{"line":1071,"address":[],"length":0,"stats":{"Line":0}},{"line":1073,"address":[],"length":0,"stats":{"Line":0}},{"line":1074,"address":[],"length":0,"stats":{"Line":0}},{"line":1076,"address":[],"length":0,"stats":{"Line":0}},{"line":1077,"address":[],"length":0,"stats":{"Line":0}},{"line":1079,"address":[],"length":0,"stats":{"Line":0}},{"line":1080,"address":[],"length":0,"stats":{"Line":0}},{"line":1082,"address":[],"length":0,"stats":{"Line":0}},{"line":1083,"address":[],"length":0,"stats":{"Line":0}},{"line":1085,"address":[],"length":0,"stats":{"Line":0}},{"line":1086,"address":[],"length":0,"stats":{"Line":0}},{"line":1088,"address":[],"length":0,"stats":{"Line":0}},{"line":1089,"address":[],"length":0,"stats":{"Line":0}},{"line":1091,"address":[],"length":0,"stats":{"Line":0}},{"line":1092,"address":[],"length":0,"stats":{"Line":0}},{"line":1094,"address":[],"length":0,"stats":{"Line":0}},{"line":1095,"address":[],"length":0,"stats":{"Line":0}},{"line":1097,"address":[],"length":0,"stats":{"Line":0}},{"line":1098,"address":[],"length":0,"stats":{"Line":0}},{"line":1102,"address":[],"length":0,"stats":{"Line":0}},{"line":1107,"address":[],"length":0,"stats":{"Line":4}},{"line":1119,"address":[],"length":0,"stats":{"Line":8}},{"line":1120,"address":[],"length":0,"stats":{"Line":8}},{"line":1121,"address":[],"length":0,"stats":{"Line":8}},{"line":1122,"address":[],"length":0,"stats":{"Line":8}},{"line":1123,"address":[],"length":0,"stats":{"Line":8}},{"line":1124,"address":[],"length":0,"stats":{"Line":8}},{"line":1125,"address":[],"length":0,"stats":{"Line":8}},{"line":1126,"address":[],"length":0,"stats":{"Line":12}},{"line":1127,"address":[],"length":0,"stats":{"Line":4}},{"line":1131,"address":[],"length":0,"stats":{"Line":12}},{"line":1133,"address":[],"length":0,"stats":{"Line":36}},{"line":1134,"address":[],"length":0,"stats":{"Line":128}},{"line":1135,"address":[],"length":0,"stats":{"Line":32}},{"line":1136,"address":[],"length":0,"stats":{"Line":64}},{"line":1137,"address":[],"length":0,"stats":{"Line":64}},{"line":1138,"address":[],"length":0,"stats":{"Line":32}},{"line":1144,"address":[],"length":0,"stats":{"Line":8}},{"line":1146,"address":[],"length":0,"stats":{"Line":4}},{"line":1147,"address":[],"length":0,"stats":{"Line":4}},{"line":1148,"address":[],"length":0,"stats":{"Line":4}},{"line":1149,"address":[],"length":0,"stats":{"Line":4}},{"line":1150,"address":[],"length":0,"stats":{"Line":4}},{"line":1152,"address":[],"length":0,"stats":{"Line":4}},{"line":1153,"address":[],"length":0,"stats":{"Line":4}},{"line":1154,"address":[],"length":0,"stats":{"Line":4}},{"line":1155,"address":[],"length":0,"stats":{"Line":4}},{"line":1156,"address":[],"length":0,"stats":{"Line":4}},{"line":1159,"address":[],"length":0,"stats":{"Line":4}},{"line":1160,"address":[],"length":0,"stats":{"Line":4}},{"line":1161,"address":[],"length":0,"stats":{"Line":4}},{"line":1162,"address":[],"length":0,"stats":{"Line":4}},{"line":1163,"address":[],"length":0,"stats":{"Line":4}},{"line":1165,"address":[],"length":0,"stats":{"Line":4}},{"line":1166,"address":[],"length":0,"stats":{"Line":4}},{"line":1167,"address":[],"length":0,"stats":{"Line":4}},{"line":1168,"address":[],"length":0,"stats":{"Line":4}},{"line":1169,"address":[],"length":0,"stats":{"Line":4}},{"line":1172,"address":[],"length":0,"stats":{"Line":4}},{"line":1173,"address":[],"length":0,"stats":{"Line":4}},{"line":1174,"address":[],"length":0,"stats":{"Line":4}},{"line":1175,"address":[],"length":0,"stats":{"Line":4}},{"line":1176,"address":[],"length":0,"stats":{"Line":4}},{"line":1178,"address":[],"length":0,"stats":{"Line":4}},{"line":1179,"address":[],"length":0,"stats":{"Line":4}},{"line":1180,"address":[],"length":0,"stats":{"Line":4}},{"line":1181,"address":[],"length":0,"stats":{"Line":4}},{"line":1182,"address":[],"length":0,"stats":{"Line":4}},{"line":1185,"address":[],"length":0,"stats":{"Line":4}},{"line":1186,"address":[],"length":0,"stats":{"Line":4}},{"line":1187,"address":[],"length":0,"stats":{"Line":4}},{"line":1188,"address":[],"length":0,"stats":{"Line":4}},{"line":1189,"address":[],"length":0,"stats":{"Line":4}},{"line":1191,"address":[],"length":0,"stats":{"Line":4}},{"line":1192,"address":[],"length":0,"stats":{"Line":4}},{"line":1193,"address":[],"length":0,"stats":{"Line":4}},{"line":1194,"address":[],"length":0,"stats":{"Line":4}},{"line":1195,"address":[],"length":0,"stats":{"Line":4}},{"line":1198,"address":[],"length":0,"stats":{"Line":4}},{"line":1199,"address":[],"length":0,"stats":{"Line":4}},{"line":1200,"address":[],"length":0,"stats":{"Line":4}},{"line":1201,"address":[],"length":0,"stats":{"Line":4}},{"line":1202,"address":[],"length":0,"stats":{"Line":4}},{"line":1204,"address":[],"length":0,"stats":{"Line":4}},{"line":1205,"address":[],"length":0,"stats":{"Line":4}},{"line":1206,"address":[],"length":0,"stats":{"Line":4}},{"line":1207,"address":[],"length":0,"stats":{"Line":4}},{"line":1208,"address":[],"length":0,"stats":{"Line":4}},{"line":1211,"address":[],"length":0,"stats":{"Line":4}},{"line":1212,"address":[],"length":0,"stats":{"Line":4}},{"line":1213,"address":[],"length":0,"stats":{"Line":4}},{"line":1214,"address":[],"length":0,"stats":{"Line":4}},{"line":1215,"address":[],"length":0,"stats":{"Line":4}},{"line":1217,"address":[],"length":0,"stats":{"Line":4}},{"line":1218,"address":[],"length":0,"stats":{"Line":4}},{"line":1219,"address":[],"length":0,"stats":{"Line":4}},{"line":1220,"address":[],"length":0,"stats":{"Line":4}},{"line":1221,"address":[],"length":0,"stats":{"Line":4}},{"line":1226,"address":[],"length":0,"stats":{"Line":12}},{"line":1228,"address":[],"length":0,"stats":{"Line":8}},{"line":1230,"address":[],"length":0,"stats":{"Line":8}},{"line":1232,"address":[],"length":0,"stats":{"Line":4}},{"line":1238,"address":[],"length":0,"stats":{"Line":0}},{"line":1249,"address":[],"length":0,"stats":{"Line":0}},{"line":1250,"address":[],"length":0,"stats":{"Line":0}},{"line":1253,"address":[],"length":0,"stats":{"Line":0}},{"line":1254,"address":[],"length":0,"stats":{"Line":0}},{"line":1255,"address":[],"length":0,"stats":{"Line":0}},{"line":1256,"address":[],"length":0,"stats":{"Line":0}},{"line":1259,"address":[],"length":0,"stats":{"Line":0}},{"line":1260,"address":[],"length":0,"stats":{"Line":0}},{"line":1261,"address":[],"length":0,"stats":{"Line":0}},{"line":1262,"address":[],"length":0,"stats":{"Line":0}},{"line":1266,"address":[],"length":0,"stats":{"Line":0}},{"line":1267,"address":[],"length":0,"stats":{"Line":0}},{"line":1268,"address":[],"length":0,"stats":{"Line":0}},{"line":1269,"address":[],"length":0,"stats":{"Line":0}},{"line":1272,"address":[],"length":0,"stats":{"Line":0}},{"line":1273,"address":[],"length":0,"stats":{"Line":0}},{"line":1274,"address":[],"length":0,"stats":{"Line":0}},{"line":1275,"address":[],"length":0,"stats":{"Line":0}},{"line":1278,"address":[],"length":0,"stats":{"Line":0}},{"line":1279,"address":[],"length":0,"stats":{"Line":0}},{"line":1280,"address":[],"length":0,"stats":{"Line":0}},{"line":1281,"address":[],"length":0,"stats":{"Line":0}},{"line":1286,"address":[],"length":0,"stats":{"Line":0}},{"line":1287,"address":[],"length":0,"stats":{"Line":0}},{"line":1288,"address":[],"length":0,"stats":{"Line":0}},{"line":1289,"address":[],"length":0,"stats":{"Line":0}},{"line":1290,"address":[],"length":0,"stats":{"Line":0}},{"line":1293,"address":[],"length":0,"stats":{"Line":0}},{"line":1294,"address":[],"length":0,"stats":{"Line":0}},{"line":1295,"address":[],"length":0,"stats":{"Line":0}},{"line":1296,"address":[],"length":0,"stats":{"Line":0}},{"line":1297,"address":[],"length":0,"stats":{"Line":0}},{"line":1300,"address":[],"length":0,"stats":{"Line":0}},{"line":1301,"address":[],"length":0,"stats":{"Line":0}},{"line":1302,"address":[],"length":0,"stats":{"Line":0}},{"line":1303,"address":[],"length":0,"stats":{"Line":0}},{"line":1304,"address":[],"length":0,"stats":{"Line":0}},{"line":1307,"address":[],"length":0,"stats":{"Line":0}},{"line":1308,"address":[],"length":0,"stats":{"Line":0}},{"line":1309,"address":[],"length":0,"stats":{"Line":0}},{"line":1310,"address":[],"length":0,"stats":{"Line":0}},{"line":1311,"address":[],"length":0,"stats":{"Line":0}},{"line":1313,"address":[],"length":0,"stats":{"Line":0}},{"line":1314,"address":[],"length":0,"stats":{"Line":0}},{"line":1315,"address":[],"length":0,"stats":{"Line":0}},{"line":1316,"address":[],"length":0,"stats":{"Line":0}},{"line":1317,"address":[],"length":0,"stats":{"Line":0}},{"line":1322,"address":[],"length":0,"stats":{"Line":0}},{"line":1324,"address":[],"length":0,"stats":{"Line":0}},{"line":1326,"address":[],"length":0,"stats":{"Line":0}},{"line":1328,"address":[],"length":0,"stats":{"Line":0}},{"line":1334,"address":[],"length":0,"stats":{"Line":0}},{"line":1344,"address":[],"length":0,"stats":{"Line":0}},{"line":1345,"address":[],"length":0,"stats":{"Line":0}},{"line":1348,"address":[],"length":0,"stats":{"Line":0}},{"line":1349,"address":[],"length":0,"stats":{"Line":0}},{"line":1350,"address":[],"length":0,"stats":{"Line":0}},{"line":1351,"address":[],"length":0,"stats":{"Line":0}},{"line":1353,"address":[],"length":0,"stats":{"Line":0}},{"line":1354,"address":[],"length":0,"stats":{"Line":0}},{"line":1355,"address":[],"length":0,"stats":{"Line":0}},{"line":1356,"address":[],"length":0,"stats":{"Line":0}},{"line":1357,"address":[],"length":0,"stats":{"Line":0}},{"line":1359,"address":[],"length":0,"stats":{"Line":0}},{"line":1360,"address":[],"length":0,"stats":{"Line":0}},{"line":1361,"address":[],"length":0,"stats":{"Line":0}},{"line":1362,"address":[],"length":0,"stats":{"Line":0}},{"line":1368,"address":[],"length":0,"stats":{"Line":0}},{"line":1369,"address":[],"length":0,"stats":{"Line":0}},{"line":1370,"address":[],"length":0,"stats":{"Line":0}},{"line":1371,"address":[],"length":0,"stats":{"Line":0}},{"line":1373,"address":[],"length":0,"stats":{"Line":0}},{"line":1374,"address":[],"length":0,"stats":{"Line":0}},{"line":1375,"address":[],"length":0,"stats":{"Line":0}},{"line":1376,"address":[],"length":0,"stats":{"Line":0}},{"line":1377,"address":[],"length":0,"stats":{"Line":0}},{"line":1379,"address":[],"length":0,"stats":{"Line":0}},{"line":1380,"address":[],"length":0,"stats":{"Line":0}},{"line":1381,"address":[],"length":0,"stats":{"Line":0}},{"line":1382,"address":[],"length":0,"stats":{"Line":0}},{"line":1383,"address":[],"length":0,"stats":{"Line":0}},{"line":1389,"address":[],"length":0,"stats":{"Line":0}},{"line":1391,"address":[],"length":0,"stats":{"Line":0}},{"line":1393,"address":[],"length":0,"stats":{"Line":0}},{"line":1395,"address":[],"length":0,"stats":{"Line":0}},{"line":1401,"address":[],"length":0,"stats":{"Line":0}},{"line":1413,"address":[],"length":0,"stats":{"Line":0}},{"line":1414,"address":[],"length":0,"stats":{"Line":0}},{"line":1417,"address":[],"length":0,"stats":{"Line":0}},{"line":1418,"address":[],"length":0,"stats":{"Line":0}},{"line":1419,"address":[],"length":0,"stats":{"Line":0}},{"line":1420,"address":[],"length":0,"stats":{"Line":0}},{"line":1422,"address":[],"length":0,"stats":{"Line":0}},{"line":1423,"address":[],"length":0,"stats":{"Line":0}},{"line":1424,"address":[],"length":0,"stats":{"Line":0}},{"line":1425,"address":[],"length":0,"stats":{"Line":0}},{"line":1426,"address":[],"length":0,"stats":{"Line":0}},{"line":1428,"address":[],"length":0,"stats":{"Line":0}},{"line":1429,"address":[],"length":0,"stats":{"Line":0}},{"line":1430,"address":[],"length":0,"stats":{"Line":0}},{"line":1431,"address":[],"length":0,"stats":{"Line":0}},{"line":1437,"address":[],"length":0,"stats":{"Line":0}},{"line":1438,"address":[],"length":0,"stats":{"Line":0}},{"line":1439,"address":[],"length":0,"stats":{"Line":0}},{"line":1440,"address":[],"length":0,"stats":{"Line":0}},{"line":1442,"address":[],"length":0,"stats":{"Line":0}},{"line":1443,"address":[],"length":0,"stats":{"Line":0}},{"line":1444,"address":[],"length":0,"stats":{"Line":0}},{"line":1445,"address":[],"length":0,"stats":{"Line":0}},{"line":1446,"address":[],"length":0,"stats":{"Line":0}},{"line":1448,"address":[],"length":0,"stats":{"Line":0}},{"line":1449,"address":[],"length":0,"stats":{"Line":0}},{"line":1450,"address":[],"length":0,"stats":{"Line":0}},{"line":1451,"address":[],"length":0,"stats":{"Line":0}},{"line":1452,"address":[],"length":0,"stats":{"Line":0}},{"line":1458,"address":[],"length":0,"stats":{"Line":0}},{"line":1460,"address":[],"length":0,"stats":{"Line":0}},{"line":1462,"address":[],"length":0,"stats":{"Line":0}},{"line":1464,"address":[],"length":0,"stats":{"Line":0}},{"line":1470,"address":[],"length":0,"stats":{"Line":0}},{"line":1479,"address":[],"length":0,"stats":{"Line":0}},{"line":1480,"address":[],"length":0,"stats":{"Line":0}},{"line":1482,"address":[],"length":0,"stats":{"Line":0}},{"line":1483,"address":[],"length":0,"stats":{"Line":0}},{"line":1484,"address":[],"length":0,"stats":{"Line":0}},{"line":1485,"address":[],"length":0,"stats":{"Line":0}},{"line":1486,"address":[],"length":0,"stats":{"Line":0}},{"line":1487,"address":[],"length":0,"stats":{"Line":0}},{"line":1488,"address":[],"length":0,"stats":{"Line":0}},{"line":1489,"address":[],"length":0,"stats":{"Line":0}},{"line":1490,"address":[],"length":0,"stats":{"Line":0}},{"line":1491,"address":[],"length":0,"stats":{"Line":0}},{"line":1495,"address":[],"length":0,"stats":{"Line":0}},{"line":1498,"address":[],"length":0,"stats":{"Line":0}},{"line":1499,"address":[],"length":0,"stats":{"Line":0}},{"line":1500,"address":[],"length":0,"stats":{"Line":0}},{"line":1501,"address":[],"length":0,"stats":{"Line":0}},{"line":1502,"address":[],"length":0,"stats":{"Line":0}},{"line":1507,"address":[],"length":0,"stats":{"Line":0}},{"line":1508,"address":[],"length":0,"stats":{"Line":0}},{"line":1509,"address":[],"length":0,"stats":{"Line":0}},{"line":1510,"address":[],"length":0,"stats":{"Line":0}},{"line":1511,"address":[],"length":0,"stats":{"Line":0}},{"line":1516,"address":[],"length":0,"stats":{"Line":0}},{"line":1517,"address":[],"length":0,"stats":{"Line":0}},{"line":1518,"address":[],"length":0,"stats":{"Line":0}},{"line":1519,"address":[],"length":0,"stats":{"Line":0}},{"line":1520,"address":[],"length":0,"stats":{"Line":0}},{"line":1521,"address":[],"length":0,"stats":{"Line":0}},{"line":1526,"address":[],"length":0,"stats":{"Line":0}},{"line":1527,"address":[],"length":0,"stats":{"Line":0}},{"line":1528,"address":[],"length":0,"stats":{"Line":0}},{"line":1529,"address":[],"length":0,"stats":{"Line":0}},{"line":1530,"address":[],"length":0,"stats":{"Line":0}},{"line":1531,"address":[],"length":0,"stats":{"Line":0}},{"line":1536,"address":[],"length":0,"stats":{"Line":0}},{"line":1537,"address":[],"length":0,"stats":{"Line":0}},{"line":1538,"address":[],"length":0,"stats":{"Line":0}},{"line":1539,"address":[],"length":0,"stats":{"Line":0}},{"line":1540,"address":[],"length":0,"stats":{"Line":0}},{"line":1541,"address":[],"length":0,"stats":{"Line":0}},{"line":1543,"address":[],"length":0,"stats":{"Line":0}},{"line":1544,"address":[],"length":0,"stats":{"Line":0}},{"line":1545,"address":[],"length":0,"stats":{"Line":0}},{"line":1546,"address":[],"length":0,"stats":{"Line":0}},{"line":1547,"address":[],"length":0,"stats":{"Line":0}},{"line":1549,"address":[],"length":0,"stats":{"Line":0}},{"line":1550,"address":[],"length":0,"stats":{"Line":0}},{"line":1551,"address":[],"length":0,"stats":{"Line":0}},{"line":1552,"address":[],"length":0,"stats":{"Line":0}},{"line":1553,"address":[],"length":0,"stats":{"Line":0}},{"line":1558,"address":[],"length":0,"stats":{"Line":0}},{"line":1560,"address":[],"length":0,"stats":{"Line":0}},{"line":1562,"address":[],"length":0,"stats":{"Line":0}},{"line":1564,"address":[],"length":0,"stats":{"Line":0}},{"line":1570,"address":[],"length":0,"stats":{"Line":0}},{"line":1573,"address":[],"length":0,"stats":{"Line":0}},{"line":1574,"address":[],"length":0,"stats":{"Line":0}},{"line":1577,"address":[],"length":0,"stats":{"Line":0}},{"line":1578,"address":[],"length":0,"stats":{"Line":0}},{"line":1581,"address":[],"length":0,"stats":{"Line":0}},{"line":1582,"address":[],"length":0,"stats":{"Line":0}},{"line":1583,"address":[],"length":0,"stats":{"Line":0}},{"line":1584,"address":[],"length":0,"stats":{"Line":0}},{"line":1585,"address":[],"length":0,"stats":{"Line":0}},{"line":1589,"address":[],"length":0,"stats":{"Line":0}},{"line":1590,"address":[],"length":0,"stats":{"Line":0}},{"line":1591,"address":[],"length":0,"stats":{"Line":0}},{"line":1592,"address":[],"length":0,"stats":{"Line":0}},{"line":1593,"address":[],"length":0,"stats":{"Line":0}},{"line":1597,"address":[],"length":0,"stats":{"Line":0}},{"line":1598,"address":[],"length":0,"stats":{"Line":0}},{"line":1599,"address":[],"length":0,"stats":{"Line":0}},{"line":1600,"address":[],"length":0,"stats":{"Line":0}},{"line":1601,"address":[],"length":0,"stats":{"Line":0}},{"line":1604,"address":[],"length":0,"stats":{"Line":0}},{"line":1605,"address":[],"length":0,"stats":{"Line":0}},{"line":1606,"address":[],"length":0,"stats":{"Line":0}},{"line":1607,"address":[],"length":0,"stats":{"Line":0}},{"line":1608,"address":[],"length":0,"stats":{"Line":0}},{"line":1611,"address":[],"length":0,"stats":{"Line":0}},{"line":1612,"address":[],"length":0,"stats":{"Line":0}},{"line":1613,"address":[],"length":0,"stats":{"Line":0}},{"line":1614,"address":[],"length":0,"stats":{"Line":0}},{"line":1615,"address":[],"length":0,"stats":{"Line":0}},{"line":1618,"address":[],"length":0,"stats":{"Line":0}},{"line":1619,"address":[],"length":0,"stats":{"Line":0}},{"line":1620,"address":[],"length":0,"stats":{"Line":0}},{"line":1621,"address":[],"length":0,"stats":{"Line":0}},{"line":1622,"address":[],"length":0,"stats":{"Line":0}},{"line":1628,"address":[],"length":0,"stats":{"Line":0}},{"line":1629,"address":[],"length":0,"stats":{"Line":0}},{"line":1630,"address":[],"length":0,"stats":{"Line":0}},{"line":1631,"address":[],"length":0,"stats":{"Line":0}},{"line":1632,"address":[],"length":0,"stats":{"Line":0}},{"line":1633,"address":[],"length":0,"stats":{"Line":0}},{"line":1634,"address":[],"length":0,"stats":{"Line":0}},{"line":1635,"address":[],"length":0,"stats":{"Line":0}},{"line":1636,"address":[],"length":0,"stats":{"Line":0}},{"line":1637,"address":[],"length":0,"stats":{"Line":0}},{"line":1639,"address":[],"length":0,"stats":{"Line":0}},{"line":1640,"address":[],"length":0,"stats":{"Line":0}},{"line":1641,"address":[],"length":0,"stats":{"Line":0}},{"line":1642,"address":[],"length":0,"stats":{"Line":0}},{"line":1643,"address":[],"length":0,"stats":{"Line":0}},{"line":1648,"address":[],"length":0,"stats":{"Line":0}},{"line":1649,"address":[],"length":0,"stats":{"Line":0}},{"line":1650,"address":[],"length":0,"stats":{"Line":0}},{"line":1651,"address":[],"length":0,"stats":{"Line":0}},{"line":1652,"address":[],"length":0,"stats":{"Line":0}},{"line":1653,"address":[],"length":0,"stats":{"Line":0}},{"line":1654,"address":[],"length":0,"stats":{"Line":0}},{"line":1655,"address":[],"length":0,"stats":{"Line":0}},{"line":1656,"address":[],"length":0,"stats":{"Line":0}},{"line":1657,"address":[],"length":0,"stats":{"Line":0}},{"line":1659,"address":[],"length":0,"stats":{"Line":0}},{"line":1660,"address":[],"length":0,"stats":{"Line":0}},{"line":1661,"address":[],"length":0,"stats":{"Line":0}},{"line":1662,"address":[],"length":0,"stats":{"Line":0}},{"line":1663,"address":[],"length":0,"stats":{"Line":0}},{"line":1668,"address":[],"length":0,"stats":{"Line":0}},{"line":1669,"address":[],"length":0,"stats":{"Line":0}},{"line":1670,"address":[],"length":0,"stats":{"Line":0}},{"line":1671,"address":[],"length":0,"stats":{"Line":0}},{"line":1672,"address":[],"length":0,"stats":{"Line":0}},{"line":1673,"address":[],"length":0,"stats":{"Line":0}},{"line":1674,"address":[],"length":0,"stats":{"Line":0}},{"line":1675,"address":[],"length":0,"stats":{"Line":0}},{"line":1676,"address":[],"length":0,"stats":{"Line":0}},{"line":1677,"address":[],"length":0,"stats":{"Line":0}},{"line":1679,"address":[],"length":0,"stats":{"Line":0}},{"line":1680,"address":[],"length":0,"stats":{"Line":0}},{"line":1681,"address":[],"length":0,"stats":{"Line":0}},{"line":1682,"address":[],"length":0,"stats":{"Line":0}},{"line":1683,"address":[],"length":0,"stats":{"Line":0}},{"line":1688,"address":[],"length":0,"stats":{"Line":0}},{"line":1689,"address":[],"length":0,"stats":{"Line":0}},{"line":1690,"address":[],"length":0,"stats":{"Line":0}},{"line":1691,"address":[],"length":0,"stats":{"Line":0}},{"line":1692,"address":[],"length":0,"stats":{"Line":0}},{"line":1693,"address":[],"length":0,"stats":{"Line":0}},{"line":1694,"address":[],"length":0,"stats":{"Line":0}},{"line":1695,"address":[],"length":0,"stats":{"Line":0}},{"line":1696,"address":[],"length":0,"stats":{"Line":0}},{"line":1697,"address":[],"length":0,"stats":{"Line":0}},{"line":1699,"address":[],"length":0,"stats":{"Line":0}},{"line":1700,"address":[],"length":0,"stats":{"Line":0}},{"line":1701,"address":[],"length":0,"stats":{"Line":0}},{"line":1702,"address":[],"length":0,"stats":{"Line":0}},{"line":1703,"address":[],"length":0,"stats":{"Line":0}},{"line":1708,"address":[],"length":0,"stats":{"Line":0}},{"line":1710,"address":[],"length":0,"stats":{"Line":0}},{"line":1712,"address":[],"length":0,"stats":{"Line":0}},{"line":1714,"address":[],"length":0,"stats":{"Line":0}},{"line":1720,"address":[],"length":0,"stats":{"Line":0}},{"line":1729,"address":[],"length":0,"stats":{"Line":0}},{"line":1730,"address":[],"length":0,"stats":{"Line":0}},{"line":1732,"address":[],"length":0,"stats":{"Line":0}},{"line":1733,"address":[],"length":0,"stats":{"Line":0}},{"line":1734,"address":[],"length":0,"stats":{"Line":0}},{"line":1735,"address":[],"length":0,"stats":{"Line":0}},{"line":1736,"address":[],"length":0,"stats":{"Line":0}},{"line":1737,"address":[],"length":0,"stats":{"Line":0}},{"line":1738,"address":[],"length":0,"stats":{"Line":0}},{"line":1739,"address":[],"length":0,"stats":{"Line":0}},{"line":1740,"address":[],"length":0,"stats":{"Line":0}},{"line":1741,"address":[],"length":0,"stats":{"Line":0}},{"line":1745,"address":[],"length":0,"stats":{"Line":0}},{"line":1748,"address":[],"length":0,"stats":{"Line":0}},{"line":1749,"address":[],"length":0,"stats":{"Line":0}},{"line":1750,"address":[],"length":0,"stats":{"Line":0}},{"line":1751,"address":[],"length":0,"stats":{"Line":0}},{"line":1753,"address":[],"length":0,"stats":{"Line":0}},{"line":1754,"address":[],"length":0,"stats":{"Line":0}},{"line":1755,"address":[],"length":0,"stats":{"Line":0}},{"line":1757,"address":[],"length":0,"stats":{"Line":0}},{"line":1758,"address":[],"length":0,"stats":{"Line":0}},{"line":1759,"address":[],"length":0,"stats":{"Line":0}},{"line":1760,"address":[],"length":0,"stats":{"Line":0}},{"line":1766,"address":[],"length":0,"stats":{"Line":0}},{"line":1767,"address":[],"length":0,"stats":{"Line":0}},{"line":1768,"address":[],"length":0,"stats":{"Line":0}},{"line":1769,"address":[],"length":0,"stats":{"Line":0}},{"line":1771,"address":[],"length":0,"stats":{"Line":0}},{"line":1772,"address":[],"length":0,"stats":{"Line":0}},{"line":1773,"address":[],"length":0,"stats":{"Line":0}},{"line":1774,"address":[],"length":0,"stats":{"Line":0}},{"line":1775,"address":[],"length":0,"stats":{"Line":0}},{"line":1777,"address":[],"length":0,"stats":{"Line":0}},{"line":1778,"address":[],"length":0,"stats":{"Line":0}},{"line":1779,"address":[],"length":0,"stats":{"Line":0}},{"line":1780,"address":[],"length":0,"stats":{"Line":0}},{"line":1781,"address":[],"length":0,"stats":{"Line":0}},{"line":1787,"address":[],"length":0,"stats":{"Line":0}},{"line":1789,"address":[],"length":0,"stats":{"Line":0}},{"line":1791,"address":[],"length":0,"stats":{"Line":0}},{"line":1793,"address":[],"length":0,"stats":{"Line":0}},{"line":1799,"address":[],"length":0,"stats":{"Line":0}},{"line":1808,"address":[],"length":0,"stats":{"Line":0}},{"line":1809,"address":[],"length":0,"stats":{"Line":0}},{"line":1811,"address":[],"length":0,"stats":{"Line":0}},{"line":1812,"address":[],"length":0,"stats":{"Line":0}},{"line":1813,"address":[],"length":0,"stats":{"Line":0}},{"line":1814,"address":[],"length":0,"stats":{"Line":0}},{"line":1815,"address":[],"length":0,"stats":{"Line":0}},{"line":1816,"address":[],"length":0,"stats":{"Line":0}},{"line":1817,"address":[],"length":0,"stats":{"Line":0}},{"line":1818,"address":[],"length":0,"stats":{"Line":0}},{"line":1819,"address":[],"length":0,"stats":{"Line":0}},{"line":1820,"address":[],"length":0,"stats":{"Line":0}},{"line":1824,"address":[],"length":0,"stats":{"Line":0}},{"line":1825,"address":[],"length":0,"stats":{"Line":0}},{"line":1829,"address":[],"length":0,"stats":{"Line":0}},{"line":1831,"address":[],"length":0,"stats":{"Line":0}},{"line":1832,"address":[],"length":0,"stats":{"Line":0}},{"line":1834,"address":[],"length":0,"stats":{"Line":0}},{"line":1835,"address":[],"length":0,"stats":{"Line":0}},{"line":1836,"address":[],"length":0,"stats":{"Line":0}},{"line":1838,"address":[],"length":0,"stats":{"Line":0}},{"line":1839,"address":[],"length":0,"stats":{"Line":0}},{"line":1841,"address":[],"length":0,"stats":{"Line":0}},{"line":1842,"address":[],"length":0,"stats":{"Line":0}},{"line":1843,"address":[],"length":0,"stats":{"Line":0}},{"line":1846,"address":[],"length":0,"stats":{"Line":0}},{"line":1847,"address":[],"length":0,"stats":{"Line":0}},{"line":1849,"address":[],"length":0,"stats":{"Line":0}},{"line":1850,"address":[],"length":0,"stats":{"Line":0}},{"line":1851,"address":[],"length":0,"stats":{"Line":0}},{"line":1856,"address":[],"length":0,"stats":{"Line":0}},{"line":1857,"address":[],"length":0,"stats":{"Line":0}},{"line":1858,"address":[],"length":0,"stats":{"Line":0}},{"line":1859,"address":[],"length":0,"stats":{"Line":0}},{"line":1861,"address":[],"length":0,"stats":{"Line":0}},{"line":1866,"address":[],"length":0,"stats":{"Line":0}},{"line":1867,"address":[],"length":0,"stats":{"Line":0}},{"line":1868,"address":[],"length":0,"stats":{"Line":0}},{"line":1869,"address":[],"length":0,"stats":{"Line":0}},{"line":1870,"address":[],"length":0,"stats":{"Line":0}},{"line":1872,"address":[],"length":0,"stats":{"Line":0}},{"line":1873,"address":[],"length":0,"stats":{"Line":0}},{"line":1875,"address":[],"length":0,"stats":{"Line":0}},{"line":1876,"address":[],"length":0,"stats":{"Line":0}},{"line":1877,"address":[],"length":0,"stats":{"Line":0}},{"line":1880,"address":[],"length":0,"stats":{"Line":0}},{"line":1884,"address":[],"length":0,"stats":{"Line":0}},{"line":1885,"address":[],"length":0,"stats":{"Line":0}},{"line":1886,"address":[],"length":0,"stats":{"Line":0}},{"line":1887,"address":[],"length":0,"stats":{"Line":0}},{"line":1891,"address":[],"length":0,"stats":{"Line":0}},{"line":1892,"address":[],"length":0,"stats":{"Line":0}},{"line":1893,"address":[],"length":0,"stats":{"Line":0}},{"line":1894,"address":[],"length":0,"stats":{"Line":0}},{"line":1896,"address":[],"length":0,"stats":{"Line":0}},{"line":1897,"address":[],"length":0,"stats":{"Line":0}},{"line":1898,"address":[],"length":0,"stats":{"Line":0}},{"line":1899,"address":[],"length":0,"stats":{"Line":0}},{"line":1905,"address":[],"length":0,"stats":{"Line":0}},{"line":1906,"address":[],"length":0,"stats":{"Line":0}},{"line":1907,"address":[],"length":0,"stats":{"Line":0}},{"line":1909,"address":[],"length":0,"stats":{"Line":0}},{"line":1910,"address":[],"length":0,"stats":{"Line":0}},{"line":1911,"address":[],"length":0,"stats":{"Line":0}},{"line":1912,"address":[],"length":0,"stats":{"Line":0}},{"line":1914,"address":[],"length":0,"stats":{"Line":0}},{"line":1915,"address":[],"length":0,"stats":{"Line":0}},{"line":1916,"address":[],"length":0,"stats":{"Line":0}},{"line":1917,"address":[],"length":0,"stats":{"Line":0}},{"line":1918,"address":[],"length":0,"stats":{"Line":0}},{"line":1920,"address":[],"length":0,"stats":{"Line":0}},{"line":1921,"address":[],"length":0,"stats":{"Line":0}},{"line":1922,"address":[],"length":0,"stats":{"Line":0}},{"line":1923,"address":[],"length":0,"stats":{"Line":0}},{"line":1924,"address":[],"length":0,"stats":{"Line":0}},{"line":1931,"address":[],"length":0,"stats":{"Line":0}},{"line":1932,"address":[],"length":0,"stats":{"Line":0}},{"line":1933,"address":[],"length":0,"stats":{"Line":0}},{"line":1934,"address":[],"length":0,"stats":{"Line":0}},{"line":1935,"address":[],"length":0,"stats":{"Line":0}},{"line":1936,"address":[],"length":0,"stats":{"Line":0}},{"line":1941,"address":[],"length":0,"stats":{"Line":0}},{"line":1942,"address":[],"length":0,"stats":{"Line":0}},{"line":1943,"address":[],"length":0,"stats":{"Line":0}},{"line":1944,"address":[],"length":0,"stats":{"Line":0}},{"line":1945,"address":[],"length":0,"stats":{"Line":0}},{"line":1946,"address":[],"length":0,"stats":{"Line":0}},{"line":1947,"address":[],"length":0,"stats":{"Line":0}},{"line":1952,"address":[],"length":0,"stats":{"Line":0}},{"line":1954,"address":[],"length":0,"stats":{"Line":0}},{"line":1956,"address":[],"length":0,"stats":{"Line":0}},{"line":1958,"address":[],"length":0,"stats":{"Line":0}}],"covered":383,"coverable":1023},{"path":["/","workspace","crates","ofml-lib","src","texture.rs"],"content":"//! Texture Loading System - Image file handling for materials.\n//!\n//! This module implements texture loading for OFML products including:\n//! - PNG, JPG, TGA, BMP format support\n//! - Texture data management for GLB export\n//! - Image format conversion\n\nuse std::collections::HashMap;\nuse std::io::Cursor;\n\nuse image::{DynamicImage, GenericImageView, ImageFormat};\n\nuse crate::errors::MaterialError;\n\n/// Loaded texture data ready for export.\n#[derive(Debug, Clone)]\npub struct TextureData {\n    /// Texture name/identifier\n    pub name: String,\n    /// Image width\n    pub width: u32,\n    /// Image height\n    pub height: u32,\n    /// PNG-encoded image data (for GLB embedding)\n    pub png_data: Vec<u8>,\n    /// Original file format\n    pub original_format: ImageFormat,\n}\n\nimpl TextureData {\n    /// Create a new texture from raw image bytes.\n    pub fn from_bytes(name: impl Into<String>, data: &[u8]) -> Result<Self, MaterialError> {\n        let name = name.into();\n\n        // Detect format\n        let format = image::guess_format(data).map_err(|e| MaterialError::TextureLoadError {\n            filename: name.clone(),\n            message: format!(\"Could not detect image format: {}\", e),\n        })?;\n\n        // Load image\n        let img = image::load_from_memory(data).map_err(|e| MaterialError::TextureLoadError {\n            filename: name.clone(),\n            message: format!(\"Failed to decode image: {}\", e),\n        })?;\n\n        // Convert to PNG for GLB embedding\n        let (width, height) = img.dimensions();\n        let png_data = encode_as_png(&img)?;\n\n        Ok(Self {\n            name,\n            width,\n            height,\n            png_data,\n            original_format: format,\n        })\n    }\n\n    /// Create a new texture from a dynamic image.\n    pub fn from_image(name: impl Into<String>, img: DynamicImage) -> Result<Self, MaterialError> {\n        let name = name.into();\n        let (width, height) = img.dimensions();\n        let png_data = encode_as_png(&img)?;\n\n        Ok(Self {\n            name,\n            width,\n            height,\n            png_data,\n            original_format: ImageFormat::Png,\n        })\n    }\n\n    /// Get the MIME type for GLB embedding.\n    pub fn mime_type(&self) -> &'static str {\n        \"image/png\" // Always PNG for GLB\n    }\n\n    /// Get the byte size of the texture data.\n    pub fn byte_size(&self) -> usize {\n        self.png_data.len()\n    }\n}\n\n/// Encode an image as PNG.\nfn encode_as_png(img: &DynamicImage) -> Result<Vec<u8>, MaterialError> {\n    let mut png_data = Vec::new();\n    let mut cursor = Cursor::new(&mut png_data);\n\n    img.write_to(&mut cursor, ImageFormat::Png)\n        .map_err(|e| MaterialError::InvalidProperty {\n            property: \"png_encode\".to_string(),\n            message: format!(\"Failed to encode as PNG: {}\", e),\n        })?;\n\n    Ok(png_data)\n}\n\n/// Texture cache for managing loaded textures.\n#[derive(Debug, Default)]\npub struct TextureCache {\n    /// Cached textures by name\n    textures: HashMap<String, TextureData>,\n}\n\nimpl TextureCache {\n    /// Create a new empty texture cache.\n    pub fn new() -> Self {\n        Self {\n            textures: HashMap::new(),\n        }\n    }\n\n    /// Load and cache a texture from bytes.\n    pub fn load(&mut self, name: &str, data: &[u8]) -> Result<&TextureData, MaterialError> {\n        if !self.textures.contains_key(name) {\n            let texture = TextureData::from_bytes(name, data)?;\n            self.textures.insert(name.to_string(), texture);\n        }\n        Ok(self.textures.get(name).unwrap())\n    }\n\n    /// Get a cached texture by name.\n    pub fn get(&self, name: &str) -> Option<&TextureData> {\n        self.textures.get(name)\n    }\n\n    /// Check if a texture is cached.\n    pub fn contains(&self, name: &str) -> bool {\n        self.textures.contains_key(name)\n    }\n\n    /// Insert a pre-loaded texture.\n    pub fn insert(&mut self, texture: TextureData) {\n        self.textures.insert(texture.name.clone(), texture);\n    }\n\n    /// Get all cached texture names.\n    pub fn names(&self) -> Vec<&String> {\n        self.textures.keys().collect()\n    }\n\n    /// Get all cached textures.\n    pub fn all(&self) -> impl Iterator<Item = &TextureData> {\n        self.textures.values()\n    }\n\n    /// Get the number of cached textures.\n    pub fn len(&self) -> usize {\n        self.textures.len()\n    }\n\n    /// Check if the cache is empty.\n    pub fn is_empty(&self) -> bool {\n        self.textures.is_empty()\n    }\n\n    /// Clear the cache.\n    pub fn clear(&mut self) {\n        self.textures.clear();\n    }\n}\n\n/// Create a solid color texture.\npub fn create_solid_color(\n    name: &str,\n    r: u8,\n    g: u8,\n    b: u8,\n    a: u8,\n) -> Result<TextureData, MaterialError> {\n    let img = DynamicImage::ImageRgba8(image::RgbaImage::from_pixel(\n        1,\n        1,\n        image::Rgba([r, g, b, a]),\n    ));\n    TextureData::from_image(name, img)\n}\n\n/// Create a checkerboard texture (useful for debugging).\npub fn create_checkerboard(\n    name: &str,\n    size: u32,\n    color1: [u8; 4],\n    color2: [u8; 4],\n) -> Result<TextureData, MaterialError> {\n    let mut img = image::RgbaImage::new(size, size);\n\n    for y in 0..size {\n        for x in 0..size {\n            let color = if ((x / 8) + (y / 8)) % 2 == 0 {\n                image::Rgba(color1)\n            } else {\n                image::Rgba(color2)\n            };\n            img.put_pixel(x, y, color);\n        }\n    }\n\n    TextureData::from_image(name, DynamicImage::ImageRgba8(img))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_solid_color_texture() {\n        let tex = create_solid_color(\"red\", 255, 0, 0, 255).unwrap();\n        assert_eq!(tex.name, \"red\");\n        assert_eq!(tex.width, 1);\n        assert_eq!(tex.height, 1);\n        assert!(!tex.png_data.is_empty());\n    }\n\n    #[test]\n    fn test_checkerboard_texture() {\n        let tex = create_checkerboard(\"check\", 64, [255, 255, 255, 255], [0, 0, 0, 255]).unwrap();\n        assert_eq!(tex.name, \"check\");\n        assert_eq!(tex.width, 64);\n        assert_eq!(tex.height, 64);\n    }\n\n    #[test]\n    fn test_texture_cache() {\n        let mut cache = TextureCache::new();\n        assert!(cache.is_empty());\n\n        let tex = create_solid_color(\"test\", 128, 128, 128, 255).unwrap();\n        cache.insert(tex);\n\n        assert_eq!(cache.len(), 1);\n        assert!(cache.contains(\"test\"));\n        assert!(cache.get(\"test\").is_some());\n    }\n\n    #[test]\n    fn test_mime_type() {\n        let tex = create_solid_color(\"test\", 0, 0, 0, 255).unwrap();\n        assert_eq!(tex.mime_type(), \"image/png\");\n    }\n\n    #[test]\n    fn test_texture_data_byte_size() {\n        let tex = create_solid_color(\"test\", 255, 0, 0, 255).unwrap();\n        assert!(tex.byte_size() > 0);\n        assert_eq!(tex.byte_size(), tex.png_data.len());\n    }\n\n    #[test]\n    fn test_texture_cache_names() {\n        let mut cache = TextureCache::new();\n        let tex1 = create_solid_color(\"tex1\", 255, 0, 0, 255).unwrap();\n        let tex2 = create_solid_color(\"tex2\", 0, 255, 0, 255).unwrap();\n        cache.insert(tex1);\n        cache.insert(tex2);\n\n        let names = cache.names();\n        assert_eq!(names.len(), 2);\n    }\n\n    #[test]\n    fn test_texture_cache_all() {\n        let mut cache = TextureCache::new();\n        let tex = create_solid_color(\"test\", 128, 128, 128, 255).unwrap();\n        cache.insert(tex);\n\n        let textures: Vec<_> = cache.all().collect();\n        assert_eq!(textures.len(), 1);\n        assert_eq!(textures[0].name, \"test\");\n    }\n\n    #[test]\n    fn test_texture_cache_clear() {\n        let mut cache = TextureCache::new();\n        let tex = create_solid_color(\"test\", 0, 0, 0, 255).unwrap();\n        cache.insert(tex);\n        assert!(!cache.is_empty());\n\n        cache.clear();\n        assert!(cache.is_empty());\n        assert_eq!(cache.len(), 0);\n    }\n\n    #[test]\n    fn test_texture_data_from_bytes_invalid() {\n        let invalid_data = vec![0, 1, 2, 3, 4, 5];\n        let result = TextureData::from_bytes(\"invalid\", &invalid_data);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_texture_cache_get_missing() {\n        let cache = TextureCache::new();\n        assert!(cache.get(\"nonexistent\").is_none());\n        assert!(!cache.contains(\"nonexistent\"));\n    }\n\n    #[test]\n    fn test_texture_data_clone() {\n        let tex = create_solid_color(\"original\", 100, 150, 200, 255).unwrap();\n        let cloned = tex.clone();\n        assert_eq!(cloned.name, \"original\");\n        assert_eq!(cloned.width, 1);\n        assert_eq!(cloned.height, 1);\n    }\n\n    #[test]\n    fn test_texture_data_debug() {\n        let tex = create_solid_color(\"test\", 0, 0, 0, 255).unwrap();\n        let debug_str = format!(\"{:?}\", tex);\n        assert!(debug_str.contains(\"TextureData\"));\n        assert!(debug_str.contains(\"test\"));\n    }\n\n    #[test]\n    fn test_texture_cache_default() {\n        let cache = TextureCache::default();\n        assert!(cache.is_empty());\n    }\n\n    #[test]\n    fn test_texture_cache_debug() {\n        let cache = TextureCache::new();\n        let debug_str = format!(\"{:?}\", cache);\n        assert!(debug_str.contains(\"TextureCache\"));\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":3}},{"line":36,"address":[],"length":0,"stats":{"Line":3}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":11}},{"line":62,"address":[],"length":0,"stats":{"Line":33}},{"line":63,"address":[],"length":0,"stats":{"Line":33}},{"line":64,"address":[],"length":0,"stats":{"Line":33}},{"line":66,"address":[],"length":0,"stats":{"Line":11}},{"line":67,"address":[],"length":0,"stats":{"Line":22}},{"line":68,"address":[],"length":0,"stats":{"Line":22}},{"line":69,"address":[],"length":0,"stats":{"Line":22}},{"line":70,"address":[],"length":0,"stats":{"Line":11}},{"line":71,"address":[],"length":0,"stats":{"Line":11}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":87,"address":[],"length":0,"stats":{"Line":11}},{"line":88,"address":[],"length":0,"stats":{"Line":22}},{"line":89,"address":[],"length":0,"stats":{"Line":33}},{"line":91,"address":[],"length":0,"stats":{"Line":44}},{"line":92,"address":[],"length":0,"stats":{"Line":11}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":11}},{"line":109,"address":[],"length":0,"stats":{"Line":6}},{"line":111,"address":[],"length":0,"stats":{"Line":6}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":6}},{"line":135,"address":[],"length":0,"stats":{"Line":5}},{"line":136,"address":[],"length":0,"stats":{"Line":25}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":3}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":2}},{"line":151,"address":[],"length":0,"stats":{"Line":4}},{"line":155,"address":[],"length":0,"stats":{"Line":4}},{"line":156,"address":[],"length":0,"stats":{"Line":8}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":10}},{"line":173,"address":[],"length":0,"stats":{"Line":30}},{"line":174,"address":[],"length":0,"stats":{"Line":10}},{"line":175,"address":[],"length":0,"stats":{"Line":10}},{"line":176,"address":[],"length":0,"stats":{"Line":30}},{"line":178,"address":[],"length":0,"stats":{"Line":30}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":188,"address":[],"length":0,"stats":{"Line":4}},{"line":190,"address":[],"length":0,"stats":{"Line":65}},{"line":191,"address":[],"length":0,"stats":{"Line":4160}},{"line":192,"address":[],"length":0,"stats":{"Line":8192}},{"line":193,"address":[],"length":0,"stats":{"Line":2048}},{"line":195,"address":[],"length":0,"stats":{"Line":2048}},{"line":197,"address":[],"length":0,"stats":{"Line":20480}},{"line":201,"address":[],"length":0,"stats":{"Line":3}}],"covered":58,"coverable":76},{"path":["/","workspace","crates","ofml-lib","src","value.rs"],"content":"//! Runtime values for the OFML interpreter\n\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::fmt;\nuse std::rc::Rc;\n\nuse crate::ast::ClassDecl;\n\n/// Runtime value types\n#[derive(Clone)]\npub enum Value {\n    /// Null value\n    Null,\n    /// Integer\n    Int(i64),\n    /// Floating point\n    Float(f64),\n    /// String\n    String(Rc<String>),\n    /// Symbol (interned string)\n    Symbol(Rc<String>),\n    /// Boolean (used internally, OFML uses Int for bools)\n    Bool(bool),\n    /// Array/Vector\n    Array(Rc<RefCell<Vec<Value>>>),\n    /// Hash map\n    Hash(Rc<RefCell<HashMap<String, Value>>>),\n    /// Object instance\n    Object(Rc<RefCell<ObjInstance>>),\n    /// Function reference\n    Func(Rc<FuncValue>),\n    /// Native function\n    NativeFunc(Rc<NativeFn>),\n    /// Class reference\n    Class(Rc<ClassValue>),\n    /// 3D Vector (convenience type for geometry)\n    Vec3([f64; 3]),\n}\n\n/// Property definition for OFML property system\n#[derive(Clone, Debug)]\npub struct PropertyDef {\n    /// Property name (symbol)\n    pub name: String,\n    /// Property type info\n    pub type_info: String,\n    /// Property description/label\n    pub description: String,\n    /// Sort order\n    pub sort_order: i32,\n    /// Property group\n    pub group: i32,\n    /// Available choices (for enum properties)\n    pub choices: Vec<Value>,\n    /// Property state (0=hidden, 1=readonly, 3=editable)\n    pub state: i32,\n    /// Default value\n    pub default_value: Value,\n}\n\nimpl Default for PropertyDef {\n    fn default() -> Self {\n        Self {\n            name: String::new(),\n            type_info: String::new(),\n            description: String::new(),\n            sort_order: 0,\n            group: 0,\n            choices: Vec::new(),\n            state: 3, // editable by default\n            default_value: Value::Null,\n        }\n    }\n}\n\n/// Object instance\n#[derive(Clone)]\npub struct ObjInstance {\n    /// Class this object is an instance of\n    pub class: Rc<ClassValue>,\n    /// Instance variables\n    pub fields: HashMap<String, Value>,\n    /// Property values (OFML property system)\n    pub properties: HashMap<String, Value>,\n    /// Property definitions\n    pub prop_defs: HashMap<String, PropertyDef>,\n    /// Property states (0=hidden, 1=readonly, 3=editable)\n    pub prop_states: HashMap<String, i32>,\n    /// Parent object (for hierarchy)\n    pub parent: Option<Rc<RefCell<ObjInstance>>>,\n    /// Child objects\n    pub children: Vec<Rc<RefCell<ObjInstance>>>,\n    /// Object name\n    pub name: String,\n    /// Position in 3D space\n    pub position: [f64; 3],\n    /// Rotation (axis angles in radians)\n    pub rotation: [f64; 3],\n    /// Scale factor\n    pub scale: f64,\n    /// Material name\n    pub material: Option<String>,\n}\n\n/// Function value\n#[derive(Clone)]\npub struct FuncValue {\n    pub name: String,\n    pub params: Vec<String>,\n    pub body: Option<crate::ast::Block>,\n    pub class: Option<Rc<ClassValue>>,\n    pub is_static: bool,\n}\n\n/// Class value\n#[derive(Clone)]\npub struct ClassValue {\n    pub name: String,\n    /// Package this class belongs to (e.g., \"::vitra::basics\")\n    pub package: String,\n    pub parent: Option<Rc<ClassValue>>,\n    pub methods: HashMap<String, Rc<FuncValue>>,\n    pub rules: HashMap<String, Rc<FuncValue>>,\n    pub static_vars: HashMap<String, Value>,\n    pub decl: ClassDecl,\n}\n\nimpl ClassValue {\n    /// Get fully qualified class name (e.g., \"::vitra::basics::VitraOiBTGPlElement3\")\n    pub fn qualified_name(&self) -> String {\n        if self.package.is_empty() {\n            self.name.clone()\n        } else {\n            format!(\"{}::{}\", self.package, self.name)\n        }\n    }\n}\n\n/// Native function signature\npub type NativeFn =\n    dyn Fn(&mut crate::interpreter::Interpreter, Vec<Value>) -> Result<Value, String>;\n\nimpl Value {\n    /// Check if value is truthy (for conditionals)\n    pub fn is_truthy(&self) -> bool {\n        match self {\n            Value::Null => false,\n            Value::Bool(b) => *b,\n            Value::Int(n) => *n != 0,\n            Value::Float(f) => *f != 0.0,\n            Value::String(s) => !s.is_empty(),\n            Value::Array(arr) => !arr.borrow().is_empty(),\n            _ => true,\n        }\n    }\n\n    /// Convert to integer\n    pub fn to_int(&self) -> Option<i64> {\n        match self {\n            Value::Int(n) => Some(*n),\n            Value::Float(f) => Some(*f as i64),\n            Value::String(s) => s.parse().ok(),\n            Value::Bool(b) => Some(if *b { 1 } else { 0 }),\n            _ => None,\n        }\n    }\n\n    /// Convert to float\n    pub fn to_float(&self) -> Option<f64> {\n        match self {\n            Value::Int(n) => Some(*n as f64),\n            Value::Float(f) => Some(*f),\n            Value::String(s) => s.parse().ok(),\n            _ => None,\n        }\n    }\n\n    /// Convert to string\n    pub fn to_string_val(&self) -> String {\n        match self {\n            Value::Null => \"NULL\".to_string(),\n            Value::Int(n) => n.to_string(),\n            Value::Float(f) => f.to_string(),\n            Value::String(s) => s.to_string(),\n            Value::Symbol(s) => format!(\"@{}\", s),\n            Value::Bool(b) => if *b { \"1\" } else { \"0\" }.to_string(),\n            Value::Array(arr) => {\n                let items: Vec<String> = arr.borrow().iter().map(|v| v.to_string_val()).collect();\n                format!(\"[{}]\", items.join(\", \"))\n            }\n            Value::Hash(_) => \"[Hash]\".to_string(),\n            Value::Object(obj) => format!(\"[Object:{}]\", obj.borrow().name),\n            Value::Func(f) => format!(\"[Func:{}]\", f.name),\n            Value::NativeFunc(_) => \"[NativeFunc]\".to_string(),\n            Value::Class(c) => format!(\"[Class:{}]\", c.name),\n            Value::Vec3(v) => format!(\"[{}, {}, {}]\", v[0], v[1], v[2]),\n        }\n    }\n\n    /// Get type name\n    pub fn type_name(&self) -> &'static str {\n        match self {\n            Value::Null => \"Null\",\n            Value::Int(_) => \"Int\",\n            Value::Float(_) => \"Float\",\n            Value::String(_) => \"String\",\n            Value::Symbol(_) => \"Symbol\",\n            Value::Bool(_) => \"Bool\",\n            Value::Array(_) => \"Array\",\n            Value::Hash(_) => \"Hash\",\n            Value::Object(_) => \"Object\",\n            Value::Func(_) => \"Func\",\n            Value::NativeFunc(_) => \"NativeFunc\",\n            Value::Class(_) => \"Class\",\n            Value::Vec3(_) => \"Vec3\",\n        }\n    }\n\n    /// Check equality\n    pub fn equals(&self, other: &Value) -> bool {\n        match (self, other) {\n            (Value::Null, Value::Null) => true,\n            (Value::Int(a), Value::Int(b)) => a == b,\n            (Value::Float(a), Value::Float(b)) => a == b,\n            (Value::Int(a), Value::Float(b)) => (*a as f64) == *b,\n            (Value::Float(a), Value::Int(b)) => *a == (*b as f64),\n            (Value::String(a), Value::String(b)) => a == b,\n            (Value::Symbol(a), Value::Symbol(b)) => a == b,\n            (Value::Bool(a), Value::Bool(b)) => a == b,\n            (Value::Vec3(a), Value::Vec3(b)) => a == b,\n            _ => false,\n        }\n    }\n}\n\nimpl fmt::Debug for Value {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.to_string_val())\n    }\n}\n\nimpl fmt::Display for Value {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.to_string_val())\n    }\n}\n\nimpl Default for ObjInstance {\n    fn default() -> Self {\n        Self {\n            class: Rc::new(ClassValue {\n                name: \"Object\".to_string(),\n                package: String::new(),\n                parent: None,\n                methods: HashMap::new(),\n                rules: HashMap::new(),\n                static_vars: HashMap::new(),\n                decl: ClassDecl {\n                    modifiers: vec![],\n                    name: \"Object\".to_string(),\n                    parent: None,\n                    members: vec![],\n                    span: crate::ast::Span::default(),\n                },\n            }),\n            fields: HashMap::new(),\n            properties: HashMap::new(),\n            prop_defs: HashMap::new(),\n            prop_states: HashMap::new(),\n            parent: None,\n            children: Vec::new(),\n            name: String::new(),\n            position: [0.0, 0.0, 0.0],\n            rotation: [0.0, 0.0, 0.0],\n            scale: 1.0,\n            material: None,\n        }\n    }\n}\n\nimpl ObjInstance {\n    /// Check if this object is an instance of a class (or its parent)\n    pub fn is_a(&self, class_name: &str) -> bool {\n        let mut current = Some(self.class.clone());\n        while let Some(cls) = current {\n            if cls.name == class_name {\n                return true;\n            }\n            current = cls.parent.clone();\n        }\n        false\n    }\n\n    /// Get property value\n    pub fn get_prop_value(&self, prop: &str) -> Value {\n        self.properties.get(prop).cloned().unwrap_or(Value::Null)\n    }\n\n    /// Set property value\n    pub fn set_prop_value(&mut self, prop: &str, value: Value) {\n        self.properties.insert(prop.to_string(), value);\n    }\n\n    /// Get position as Value\n    pub fn get_position(&self) -> Value {\n        Value::Array(Rc::new(RefCell::new(vec![\n            Value::Float(self.position[0]),\n            Value::Float(self.position[1]),\n            Value::Float(self.position[2]),\n        ])))\n    }\n\n    /// Set position from Value\n    pub fn set_position(&mut self, pos: &Value) -> Result<(), String> {\n        match pos {\n            Value::Array(arr) => {\n                let arr = arr.borrow();\n                if arr.len() >= 3 {\n                    self.position[0] = arr[0].to_float().unwrap_or(0.0);\n                    self.position[1] = arr[1].to_float().unwrap_or(0.0);\n                    self.position[2] = arr[2].to_float().unwrap_or(0.0);\n                    Ok(())\n                } else {\n                    Err(\"Position array must have 3 elements\".to_string())\n                }\n            }\n            Value::Vec3(v) => {\n                self.position = *v;\n                Ok(())\n            }\n            _ => Err(\"Position must be an array or Vec3\".to_string()),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // ============== Value tests ==============\n\n    #[test]\n    fn test_value_null() {\n        let v = Value::Null;\n        assert!(!v.is_truthy());\n        assert_eq!(v.to_int(), None);\n        assert_eq!(v.to_float(), None);\n        assert_eq!(v.to_string_val(), \"NULL\");\n        assert_eq!(v.type_name(), \"Null\");\n    }\n\n    #[test]\n    fn test_value_int() {\n        let v = Value::Int(42);\n        assert!(v.is_truthy());\n        assert_eq!(v.to_int(), Some(42));\n        assert_eq!(v.to_float(), Some(42.0));\n        assert_eq!(v.to_string_val(), \"42\");\n        assert_eq!(v.type_name(), \"Int\");\n\n        // Zero is falsy\n        let zero = Value::Int(0);\n        assert!(!zero.is_truthy());\n    }\n\n    #[test]\n    fn test_value_float() {\n        let v = Value::Float(3.14);\n        assert!(v.is_truthy());\n        assert_eq!(v.to_int(), Some(3));\n        assert_eq!(v.to_float(), Some(3.14));\n        assert_eq!(v.type_name(), \"Float\");\n\n        // Zero float is falsy\n        let zero = Value::Float(0.0);\n        assert!(!zero.is_truthy());\n    }\n\n    #[test]\n    fn test_value_string() {\n        let v = Value::String(Rc::new(\"hello\".to_string()));\n        assert!(v.is_truthy());\n        assert_eq!(v.to_string_val(), \"hello\");\n        assert_eq!(v.type_name(), \"String\");\n\n        // Empty string is falsy\n        let empty = Value::String(Rc::new(String::new()));\n        assert!(!empty.is_truthy());\n\n        // Numeric string conversion\n        let num_str = Value::String(Rc::new(\"123\".to_string()));\n        assert_eq!(num_str.to_int(), Some(123));\n        assert_eq!(num_str.to_float(), Some(123.0));\n\n        // Non-numeric string\n        let non_num = Value::String(Rc::new(\"abc\".to_string()));\n        assert_eq!(non_num.to_int(), None);\n        assert_eq!(non_num.to_float(), None);\n    }\n\n    #[test]\n    fn test_value_symbol() {\n        let v = Value::Symbol(Rc::new(\"mysymbol\".to_string()));\n        assert!(v.is_truthy());\n        assert_eq!(v.to_string_val(), \"@mysymbol\");\n        assert_eq!(v.type_name(), \"Symbol\");\n    }\n\n    #[test]\n    fn test_value_bool() {\n        let t = Value::Bool(true);\n        assert!(t.is_truthy());\n        assert_eq!(t.to_int(), Some(1));\n        assert_eq!(t.to_string_val(), \"1\");\n        assert_eq!(t.type_name(), \"Bool\");\n\n        let f = Value::Bool(false);\n        assert!(!f.is_truthy());\n        assert_eq!(f.to_int(), Some(0));\n        assert_eq!(f.to_string_val(), \"0\");\n    }\n\n    #[test]\n    fn test_value_array() {\n        let arr = Value::Array(Rc::new(RefCell::new(vec![\n            Value::Int(1),\n            Value::Int(2),\n            Value::Int(3),\n        ])));\n        assert!(arr.is_truthy());\n        assert_eq!(arr.to_string_val(), \"[1, 2, 3]\");\n        assert_eq!(arr.type_name(), \"Array\");\n\n        // Empty array is falsy\n        let empty = Value::Array(Rc::new(RefCell::new(vec![])));\n        assert!(!empty.is_truthy());\n    }\n\n    #[test]\n    fn test_value_hash() {\n        let hash = Value::Hash(Rc::new(RefCell::new(HashMap::new())));\n        assert!(hash.is_truthy());\n        assert_eq!(hash.to_string_val(), \"[Hash]\");\n        assert_eq!(hash.type_name(), \"Hash\");\n    }\n\n    #[test]\n    fn test_value_vec3() {\n        let v = Value::Vec3([1.0, 2.0, 3.0]);\n        assert!(v.is_truthy());\n        assert_eq!(v.to_string_val(), \"[1, 2, 3]\");\n        assert_eq!(v.type_name(), \"Vec3\");\n    }\n\n    #[test]\n    fn test_value_equals() {\n        // Null equality\n        assert!(Value::Null.equals(&Value::Null));\n        assert!(!Value::Null.equals(&Value::Int(0)));\n\n        // Int equality\n        assert!(Value::Int(42).equals(&Value::Int(42)));\n        assert!(!Value::Int(42).equals(&Value::Int(43)));\n\n        // Float equality\n        assert!(Value::Float(3.14).equals(&Value::Float(3.14)));\n\n        // Cross-type numeric equality\n        assert!(Value::Int(42).equals(&Value::Float(42.0)));\n        assert!(Value::Float(42.0).equals(&Value::Int(42)));\n\n        // String equality\n        let s1 = Value::String(Rc::new(\"test\".to_string()));\n        let s2 = Value::String(Rc::new(\"test\".to_string()));\n        let s3 = Value::String(Rc::new(\"other\".to_string()));\n        assert!(s1.equals(&s2));\n        assert!(!s1.equals(&s3));\n\n        // Symbol equality\n        let sym1 = Value::Symbol(Rc::new(\"sym\".to_string()));\n        let sym2 = Value::Symbol(Rc::new(\"sym\".to_string()));\n        assert!(sym1.equals(&sym2));\n\n        // Bool equality\n        assert!(Value::Bool(true).equals(&Value::Bool(true)));\n        assert!(!Value::Bool(true).equals(&Value::Bool(false)));\n\n        // Vec3 equality\n        assert!(Value::Vec3([1.0, 2.0, 3.0]).equals(&Value::Vec3([1.0, 2.0, 3.0])));\n        assert!(!Value::Vec3([1.0, 2.0, 3.0]).equals(&Value::Vec3([1.0, 2.0, 4.0])));\n\n        // Different types don't equal\n        assert!(!Value::Int(1).equals(&Value::String(Rc::new(\"1\".to_string()))));\n    }\n\n    #[test]\n    fn test_value_debug_display() {\n        let v = Value::Int(42);\n        assert_eq!(format!(\"{:?}\", v), \"42\");\n        assert_eq!(format!(\"{}\", v), \"42\");\n    }\n\n    #[test]\n    fn test_value_clone() {\n        let v1 = Value::Int(42);\n        let v2 = v1.clone();\n        assert!(v1.equals(&v2));\n\n        let arr = Value::Array(Rc::new(RefCell::new(vec![Value::Int(1)])));\n        let arr2 = arr.clone();\n        assert_eq!(arr.type_name(), arr2.type_name());\n    }\n\n    // ============== PropertyDef tests ==============\n\n    #[test]\n    fn test_property_def_default() {\n        let pd = PropertyDef::default();\n        assert_eq!(pd.name, \"\");\n        assert_eq!(pd.type_info, \"\");\n        assert_eq!(pd.description, \"\");\n        assert_eq!(pd.sort_order, 0);\n        assert_eq!(pd.group, 0);\n        assert!(pd.choices.is_empty());\n        assert_eq!(pd.state, 3); // editable\n        assert!(matches!(pd.default_value, Value::Null));\n    }\n\n    #[test]\n    fn test_property_def_clone_debug() {\n        let pd = PropertyDef {\n            name: \"color\".to_string(),\n            type_info: \"string\".to_string(),\n            description: \"Color selection\".to_string(),\n            sort_order: 1,\n            group: 0,\n            choices: vec![Value::String(Rc::new(\"red\".to_string()))],\n            state: 3,\n            default_value: Value::String(Rc::new(\"blue\".to_string())),\n        };\n\n        let pd2 = pd.clone();\n        assert_eq!(pd2.name, \"color\");\n\n        let debug = format!(\"{:?}\", pd);\n        assert!(debug.contains(\"color\"));\n    }\n\n    // ============== ClassValue tests ==============\n\n    #[test]\n    fn test_class_value_qualified_name() {\n        let cv = ClassValue {\n            name: \"MyClass\".to_string(),\n            package: \"::vitra::basics\".to_string(),\n            parent: None,\n            methods: HashMap::new(),\n            rules: HashMap::new(),\n            static_vars: HashMap::new(),\n            decl: ClassDecl {\n                modifiers: vec![],\n                name: \"MyClass\".to_string(),\n                parent: None,\n                members: vec![],\n                span: crate::ast::Span::default(),\n            },\n        };\n\n        assert_eq!(cv.qualified_name(), \"::vitra::basics::MyClass\");\n\n        // Empty package\n        let cv2 = ClassValue {\n            name: \"Standalone\".to_string(),\n            package: String::new(),\n            parent: None,\n            methods: HashMap::new(),\n            rules: HashMap::new(),\n            static_vars: HashMap::new(),\n            decl: ClassDecl {\n                modifiers: vec![],\n                name: \"Standalone\".to_string(),\n                parent: None,\n                members: vec![],\n                span: crate::ast::Span::default(),\n            },\n        };\n\n        assert_eq!(cv2.qualified_name(), \"Standalone\");\n    }\n\n    // ============== ObjInstance tests ==============\n\n    #[test]\n    fn test_obj_instance_default() {\n        let obj = ObjInstance::default();\n        assert_eq!(obj.class.name, \"Object\");\n        assert!(obj.fields.is_empty());\n        assert!(obj.properties.is_empty());\n        assert_eq!(obj.name, \"\");\n        assert_eq!(obj.position, [0.0, 0.0, 0.0]);\n        assert_eq!(obj.rotation, [0.0, 0.0, 0.0]);\n        assert_eq!(obj.scale, 1.0);\n        assert!(obj.material.is_none());\n    }\n\n    #[test]\n    fn test_obj_instance_is_a() {\n        let obj = ObjInstance::default();\n        assert!(obj.is_a(\"Object\"));\n        assert!(!obj.is_a(\"SomethingElse\"));\n    }\n\n    #[test]\n    fn test_obj_instance_is_a_with_parent() {\n        use crate::ast::QualifiedName;\n\n        let parent_class = Rc::new(ClassValue {\n            name: \"Parent\".to_string(),\n            package: String::new(),\n            parent: None,\n            methods: HashMap::new(),\n            rules: HashMap::new(),\n            static_vars: HashMap::new(),\n            decl: ClassDecl {\n                modifiers: vec![],\n                name: \"Parent\".to_string(),\n                parent: None,\n                members: vec![],\n                span: crate::ast::Span::default(),\n            },\n        });\n\n        let child_class = Rc::new(ClassValue {\n            name: \"Child\".to_string(),\n            package: String::new(),\n            parent: Some(parent_class),\n            methods: HashMap::new(),\n            rules: HashMap::new(),\n            static_vars: HashMap::new(),\n            decl: ClassDecl {\n                modifiers: vec![],\n                name: \"Child\".to_string(),\n                parent: Some(QualifiedName {\n                    absolute: false,\n                    parts: vec![\"Parent\".to_string()],\n                    span: crate::ast::Span::default(),\n                }),\n                members: vec![],\n                span: crate::ast::Span::default(),\n            },\n        });\n\n        let mut obj = ObjInstance::default();\n        obj.class = child_class;\n\n        assert!(obj.is_a(\"Child\"));\n        assert!(obj.is_a(\"Parent\"));\n        assert!(!obj.is_a(\"Grandparent\"));\n    }\n\n    #[test]\n    fn test_obj_instance_properties() {\n        let mut obj = ObjInstance::default();\n\n        // Get non-existent property returns Null\n        assert!(matches!(obj.get_prop_value(\"color\"), Value::Null));\n\n        // Set and get property\n        obj.set_prop_value(\"color\", Value::String(Rc::new(\"red\".to_string())));\n        let color = obj.get_prop_value(\"color\");\n        assert_eq!(color.to_string_val(), \"red\");\n\n        // Overwrite property\n        obj.set_prop_value(\"color\", Value::String(Rc::new(\"blue\".to_string())));\n        let color = obj.get_prop_value(\"color\");\n        assert_eq!(color.to_string_val(), \"blue\");\n    }\n\n    #[test]\n    fn test_obj_instance_get_position() {\n        let mut obj = ObjInstance::default();\n        obj.position = [1.0, 2.0, 3.0];\n\n        let pos = obj.get_position();\n        if let Value::Array(arr) = pos {\n            let arr = arr.borrow();\n            assert_eq!(arr.len(), 3);\n            assert_eq!(arr[0].to_float(), Some(1.0));\n            assert_eq!(arr[1].to_float(), Some(2.0));\n            assert_eq!(arr[2].to_float(), Some(3.0));\n        } else {\n            panic!(\"Expected Array\");\n        }\n    }\n\n    #[test]\n    fn test_obj_instance_set_position_array() {\n        let mut obj = ObjInstance::default();\n\n        let pos = Value::Array(Rc::new(RefCell::new(vec![\n            Value::Float(10.0),\n            Value::Float(20.0),\n            Value::Float(30.0),\n        ])));\n\n        assert!(obj.set_position(&pos).is_ok());\n        assert_eq!(obj.position, [10.0, 20.0, 30.0]);\n    }\n\n    #[test]\n    fn test_obj_instance_set_position_vec3() {\n        let mut obj = ObjInstance::default();\n\n        let pos = Value::Vec3([5.0, 6.0, 7.0]);\n        assert!(obj.set_position(&pos).is_ok());\n        assert_eq!(obj.position, [5.0, 6.0, 7.0]);\n    }\n\n    #[test]\n    fn test_obj_instance_set_position_invalid() {\n        let mut obj = ObjInstance::default();\n\n        // Wrong type\n        let err = obj.set_position(&Value::Int(1));\n        assert!(err.is_err());\n\n        // Array too short\n        let short = Value::Array(Rc::new(RefCell::new(vec![Value::Float(1.0)])));\n        let err = obj.set_position(&short);\n        assert!(err.is_err());\n    }\n\n    // ============== FuncValue tests ==============\n\n    #[test]\n    fn test_func_value_clone() {\n        let fv = FuncValue {\n            name: \"test_func\".to_string(),\n            params: vec![\"a\".to_string(), \"b\".to_string()],\n            body: None,\n            class: None,\n            is_static: false,\n        };\n\n        let fv2 = fv.clone();\n        assert_eq!(fv2.name, \"test_func\");\n        assert_eq!(fv2.params.len(), 2);\n        assert!(!fv2.is_static);\n    }\n\n    // ============== Value type conversion tests ==============\n\n    #[test]\n    fn test_value_object_display() {\n        let obj = ObjInstance {\n            name: \"TestObj\".to_string(),\n            ..Default::default()\n        };\n        let v = Value::Object(Rc::new(RefCell::new(obj)));\n        assert_eq!(v.to_string_val(), \"[Object:TestObj]\");\n        assert_eq!(v.type_name(), \"Object\");\n    }\n\n    #[test]\n    fn test_value_func_display() {\n        let func = FuncValue {\n            name: \"myFunc\".to_string(),\n            params: vec![],\n            body: None,\n            class: None,\n            is_static: false,\n        };\n        let v = Value::Func(Rc::new(func));\n        assert_eq!(v.to_string_val(), \"[Func:myFunc]\");\n        assert_eq!(v.type_name(), \"Func\");\n    }\n\n    #[test]\n    fn test_value_class_display() {\n        let class = ClassValue {\n            name: \"TestClass\".to_string(),\n            package: String::new(),\n            parent: None,\n            methods: HashMap::new(),\n            rules: HashMap::new(),\n            static_vars: HashMap::new(),\n            decl: ClassDecl {\n                modifiers: vec![],\n                name: \"TestClass\".to_string(),\n                parent: None,\n                members: vec![],\n                span: crate::ast::Span::default(),\n            },\n        };\n        let v = Value::Class(Rc::new(class));\n        assert_eq!(v.to_string_val(), \"[Class:TestClass]\");\n        assert_eq!(v.type_name(), \"Class\");\n    }\n}\n","traces":[{"line":63,"address":[],"length":0,"stats":{"Line":3}},{"line":65,"address":[],"length":0,"stats":{"Line":6}},{"line":66,"address":[],"length":0,"stats":{"Line":6}},{"line":67,"address":[],"length":0,"stats":{"Line":6}},{"line":70,"address":[],"length":0,"stats":{"Line":3}},{"line":131,"address":[],"length":0,"stats":{"Line":20}},{"line":132,"address":[],"length":0,"stats":{"Line":40}},{"line":133,"address":[],"length":0,"stats":{"Line":22}},{"line":135,"address":[],"length":0,"stats":{"Line":18}},{"line":146,"address":[],"length":0,"stats":{"Line":122}},{"line":147,"address":[],"length":0,"stats":{"Line":122}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":149,"address":[],"length":0,"stats":{"Line":162}},{"line":150,"address":[],"length":0,"stats":{"Line":56}},{"line":151,"address":[],"length":0,"stats":{"Line":4}},{"line":152,"address":[],"length":0,"stats":{"Line":8}},{"line":153,"address":[],"length":0,"stats":{"Line":4}},{"line":154,"address":[],"length":0,"stats":{"Line":3}},{"line":159,"address":[],"length":0,"stats":{"Line":48}},{"line":160,"address":[],"length":0,"stats":{"Line":48}},{"line":161,"address":[],"length":0,"stats":{"Line":84}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":163,"address":[],"length":0,"stats":{"Line":6}},{"line":164,"address":[],"length":0,"stats":{"Line":6}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":155}},{"line":171,"address":[],"length":0,"stats":{"Line":155}},{"line":172,"address":[],"length":0,"stats":{"Line":250}},{"line":173,"address":[],"length":0,"stats":{"Line":54}},{"line":174,"address":[],"length":0,"stats":{"Line":6}},{"line":175,"address":[],"length":0,"stats":{"Line":1}},{"line":180,"address":[],"length":0,"stats":{"Line":58}},{"line":181,"address":[],"length":0,"stats":{"Line":58}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":24}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":78}},{"line":186,"address":[],"length":0,"stats":{"Line":42}},{"line":187,"address":[],"length":0,"stats":{"Line":8}},{"line":188,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":11}},{"line":190,"address":[],"length":0,"stats":{"Line":4}},{"line":192,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":4}},{"line":194,"address":[],"length":0,"stats":{"Line":4}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":4}},{"line":197,"address":[],"length":0,"stats":{"Line":6}},{"line":202,"address":[],"length":0,"stats":{"Line":14}},{"line":203,"address":[],"length":0,"stats":{"Line":14}},{"line":204,"address":[],"length":0,"stats":{"Line":1}},{"line":205,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":1}},{"line":207,"address":[],"length":0,"stats":{"Line":1}},{"line":208,"address":[],"length":0,"stats":{"Line":1}},{"line":209,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":3}},{"line":211,"address":[],"length":0,"stats":{"Line":1}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":213,"address":[],"length":0,"stats":{"Line":1}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":1}},{"line":216,"address":[],"length":0,"stats":{"Line":1}},{"line":221,"address":[],"length":0,"stats":{"Line":45}},{"line":222,"address":[],"length":0,"stats":{"Line":90}},{"line":223,"address":[],"length":0,"stats":{"Line":1}},{"line":224,"address":[],"length":0,"stats":{"Line":90}},{"line":225,"address":[],"length":0,"stats":{"Line":3}},{"line":226,"address":[],"length":0,"stats":{"Line":3}},{"line":227,"address":[],"length":0,"stats":{"Line":3}},{"line":228,"address":[],"length":0,"stats":{"Line":12}},{"line":229,"address":[],"length":0,"stats":{"Line":3}},{"line":230,"address":[],"length":0,"stats":{"Line":6}},{"line":231,"address":[],"length":0,"stats":{"Line":6}},{"line":232,"address":[],"length":0,"stats":{"Line":2}},{"line":238,"address":[],"length":0,"stats":{"Line":3}},{"line":239,"address":[],"length":0,"stats":{"Line":15}},{"line":244,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":5}},{"line":250,"address":[],"length":0,"stats":{"Line":177}},{"line":252,"address":[],"length":0,"stats":{"Line":531}},{"line":267,"address":[],"length":0,"stats":{"Line":354}},{"line":268,"address":[],"length":0,"stats":{"Line":354}},{"line":269,"address":[],"length":0,"stats":{"Line":354}},{"line":270,"address":[],"length":0,"stats":{"Line":354}},{"line":272,"address":[],"length":0,"stats":{"Line":354}},{"line":273,"address":[],"length":0,"stats":{"Line":354}},{"line":274,"address":[],"length":0,"stats":{"Line":354}},{"line":275,"address":[],"length":0,"stats":{"Line":177}},{"line":284,"address":[],"length":0,"stats":{"Line":5}},{"line":285,"address":[],"length":0,"stats":{"Line":10}},{"line":286,"address":[],"length":0,"stats":{"Line":16}},{"line":287,"address":[],"length":0,"stats":{"Line":7}},{"line":288,"address":[],"length":0,"stats":{"Line":3}},{"line":290,"address":[],"length":0,"stats":{"Line":12}},{"line":292,"address":[],"length":0,"stats":{"Line":2}},{"line":296,"address":[],"length":0,"stats":{"Line":4}},{"line":297,"address":[],"length":0,"stats":{"Line":24}},{"line":301,"address":[],"length":0,"stats":{"Line":7}},{"line":302,"address":[],"length":0,"stats":{"Line":35}},{"line":306,"address":[],"length":0,"stats":{"Line":1}},{"line":307,"address":[],"length":0,"stats":{"Line":4}},{"line":308,"address":[],"length":0,"stats":{"Line":2}},{"line":309,"address":[],"length":0,"stats":{"Line":1}},{"line":310,"address":[],"length":0,"stats":{"Line":1}},{"line":315,"address":[],"length":0,"stats":{"Line":4}},{"line":316,"address":[],"length":0,"stats":{"Line":4}},{"line":317,"address":[],"length":0,"stats":{"Line":2}},{"line":318,"address":[],"length":0,"stats":{"Line":4}},{"line":319,"address":[],"length":0,"stats":{"Line":2}},{"line":320,"address":[],"length":0,"stats":{"Line":3}},{"line":321,"address":[],"length":0,"stats":{"Line":3}},{"line":322,"address":[],"length":0,"stats":{"Line":3}},{"line":323,"address":[],"length":0,"stats":{"Line":1}},{"line":325,"address":[],"length":0,"stats":{"Line":1}},{"line":328,"address":[],"length":0,"stats":{"Line":1}},{"line":329,"address":[],"length":0,"stats":{"Line":1}},{"line":330,"address":[],"length":0,"stats":{"Line":1}},{"line":332,"address":[],"length":0,"stats":{"Line":1}}],"covered":116,"coverable":119},{"path":["/","workspace","crates","ofml-lib","src","xoi_framework.rs"],"content":"//! xOi Framework Implementation\n//!\n//! This module implements the xOi (Extended Object Instance) framework classes\n//! used in OFML for advanced product configuration and database access.\n//!\n//! ## Class Hierarchy\n//!\n//! ```text\n//! xxPart (native)\n//!    ‚îî‚îÄ‚îÄ OiPart\n//!         ‚îî‚îÄ‚îÄ OiPlElement\n//!              ‚îî‚îÄ‚îÄ xOiPlElement\n//!                   ‚îî‚îÄ‚îÄ xOiBTGPlElement\n//!                        ‚îî‚îÄ‚îÄ xOiBTGPlElement2\n//!                             ‚îî‚îÄ‚îÄ xOiBTGPlElement3 (most manufacturer products inherit from this)\n//! ```\n//!\n//! ## Key Components\n//!\n//! - `xOiTable2` - Database access for reading product configuration data\n//! - `xOiPlanning` - Scene/planning management\n//! - `oiTable()` - Native function for EBASE table operations\n//! - Attachment point system (stdAttPts, addAttPts)\n\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::rc::Rc;\n\nuse crate::ebase::OcdRecord;\nuse crate::interpreter::Interpreter;\nuse crate::value::{ClassValue, ObjInstance, Value};\n\n/// xOiTable2 - Database table wrapper for reading product configuration data.\n///\n/// This class provides access to OFML control data tables (OCD) which contain\n/// product-specific configuration like material packages, categories, properties, etc.\n#[derive(Debug, Clone)]\npub struct XOiTable2 {\n    /// Table identifier (usually derived from article/program)\n    pub id: String,\n    /// Table structure definition\n    pub structure: Vec<TableAttribute>,\n    /// Whether the table is currently open\n    pub is_open: bool,\n    /// Cached table records\n    pub records: Vec<OcdRecord>,\n    /// Index definitions for fast lookup\n    pub indices: Vec<String>,\n}\n\n/// Table attribute definition\n#[derive(Debug, Clone)]\npub struct TableAttribute {\n    /// Attribute name\n    pub name: String,\n    /// Primary key flag (0 or 1)\n    pub primary_key: i32,\n    /// Secondary key flag\n    pub key: i32,\n    /// Data type (@s=string, @i=int, @f=float)\n    pub data_type: char,\n    /// Default value\n    pub default: String,\n    /// Format string\n    pub format: String,\n}\n\nimpl XOiTable2 {\n    /// Create a new table wrapper\n    pub fn new(id: &str, structure: Vec<TableAttribute>) -> Self {\n        Self {\n            id: id.to_string(),\n            structure,\n            is_open: false,\n            records: Vec::new(),\n            indices: Vec::new(),\n        }\n    }\n\n    /// Open the table and load records\n    pub fn open(&mut self, alb_path: Option<&std::path::Path>) -> bool {\n        if self.is_open {\n            return true;\n        }\n\n        // Try to load OCD data from ALB\n        if let Some(path) = alb_path {\n            // The table ID is typically like \"manufacturer.article.ocd\"\n            // We need to find the corresponding OCD file\n            let ocd_name = format!(\"{}.ocd\", self.id.replace('.', \"/\"));\n\n            // Try to read OCD from ALB\n            if let Ok(records) = read_ocd_from_alb(path, &ocd_name) {\n                self.records = records;\n                self.is_open = true;\n                return true;\n            }\n        }\n\n        // If no ALB path or loading failed, create empty table\n        self.is_open = true;\n        true\n    }\n\n    /// Close the table\n    pub fn close(&mut self) {\n        self.is_open = false;\n    }\n\n    /// Get attribute definition by name\n    pub fn get_attr_def(&self, name: &str) -> Option<&TableAttribute> {\n        self.structure.iter().find(|attr| attr.name == name)\n    }\n\n    /// Get attribute index by name\n    pub fn get_attr_idx(&self, name: &str) -> Option<usize> {\n        self.structure.iter().position(|attr| attr.name == name)\n    }\n\n    /// Read entries matching a filter\n    pub fn read_entries_for(\n        &self,\n        filter: &[(String, String)],\n        attrs: &[String],\n        _limit: usize,\n    ) -> Vec<Vec<String>> {\n        let mut results = Vec::new();\n\n        for record in &self.records {\n            // Check if record matches filter\n            let matches = filter\n                .iter()\n                .all(|(key, value)| record.fields.get(key).is_some_and(|v| v == value));\n\n            if matches {\n                // Extract requested attributes\n                let row: Vec<String> = attrs\n                    .iter()\n                    .map(|attr| record.fields.get(attr).cloned().unwrap_or_default())\n                    .collect();\n                results.push(row);\n            }\n        }\n\n        results\n    }\n\n    /// Read a single entry matching a filter\n    pub fn read_1_entry_for(\n        &self,\n        filter: &[(String, String)],\n        attrs: &[String],\n        _flags: i32,\n    ) -> Option<Vec<String>> {\n        self.read_entries_for(filter, attrs, 1).into_iter().next()\n    }\n}\n\n/// Try to read OCD file from ALB archive\nfn read_ocd_from_alb(alb_path: &std::path::Path, ocd_name: &str) -> Result<Vec<OcdRecord>, String> {\n    // Try to open the ALB and extract OCD\n    if let Ok(records) = crate::ebase::read_ocd(alb_path, ocd_name) {\n        return Ok(records);\n    }\n\n    Err(format!(\"Could not load OCD: {}\", ocd_name))\n}\n\n/// xOi class hierarchy registration for the interpreter\nimpl Interpreter {\n    /// Register xOi framework classes\n    pub fn register_xoi_classes(&mut self) {\n        // Get base classes\n        let _oi_part = self\n            .classes\n            .get(\"OiPart\")\n            .cloned()\n            .unwrap_or_else(|| self.create_native_class_internal(\"OiPart\", None));\n        let oi_object = self\n            .classes\n            .get(\"OiObject\")\n            .cloned()\n            .unwrap_or_else(|| self.create_native_class_internal(\"OiObject\", None));\n\n        // Register xxScElement (base for scene elements)\n        let xx_sc_element =\n            self.create_native_class_internal(\"xxScElement\", Some(oi_object.clone()));\n        self.classes\n            .insert(\"xxScElement\".to_string(), xx_sc_element.clone());\n        self.env\n            .define_global(\"xxScElement\", Value::Class(xx_sc_element.clone()));\n\n        // Register OiPlElement (extends xxScElement for planning elements)\n        let oi_pl_element =\n            self.create_native_class_internal(\"OiPlElement\", Some(xx_sc_element.clone()));\n        self.classes\n            .insert(\"OiPlElement\".to_string(), oi_pl_element.clone());\n        self.env\n            .define_global(\"OiPlElement\", Value::Class(oi_pl_element.clone()));\n\n        // Register xOiPlElement (extends OiPlElement with attachment points)\n        let x_oi_pl_element =\n            self.create_native_class_internal(\"xOiPlElement\", Some(oi_pl_element.clone()));\n        self.classes\n            .insert(\"xOiPlElement\".to_string(), x_oi_pl_element.clone());\n        self.env\n            .define_global(\"xOiPlElement\", Value::Class(x_oi_pl_element.clone()));\n\n        // Register xOiBTGPlElement (extends xOiPlElement, \"BTG\" = Business Transaction Group)\n        let x_oi_btg_pl_element =\n            self.create_native_class_internal(\"xOiBTGPlElement\", Some(x_oi_pl_element.clone()));\n        self.classes\n            .insert(\"xOiBTGPlElement\".to_string(), x_oi_btg_pl_element.clone());\n        self.env\n            .define_global(\"xOiBTGPlElement\", Value::Class(x_oi_btg_pl_element.clone()));\n\n        // Register xOiBTGPlElement2 (extends xOiBTGPlElement)\n        let x_oi_btg_pl_element2 = self\n            .create_native_class_internal(\"xOiBTGPlElement2\", Some(x_oi_btg_pl_element.clone()));\n        self.classes\n            .insert(\"xOiBTGPlElement2\".to_string(), x_oi_btg_pl_element2.clone());\n        self.env.define_global(\n            \"xOiBTGPlElement2\",\n            Value::Class(x_oi_btg_pl_element2.clone()),\n        );\n\n        // Register xOiBTGPlElement3 (main product element class most manufacturers use)\n        let x_oi_btg_pl_element3 = self\n            .create_native_class_internal(\"xOiBTGPlElement3\", Some(x_oi_btg_pl_element2.clone()));\n        self.classes\n            .insert(\"xOiBTGPlElement3\".to_string(), x_oi_btg_pl_element3.clone());\n        self.env.define_global(\n            \"xOiBTGPlElement3\",\n            Value::Class(x_oi_btg_pl_element3.clone()),\n        );\n\n        // Register OiOdbPlElement (ODB = OFML Database - database-backed planning element)\n        let oi_odb_pl_element =\n            self.create_native_class_internal(\"OiOdbPlElement\", Some(x_oi_btg_pl_element3.clone()));\n        self.classes\n            .insert(\"OiOdbPlElement\".to_string(), oi_odb_pl_element.clone());\n        self.env\n            .define_global(\"OiOdbPlElement\", Value::Class(oi_odb_pl_element.clone()));\n\n        // Register xOiOdbPlElement (extended ODB element)\n        let x_oi_odb_pl_element =\n            self.create_native_class_internal(\"xOiOdbPlElement\", Some(oi_odb_pl_element.clone()));\n        self.classes\n            .insert(\"xOiOdbPlElement\".to_string(), x_oi_odb_pl_element.clone());\n        self.env\n            .define_global(\"xOiOdbPlElement\", Value::Class(x_oi_odb_pl_element.clone()));\n\n        // Register OiCompPlElement (composite planning element)\n        let oi_comp_pl_element = self\n            .create_native_class_internal(\"OiCompPlElement\", Some(x_oi_btg_pl_element3.clone()));\n        self.classes\n            .insert(\"OiCompPlElement\".to_string(), oi_comp_pl_element.clone());\n        self.env\n            .define_global(\"OiCompPlElement\", Value::Class(oi_comp_pl_element.clone()));\n\n        // Register xOiCompPlElement (extended composite element)\n        let x_oi_comp_pl_element =\n            self.create_native_class_internal(\"xOiCompPlElement\", Some(oi_comp_pl_element.clone()));\n        self.classes\n            .insert(\"xOiCompPlElement\".to_string(), x_oi_comp_pl_element.clone());\n        self.env.define_global(\n            \"xOiCompPlElement\",\n            Value::Class(x_oi_comp_pl_element.clone()),\n        );\n\n        // Register OiPlanning (scene management)\n        let oi_planning = self.create_native_class_internal(\"OiPlanning\", Some(oi_object.clone()));\n        self.classes\n            .insert(\"OiPlanning\".to_string(), oi_planning.clone());\n        self.env\n            .define_global(\"OiPlanning\", Value::Class(oi_planning.clone()));\n\n        // Register xOiPlanning (extended planning)\n        let x_oi_planning =\n            self.create_native_class_internal(\"xOiPlanning\", Some(oi_planning.clone()));\n        self.classes\n            .insert(\"xOiPlanning\".to_string(), x_oi_planning.clone());\n        self.env\n            .define_global(\"xOiPlanning\", Value::Class(x_oi_planning.clone()));\n\n        // Register xOiTable2 (database access)\n        let x_oi_table2 = self.create_native_class_internal(\"xOiTable2\", None);\n        self.classes\n            .insert(\"xOiTable2\".to_string(), x_oi_table2.clone());\n        self.env\n            .define_global(\"xOiTable2\", Value::Class(x_oi_table2.clone()));\n\n        // Register xOiFreeArticle (free-standing articles)\n        let x_oi_free_article =\n            self.create_native_class_internal(\"xOiFreeArticle\", Some(x_oi_btg_pl_element3.clone()));\n        self.classes\n            .insert(\"xOiFreeArticle\".to_string(), x_oi_free_article.clone());\n        self.env\n            .define_global(\"xOiFreeArticle\", Value::Class(x_oi_free_article.clone()));\n\n        // Register xOiAttPtInteractor (attachment point interactor)\n        let x_oi_attpt_interactor =\n            self.create_native_class_internal(\"xOiAttPtInteractor\", Some(oi_object.clone()));\n        self.classes.insert(\n            \"xOiAttPtInteractor\".to_string(),\n            x_oi_attpt_interactor.clone(),\n        );\n        self.env.define_global(\n            \"xOiAttPtInteractor\",\n            Value::Class(x_oi_attpt_interactor.clone()),\n        );\n\n        // Register xOiProgInfo (program information - scene-level configuration)\n        let x_oi_prog_info =\n            self.create_native_class_internal(\"xOiProgInfo\", Some(oi_object.clone()));\n        self.classes\n            .insert(\"xOiProgInfo\".to_string(), x_oi_prog_info.clone());\n        self.env\n            .define_global(\"xOiProgInfo\", Value::Class(x_oi_prog_info.clone()));\n\n        // Register xOiSurface (surface/polygon element)\n        let x_oi_surface = self.create_native_class_internal(\"xOiSurface\", Some(oi_object.clone()));\n        self.classes\n            .insert(\"xOiSurface\".to_string(), x_oi_surface.clone());\n        self.env\n            .define_global(\"xOiSurface\", Value::Class(x_oi_surface.clone()));\n\n        // Register xOiLayoutGroup (layout group for arranging elements)\n        // Uses xOiBTGPlElement3 as parent since xOiPlGroup is registered in interpreter\n        let x_oi_layout_group =\n            self.create_native_class_internal(\"xOiLayoutGroup\", Some(x_oi_btg_pl_element3.clone()));\n        self.classes\n            .insert(\"xOiLayoutGroup\".to_string(), x_oi_layout_group.clone());\n        self.env\n            .define_global(\"xOiLayoutGroup\", Value::Class(x_oi_layout_group.clone()));\n\n        // Register xOiImport (3D model import element)\n        let x_oi_import =\n            self.create_native_class_internal(\"xOiImport\", Some(x_oi_btg_pl_element3.clone()));\n        self.classes\n            .insert(\"xOiImport\".to_string(), x_oi_import.clone());\n        self.env\n            .define_global(\"xOiImport\", Value::Class(x_oi_import.clone()));\n\n        // Register xOiAttPtIF (attachment point interface singleton)\n        self.register_xoi_attpt_if();\n\n        // Register helper functions\n        self.register_xoi_functions();\n    }\n\n    /// Register xOiAttPtIF singleton object\n    fn register_xoi_attpt_if(&mut self) {\n        let attpt_if_class = self.create_native_class_internal(\"xOiAttPtIF_Class\", None);\n        let instance = Rc::new(RefCell::new(ObjInstance {\n            class: attpt_if_class,\n            name: \"xOiAttPtIF\".to_string(),\n            ..Default::default()\n        }));\n        self.env\n            .define_global(\"xOiAttPtIF\", Value::Object(instance));\n    }\n\n    /// Register xOi helper functions\n    fn register_xoi_functions(&mut self) {\n        // openDataTbl - opens a control data table for the current article\n        self.env.define_global(\n            \"openDataTbl\",\n            Value::NativeFunc(Rc::new(|interp, _args| {\n                // Get current object's program and article to construct table ID\n                let table_id = if let Some(ref instance) = interp.current_self {\n                    let inst = instance.borrow();\n                    // Try to get article from properties\n                    let article = inst\n                        .properties\n                        .get(\"article\")\n                        .map(|v| v.to_string_val())\n                        .unwrap_or_else(|| \"default\".to_string());\n                    format!(\"ocd.{}\", article)\n                } else {\n                    \"ocd.default\".to_string()\n                };\n\n                // Create xOiTable2 instance\n                let table_class = interp\n                    .classes\n                    .get(\"xOiTable2\")\n                    .cloned()\n                    .unwrap_or_else(|| interp.create_native_class_internal(\"xOiTable2\", None));\n\n                let instance = Rc::new(RefCell::new(ObjInstance {\n                    class: table_class,\n                    name: table_id.clone(),\n                    ..Default::default()\n                }));\n\n                // Store table ID\n                instance\n                    .borrow_mut()\n                    .fields\n                    .insert(\"mID\".to_string(), Value::String(Rc::new(table_id)));\n                instance\n                    .borrow_mut()\n                    .fields\n                    .insert(\"mIsOpen\".to_string(), Value::Bool(true));\n\n                Ok(Value::Object(instance))\n            })),\n        );\n\n        // oiTable - low-level table operations\n        self.env.define_global(\n            \"oiTable\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                // oiTable(@openTbl, @([tableId, structure])) -> 0/1\n                // oiTable(@readTbl, @([filter, attrs])) -> results\n                let op = match args.first() {\n                    Some(Value::Symbol(s)) => s.to_string(),\n                    _ => return Ok(Value::Int(0)),\n                };\n\n                match op.as_str() {\n                    \"openTbl\" => {\n                        // Always succeed for now - actual EBASE loading happens elsewhere\n                        Ok(Value::Int(1))\n                    }\n                    \"closeTbl\" => Ok(Value::Int(1)),\n                    \"readTbl\" => {\n                        // Return empty results for now\n                        Ok(Value::Array(Rc::new(RefCell::new(Vec::new()))))\n                    }\n                    _ => Ok(Value::Int(0)),\n                }\n            })),\n        );\n\n        // oiGetStdAttPts - get standard attachment points\n        self.env.define_global(\n            \"oiGetStdAttPts\",\n            Value::NativeFunc(Rc::new(|interp, _args| {\n                // Return attachment points from current object if available\n                if let Some(ref instance) = interp.current_self {\n                    let inst = instance.borrow();\n                    if let Some(Value::Array(attpts)) = inst.fields.get(\"mStdAttPts\") {\n                        return Ok(Value::Array(attpts.clone()));\n                    }\n                }\n                // Return empty list\n                Ok(Value::Array(Rc::new(RefCell::new(Vec::new()))))\n            })),\n        );\n\n        // oiGetStdAttPtsOrder - get attachment points in priority order\n        self.env.define_global(\n            \"oiGetStdAttPtsOrder\",\n            Value::NativeFunc(Rc::new(|_interp, _args| {\n                // Return default attachment point order\n                Ok(Value::Array(Rc::new(RefCell::new(vec![\n                    Value::Symbol(Rc::new(\"front\".to_string())),\n                    Value::Symbol(Rc::new(\"back\".to_string())),\n                    Value::Symbol(Rc::new(\"left\".to_string())),\n                    Value::Symbol(Rc::new(\"right\".to_string())),\n                    Value::Symbol(Rc::new(\"top\".to_string())),\n                    Value::Symbol(Rc::new(\"bottom\".to_string())),\n                ]))))\n            })),\n        );\n\n        // oiGetOppositeAttPts4Std - get opposite attachment points\n        self.env.define_global(\n            \"oiGetOppositeAttPts4Std\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let key = match args.get(1) {\n                    Some(Value::Symbol(s)) => s.to_string(),\n                    _ => return Ok(Value::Null),\n                };\n\n                // Return opposite attachment point\n                let opposite = match key.as_str() {\n                    \"front\" => \"back\",\n                    \"back\" => \"front\",\n                    \"left\" => \"right\",\n                    \"right\" => \"left\",\n                    \"top\" => \"bottom\",\n                    \"bottom\" => \"top\",\n                    _ => return Ok(Value::Null),\n                };\n\n                Ok(Value::Array(Rc::new(RefCell::new(vec![Value::Symbol(\n                    Rc::new(opposite.to_string()),\n                )]))))\n            })),\n        );\n\n        // setRtAxis - set rotation axis\n        self.env.define_global(\n            \"setRtAxis\",\n            Value::NativeFunc(Rc::new(|interp, args| {\n                let axis = args.first().and_then(|v| v.to_int()).unwrap_or(2);\n                if let Some(ref instance) = interp.current_self {\n                    instance\n                        .borrow_mut()\n                        .fields\n                        .insert(\"mRtAxis\".to_string(), Value::Int(axis));\n                }\n                Ok(Value::Null)\n            })),\n        );\n\n        // setTrAxis - set translation axis\n        self.env.define_global(\n            \"setTrAxis\",\n            Value::NativeFunc(Rc::new(|interp, args| {\n                let axis = args.first().and_then(|v| v.to_int()).unwrap_or(5);\n                if let Some(ref instance) = interp.current_self {\n                    instance\n                        .borrow_mut()\n                        .fields\n                        .insert(\"mTrAxis\".to_string(), Value::Int(axis));\n                }\n                Ok(Value::Null)\n            })),\n        );\n\n        // getScene / getPlanning - get the planning object\n        self.env.define_global(\n            \"getScene\",\n            Value::NativeFunc(Rc::new(|interp, _args| {\n                // Return the current planning object if it exists\n                if let Some(planning) = interp.env.get(\"_planning\") {\n                    return Ok(planning);\n                }\n                Ok(Value::Null)\n            })),\n        );\n\n        self.env.define_global(\n            \"getPlanning\",\n            Value::NativeFunc(Rc::new(|interp, _args| {\n                if let Some(planning) = interp.env.get(\"_planning\") {\n                    return Ok(planning);\n                }\n                Ok(Value::Null)\n            })),\n        );\n\n        // getRoot - get root object\n        self.env.define_global(\n            \"getRoot\",\n            Value::NativeFunc(Rc::new(|interp, _args| {\n                if let Some(ref instance) = interp.current_self {\n                    let mut current = instance.clone();\n                    loop {\n                        let parent = current.borrow().parent.clone();\n                        match parent {\n                            Some(p) => current = p,\n                            None => break,\n                        }\n                    }\n                    return Ok(Value::Object(current));\n                }\n                Ok(Value::Null)\n            })),\n        );\n\n        // getFather - get parent object\n        self.env.define_global(\n            \"getFather\",\n            Value::NativeFunc(Rc::new(|interp, _args| {\n                if let Some(ref instance) = interp.current_self {\n                    if let Some(parent) = &instance.borrow().parent {\n                        return Ok(Value::Object(parent.clone()));\n                    }\n                }\n                Ok(Value::Null)\n            })),\n        );\n\n        // getChildren - get child objects\n        self.env.define_global(\n            \"getChildren\",\n            Value::NativeFunc(Rc::new(|interp, _args| {\n                if let Some(ref instance) = interp.current_self {\n                    let children: Vec<Value> = instance\n                        .borrow()\n                        .children\n                        .iter()\n                        .map(|c| Value::Object(c.clone()))\n                        .collect();\n                    return Ok(Value::Array(Rc::new(RefCell::new(children))));\n                }\n                Ok(Value::Array(Rc::new(RefCell::new(Vec::new()))))\n            })),\n        );\n\n        // hasMember - check if object has a member\n        self.env.define_global(\n            \"hasMember\",\n            Value::NativeFunc(Rc::new(|interp, args| {\n                let member = match args.first() {\n                    Some(Value::Symbol(s)) => s.to_string(),\n                    Some(Value::String(s)) => s.to_string(),\n                    _ => return Ok(Value::Bool(false)),\n                };\n\n                if let Some(ref instance) = interp.current_self {\n                    let inst = instance.borrow();\n                    let has = inst.fields.contains_key(&member)\n                        || inst.properties.contains_key(&member)\n                        || inst.class.methods.contains_key(&member);\n                    return Ok(Value::Bool(has));\n                }\n                Ok(Value::Bool(false))\n            })),\n        );\n\n        // xOiCopyAggr - copy aggregate structures\n        self.env.define_global(\n            \"xOiCopyAggr\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                // Copy source to destination\n                if let (Some(Value::Array(src_arr)), Some(Value::Array(dst))) =\n                    (args.first(), args.get(1))\n                {\n                    let mut dst_ref = dst.borrow_mut();\n                    dst_ref.clear();\n                    for item in src_arr.borrow().iter() {\n                        dst_ref.push(item.clone());\n                    }\n                }\n                Ok(Value::Null)\n            })),\n        );\n\n        // oiOutput - output messages\n        self.env.define_global(\n            \"oiOutput\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let level = match args.first() {\n                    Some(Value::Symbol(s)) => s.to_string(),\n                    _ => \"INFO\".to_string(),\n                };\n                let msg = args.get(1).map(|v| v.to_string_val()).unwrap_or_default();\n                eprintln!(\"[{}] {}\", level, msg);\n                Ok(Value::Null)\n            })),\n        );\n\n        // xOiCheckElPos - check element position\n        self.env.define_global(\n            \"xOiCheckElPos\",\n            Value::NativeFunc(Rc::new(|_interp, _args| {\n                // Return current position (allow movement)\n                Ok(Value::Array(Rc::new(RefCell::new(vec![\n                    Value::Float(0.0),\n                    Value::Float(0.0),\n                    Value::Float(0.0),\n                ]))))\n            })),\n        );\n\n        // oiGetPosRot4AttachPts - get position and rotation for attachment points\n        self.env.define_global(\n            \"oiGetPosRot4AttachPts\",\n            Value::NativeFunc(Rc::new(|_interp, _args| {\n                // Return [position, rotation, error]\n                Ok(Value::Array(Rc::new(RefCell::new(vec![\n                    Value::Array(Rc::new(RefCell::new(vec![\n                        Value::Float(0.0),\n                        Value::Float(0.0),\n                        Value::Float(0.0),\n                    ]))),\n                    Value::Float(0.0),\n                    Value::Null,\n                ]))))\n            })),\n        );\n\n        // xOiAutoDecoration4Obj - auto decoration\n        self.env.define_global(\n            \"xOiAutoDecoration4Obj\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Bool(true)))),\n        );\n\n        // xOiDeleteAutoDeco - delete auto decoration\n        self.env.define_global(\n            \"xOiDeleteAutoDeco\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Null))),\n        );\n\n        // xOiGetMetaInfo - get meta information\n        self.env.define_global(\n            \"xOiGetMetaInfo\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Null))),\n        );\n\n        // setMethod - set creation method string\n        self.env.define_global(\n            \"setMethod\",\n            Value::NativeFunc(Rc::new(|interp, args| {\n                let method = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                if let Some(ref instance) = interp.current_self {\n                    instance\n                        .borrow_mut()\n                        .fields\n                        .insert(\"mMethod\".to_string(), Value::String(Rc::new(method)));\n                }\n                Ok(Value::Null)\n            })),\n        );\n\n        // createChParams - create child parameters\n        self.env.define_global(\n            \"createChParams\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Null))),\n        );\n\n        // acceptCh - accept child\n        self.env.define_global(\n            \"acceptCh\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                // Return the position\n                Ok(args.first().cloned().unwrap_or(Value::Null))\n            })),\n        );\n\n        // removeCh - remove child\n        self.env.define_global(\n            \"removeCh\",\n            Value::NativeFunc(Rc::new(|_interp, _args| Ok(Value::Null))),\n        );\n\n        // eval - evaluate expression string\n        self.env.define_global(\n            \"eval\",\n            Value::NativeFunc(Rc::new(|interp, args| {\n                let code = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n\n                // Skip empty code\n                if code.trim().is_empty() {\n                    return Ok(Value::Null);\n                }\n\n                // Parse and evaluate the expression - return Null on errors for graceful degradation\n                let parser_result = crate::parser::Parser::new(&code);\n                let mut parser = match parser_result {\n                    Ok(p) => p,\n                    Err(_) => return Ok(Value::Null),\n                };\n\n                let ast = match parser.parse() {\n                    Ok(a) => a,\n                    Err(_) => return Ok(Value::Null),\n                };\n\n                if interp.execute(&ast).is_err() {\n                    return Ok(Value::Null);\n                }\n\n                // Return the last evaluated value or null\n                Ok(Value::Null)\n            })),\n        );\n\n        // Error class for try/catch\n        let error_class = self.create_native_class_internal(\"Error\", None);\n        self.classes\n            .insert(\"Error\".to_string(), error_class.clone());\n        self.env.define_global(\"Error\", Value::Class(error_class));\n\n        // Vector class (alias for Array in OFML)\n        self.env.define_global(\n            \"Vector\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let size = args.first().and_then(|v| v.to_int()).unwrap_or(0) as usize;\n                let arr = vec![Value::Null; size];\n                Ok(Value::Array(Rc::new(RefCell::new(arr))))\n            })),\n        );\n\n        // List class (alias for Array)\n        self.env.define_global(\n            \"List\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let arr: Vec<Value> = args.to_vec();\n                Ok(Value::Array(Rc::new(RefCell::new(arr))))\n            })),\n        );\n\n        // Additional helper functions for manufacturer CLS files\n\n        // oiGetPlanning - get the current planning object\n        self.env.define_global(\n            \"oiGetPlanning\",\n            Value::NativeFunc(Rc::new(|interp, _args| {\n                if let Some(planning) = interp.env.get(\"_planning\") {\n                    return Ok(planning);\n                }\n                // Create a default planning object\n                let planning_class = interp\n                    .classes\n                    .get(\"xOiPlanning\")\n                    .cloned()\n                    .unwrap_or_else(|| interp.create_native_class_internal(\"xOiPlanning\", None));\n                let instance = Rc::new(RefCell::new(ObjInstance {\n                    class: planning_class,\n                    name: \"_planning\".to_string(),\n                    ..Default::default()\n                }));\n                Ok(Value::Object(instance))\n            })),\n        );\n\n        // oiGetStringResource - get localized string resource\n        self.env.define_global(\n            \"oiGetStringResource\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let key = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                let _lang = args\n                    .get(1)\n                    .map(|v| v.to_string_val())\n                    .unwrap_or_else(|| \"de\".to_string());\n                // Return the key as default (real implementation would look up translations)\n                Ok(Value::String(Rc::new(key)))\n            })),\n        );\n\n        // xOiGetAppRegistryKey - get application registry value\n        self.env.define_global(\n            \"xOiGetAppRegistryKey\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let _program = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                let _key = args.get(1).map(|v| v.to_string_val()).unwrap_or_default();\n                let default = args.get(2).map(|v| v.to_string_val()).unwrap_or_default();\n                // Return default value\n                Ok(Value::String(Rc::new(default)))\n            })),\n        );\n\n        // hasProperty - check if object has a property\n        self.env.define_global(\n            \"hasProperty\",\n            Value::NativeFunc(Rc::new(|interp, args| {\n                let key = match args.first() {\n                    Some(Value::Symbol(s)) => s.to_string(),\n                    Some(Value::String(s)) => s.to_string(),\n                    _ => return Ok(Value::Bool(false)),\n                };\n\n                if let Some(ref instance) = interp.current_self {\n                    let inst = instance.borrow();\n                    let has =\n                        inst.properties.contains_key(&key) || inst.prop_defs.contains_key(&key);\n                    return Ok(Value::Bool(has));\n                }\n                Ok(Value::Bool(false))\n            })),\n        );\n\n        // getLanguage - get current language\n        self.env.define_global(\n            \"getLanguage\",\n            Value::NativeFunc(Rc::new(|_interp, _args| {\n                Ok(Value::String(Rc::new(\"de\".to_string())))\n            })),\n        );\n\n        // getProgram - get current program/manufacturer ID\n        self.env.define_global(\n            \"getProgram\",\n            Value::NativeFunc(Rc::new(|interp, _args| {\n                if let Some(ref instance) = interp.current_self {\n                    if let Some(prog) = instance.borrow().fields.get(\"mOiPID\") {\n                        return Ok(prog.clone());\n                    }\n                }\n                Ok(Value::Null)\n            })),\n        );\n\n        // getArticleObj - get the article object\n        self.env.define_global(\n            \"getArticleObj\",\n            Value::NativeFunc(Rc::new(|interp, _args| {\n                if let Some(ref instance) = interp.current_self {\n                    if let Some(art) = instance.borrow().fields.get(\"mArticleObj\") {\n                        return Ok(art.clone());\n                    }\n                    // Return self as article object if no separate article\n                    return Ok(Value::Object(instance.clone()));\n                }\n                Ok(Value::Null)\n            })),\n        );\n\n        // setPropState2 - set property state (visibility, enabled, etc.)\n        self.env.define_global(\n            \"setPropState2\",\n            Value::NativeFunc(Rc::new(|interp, args| {\n                let key = match args.first() {\n                    Some(Value::Symbol(s)) => s.to_string(),\n                    Some(Value::String(s)) => s.to_string(),\n                    _ => return Ok(Value::Null),\n                };\n                let state = args.get(1).and_then(|v| v.to_int()).unwrap_or(0) as i32;\n\n                if let Some(ref instance) = interp.current_self {\n                    instance.borrow_mut().prop_states.insert(key, state);\n                }\n                Ok(Value::Null)\n            })),\n        );\n\n        // setupNoteProperty - setup a note/comment property\n        self.env.define_global(\n            \"setupNoteProperty\",\n            Value::NativeFunc(Rc::new(|interp, args| {\n                let key = match args.first() {\n                    Some(Value::Symbol(s)) => s.to_string(),\n                    Some(Value::String(s)) => s.to_string(),\n                    _ => return Ok(Value::Null),\n                };\n                let value = args.get(1).cloned().unwrap_or(Value::Null);\n\n                if let Some(ref instance) = interp.current_self {\n                    instance.borrow_mut().properties.insert(key, value);\n                }\n                Ok(Value::Null)\n            })),\n        );\n\n        // removeNoteProperty - remove a note property\n        self.env.define_global(\n            \"removeNoteProperty\",\n            Value::NativeFunc(Rc::new(|interp, args| {\n                let key = match args.first() {\n                    Some(Value::Symbol(s)) => s.to_string(),\n                    Some(Value::String(s)) => s.to_string(),\n                    _ => return Ok(Value::Null),\n                };\n\n                if let Some(ref instance) = interp.current_self {\n                    instance.borrow_mut().properties.remove(&key);\n                }\n                Ok(Value::Null)\n            })),\n        );\n\n        // listContains - check if list contains an element\n        self.env.define_global(\n            \"listContains\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let list = match args.first() {\n                    Some(Value::Array(arr)) => arr.borrow().clone(),\n                    _ => return Ok(Value::Bool(false)),\n                };\n                let item = args.get(1).cloned().unwrap_or(Value::Null);\n\n                for elem in list {\n                    if elem.to_string_val() == item.to_string_val() {\n                        return Ok(Value::Bool(true));\n                    }\n                }\n                Ok(Value::Bool(false))\n            })),\n        );\n\n        // isA - check if object is instance of class\n        self.env.define_global(\n            \"isA\",\n            Value::NativeFunc(Rc::new(|interp, args| {\n                let class_name = match args.first() {\n                    Some(Value::Class(c)) => c.name.clone(),\n                    Some(Value::String(s)) => s.to_string(),\n                    Some(Value::Symbol(s)) => s.to_string(),\n                    _ => return Ok(Value::Bool(false)),\n                };\n\n                if let Some(ref instance) = interp.current_self {\n                    let inst = instance.borrow();\n                    // Check class hierarchy\n                    let mut current_class = Some(inst.class.clone());\n                    while let Some(cls) = current_class {\n                        if cls.name == class_name {\n                            return Ok(Value::Bool(true));\n                        }\n                        current_class = cls.parent.clone();\n                    }\n                }\n                Ok(Value::Bool(false))\n            })),\n        );\n\n        // instanceof operator support\n        self.env.define_global(\n            \"instanceof\",\n            Value::NativeFunc(Rc::new(|_interp, args| {\n                let obj = match args.first() {\n                    Some(Value::Object(o)) => o.clone(),\n                    _ => return Ok(Value::Bool(false)),\n                };\n                let class_name = match args.get(1) {\n                    Some(Value::Class(c)) => c.name.clone(),\n                    Some(Value::String(s)) => s.to_string(),\n                    Some(Value::Symbol(s)) => s.to_string(),\n                    _ => return Ok(Value::Bool(false)),\n                };\n\n                let inst = obj.borrow();\n                let mut current_class = Some(inst.class.clone());\n                while let Some(cls) = current_class {\n                    if cls.name == class_name {\n                        return Ok(Value::Bool(true));\n                    }\n                    current_class = cls.parent.clone();\n                }\n                Ok(Value::Bool(false))\n            })),\n        );\n\n        // setArticleSpec - set article specification\n        self.env.define_global(\n            \"setArticleSpec\",\n            Value::NativeFunc(Rc::new(|interp, args| {\n                let article = args.first().map(|v| v.to_string_val()).unwrap_or_default();\n                if let Some(ref instance) = interp.current_self {\n                    instance\n                        .borrow_mut()\n                        .fields\n                        .insert(\"mArticleSpec\".to_string(), Value::String(Rc::new(article)));\n                }\n                Ok(Value::Null)\n            })),\n        );\n\n        // getArticleSpec - get article specification\n        self.env.define_global(\n            \"getArticleSpec\",\n            Value::NativeFunc(Rc::new(|interp, _args| {\n                if let Some(ref instance) = interp.current_self {\n                    if let Some(spec) = instance.borrow().fields.get(\"mArticleSpec\") {\n                        return Ok(spec.clone());\n                    }\n                }\n                Ok(Value::Null)\n            })),\n        );\n\n        // getCreationMode - get object creation mode\n        self.env.define_global(\n            \"getCreationMode\",\n            Value::NativeFunc(Rc::new(|_interp, _args| {\n                Ok(Value::Int(0)) // Default creation mode\n            })),\n        );\n\n        // setXArticleSpec - set extended article specification\n        self.env.define_global(\n            \"setXArticleSpec\",\n            Value::NativeFunc(Rc::new(|interp, args| {\n                let mode = args.first().cloned().unwrap_or(Value::Null);\n                let spec = args.get(1).map(|v| v.to_string_val()).unwrap_or_default();\n                if let Some(ref instance) = interp.current_self {\n                    instance\n                        .borrow_mut()\n                        .fields\n                        .insert(\"mXArticleSpec\".to_string(), Value::String(Rc::new(spec)));\n                    instance\n                        .borrow_mut()\n                        .fields\n                        .insert(\"mXArticleMode\".to_string(), mode);\n                }\n                Ok(Value::Null)\n            })),\n        );\n    }\n\n    /// Create a native class (internal version for xoi_framework)\n    fn create_native_class_internal(\n        &self,\n        name: &str,\n        parent: Option<Rc<ClassValue>>,\n    ) -> Rc<ClassValue> {\n        Rc::new(ClassValue {\n            name: name.to_string(),\n            package: String::new(), // Native classes have no package\n            parent,\n            methods: HashMap::new(),\n            rules: HashMap::new(),\n            static_vars: HashMap::new(),\n            decl: crate::ast::ClassDecl {\n                modifiers: vec![],\n                name: name.to_string(),\n                parent: None,\n                members: vec![],\n                span: crate::ast::Span::default(),\n            },\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn create_test_table() -> XOiTable2 {\n        let attrs = vec![\n            TableAttribute {\n                name: \"type\".to_string(),\n                primary_key: 1,\n                key: 0,\n                data_type: 's',\n                default: \"\".to_string(),\n                format: \"0\".to_string(),\n            },\n            TableAttribute {\n                name: \"value\".to_string(),\n                primary_key: 0,\n                key: 0,\n                data_type: 's',\n                default: \"\".to_string(),\n                format: \"0\".to_string(),\n            },\n        ];\n        XOiTable2::new(\"test.ocd\", attrs)\n    }\n\n    #[test]\n    fn test_xoi_table2_new() {\n        let table = create_test_table();\n        assert_eq!(table.id, \"test.ocd\");\n        assert!(!table.is_open);\n        assert_eq!(table.structure.len(), 2);\n    }\n\n    #[test]\n    fn test_xoi_table2_attr_lookup() {\n        let table = create_test_table();\n\n        assert!(table.get_attr_def(\"type\").is_some());\n        assert!(table.get_attr_def(\"value\").is_some());\n        assert!(table.get_attr_def(\"nonexistent\").is_none());\n\n        assert_eq!(table.get_attr_idx(\"type\"), Some(0));\n        assert_eq!(table.get_attr_idx(\"value\"), Some(1));\n        assert_eq!(table.get_attr_idx(\"nonexistent\"), None);\n    }\n\n    #[test]\n    fn test_table_attribute_debug_clone() {\n        let attr = TableAttribute {\n            name: \"test_attr\".to_string(),\n            primary_key: 1,\n            key: 0,\n            data_type: 's',\n            default: \"default_val\".to_string(),\n            format: \"%.2f\".to_string(),\n        };\n        let debug = format!(\"{:?}\", attr);\n        assert!(debug.contains(\"test_attr\"));\n        assert!(debug.contains(\"TableAttribute\"));\n\n        let cloned = attr.clone();\n        assert_eq!(cloned.name, attr.name);\n        assert_eq!(cloned.primary_key, attr.primary_key);\n        assert_eq!(cloned.data_type, attr.data_type);\n    }\n\n    #[test]\n    fn test_xoi_table2_debug_clone() {\n        let table = create_test_table();\n        let debug = format!(\"{:?}\", table);\n        assert!(debug.contains(\"XOiTable2\"));\n        assert!(debug.contains(\"test.ocd\"));\n\n        let cloned = table.clone();\n        assert_eq!(cloned.id, table.id);\n        assert_eq!(cloned.is_open, table.is_open);\n    }\n\n    #[test]\n    fn test_xoi_table2_open_close() {\n        let mut table = create_test_table();\n        assert!(!table.is_open);\n\n        // Open with no ALB path should still succeed (creates empty table)\n        let result = table.open(None);\n        assert!(result);\n        assert!(table.is_open);\n\n        // Opening again should return true\n        let result = table.open(None);\n        assert!(result);\n\n        // Close the table\n        table.close();\n        assert!(!table.is_open);\n    }\n\n    #[test]\n    fn test_xoi_table2_open_with_invalid_alb() {\n        let mut table = create_test_table();\n        let invalid_path = std::path::Path::new(\"/nonexistent/path.alb\");\n\n        // Should still return true (opens as empty table)\n        let result = table.open(Some(invalid_path));\n        assert!(result);\n        assert!(table.is_open);\n        assert!(table.records.is_empty());\n    }\n\n    #[test]\n    fn test_xoi_table2_read_entries_empty() {\n        let table = create_test_table();\n        let filter = vec![(\"type\".to_string(), \"test\".to_string())];\n        let attrs = vec![\"value\".to_string()];\n\n        let results = table.read_entries_for(&filter, &attrs, 10);\n        assert!(results.is_empty());\n    }\n\n    #[test]\n    fn test_xoi_table2_read_entries_with_records() {\n        let mut table = create_test_table();\n\n        // Add some test records\n        let mut fields1 = HashMap::new();\n        fields1.insert(\"type\".to_string(), \"material\".to_string());\n        fields1.insert(\"value\".to_string(), \"wood\".to_string());\n        table.records.push(OcdRecord { fields: fields1 });\n\n        let mut fields2 = HashMap::new();\n        fields2.insert(\"type\".to_string(), \"material\".to_string());\n        fields2.insert(\"value\".to_string(), \"metal\".to_string());\n        table.records.push(OcdRecord { fields: fields2 });\n\n        let mut fields3 = HashMap::new();\n        fields3.insert(\"type\".to_string(), \"color\".to_string());\n        fields3.insert(\"value\".to_string(), \"red\".to_string());\n        table.records.push(OcdRecord { fields: fields3 });\n\n        // Filter by type=material\n        let filter = vec![(\"type\".to_string(), \"material\".to_string())];\n        let attrs = vec![\"value\".to_string()];\n\n        let results = table.read_entries_for(&filter, &attrs, 10);\n        assert_eq!(results.len(), 2);\n        assert!(results.iter().any(|r| r[0] == \"wood\"));\n        assert!(results.iter().any(|r| r[0] == \"metal\"));\n    }\n\n    #[test]\n    fn test_xoi_table2_read_1_entry_for() {\n        let mut table = create_test_table();\n\n        // Add a test record\n        let mut fields = HashMap::new();\n        fields.insert(\"type\".to_string(), \"unique\".to_string());\n        fields.insert(\"value\".to_string(), \"special\".to_string());\n        table.records.push(OcdRecord { fields });\n\n        // Read single entry\n        let filter = vec![(\"type\".to_string(), \"unique\".to_string())];\n        let attrs = vec![\"value\".to_string()];\n\n        let result = table.read_1_entry_for(&filter, &attrs, 0);\n        assert!(result.is_some());\n        assert_eq!(result.unwrap()[0], \"special\");\n    }\n\n    #[test]\n    fn test_xoi_table2_read_1_entry_for_not_found() {\n        let table = create_test_table();\n\n        let filter = vec![(\"type\".to_string(), \"nonexistent\".to_string())];\n        let attrs = vec![\"value\".to_string()];\n\n        let result = table.read_1_entry_for(&filter, &attrs, 0);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_xoi_table2_read_entries_missing_attr() {\n        let mut table = create_test_table();\n\n        // Add a record with only \"type\" field\n        let mut fields = HashMap::new();\n        fields.insert(\"type\".to_string(), \"test\".to_string());\n        table.records.push(OcdRecord { fields });\n\n        // Try to read \"value\" which doesn't exist\n        let filter = vec![(\"type\".to_string(), \"test\".to_string())];\n        let attrs = vec![\"value\".to_string(), \"missing_attr\".to_string()];\n\n        let results = table.read_entries_for(&filter, &attrs, 10);\n        assert_eq!(results.len(), 1);\n        // Missing attrs should return empty strings\n        assert_eq!(results[0][0], \"\");\n        assert_eq!(results[0][1], \"\");\n    }\n\n    #[test]\n    fn test_table_attribute_types() {\n        let string_attr = TableAttribute {\n            name: \"str\".to_string(),\n            primary_key: 0,\n            key: 0,\n            data_type: 's',\n            default: \"\".to_string(),\n            format: \"\".to_string(),\n        };\n        assert_eq!(string_attr.data_type, 's');\n\n        let int_attr = TableAttribute {\n            name: \"int\".to_string(),\n            primary_key: 0,\n            key: 0,\n            data_type: 'i',\n            default: \"0\".to_string(),\n            format: \"\".to_string(),\n        };\n        assert_eq!(int_attr.data_type, 'i');\n\n        let float_attr = TableAttribute {\n            name: \"float\".to_string(),\n            primary_key: 0,\n            key: 0,\n            data_type: 'f',\n            default: \"0.0\".to_string(),\n            format: \"%.2f\".to_string(),\n        };\n        assert_eq!(float_attr.data_type, 'f');\n    }\n\n    #[test]\n    fn test_read_ocd_from_alb_not_found() {\n        let result = read_ocd_from_alb(\n            std::path::Path::new(\"/nonexistent/path.alb\"),\n            \"test.ocd\",\n        );\n        assert!(result.is_err());\n        let err = result.unwrap_err();\n        assert!(err.contains(\"Could not load OCD\"));\n    }\n\n    #[test]\n    fn test_xoi_table2_empty_new() {\n        let table = XOiTable2::new(\"empty.ocd\", vec![]);\n        assert_eq!(table.id, \"empty.ocd\");\n        assert!(table.structure.is_empty());\n        assert!(table.records.is_empty());\n        assert!(table.indices.is_empty());\n    }\n\n    #[test]\n    fn test_xoi_table2_multiple_filters() {\n        let mut table = XOiTable2::new(\n            \"multi.ocd\",\n            vec![\n                TableAttribute {\n                    name: \"key1\".to_string(),\n                    primary_key: 1,\n                    key: 0,\n                    data_type: 's',\n                    default: \"\".to_string(),\n                    format: \"\".to_string(),\n                },\n                TableAttribute {\n                    name: \"key2\".to_string(),\n                    primary_key: 0,\n                    key: 1,\n                    data_type: 's',\n                    default: \"\".to_string(),\n                    format: \"\".to_string(),\n                },\n                TableAttribute {\n                    name: \"value\".to_string(),\n                    primary_key: 0,\n                    key: 0,\n                    data_type: 's',\n                    default: \"\".to_string(),\n                    format: \"\".to_string(),\n                },\n            ],\n        );\n\n        // Add records\n        let mut f1 = HashMap::new();\n        f1.insert(\"key1\".to_string(), \"A\".to_string());\n        f1.insert(\"key2\".to_string(), \"X\".to_string());\n        f1.insert(\"value\".to_string(), \"AX\".to_string());\n        table.records.push(OcdRecord { fields: f1 });\n\n        let mut f2 = HashMap::new();\n        f2.insert(\"key1\".to_string(), \"A\".to_string());\n        f2.insert(\"key2\".to_string(), \"Y\".to_string());\n        f2.insert(\"value\".to_string(), \"AY\".to_string());\n        table.records.push(OcdRecord { fields: f2 });\n\n        let mut f3 = HashMap::new();\n        f3.insert(\"key1\".to_string(), \"B\".to_string());\n        f3.insert(\"key2\".to_string(), \"X\".to_string());\n        f3.insert(\"value\".to_string(), \"BX\".to_string());\n        table.records.push(OcdRecord { fields: f3 });\n\n        // Filter by both keys\n        let filter = vec![\n            (\"key1\".to_string(), \"A\".to_string()),\n            (\"key2\".to_string(), \"X\".to_string()),\n        ];\n        let results = table.read_entries_for(&filter, &[\"value\".to_string()], 10);\n        assert_eq!(results.len(), 1);\n        assert_eq!(results[0][0], \"AX\");\n    }\n\n    #[test]\n    fn test_interpreter_register_xoi_classes() {\n        let mut interp = Interpreter::new();\n        interp.register_xoi_classes();\n\n        // Check that classes were registered\n        assert!(interp.classes.contains_key(\"xxScElement\"));\n        assert!(interp.classes.contains_key(\"OiPlElement\"));\n        assert!(interp.classes.contains_key(\"xOiPlElement\"));\n        assert!(interp.classes.contains_key(\"xOiBTGPlElement\"));\n        assert!(interp.classes.contains_key(\"xOiBTGPlElement2\"));\n        assert!(interp.classes.contains_key(\"xOiBTGPlElement3\"));\n    }\n\n    #[test]\n    fn test_interpreter_register_xoi_classes_full() {\n        let mut interp = Interpreter::new();\n        interp.register_xoi_classes();\n\n        // Check all xOi classes were registered\n        assert!(interp.classes.contains_key(\"OiOdbPlElement\"));\n        assert!(interp.classes.contains_key(\"xOiOdbPlElement\"));\n        assert!(interp.classes.contains_key(\"OiCompPlElement\"));\n        assert!(interp.classes.contains_key(\"xOiCompPlElement\"));\n        assert!(interp.classes.contains_key(\"OiPlanning\"));\n        assert!(interp.classes.contains_key(\"xOiPlanning\"));\n        assert!(interp.classes.contains_key(\"xOiTable2\"));\n        assert!(interp.classes.contains_key(\"xOiSurface\"));\n        assert!(interp.classes.contains_key(\"xOiLayoutGroup\"));\n        assert!(interp.classes.contains_key(\"xOiImport\"));\n        assert!(interp.classes.contains_key(\"xOiFreeArticle\"));\n        assert!(interp.classes.contains_key(\"xOiAttPtInteractor\"));\n        assert!(interp.classes.contains_key(\"xOiProgInfo\"));\n    }\n\n    #[test]\n    fn test_xoi_table2_read_entries_limit() {\n        let mut table = create_test_table();\n\n        // Add many records\n        for i in 0..20 {\n            let mut fields = HashMap::new();\n            fields.insert(\"type\".to_string(), \"material\".to_string());\n            fields.insert(\"value\".to_string(), format!(\"val{}\", i));\n            table.records.push(OcdRecord { fields });\n        }\n\n        // The limit parameter is currently not enforced by the implementation\n        // Verify that all matching records are returned regardless of limit\n        let filter = vec![(\"type\".to_string(), \"material\".to_string())];\n        let attrs = vec![\"value\".to_string()];\n        let results = table.read_entries_for(&filter, &attrs, 5);\n        assert_eq!(results.len(), 20);\n    }\n\n    #[test]\n    fn test_xoi_table2_read_entries_no_limit() {\n        let mut table = create_test_table();\n\n        // Add some records\n        for i in 0..3 {\n            let mut fields = HashMap::new();\n            fields.insert(\"type\".to_string(), \"test\".to_string());\n            fields.insert(\"value\".to_string(), format!(\"val{}\", i));\n            table.records.push(OcdRecord { fields });\n        }\n\n        // Use 0 as \"no limit\"\n        let filter = vec![(\"type\".to_string(), \"test\".to_string())];\n        let attrs = vec![\"value\".to_string()];\n        let results = table.read_entries_for(&filter, &attrs, 0);\n        assert_eq!(results.len(), 3);\n    }\n\n    #[test]\n    fn test_xoi_table2_multiple_attrs() {\n        let mut table = XOiTable2::new(\n            \"multi_attr.ocd\",\n            vec![\n                TableAttribute {\n                    name: \"a\".to_string(),\n                    primary_key: 1,\n                    key: 0,\n                    data_type: 's',\n                    default: \"\".to_string(),\n                    format: \"\".to_string(),\n                },\n                TableAttribute {\n                    name: \"b\".to_string(),\n                    primary_key: 0,\n                    key: 0,\n                    data_type: 's',\n                    default: \"\".to_string(),\n                    format: \"\".to_string(),\n                },\n                TableAttribute {\n                    name: \"c\".to_string(),\n                    primary_key: 0,\n                    key: 0,\n                    data_type: 's',\n                    default: \"\".to_string(),\n                    format: \"\".to_string(),\n                },\n            ],\n        );\n\n        let mut fields = HashMap::new();\n        fields.insert(\"a\".to_string(), \"1\".to_string());\n        fields.insert(\"b\".to_string(), \"2\".to_string());\n        fields.insert(\"c\".to_string(), \"3\".to_string());\n        table.records.push(OcdRecord { fields });\n\n        // Read multiple attributes at once\n        let filter = vec![(\"a\".to_string(), \"1\".to_string())];\n        let attrs = vec![\"b\".to_string(), \"c\".to_string()];\n        let results = table.read_entries_for(&filter, &attrs, 10);\n        assert_eq!(results.len(), 1);\n        assert_eq!(results[0].len(), 2);\n        assert_eq!(results[0][0], \"2\");\n        assert_eq!(results[0][1], \"3\");\n    }\n\n    #[test]\n    fn test_xoi_table2_partial_filter_match() {\n        let mut table = create_test_table();\n\n        let mut fields = HashMap::new();\n        fields.insert(\"type\".to_string(), \"material\".to_string());\n        fields.insert(\"value\".to_string(), \"wood\".to_string());\n        table.records.push(OcdRecord { fields });\n\n        // Filter with different value - should not match\n        let filter = vec![(\"type\".to_string(), \"color\".to_string())];\n        let attrs = vec![\"value\".to_string()];\n        let results = table.read_entries_for(&filter, &attrs, 10);\n        assert!(results.is_empty());\n    }\n\n    #[test]\n    fn test_xoi_table2_wildcard_filter() {\n        let mut table = create_test_table();\n\n        // Add records\n        let mut fields = HashMap::new();\n        fields.insert(\"type\".to_string(), \"material\".to_string());\n        fields.insert(\"value\".to_string(), \"wood\".to_string());\n        table.records.push(OcdRecord { fields });\n\n        // Filter with wildcard (empty value matches all)\n        let filter = vec![(\"type\".to_string(), \"*\".to_string())];\n        let attrs = vec![\"value\".to_string()];\n        let results = table.read_entries_for(&filter, &attrs, 10);\n        // Wildcard doesn't match in current implementation\n        assert!(results.is_empty());\n    }\n\n    #[test]\n    fn test_xoi_table2_read_1_entry_offset() {\n        let mut table = create_test_table();\n\n        // Add multiple matching records\n        for i in 0..3 {\n            let mut fields = HashMap::new();\n            fields.insert(\"type\".to_string(), \"material\".to_string());\n            fields.insert(\"value\".to_string(), format!(\"val{}\", i));\n            table.records.push(OcdRecord { fields });\n        }\n\n        // The flags parameter is not used for offset in current implementation\n        // read_1_entry_for always returns the first matching record\n        let filter = vec![(\"type\".to_string(), \"material\".to_string())];\n        let attrs = vec![\"value\".to_string()];\n\n        let result0 = table.read_1_entry_for(&filter, &attrs, 0);\n        assert!(result0.is_some());\n        assert_eq!(result0.unwrap()[0], \"val0\");\n\n        // Any flags value returns the same first match\n        let result1 = table.read_1_entry_for(&filter, &attrs, 1);\n        assert!(result1.is_some());\n        assert_eq!(result1.unwrap()[0], \"val0\"); // Still returns first match\n\n        let result2 = table.read_1_entry_for(&filter, &attrs, 2);\n        assert!(result2.is_some());\n        assert_eq!(result2.unwrap()[0], \"val0\"); // Still returns first match\n    }\n\n    #[test]\n    fn test_xoi_table2_indices() {\n        let mut table = create_test_table();\n        assert!(table.indices.is_empty());\n\n        table.indices.push(\"idx_type\".to_string());\n        table.indices.push(\"idx_value\".to_string());\n        assert_eq!(table.indices.len(), 2);\n    }\n\n    // Tests for native xOi functions\n    #[test]\n    fn test_oi_table_function() {\n        let mut interp = Interpreter::new();\n        interp.register_xoi_classes();\n\n        // Test openTbl operation\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"oiTable\") {\n            let args = vec![Value::Symbol(Rc::new(\"openTbl\".to_string()))];\n            let result = func(&mut interp, args).unwrap();\n            assert_eq!(result.to_int(), Some(1));\n        }\n\n        // Test closeTbl operation\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"oiTable\") {\n            let args = vec![Value::Symbol(Rc::new(\"closeTbl\".to_string()))];\n            let result = func(&mut interp, args).unwrap();\n            assert_eq!(result.to_int(), Some(1));\n        }\n\n        // Test readTbl operation\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"oiTable\") {\n            let args = vec![Value::Symbol(Rc::new(\"readTbl\".to_string()))];\n            let result = func(&mut interp, args).unwrap();\n            if let Value::Array(arr) = result {\n                assert!(arr.borrow().is_empty());\n            } else {\n                panic!(\"Expected array\");\n            }\n        }\n\n        // Test unknown operation\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"oiTable\") {\n            let args = vec![Value::Symbol(Rc::new(\"unknownOp\".to_string()))];\n            let result = func(&mut interp, args).unwrap();\n            assert_eq!(result.to_int(), Some(0));\n        }\n\n        // Test with invalid args\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"oiTable\") {\n            let args = vec![Value::Int(42)];\n            let result = func(&mut interp, args).unwrap();\n            assert_eq!(result.to_int(), Some(0));\n        }\n    }\n\n    #[test]\n    fn test_oi_get_std_att_pts_order() {\n        let mut interp = Interpreter::new();\n        interp.register_xoi_classes();\n\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"oiGetStdAttPtsOrder\") {\n            let result = func(&mut interp, vec![]).unwrap();\n            if let Value::Array(arr) = result {\n                let arr_ref = arr.borrow();\n                assert_eq!(arr_ref.len(), 6);\n                // Symbols are prefixed with \"@\" when converted to string\n                assert_eq!(arr_ref[0].to_string_val(), \"@front\");\n                assert_eq!(arr_ref[1].to_string_val(), \"@back\");\n                assert_eq!(arr_ref[2].to_string_val(), \"@left\");\n                assert_eq!(arr_ref[3].to_string_val(), \"@right\");\n                assert_eq!(arr_ref[4].to_string_val(), \"@top\");\n                assert_eq!(arr_ref[5].to_string_val(), \"@bottom\");\n            } else {\n                panic!(\"Expected array\");\n            }\n        }\n    }\n\n    #[test]\n    fn test_oi_get_opposite_att_pts_4_std() {\n        let mut interp = Interpreter::new();\n        interp.register_xoi_classes();\n\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"oiGetOppositeAttPts4Std\") {\n            // Test front -> back (Symbols prefixed with \"@\" in to_string_val)\n            let args = vec![Value::Null, Value::Symbol(Rc::new(\"front\".to_string()))];\n            let result = func(&mut interp, args).unwrap();\n            if let Value::Array(arr) = result {\n                assert_eq!(arr.borrow()[0].to_string_val(), \"@back\");\n            }\n\n            // Test back -> front\n            let args = vec![Value::Null, Value::Symbol(Rc::new(\"back\".to_string()))];\n            let result = func(&mut interp, args).unwrap();\n            if let Value::Array(arr) = result {\n                assert_eq!(arr.borrow()[0].to_string_val(), \"@front\");\n            }\n\n            // Test left -> right\n            let args = vec![Value::Null, Value::Symbol(Rc::new(\"left\".to_string()))];\n            let result = func(&mut interp, args).unwrap();\n            if let Value::Array(arr) = result {\n                assert_eq!(arr.borrow()[0].to_string_val(), \"@right\");\n            }\n\n            // Test right -> left\n            let args = vec![Value::Null, Value::Symbol(Rc::new(\"right\".to_string()))];\n            let result = func(&mut interp, args).unwrap();\n            if let Value::Array(arr) = result {\n                assert_eq!(arr.borrow()[0].to_string_val(), \"@left\");\n            }\n\n            // Test top -> bottom\n            let args = vec![Value::Null, Value::Symbol(Rc::new(\"top\".to_string()))];\n            let result = func(&mut interp, args).unwrap();\n            if let Value::Array(arr) = result {\n                assert_eq!(arr.borrow()[0].to_string_val(), \"@bottom\");\n            }\n\n            // Test bottom -> top\n            let args = vec![Value::Null, Value::Symbol(Rc::new(\"bottom\".to_string()))];\n            let result = func(&mut interp, args).unwrap();\n            if let Value::Array(arr) = result {\n                assert_eq!(arr.borrow()[0].to_string_val(), \"@top\");\n            }\n\n            // Test unknown -> Null\n            let args = vec![Value::Null, Value::Symbol(Rc::new(\"unknown\".to_string()))];\n            let result = func(&mut interp, args).unwrap();\n            assert!(matches!(result, Value::Null));\n\n            // Test invalid args -> Null\n            let args = vec![Value::Null, Value::Int(42)];\n            let result = func(&mut interp, args).unwrap();\n            assert!(matches!(result, Value::Null));\n        }\n    }\n\n    #[test]\n    fn test_get_scene_and_get_planning() {\n        let mut interp = Interpreter::new();\n        interp.register_xoi_classes();\n\n        // Test getScene with no planning defined\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"getScene\") {\n            let result = func(&mut interp, vec![]).unwrap();\n            assert!(matches!(result, Value::Null));\n        }\n\n        // Test getPlanning with no planning defined\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"getPlanning\") {\n            let result = func(&mut interp, vec![]).unwrap();\n            assert!(matches!(result, Value::Null));\n        }\n\n        // Define a planning object\n        let planning_class = interp.classes.get(\"xOiPlanning\").cloned().unwrap();\n        let planning = Rc::new(RefCell::new(ObjInstance {\n            class: planning_class,\n            name: \"_planning\".to_string(),\n            ..Default::default()\n        }));\n        interp\n            .env\n            .define_global(\"_planning\", Value::Object(planning.clone()));\n\n        // Test getScene with planning defined\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"getScene\") {\n            let result = func(&mut interp, vec![]).unwrap();\n            if let Value::Object(obj) = result {\n                assert_eq!(obj.borrow().name, \"_planning\");\n            }\n        }\n    }\n\n    #[test]\n    fn test_xoi_check_el_pos() {\n        let mut interp = Interpreter::new();\n        interp.register_xoi_classes();\n\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"xOiCheckElPos\") {\n            let result = func(&mut interp, vec![]).unwrap();\n            if let Value::Array(arr) = result {\n                let arr_ref = arr.borrow();\n                assert_eq!(arr_ref.len(), 3);\n                assert_eq!(arr_ref[0].to_float(), Some(0.0));\n                assert_eq!(arr_ref[1].to_float(), Some(0.0));\n                assert_eq!(arr_ref[2].to_float(), Some(0.0));\n            }\n        }\n    }\n\n    #[test]\n    fn test_oi_get_pos_rot_4_attach_pts() {\n        let mut interp = Interpreter::new();\n        interp.register_xoi_classes();\n\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"oiGetPosRot4AttachPts\") {\n            let result = func(&mut interp, vec![]).unwrap();\n            if let Value::Array(arr) = result {\n                let arr_ref = arr.borrow();\n                assert_eq!(arr_ref.len(), 3);\n                // First element is position array\n                if let Value::Array(pos) = &arr_ref[0] {\n                    assert_eq!(pos.borrow().len(), 3);\n                }\n                // Second is rotation\n                assert_eq!(arr_ref[1].to_float(), Some(0.0));\n                // Third is error (null)\n                assert!(matches!(arr_ref[2], Value::Null));\n            }\n        }\n    }\n\n    #[test]\n    fn test_xoi_auto_decoration_functions() {\n        let mut interp = Interpreter::new();\n        interp.register_xoi_classes();\n\n        // xOiAutoDecoration4Obj returns true\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"xOiAutoDecoration4Obj\") {\n            let result = func(&mut interp, vec![]).unwrap();\n            assert!(matches!(result, Value::Bool(true)));\n        }\n\n        // xOiDeleteAutoDeco returns null\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"xOiDeleteAutoDeco\") {\n            let result = func(&mut interp, vec![]).unwrap();\n            assert!(matches!(result, Value::Null));\n        }\n\n        // xOiGetMetaInfo returns null\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"xOiGetMetaInfo\") {\n            let result = func(&mut interp, vec![]).unwrap();\n            assert!(matches!(result, Value::Null));\n        }\n    }\n\n    #[test]\n    fn test_create_ch_params_and_accept_ch() {\n        let mut interp = Interpreter::new();\n        interp.register_xoi_classes();\n\n        // createChParams returns null\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"createChParams\") {\n            let result = func(&mut interp, vec![]).unwrap();\n            assert!(matches!(result, Value::Null));\n        }\n\n        // acceptCh returns first arg or null\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"acceptCh\") {\n            let result = func(&mut interp, vec![]).unwrap();\n            assert!(matches!(result, Value::Null));\n\n            let args = vec![Value::Int(42)];\n            let result = func(&mut interp, args).unwrap();\n            assert_eq!(result.to_int(), Some(42));\n        }\n\n        // removeCh returns null\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"removeCh\") {\n            let result = func(&mut interp, vec![]).unwrap();\n            assert!(matches!(result, Value::Null));\n        }\n    }\n\n    #[test]\n    fn test_get_language() {\n        let mut interp = Interpreter::new();\n        interp.register_xoi_classes();\n\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"getLanguage\") {\n            let result = func(&mut interp, vec![]).unwrap();\n            if let Value::String(s) = result {\n                assert_eq!(s.as_str(), \"de\");\n            }\n        }\n    }\n\n    #[test]\n    fn test_get_creation_mode() {\n        let mut interp = Interpreter::new();\n        interp.register_xoi_classes();\n\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"getCreationMode\") {\n            let result = func(&mut interp, vec![]).unwrap();\n            assert_eq!(result.to_int(), Some(0));\n        }\n    }\n\n    #[test]\n    fn test_vector_constructor() {\n        let mut interp = Interpreter::new();\n        interp.register_xoi_classes();\n\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"Vector\") {\n            // Create empty vector\n            let result = func(&mut interp, vec![]).unwrap();\n            if let Value::Array(arr) = result {\n                assert!(arr.borrow().is_empty());\n            }\n\n            // Create vector with size\n            let args = vec![Value::Int(5)];\n            let result = func(&mut interp, args).unwrap();\n            if let Value::Array(arr) = result {\n                assert_eq!(arr.borrow().len(), 5);\n                // All elements should be null\n                for elem in arr.borrow().iter() {\n                    assert!(matches!(elem, Value::Null));\n                }\n            }\n        }\n    }\n\n    #[test]\n    fn test_list_constructor() {\n        let mut interp = Interpreter::new();\n        interp.register_xoi_classes();\n\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"List\") {\n            // Create empty list\n            let result = func(&mut interp, vec![]).unwrap();\n            if let Value::Array(arr) = result {\n                assert!(arr.borrow().is_empty());\n            }\n\n            // Create list with elements\n            let args = vec![Value::Int(1), Value::Int(2), Value::Int(3)];\n            let result = func(&mut interp, args).unwrap();\n            if let Value::Array(arr) = result {\n                let arr_ref = arr.borrow();\n                assert_eq!(arr_ref.len(), 3);\n                assert_eq!(arr_ref[0].to_int(), Some(1));\n                assert_eq!(arr_ref[1].to_int(), Some(2));\n                assert_eq!(arr_ref[2].to_int(), Some(3));\n            }\n        }\n    }\n\n    #[test]\n    fn test_oi_get_string_resource() {\n        let mut interp = Interpreter::new();\n        interp.register_xoi_classes();\n\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"oiGetStringResource\") {\n            let args = vec![Value::String(Rc::new(\"my_key\".to_string()))];\n            let result = func(&mut interp, args).unwrap();\n            if let Value::String(s) = result {\n                assert_eq!(s.as_str(), \"my_key\"); // Returns key as default\n            }\n        }\n    }\n\n    #[test]\n    fn test_xoi_get_app_registry_key() {\n        let mut interp = Interpreter::new();\n        interp.register_xoi_classes();\n\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"xOiGetAppRegistryKey\") {\n            let args = vec![\n                Value::String(Rc::new(\"program\".to_string())),\n                Value::String(Rc::new(\"key\".to_string())),\n                Value::String(Rc::new(\"default_value\".to_string())),\n            ];\n            let result = func(&mut interp, args).unwrap();\n            if let Value::String(s) = result {\n                assert_eq!(s.as_str(), \"default_value\");\n            }\n        }\n    }\n\n    #[test]\n    fn test_list_contains() {\n        let mut interp = Interpreter::new();\n        interp.register_xoi_classes();\n\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"listContains\") {\n            // Test with matching element\n            let arr = Rc::new(RefCell::new(vec![\n                Value::String(Rc::new(\"a\".to_string())),\n                Value::String(Rc::new(\"b\".to_string())),\n                Value::String(Rc::new(\"c\".to_string())),\n            ]));\n            let args = vec![\n                Value::Array(arr.clone()),\n                Value::String(Rc::new(\"b\".to_string())),\n            ];\n            let result = func(&mut interp, args).unwrap();\n            assert!(matches!(result, Value::Bool(true)));\n\n            // Test with non-matching element\n            let args = vec![\n                Value::Array(arr.clone()),\n                Value::String(Rc::new(\"x\".to_string())),\n            ];\n            let result = func(&mut interp, args).unwrap();\n            assert!(matches!(result, Value::Bool(false)));\n\n            // Test with non-array first arg\n            let args = vec![Value::Int(42), Value::String(Rc::new(\"x\".to_string()))];\n            let result = func(&mut interp, args).unwrap();\n            assert!(matches!(result, Value::Bool(false)));\n        }\n    }\n\n    #[test]\n    fn test_eval_function() {\n        let mut interp = Interpreter::new();\n        interp.register_xoi_classes();\n\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"eval\") {\n            // Test empty string\n            let args = vec![Value::String(Rc::new(\"\".to_string()))];\n            let result = func(&mut interp, args).unwrap();\n            assert!(matches!(result, Value::Null));\n\n            // Test whitespace only\n            let args = vec![Value::String(Rc::new(\"   \".to_string()))];\n            let result = func(&mut interp, args).unwrap();\n            assert!(matches!(result, Value::Null));\n\n            // Test simple expression\n            let args = vec![Value::String(Rc::new(\"1 + 2;\".to_string()))];\n            let result = func(&mut interp, args);\n            assert!(result.is_ok());\n        }\n    }\n\n    #[test]\n    fn test_error_class_registered() {\n        let mut interp = Interpreter::new();\n        interp.register_xoi_classes();\n\n        // Check Error class is registered\n        assert!(interp.classes.contains_key(\"Error\"));\n\n        // Check it's also in env\n        if let Some(Value::Class(cls)) = interp.env.get(\"Error\") {\n            assert_eq!(cls.name, \"Error\");\n        } else {\n            panic!(\"Error class not in env\");\n        }\n    }\n\n    #[test]\n    fn test_xoi_copy_aggr() {\n        let mut interp = Interpreter::new();\n        interp.register_xoi_classes();\n\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"xOiCopyAggr\") {\n            let src = Rc::new(RefCell::new(vec![Value::Int(1), Value::Int(2)]));\n            let dst = Rc::new(RefCell::new(vec![Value::Int(99)]));\n\n            let args = vec![Value::Array(src.clone()), Value::Array(dst.clone())];\n            let result = func(&mut interp, args);\n            assert!(result.is_ok());\n\n            // Check dst was updated\n            let dst_ref = dst.borrow();\n            assert_eq!(dst_ref.len(), 2);\n            assert_eq!(dst_ref[0].to_int(), Some(1));\n            assert_eq!(dst_ref[1].to_int(), Some(2));\n        }\n    }\n\n    #[test]\n    fn test_oi_get_planning_creates_default() {\n        let mut interp = Interpreter::new();\n        interp.register_xoi_classes();\n\n        if let Some(Value::NativeFunc(func)) = interp.env.get(\"oiGetPlanning\") {\n            let result = func(&mut interp, vec![]).unwrap();\n            // Should create a default planning object\n            if let Value::Object(obj) = result {\n                assert_eq!(obj.borrow().name, \"_planning\");\n            }\n        }\n    }\n}\n","traces":[{"line":70,"address":[],"length":0,"stats":{"Line":19}},{"line":72,"address":[],"length":0,"stats":{"Line":57}},{"line":75,"address":[],"length":0,"stats":{"Line":19}},{"line":76,"address":[],"length":0,"stats":{"Line":19}},{"line":81,"address":[],"length":0,"stats":{"Line":3}},{"line":82,"address":[],"length":0,"stats":{"Line":3}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":87,"address":[],"length":0,"stats":{"Line":3}},{"line":90,"address":[],"length":0,"stats":{"Line":5}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":3}},{"line":112,"address":[],"length":0,"stats":{"Line":16}},{"line":116,"address":[],"length":0,"stats":{"Line":3}},{"line":117,"address":[],"length":0,"stats":{"Line":16}},{"line":121,"address":[],"length":0,"stats":{"Line":14}},{"line":127,"address":[],"length":0,"stats":{"Line":28}},{"line":129,"address":[],"length":0,"stats":{"Line":100}},{"line":131,"address":[],"length":0,"stats":{"Line":86}},{"line":133,"address":[],"length":0,"stats":{"Line":313}},{"line":135,"address":[],"length":0,"stats":{"Line":43}},{"line":137,"address":[],"length":0,"stats":{"Line":114}},{"line":139,"address":[],"length":0,"stats":{"Line":238}},{"line":141,"address":[],"length":0,"stats":{"Line":114}},{"line":145,"address":[],"length":0,"stats":{"Line":14}},{"line":149,"address":[],"length":0,"stats":{"Line":5}},{"line":155,"address":[],"length":0,"stats":{"Line":25}},{"line":160,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":4}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[],"length":0,"stats":{"Line":153}},{"line":174,"address":[],"length":0,"stats":{"Line":306}},{"line":175,"address":[],"length":0,"stats":{"Line":153}},{"line":178,"address":[],"length":0,"stats":{"Line":153}},{"line":179,"address":[],"length":0,"stats":{"Line":306}},{"line":180,"address":[],"length":0,"stats":{"Line":153}},{"line":183,"address":[],"length":0,"stats":{"Line":153}},{"line":186,"address":[],"length":0,"stats":{"Line":153}},{"line":187,"address":[],"length":0,"stats":{"Line":612}},{"line":188,"address":[],"length":0,"stats":{"Line":153}},{"line":189,"address":[],"length":0,"stats":{"Line":765}},{"line":190,"address":[],"length":0,"stats":{"Line":153}},{"line":191,"address":[],"length":0,"stats":{"Line":459}},{"line":194,"address":[],"length":0,"stats":{"Line":153}},{"line":195,"address":[],"length":0,"stats":{"Line":612}},{"line":196,"address":[],"length":0,"stats":{"Line":153}},{"line":197,"address":[],"length":0,"stats":{"Line":765}},{"line":198,"address":[],"length":0,"stats":{"Line":153}},{"line":199,"address":[],"length":0,"stats":{"Line":459}},{"line":202,"address":[],"length":0,"stats":{"Line":153}},{"line":203,"address":[],"length":0,"stats":{"Line":612}},{"line":204,"address":[],"length":0,"stats":{"Line":153}},{"line":205,"address":[],"length":0,"stats":{"Line":765}},{"line":206,"address":[],"length":0,"stats":{"Line":153}},{"line":207,"address":[],"length":0,"stats":{"Line":459}},{"line":210,"address":[],"length":0,"stats":{"Line":153}},{"line":211,"address":[],"length":0,"stats":{"Line":612}},{"line":212,"address":[],"length":0,"stats":{"Line":153}},{"line":213,"address":[],"length":0,"stats":{"Line":765}},{"line":214,"address":[],"length":0,"stats":{"Line":153}},{"line":215,"address":[],"length":0,"stats":{"Line":459}},{"line":218,"address":[],"length":0,"stats":{"Line":306}},{"line":219,"address":[],"length":0,"stats":{"Line":459}},{"line":220,"address":[],"length":0,"stats":{"Line":153}},{"line":221,"address":[],"length":0,"stats":{"Line":765}},{"line":222,"address":[],"length":0,"stats":{"Line":306}},{"line":224,"address":[],"length":0,"stats":{"Line":153}},{"line":228,"address":[],"length":0,"stats":{"Line":306}},{"line":229,"address":[],"length":0,"stats":{"Line":459}},{"line":230,"address":[],"length":0,"stats":{"Line":153}},{"line":231,"address":[],"length":0,"stats":{"Line":765}},{"line":232,"address":[],"length":0,"stats":{"Line":306}},{"line":234,"address":[],"length":0,"stats":{"Line":153}},{"line":238,"address":[],"length":0,"stats":{"Line":153}},{"line":239,"address":[],"length":0,"stats":{"Line":612}},{"line":240,"address":[],"length":0,"stats":{"Line":153}},{"line":241,"address":[],"length":0,"stats":{"Line":765}},{"line":242,"address":[],"length":0,"stats":{"Line":153}},{"line":243,"address":[],"length":0,"stats":{"Line":459}},{"line":246,"address":[],"length":0,"stats":{"Line":153}},{"line":247,"address":[],"length":0,"stats":{"Line":612}},{"line":248,"address":[],"length":0,"stats":{"Line":153}},{"line":249,"address":[],"length":0,"stats":{"Line":765}},{"line":250,"address":[],"length":0,"stats":{"Line":153}},{"line":251,"address":[],"length":0,"stats":{"Line":459}},{"line":254,"address":[],"length":0,"stats":{"Line":306}},{"line":255,"address":[],"length":0,"stats":{"Line":459}},{"line":256,"address":[],"length":0,"stats":{"Line":153}},{"line":257,"address":[],"length":0,"stats":{"Line":765}},{"line":258,"address":[],"length":0,"stats":{"Line":153}},{"line":259,"address":[],"length":0,"stats":{"Line":459}},{"line":262,"address":[],"length":0,"stats":{"Line":153}},{"line":263,"address":[],"length":0,"stats":{"Line":612}},{"line":264,"address":[],"length":0,"stats":{"Line":153}},{"line":265,"address":[],"length":0,"stats":{"Line":765}},{"line":266,"address":[],"length":0,"stats":{"Line":306}},{"line":268,"address":[],"length":0,"stats":{"Line":153}},{"line":272,"address":[],"length":0,"stats":{"Line":765}},{"line":273,"address":[],"length":0,"stats":{"Line":153}},{"line":274,"address":[],"length":0,"stats":{"Line":765}},{"line":275,"address":[],"length":0,"stats":{"Line":153}},{"line":276,"address":[],"length":0,"stats":{"Line":459}},{"line":279,"address":[],"length":0,"stats":{"Line":153}},{"line":280,"address":[],"length":0,"stats":{"Line":612}},{"line":281,"address":[],"length":0,"stats":{"Line":153}},{"line":282,"address":[],"length":0,"stats":{"Line":765}},{"line":283,"address":[],"length":0,"stats":{"Line":153}},{"line":284,"address":[],"length":0,"stats":{"Line":459}},{"line":287,"address":[],"length":0,"stats":{"Line":765}},{"line":288,"address":[],"length":0,"stats":{"Line":153}},{"line":289,"address":[],"length":0,"stats":{"Line":765}},{"line":290,"address":[],"length":0,"stats":{"Line":153}},{"line":291,"address":[],"length":0,"stats":{"Line":459}},{"line":294,"address":[],"length":0,"stats":{"Line":153}},{"line":295,"address":[],"length":0,"stats":{"Line":612}},{"line":296,"address":[],"length":0,"stats":{"Line":153}},{"line":297,"address":[],"length":0,"stats":{"Line":765}},{"line":298,"address":[],"length":0,"stats":{"Line":153}},{"line":299,"address":[],"length":0,"stats":{"Line":459}},{"line":302,"address":[],"length":0,"stats":{"Line":153}},{"line":303,"address":[],"length":0,"stats":{"Line":612}},{"line":304,"address":[],"length":0,"stats":{"Line":306}},{"line":305,"address":[],"length":0,"stats":{"Line":306}},{"line":306,"address":[],"length":0,"stats":{"Line":306}},{"line":308,"address":[],"length":0,"stats":{"Line":306}},{"line":310,"address":[],"length":0,"stats":{"Line":153}},{"line":314,"address":[],"length":0,"stats":{"Line":153}},{"line":315,"address":[],"length":0,"stats":{"Line":612}},{"line":316,"address":[],"length":0,"stats":{"Line":153}},{"line":317,"address":[],"length":0,"stats":{"Line":765}},{"line":318,"address":[],"length":0,"stats":{"Line":153}},{"line":319,"address":[],"length":0,"stats":{"Line":459}},{"line":322,"address":[],"length":0,"stats":{"Line":765}},{"line":323,"address":[],"length":0,"stats":{"Line":153}},{"line":324,"address":[],"length":0,"stats":{"Line":765}},{"line":325,"address":[],"length":0,"stats":{"Line":153}},{"line":326,"address":[],"length":0,"stats":{"Line":459}},{"line":330,"address":[],"length":0,"stats":{"Line":153}},{"line":331,"address":[],"length":0,"stats":{"Line":612}},{"line":332,"address":[],"length":0,"stats":{"Line":153}},{"line":333,"address":[],"length":0,"stats":{"Line":765}},{"line":334,"address":[],"length":0,"stats":{"Line":153}},{"line":335,"address":[],"length":0,"stats":{"Line":459}},{"line":338,"address":[],"length":0,"stats":{"Line":153}},{"line":339,"address":[],"length":0,"stats":{"Line":612}},{"line":340,"address":[],"length":0,"stats":{"Line":153}},{"line":341,"address":[],"length":0,"stats":{"Line":765}},{"line":342,"address":[],"length":0,"stats":{"Line":153}},{"line":343,"address":[],"length":0,"stats":{"Line":459}},{"line":346,"address":[],"length":0,"stats":{"Line":306}},{"line":349,"address":[],"length":0,"stats":{"Line":306}},{"line":353,"address":[],"length":0,"stats":{"Line":153}},{"line":354,"address":[],"length":0,"stats":{"Line":765}},{"line":355,"address":[],"length":0,"stats":{"Line":612}},{"line":356,"address":[],"length":0,"stats":{"Line":306}},{"line":357,"address":[],"length":0,"stats":{"Line":306}},{"line":358,"address":[],"length":0,"stats":{"Line":153}},{"line":360,"address":[],"length":0,"stats":{"Line":153}},{"line":361,"address":[],"length":0,"stats":{"Line":459}},{"line":365,"address":[],"length":0,"stats":{"Line":153}},{"line":367,"address":[],"length":0,"stats":{"Line":306}},{"line":369,"address":[],"length":0,"stats":{"Line":153}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":306}},{"line":414,"address":[],"length":0,"stats":{"Line":158}},{"line":417,"address":[],"length":0,"stats":{"Line":14}},{"line":418,"address":[],"length":0,"stats":{"Line":12}},{"line":419,"address":[],"length":0,"stats":{"Line":1}},{"line":422,"address":[],"length":0,"stats":{"Line":4}},{"line":423,"address":[],"length":0,"stats":{"Line":4}},{"line":425,"address":[],"length":0,"stats":{"Line":1}},{"line":427,"address":[],"length":0,"stats":{"Line":4}},{"line":428,"address":[],"length":0,"stats":{"Line":2}},{"line":430,"address":[],"length":0,"stats":{"Line":2}},{"line":432,"address":[],"length":0,"stats":{"Line":1}},{"line":438,"address":[],"length":0,"stats":{"Line":306}},{"line":440,"address":[],"length":0,"stats":{"Line":153}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":306}},{"line":456,"address":[],"length":0,"stats":{"Line":154}},{"line":458,"address":[],"length":0,"stats":{"Line":4}},{"line":459,"address":[],"length":0,"stats":{"Line":3}},{"line":460,"address":[],"length":0,"stats":{"Line":3}},{"line":461,"address":[],"length":0,"stats":{"Line":3}},{"line":462,"address":[],"length":0,"stats":{"Line":3}},{"line":463,"address":[],"length":0,"stats":{"Line":3}},{"line":464,"address":[],"length":0,"stats":{"Line":2}},{"line":470,"address":[],"length":0,"stats":{"Line":306}},{"line":472,"address":[],"length":0,"stats":{"Line":161}},{"line":473,"address":[],"length":0,"stats":{"Line":23}},{"line":474,"address":[],"length":0,"stats":{"Line":21}},{"line":475,"address":[],"length":0,"stats":{"Line":1}},{"line":479,"address":[],"length":0,"stats":{"Line":13}},{"line":480,"address":[],"length":0,"stats":{"Line":8}},{"line":481,"address":[],"length":0,"stats":{"Line":7}},{"line":482,"address":[],"length":0,"stats":{"Line":6}},{"line":483,"address":[],"length":0,"stats":{"Line":5}},{"line":484,"address":[],"length":0,"stats":{"Line":4}},{"line":485,"address":[],"length":0,"stats":{"Line":3}},{"line":486,"address":[],"length":0,"stats":{"Line":1}},{"line":489,"address":[],"length":0,"stats":{"Line":24}},{"line":490,"address":[],"length":0,"stats":{"Line":12}},{"line":496,"address":[],"length":0,"stats":{"Line":306}},{"line":498,"address":[],"length":0,"stats":{"Line":153}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":306}},{"line":513,"address":[],"length":0,"stats":{"Line":153}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":306}},{"line":528,"address":[],"length":0,"stats":{"Line":155}},{"line":530,"address":[],"length":0,"stats":{"Line":5}},{"line":531,"address":[],"length":0,"stats":{"Line":1}},{"line":533,"address":[],"length":0,"stats":{"Line":1}},{"line":537,"address":[],"length":0,"stats":{"Line":306}},{"line":539,"address":[],"length":0,"stats":{"Line":154}},{"line":540,"address":[],"length":0,"stats":{"Line":2}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":1}},{"line":548,"address":[],"length":0,"stats":{"Line":306}},{"line":550,"address":[],"length":0,"stats":{"Line":153}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":306}},{"line":569,"address":[],"length":0,"stats":{"Line":153}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":306}},{"line":582,"address":[],"length":0,"stats":{"Line":153}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":306}},{"line":599,"address":[],"length":0,"stats":{"Line":153}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":306}},{"line":620,"address":[],"length":0,"stats":{"Line":154}},{"line":622,"address":[],"length":0,"stats":{"Line":2}},{"line":623,"address":[],"length":0,"stats":{"Line":2}},{"line":625,"address":[],"length":0,"stats":{"Line":2}},{"line":626,"address":[],"length":0,"stats":{"Line":1}},{"line":627,"address":[],"length":0,"stats":{"Line":6}},{"line":628,"address":[],"length":0,"stats":{"Line":6}},{"line":631,"address":[],"length":0,"stats":{"Line":1}},{"line":636,"address":[],"length":0,"stats":{"Line":306}},{"line":638,"address":[],"length":0,"stats":{"Line":153}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":306}},{"line":652,"address":[],"length":0,"stats":{"Line":154}},{"line":654,"address":[],"length":0,"stats":{"Line":4}},{"line":655,"address":[],"length":0,"stats":{"Line":2}},{"line":656,"address":[],"length":0,"stats":{"Line":1}},{"line":657,"address":[],"length":0,"stats":{"Line":1}},{"line":663,"address":[],"length":0,"stats":{"Line":306}},{"line":665,"address":[],"length":0,"stats":{"Line":154}},{"line":667,"address":[],"length":0,"stats":{"Line":4}},{"line":668,"address":[],"length":0,"stats":{"Line":5}},{"line":669,"address":[],"length":0,"stats":{"Line":3}},{"line":670,"address":[],"length":0,"stats":{"Line":2}},{"line":671,"address":[],"length":0,"stats":{"Line":2}},{"line":673,"address":[],"length":0,"stats":{"Line":1}},{"line":674,"address":[],"length":0,"stats":{"Line":1}},{"line":680,"address":[],"length":0,"stats":{"Line":306}},{"line":682,"address":[],"length":0,"stats":{"Line":154}},{"line":686,"address":[],"length":0,"stats":{"Line":306}},{"line":688,"address":[],"length":0,"stats":{"Line":154}},{"line":692,"address":[],"length":0,"stats":{"Line":306}},{"line":694,"address":[],"length":0,"stats":{"Line":154}},{"line":698,"address":[],"length":0,"stats":{"Line":306}},{"line":700,"address":[],"length":0,"stats":{"Line":153}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":306}},{"line":715,"address":[],"length":0,"stats":{"Line":154}},{"line":719,"address":[],"length":0,"stats":{"Line":306}},{"line":721,"address":[],"length":0,"stats":{"Line":155}},{"line":723,"address":[],"length":0,"stats":{"Line":6}},{"line":728,"address":[],"length":0,"stats":{"Line":306}},{"line":730,"address":[],"length":0,"stats":{"Line":154}},{"line":734,"address":[],"length":0,"stats":{"Line":306}},{"line":736,"address":[],"length":0,"stats":{"Line":156}},{"line":737,"address":[],"length":0,"stats":{"Line":18}},{"line":740,"address":[],"length":0,"stats":{"Line":6}},{"line":741,"address":[],"length":0,"stats":{"Line":2}},{"line":745,"address":[],"length":0,"stats":{"Line":3}},{"line":746,"address":[],"length":0,"stats":{"Line":2}},{"line":747,"address":[],"length":0,"stats":{"Line":2}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":2}},{"line":752,"address":[],"length":0,"stats":{"Line":2}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":3}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":1}},{"line":766,"address":[],"length":0,"stats":{"Line":765}},{"line":767,"address":[],"length":0,"stats":{"Line":153}},{"line":768,"address":[],"length":0,"stats":{"Line":765}},{"line":769,"address":[],"length":0,"stats":{"Line":612}},{"line":772,"address":[],"length":0,"stats":{"Line":306}},{"line":774,"address":[],"length":0,"stats":{"Line":155}},{"line":775,"address":[],"length":0,"stats":{"Line":10}},{"line":776,"address":[],"length":0,"stats":{"Line":8}},{"line":777,"address":[],"length":0,"stats":{"Line":4}},{"line":782,"address":[],"length":0,"stats":{"Line":306}},{"line":784,"address":[],"length":0,"stats":{"Line":155}},{"line":785,"address":[],"length":0,"stats":{"Line":6}},{"line":786,"address":[],"length":0,"stats":{"Line":4}},{"line":793,"address":[],"length":0,"stats":{"Line":306}},{"line":795,"address":[],"length":0,"stats":{"Line":154}},{"line":796,"address":[],"length":0,"stats":{"Line":2}},{"line":797,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":2}},{"line":801,"address":[],"length":0,"stats":{"Line":1}},{"line":802,"address":[],"length":0,"stats":{"Line":2}},{"line":803,"address":[],"length":0,"stats":{"Line":1}},{"line":804,"address":[],"length":0,"stats":{"Line":1}},{"line":805,"address":[],"length":0,"stats":{"Line":4}},{"line":806,"address":[],"length":0,"stats":{"Line":2}},{"line":807,"address":[],"length":0,"stats":{"Line":2}},{"line":808,"address":[],"length":0,"stats":{"Line":1}},{"line":810,"address":[],"length":0,"stats":{"Line":1}},{"line":815,"address":[],"length":0,"stats":{"Line":306}},{"line":817,"address":[],"length":0,"stats":{"Line":154}},{"line":818,"address":[],"length":0,"stats":{"Line":6}},{"line":819,"address":[],"length":0,"stats":{"Line":2}},{"line":820,"address":[],"length":0,"stats":{"Line":1}},{"line":821,"address":[],"length":0,"stats":{"Line":1}},{"line":822,"address":[],"length":0,"stats":{"Line":3}},{"line":824,"address":[],"length":0,"stats":{"Line":1}},{"line":829,"address":[],"length":0,"stats":{"Line":306}},{"line":831,"address":[],"length":0,"stats":{"Line":154}},{"line":832,"address":[],"length":0,"stats":{"Line":6}},{"line":833,"address":[],"length":0,"stats":{"Line":6}},{"line":834,"address":[],"length":0,"stats":{"Line":6}},{"line":836,"address":[],"length":0,"stats":{"Line":1}},{"line":841,"address":[],"length":0,"stats":{"Line":306}},{"line":843,"address":[],"length":0,"stats":{"Line":153}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":0}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":851,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":306}},{"line":863,"address":[],"length":0,"stats":{"Line":154}},{"line":864,"address":[],"length":0,"stats":{"Line":2}},{"line":869,"address":[],"length":0,"stats":{"Line":306}},{"line":871,"address":[],"length":0,"stats":{"Line":153}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":874,"address":[],"length":0,"stats":{"Line":0}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":306}},{"line":884,"address":[],"length":0,"stats":{"Line":153}},{"line":885,"address":[],"length":0,"stats":{"Line":0}},{"line":886,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}},{"line":890,"address":[],"length":0,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[],"length":0,"stats":{"Line":306}},{"line":899,"address":[],"length":0,"stats":{"Line":153}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":902,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":0}},{"line":905,"address":[],"length":0,"stats":{"Line":0}},{"line":907,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":910,"address":[],"length":0,"stats":{"Line":0}},{"line":915,"address":[],"length":0,"stats":{"Line":306}},{"line":917,"address":[],"length":0,"stats":{"Line":153}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":920,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[],"length":0,"stats":{"Line":0}},{"line":923,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":926,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":0}},{"line":933,"address":[],"length":0,"stats":{"Line":306}},{"line":935,"address":[],"length":0,"stats":{"Line":153}},{"line":936,"address":[],"length":0,"stats":{"Line":0}},{"line":937,"address":[],"length":0,"stats":{"Line":0}},{"line":938,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":942,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":945,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":306}},{"line":952,"address":[],"length":0,"stats":{"Line":156}},{"line":953,"address":[],"length":0,"stats":{"Line":8}},{"line":954,"address":[],"length":0,"stats":{"Line":4}},{"line":955,"address":[],"length":0,"stats":{"Line":1}},{"line":957,"address":[],"length":0,"stats":{"Line":10}},{"line":959,"address":[],"length":0,"stats":{"Line":11}},{"line":960,"address":[],"length":0,"stats":{"Line":10}},{"line":961,"address":[],"length":0,"stats":{"Line":1}},{"line":964,"address":[],"length":0,"stats":{"Line":1}},{"line":969,"address":[],"length":0,"stats":{"Line":306}},{"line":971,"address":[],"length":0,"stats":{"Line":153}},{"line":972,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[],"length":0,"stats":{"Line":0}},{"line":979,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":982,"address":[],"length":0,"stats":{"Line":0}},{"line":983,"address":[],"length":0,"stats":{"Line":0}},{"line":984,"address":[],"length":0,"stats":{"Line":0}},{"line":985,"address":[],"length":0,"stats":{"Line":0}},{"line":987,"address":[],"length":0,"stats":{"Line":0}},{"line":990,"address":[],"length":0,"stats":{"Line":0}},{"line":995,"address":[],"length":0,"stats":{"Line":306}},{"line":997,"address":[],"length":0,"stats":{"Line":153}},{"line":998,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1000,"address":[],"length":0,"stats":{"Line":0}},{"line":1002,"address":[],"length":0,"stats":{"Line":0}},{"line":1003,"address":[],"length":0,"stats":{"Line":0}},{"line":1004,"address":[],"length":0,"stats":{"Line":0}},{"line":1005,"address":[],"length":0,"stats":{"Line":0}},{"line":1006,"address":[],"length":0,"stats":{"Line":0}},{"line":1009,"address":[],"length":0,"stats":{"Line":0}},{"line":1010,"address":[],"length":0,"stats":{"Line":0}},{"line":1011,"address":[],"length":0,"stats":{"Line":0}},{"line":1012,"address":[],"length":0,"stats":{"Line":0}},{"line":1013,"address":[],"length":0,"stats":{"Line":0}},{"line":1015,"address":[],"length":0,"stats":{"Line":0}},{"line":1017,"address":[],"length":0,"stats":{"Line":0}},{"line":1022,"address":[],"length":0,"stats":{"Line":306}},{"line":1024,"address":[],"length":0,"stats":{"Line":153}},{"line":1025,"address":[],"length":0,"stats":{"Line":0}},{"line":1026,"address":[],"length":0,"stats":{"Line":0}},{"line":1027,"address":[],"length":0,"stats":{"Line":0}},{"line":1028,"address":[],"length":0,"stats":{"Line":0}},{"line":1029,"address":[],"length":0,"stats":{"Line":0}},{"line":1030,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":306}},{"line":1039,"address":[],"length":0,"stats":{"Line":153}},{"line":1040,"address":[],"length":0,"stats":{"Line":0}},{"line":1041,"address":[],"length":0,"stats":{"Line":0}},{"line":1042,"address":[],"length":0,"stats":{"Line":0}},{"line":1045,"address":[],"length":0,"stats":{"Line":0}},{"line":1050,"address":[],"length":0,"stats":{"Line":306}},{"line":1052,"address":[],"length":0,"stats":{"Line":154}},{"line":1053,"address":[],"length":0,"stats":{"Line":1}},{"line":1058,"address":[],"length":0,"stats":{"Line":306}},{"line":1060,"address":[],"length":0,"stats":{"Line":153}},{"line":1061,"address":[],"length":0,"stats":{"Line":0}},{"line":1062,"address":[],"length":0,"stats":{"Line":0}},{"line":1063,"address":[],"length":0,"stats":{"Line":0}},{"line":1064,"address":[],"length":0,"stats":{"Line":0}},{"line":1065,"address":[],"length":0,"stats":{"Line":0}},{"line":1066,"address":[],"length":0,"stats":{"Line":0}},{"line":1067,"address":[],"length":0,"stats":{"Line":0}},{"line":1068,"address":[],"length":0,"stats":{"Line":0}},{"line":1069,"address":[],"length":0,"stats":{"Line":0}},{"line":1070,"address":[],"length":0,"stats":{"Line":0}},{"line":1071,"address":[],"length":0,"stats":{"Line":0}},{"line":1073,"address":[],"length":0,"stats":{"Line":0}},{"line":1079,"address":[],"length":0,"stats":{"Line":3213}},{"line":1084,"address":[],"length":0,"stats":{"Line":6426}},{"line":1085,"address":[],"length":0,"stats":{"Line":9639}},{"line":1086,"address":[],"length":0,"stats":{"Line":6426}},{"line":1087,"address":[],"length":0,"stats":{"Line":6426}},{"line":1088,"address":[],"length":0,"stats":{"Line":6426}},{"line":1089,"address":[],"length":0,"stats":{"Line":6426}},{"line":1090,"address":[],"length":0,"stats":{"Line":6426}},{"line":1091,"address":[],"length":0,"stats":{"Line":3213}},{"line":1092,"address":[],"length":0,"stats":{"Line":6426}},{"line":1093,"address":[],"length":0,"stats":{"Line":9639}},{"line":1094,"address":[],"length":0,"stats":{"Line":6426}},{"line":1095,"address":[],"length":0,"stats":{"Line":3213}},{"line":1096,"address":[],"length":0,"stats":{"Line":3213}}],"covered":369,"coverable":562},{"path":["/","workspace","crates","ofml-lib","tests","article_tests.rs"],"content":"//! Integration tests for article configuration system.\n//!\n//! These tests verify article configuration, property resolution, and variant selection.\n\nuse ofml_lib::article::{\n    ArticleConfig, ArticleLoader, Properties, PropertyValue, Variant, VariantGroup,\n};\nuse std::collections::HashMap;\n\n/// Test basic article configuration\n#[test]\nfn test_article_config_basic() {\n    let mut config = ArticleConfig::new(\"T1600800\", \"desk_standard\");\n\n    // Set properties\n    config.set(\"M__BREITE\", 1600i64);\n    config.set(\"M__TIEFE\", 800i64);\n    config.set(\"M__HOEHE\", 740i64);\n    config.set(\"SH__BASIC\", \"::egr::aci::ACI5\");\n\n    // Verify properties\n    assert_eq!(config.article_nr, \"T1600800\");\n    assert_eq!(config.odb_name, \"desk_standard\");\n    assert_eq!(config.get_int(\"M__BREITE\", 0), 1600);\n    assert_eq!(config.get_int(\"M__TIEFE\", 0), 800);\n    assert_eq!(config.get_string(\"SH__BASIC\", \"\"), \"::egr::aci::ACI5\");\n}\n\n/// Test default property values\n#[test]\nfn test_article_config_defaults() {\n    let mut config = ArticleConfig::new(\"test\", \"test\");\n\n    // Set defaults\n    config.set_default(\"M__HOEHE\", 740i64);\n    config.set_default(\"VARIANT\", \"standard\");\n\n    // Verify defaults are used when property not set\n    assert_eq!(config.get_int(\"M__HOEHE\", 0), 740);\n    assert_eq!(config.get_string(\"VARIANT\", \"\"), \"standard\");\n\n    // Override default\n    config.set(\"M__HOEHE\", 720i64);\n    assert_eq!(config.get_int(\"M__HOEHE\", 0), 720);\n}\n\n/// Test property value types\n#[test]\nfn test_property_value_types() {\n    // Integer\n    let int_val = PropertyValue::Int(1600);\n    assert_eq!(int_val.as_int(), Some(1600));\n    assert_eq!(int_val.as_float(), Some(1600.0));\n\n    // Float\n    let float_val = PropertyValue::Float(3.14159);\n    assert!((float_val.as_float().unwrap() - 3.14159).abs() < 0.0001);\n    assert_eq!(float_val.as_int(), Some(3));\n\n    // String\n    let str_val = PropertyValue::String(\"wood_oak\".to_string());\n    assert_eq!(str_val.as_str(), Some(\"wood_oak\"));\n    assert_eq!(str_val.as_int(), None);\n\n    // Bool\n    let bool_val = PropertyValue::Bool(true);\n    assert_eq!(bool_val.as_bool(), Some(true));\n}\n\n/// Test property value display\n#[test]\nfn test_property_value_display() {\n    assert_eq!(format!(\"{}\", PropertyValue::Int(42)), \"42\");\n    assert_eq!(format!(\"{}\", PropertyValue::Float(3.14)), \"3.14\");\n    assert_eq!(\n        format!(\"{}\", PropertyValue::String(\"test\".to_string())),\n        \"test\"\n    );\n    assert_eq!(format!(\"{}\", PropertyValue::Bool(true)), \"true\");\n}\n\n/// Test property value from conversions\n#[test]\nfn test_property_value_from() {\n    let from_i64: PropertyValue = 42i64.into();\n    assert_eq!(from_i64, PropertyValue::Int(42));\n\n    let from_f64: PropertyValue = 3.14f64.into();\n    assert_eq!(from_f64, PropertyValue::Float(3.14));\n\n    let from_str: PropertyValue = \"test\".into();\n    assert_eq!(from_str, PropertyValue::String(\"test\".to_string()));\n\n    let from_bool: PropertyValue = true.into();\n    assert_eq!(from_bool, PropertyValue::Bool(true));\n}\n\n/// Test parsing property values from strings\n#[test]\nfn test_property_value_from_string() {\n    // Integer\n    assert_eq!(PropertyValue::from_string(\"42\"), PropertyValue::Int(42));\n    assert_eq!(PropertyValue::from_string(\"-100\"), PropertyValue::Int(-100));\n\n    // Float\n    assert_eq!(\n        PropertyValue::from_string(\"3.14\"),\n        PropertyValue::Float(3.14)\n    );\n    assert_eq!(\n        PropertyValue::from_string(\"-0.5\"),\n        PropertyValue::Float(-0.5)\n    );\n\n    // Bool\n    assert_eq!(\n        PropertyValue::from_string(\"true\"),\n        PropertyValue::Bool(true)\n    );\n    assert_eq!(\n        PropertyValue::from_string(\"false\"),\n        PropertyValue::Bool(false)\n    );\n    assert_eq!(PropertyValue::from_string(\"yes\"), PropertyValue::Bool(true));\n    assert_eq!(PropertyValue::from_string(\"no\"), PropertyValue::Bool(false));\n\n    // String (fallback)\n    assert_eq!(\n        PropertyValue::from_string(\"hello world\"),\n        PropertyValue::String(\"hello world\".to_string())\n    );\n}\n\n/// Test to_f64_map conversion\n#[test]\nfn test_to_f64_map() {\n    let mut config = ArticleConfig::new(\"test\", \"test\");\n    config.set(\"WIDTH\", 1600i64);\n    config.set(\"HEIGHT\", 740.5f64);\n    config.set(\"DEPTH\", 800i64);\n    config.set(\"NAME\", \"desk\"); // String - should be excluded\n\n    let map = config.to_f64_map();\n\n    assert_eq!(map.get(\"WIDTH\"), Some(&1600.0));\n    assert_eq!(map.get(\"HEIGHT\"), Some(&740.5));\n    assert_eq!(map.get(\"DEPTH\"), Some(&800.0));\n    assert!(map.get(\"NAME\").is_none());\n}\n\n/// Test variant definition\n#[test]\nfn test_variant() {\n    let variant = Variant::new(\"large\", \"Large Desk (1800x900)\")\n        .with_property(\"M__BREITE\", 1800i64)\n        .with_property(\"M__TIEFE\", 900i64)\n        .with_available(true);\n\n    assert_eq!(variant.id, \"large\");\n    assert_eq!(variant.name, \"Large Desk (1800x900)\");\n    assert!(variant.available);\n    assert_eq!(\n        variant.properties.get(\"M__BREITE\"),\n        Some(&PropertyValue::Int(1800))\n    );\n}\n\n/// Test variant availability\n#[test]\nfn test_variant_availability() {\n    let unavailable = Variant::new(\"special\", \"Special Edition\").with_available(false);\n\n    assert!(!unavailable.available);\n}\n\n/// Test variant group\n#[test]\nfn test_variant_group() {\n    let mut group = VariantGroup::new(\"size\", \"Desk Size\");\n    group.add_variant(Variant::new(\"small\", \"Small (1200x600)\"));\n    group.add_variant(Variant::new(\"medium\", \"Medium (1600x800)\"));\n    group.add_variant(Variant::new(\"large\", \"Large (1800x900)\"));\n\n    assert_eq!(group.variants.len(), 3);\n    assert!(group.selected.is_none());\n}\n\n/// Test variant group selection\n#[test]\nfn test_variant_group_selection() {\n    let mut group = VariantGroup::new(\"size\", \"Desk Size\");\n    group.add_variant(Variant::new(\"small\", \"Small\"));\n    group.add_variant(Variant::new(\"medium\", \"Medium\"));\n    group.add_variant(Variant::new(\"large\", \"Large\"));\n\n    // Select a variant\n    assert!(group.select(\"medium\").is_ok());\n    assert_eq!(group.selected, Some(1));\n\n    let selected = group.get_selected();\n    assert!(selected.is_some());\n    assert_eq!(selected.unwrap().id, \"medium\");\n\n    // Try selecting invalid variant\n    assert!(group.select(\"invalid\").is_err());\n\n    // Selection should remain unchanged after error\n    assert_eq!(group.selected, Some(1));\n}\n\n/// Test variant group with unavailable variants\n#[test]\nfn test_variant_group_unavailable() {\n    let mut group = VariantGroup::new(\"size\", \"Desk Size\");\n    group.add_variant(Variant::new(\"available\", \"Available\").with_available(true));\n    group.add_variant(Variant::new(\"unavailable\", \"Unavailable\").with_available(false));\n\n    // Should fail to select unavailable variant\n    assert!(group.select(\"unavailable\").is_err());\n    assert!(group.selected.is_none());\n\n    // Should succeed for available variant\n    assert!(group.select(\"available\").is_ok());\n    assert_eq!(group.selected, Some(0));\n}\n\n/// Test article loader\n#[test]\nfn test_article_loader() {\n    let mut loader = ArticleLoader::new();\n\n    // Set default height\n    loader.set_default(\"M__HOEHE\", 740i64);\n\n    // Create article\n    let article = loader.create_desk_article(\"1600x800\", 1600, 800, 740);\n\n    assert_eq!(article.get_int(\"M__BREITE\", 0), 1600);\n    assert_eq!(article.get_int(\"M__TIEFE\", 0), 800);\n    assert_eq!(article.get_int(\"M__HOEHE\", 0), 740);\n}\n\n/// Test article loader with custom properties\n#[test]\nfn test_article_loader_custom() {\n    let loader = ArticleLoader::new();\n\n    let mut properties: Properties = HashMap::new();\n    properties.insert(\"M__BREITE\".to_string(), PropertyValue::Int(1600));\n    properties.insert(\"M__TIEFE\".to_string(), PropertyValue::Int(800));\n    properties.insert(\n        \"SH__BASIC\".to_string(),\n        PropertyValue::String(\"::egr::aci::ACI5\".to_string()),\n    );\n\n    let article = loader.create_article(\"custom_desk\", \"desk_odb\", properties);\n\n    assert_eq!(article.article_nr, \"custom_desk\");\n    assert_eq!(article.odb_name, \"desk_odb\");\n    assert_eq!(article.get_int(\"M__BREITE\", 0), 1600);\n    assert_eq!(article.get_string(\"SH__BASIC\", \"\"), \"::egr::aci::ACI5\");\n}\n\n/// Test property names enumeration\n#[test]\nfn test_property_names() {\n    let mut config = ArticleConfig::new(\"test\", \"test\");\n    config.set(\"WIDTH\", 1600i64);\n    config.set(\"HEIGHT\", 740i64);\n    config.set_default(\"DEPTH\", 800i64);\n\n    let names = config.property_names();\n    assert!(names.len() >= 3);\n\n    assert!(config.has(\"WIDTH\"));\n    assert!(config.has(\"HEIGHT\"));\n    assert!(config.has(\"DEPTH\"));\n    assert!(!config.has(\"MISSING\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","check_sedus_relations.rs"],"content":"//! Quick check for Sedus relation rules\r\n\r\nuse std::path::Path;\r\nuse ofml_lib::oap::ocd_relation::RelationRuleReader;\r\nuse ofml_lib::oap::ocd::find_pdata_files;\r\n\r\n#[test]\r\nfn check_sedus_all_relations() {\r\n    let mfr_path = Path::new(\"/reference/ofmldata/sex\");\r\n    if !mfr_path.exists() {\r\n        println!(\"Sedus not found\");\r\n        return;\r\n    }\r\n\r\n    let pdata_files = find_pdata_files(mfr_path);\r\n    println!(\"Found {} pdata files for Sedus\", pdata_files.len());\r\n\r\n    let mut files_with_rules = 0;\r\n    for pdata_path in &pdata_files {\r\n        if let Some(reader) = RelationRuleReader::from_ebase(pdata_path) {\r\n            if reader.has_pricing_rules() {\r\n                files_with_rules += 1;\r\n                println!(\"\\n=== {} ===\", pdata_path.display());\r\n                println!(\"  {} pricing rules\", reader.varcond_rules.len());\r\n            }\r\n        }\r\n    }\r\n    println!(\"\\nTotal files with pricing rules: {}\", files_with_rules);\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","cls_processing_tests.rs"],"content":"//! Integration tests for CLS file processing.\n//!\n//! These tests verify the complete pipeline from CLS parsing through\n//! scene graph generation.\n\nuse ofml_lib::{\n    interpreter::Interpreter, parser::Parser, scene::SceneGraph, EbaseEvaluator, EbaseResult,\n    GeometryTransform, OfmlClassInstance, OfmlClassRegistry, Value,\n};\nuse std::collections::HashMap;\n\n/// Test CLS class definition and instantiation\n#[test]\nfn test_cls_class_definition() {\n    let code = r#\"\n        class TestPart : OiPart {\n            var width = 1.6;\n            var height = 0.74;\n\n            func initialize() {\n                // Simple part creation\n            }\n\n            func getWidth() {\n                return width;\n            }\n        }\n\n        var part = TestPart();\n    \"#;\n\n    let mut parser = Parser::new(code).expect(\"Parser creation should succeed\");\n    let ast = parser.parse().expect(\"Parsing should succeed\");\n    let mut interp = Interpreter::new();\n    interp.execute(&ast).expect(\"Execution should succeed\");\n\n    // Verify the part was created\n    let part = interp.env.get(\"part\").expect(\"part should exist\");\n    assert!(matches!(part, Value::Object(_)));\n}\n\n/// Test CLS class with parameters\n#[test]\nfn test_cls_class_with_parameters() {\n    let code = r#\"\n        class ConfigurableDesk : OiPart {\n            var M__BREITE = 1600;\n            var M__TIEFE = 800;\n            var M__HOEHE = 740;\n\n            func initialize() {\n                // Initialize with default values\n            }\n\n            func getVolume() {\n                return M__BREITE * M__TIEFE * M__HOEHE / 1000000000.0;\n            }\n        }\n\n        var desk = ConfigurableDesk();\n    \"#;\n\n    let mut parser = Parser::new(code).expect(\"Parser creation should succeed\");\n    let ast = parser.parse().expect(\"Parsing should succeed\");\n    let mut interp = Interpreter::new();\n    interp.execute(&ast).expect(\"Execution should succeed\");\n\n    let desk = interp.env.get(\"desk\").expect(\"desk should exist\");\n    if let Value::Object(obj) = desk {\n        let obj = obj.borrow();\n        // Check default values were set\n        assert_eq!(\n            obj.fields.get(\"M__BREITE\").and_then(|v| v.to_int()),\n            Some(1600)\n        );\n        assert_eq!(\n            obj.fields.get(\"M__TIEFE\").and_then(|v| v.to_int()),\n            Some(800)\n        );\n        assert_eq!(\n            obj.fields.get(\"M__HOEHE\").and_then(|v| v.to_int()),\n            Some(740)\n        );\n    } else {\n        panic!(\"desk should be an object\");\n    }\n}\n\n/// Test scene graph node creation from CLS\n#[test]\nfn test_scene_graph_from_cls() {\n    let code = r#\"\n        class DeskAssembly : OiPart {\n            func initialize() {\n                // Create a desk with block geometry\n                Block(self, @top, [1.6, 0.025, 0.8]);\n            }\n        }\n\n        var desk = DeskAssembly();\n    \"#;\n\n    let mut parser = Parser::new(code).expect(\"Parser creation should succeed\");\n    let ast = parser.parse().expect(\"Parsing should succeed\");\n    let mut interp = Interpreter::new();\n    interp.execute(&ast).expect(\"Execution should succeed\");\n\n    // The scene graph should have at least one node\n    assert!(interp.scene.roots.len() > 0 || interp.scene.mesh_count() > 0);\n}\n\n/// Test OFML class instantiation from clsref result\n#[test]\nfn test_clsref_class_instantiation() {\n    // Simulate evaluating a clsref expression\n    let class_name = \"::ofml::go::GoYLTrans\";\n    let params = vec![100.0, 200.0, 10.0];\n\n    let result = OfmlClassRegistry::instantiate(class_name, &params);\n\n    match result {\n        Ok(OfmlClassInstance::Transform(GeometryTransform::YStretch(trans))) => {\n            assert_eq!(trans.base_height, 100.0);\n            assert_eq!(trans.target_height, 200.0);\n            assert_eq!(trans.stretch_min, 10.0);\n        }\n        _ => panic!(\"Expected YStretch transform\"),\n    }\n}\n\n/// Test complete ctor evaluation to class instantiation pipeline\n#[test]\nfn test_ctor_to_class_instantiation() {\n    let ctor = r#\"${M__BREITE:-1000} 1000 / ${M__TIEFE:-600} 1000 / ${M__HOEHE:-740} 1000 / \"::ofml::go::GoYLTrans\" clsref\"#;\n\n    let mut props = HashMap::new();\n    props.insert(\"M__BREITE\".to_string(), 1600.0);\n    props.insert(\"M__TIEFE\".to_string(), 800.0);\n    props.insert(\"M__HOEHE\".to_string(), 740.0);\n\n    let mut evaluator = EbaseEvaluator::new();\n    let result = evaluator\n        .evaluate(ctor, &props)\n        .expect(\"Evaluation should succeed\");\n\n    match result {\n        EbaseResult::ClsRef { class, params } => {\n            assert_eq!(class, \"::ofml::go::GoYLTrans\");\n            assert!((params[0] - 1.6).abs() < 0.01);\n            assert!((params[1] - 0.8).abs() < 0.01);\n            assert!((params[2] - 0.74).abs() < 0.01);\n\n            // Now instantiate the class\n            let instance = OfmlClassRegistry::instantiate(&class, &params);\n            assert!(instance.is_ok());\n        }\n        _ => panic!(\"Expected ClsRef result\"),\n    }\n}\n\n/// Test nested class hierarchy\n#[test]\nfn test_nested_class_hierarchy() {\n    let code = r#\"\n        class BasePart : OiPart {\n            var baseValue = 100;\n            func getBaseValue() {\n                return baseValue;\n            }\n        }\n\n        class ChildPart : BasePart {\n            var color = \"white\";\n            var childValue = 200;\n\n            func getColor() {\n                return color;\n            }\n        }\n\n        var part = ChildPart();\n    \"#;\n\n    let mut parser = Parser::new(code).expect(\"Parser creation should succeed\");\n    let ast = parser.parse().expect(\"Parsing should succeed\");\n    let mut interp = Interpreter::new();\n    interp.execute(&ast).expect(\"Execution should succeed\");\n\n    let part = interp.env.get(\"part\").expect(\"part should exist\");\n    if let Value::Object(obj) = part {\n        let obj = obj.borrow();\n        // Child should have its own fields\n        assert_eq!(\n            obj.fields.get(\"color\").map(|v| v.to_string_val()),\n            Some(\"white\".to_string())\n        );\n        assert_eq!(\n            obj.fields.get(\"childValue\").and_then(|v| v.to_int()),\n            Some(200)\n        );\n    } else {\n        panic!(\"part should be an object\");\n    }\n}\n\n/// Test property system integration\n#[test]\nfn test_property_system_in_cls() {\n    let code = r#\"\n        class ConfiguredPart : OiPart {\n            func initialize() {\n                setupProperty(@width, [\"Width\", NULL, NULL, 0, \"num 0.5 3.0\"], 1.6);\n                setupProperty(@height, [\"Height\", NULL, NULL, 0, \"num 0.3 1.2\"], 0.74);\n            }\n        }\n\n        var part = ConfiguredPart();\n    \"#;\n\n    let mut parser = Parser::new(code).expect(\"Parser creation should succeed\");\n    let ast = parser.parse().expect(\"Parsing should succeed\");\n    let mut interp = Interpreter::new();\n    interp.execute(&ast).expect(\"Execution should succeed\");\n\n    let part = interp.env.get(\"part\").expect(\"part should exist\");\n    if let Value::Object(obj) = part {\n        let obj = obj.borrow();\n        // Properties should exist\n        assert!(obj.properties.contains_key(\"width\") || obj.fields.contains_key(\"width\"));\n    }\n}\n\n/// Test transform application with multiple transformations\n#[test]\nfn test_multiple_transform_classes() {\n    // Test that we can instantiate multiple transform classes\n    let transforms = vec![\n        (\"GoYLTrans\", vec![100.0, 200.0, 10.0]),\n        (\"GoXLTrans\", vec![50.0, 100.0, 5.0]),\n        (\"GoZLTrans\", vec![30.0, 60.0, 3.0]),\n        (\"GoMirror\", vec![0.0, 25.0]),\n    ];\n\n    for (class_name, params) in transforms {\n        let result = OfmlClassRegistry::instantiate(class_name, &params);\n        assert!(result.is_ok(), \"Failed to instantiate {}\", class_name);\n    }\n}\n\n/// Test primitive geometry class instantiation\n#[test]\nfn test_primitive_geometry_classes() {\n    // Test OiBlock\n    let block = OfmlClassRegistry::instantiate(\"OiBlock\", &[1.6, 0.025, 0.8]);\n    assert!(block.is_ok());\n\n    // Test OiCylinder\n    let cylinder = OfmlClassRegistry::instantiate(\"OiCylinder\", &[0.05, 0.74]);\n    assert!(cylinder.is_ok());\n\n    // Test OiSphere\n    let sphere = OfmlClassRegistry::instantiate(\"OiSphere\", &[0.5]);\n    assert!(sphere.is_ok());\n\n    // Test OiEllipsoid\n    let ellipsoid = OfmlClassRegistry::instantiate(\"OiEllipsoid\", &[0.3, 0.4, 0.5]);\n    assert!(ellipsoid.is_ok());\n}\n\n/// Test error handling for unknown classes\n#[test]\nfn test_unknown_class_error() {\n    let result = OfmlClassRegistry::instantiate(\"::unknown::NonExistentClass\", &[1.0, 2.0]);\n    assert!(result.is_err());\n}\n\n/// Test error handling for insufficient parameters\n#[test]\nfn test_insufficient_params_error() {\n    // OiBlock requires 3 parameters\n    let result = OfmlClassRegistry::instantiate(\"OiBlock\", &[1.0, 2.0]);\n    assert!(result.is_err());\n}\n\n/// Test scene graph hierarchy\n#[test]\nfn test_scene_graph_hierarchy() {\n    let mut scene = SceneGraph::new();\n\n    // Create a desk with parts\n    let desk = scene.create_part(\"desk\".to_string(), None);\n\n    // Add table top\n    let top = scene.create_block(\"top\".to_string(), [1.6, 0.025, 0.8], Some(desk.clone()));\n    top.borrow_mut().set_position([0.0, 0.74, 0.0]);\n\n    // Add legs\n    let leg1 = scene.create_cylinder(\"leg1\".to_string(), 0.025, 0.74, Some(desk.clone()));\n    leg1.borrow_mut().set_position([0.05, 0.0, 0.05]);\n\n    let leg2 = scene.create_cylinder(\"leg2\".to_string(), 0.025, 0.74, Some(desk.clone()));\n    leg2.borrow_mut().set_position([1.55, 0.0, 0.05]);\n\n    // Verify hierarchy\n    assert!(scene.exists(\"desk.top\"));\n    assert!(scene.exists(\"desk.leg1\"));\n    assert!(scene.exists(\"desk.leg2\"));\n    assert_eq!(scene.mesh_count(), 3);\n}\n\n/// Test CLS with method calls\n#[test]\nfn test_cls_method_calls() {\n    let code = r#\"\n        class Calculator : OiPart {\n            var result = 0;\n\n            func add(a, b) {\n                result = a + b;\n                return result;\n            }\n\n            func multiply(a, b) {\n                result = a * b;\n                return result;\n            }\n\n            func getResult() {\n                return result;\n            }\n        }\n\n        var calc = Calculator();\n        var sum = calc.add(10, 20);\n        var product = calc.multiply(5, 6);\n    \"#;\n\n    let mut parser = Parser::new(code).expect(\"Parser creation should succeed\");\n    let ast = parser.parse().expect(\"Parsing should succeed\");\n    let mut interp = Interpreter::new();\n    interp.execute(&ast).expect(\"Execution should succeed\");\n\n    let sum = interp.env.get(\"sum\").expect(\"sum should exist\");\n    assert_eq!(sum.to_int(), Some(30));\n\n    let product = interp.env.get(\"product\").expect(\"product should exist\");\n    assert_eq!(product.to_int(), Some(30));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","e2e_tests.rs"],"content":"//! End-to-end integration tests for the OFML interpreter.\n//!\n//! These tests verify the complete pipeline from article configuration\n//! through expression evaluation, geometry generation, and GLB export.\n\nuse ofml_lib::{\n    article::{ArticleConfig, ArticleLoader},\n    ebase_expr::{EbaseEvaluator, EbaseResult},\n    geometry::{\n        scene_to_glb, CoordSystem, EmbeddedTexture, Face, Material3DS, Mesh, Scene3DS, Vertex,\n    },\n    material::{MaterialDef, MaterialResolver},\n    scene::SceneGraph,\n    texture::create_solid_color,\n};\nuse std::collections::HashMap;\n\n/// Test complete pipeline: Article -> Expression -> Geometry\n#[test]\nfn test_full_article_to_geometry_pipeline() {\n    // 1. Create article configuration\n    let loader = ArticleLoader::new();\n    let article = loader.create_desk_article(\"DESK1600x800\", 1600, 800, 740);\n\n    assert_eq!(article.get_int(\"M__BREITE\", 0), 1600);\n    assert_eq!(article.get_int(\"M__TIEFE\", 0), 800);\n\n    // 2. Evaluate EBASE expression with article properties\n    let ctor = r#\"\"desk_geometry\" ${M__BREITE:-1000} 1000 / ${M__TIEFE:-600} 1000 / ${M__HOEHE:-740} 1000 / imp\"#;\n    let props = article.to_f64_map();\n\n    let mut evaluator = EbaseEvaluator::new();\n    let result = evaluator\n        .evaluate(ctor, &props)\n        .expect(\"Expression should evaluate\");\n\n    // 3. Verify expression result\n    match result {\n        EbaseResult::Import { filename, scale } => {\n            assert_eq!(filename, \"desk_geometry\");\n            assert!((scale[0] - 1.6).abs() < 0.01);\n            assert!((scale[1] - 0.8).abs() < 0.01);\n            assert!((scale[2] - 0.74).abs() < 0.01);\n        }\n        _ => panic!(\"Expected Import result\"),\n    }\n}\n\n/// Test material resolution with article properties\n#[test]\nfn test_material_resolution_with_article() {\n    // Configure article with material reference\n    let mut article = ArticleConfig::new(\"test\", \"test\");\n    article.set(\"SH__BASIC\", \"::egr::aci::ACI5\");\n\n    // Resolve material\n    let resolver = MaterialResolver::new();\n    let material_name = article.get_string(\"SH__BASIC\", \"default\");\n\n    // Material resolver should return a material (or fallback)\n    let resolved = resolver.resolve(&material_name);\n    assert!(!resolved.name.is_empty());\n}\n\n/// Test scene graph to GLB export\n#[test]\nfn test_scene_to_glb_export() {\n    let mut scene_graph = SceneGraph::new();\n\n    // Create a simple desk structure\n    let desk = scene_graph.create_part(\"desk\".to_string(), None);\n\n    // Add desk top\n    let top = scene_graph.create_block(\"top\".to_string(), [1.6, 0.025, 0.8], Some(desk.clone()));\n    top.borrow_mut().set_position([0.0, 0.74, 0.0]);\n    top.borrow_mut().material = \"oak_wood\".to_string();\n\n    // Convert to Scene3DS\n    let scene3ds = scene_graph.to_scene();\n\n    // Export to GLB\n    let glb = scene_to_glb(&scene3ds).expect(\"GLB export should succeed\");\n\n    // Verify GLB structure\n    assert!(glb.len() > 12);\n    assert_eq!(&glb[0..4], b\"glTF\");\n}\n\n/// Test complete desk assembly with materials\n#[test]\nfn test_desk_assembly_complete() {\n    let mut scene_graph = SceneGraph::new();\n\n    // Create desk structure\n    let desk = scene_graph.create_part(\"desk\".to_string(), None);\n    desk.borrow_mut().set_position([0.0, 0.0, 0.0]);\n\n    // Table top\n    let top = scene_graph.create_block(\"top\".to_string(), [1.6, 0.025, 0.8], Some(desk.clone()));\n    top.borrow_mut().set_position([0.0, 0.74, 0.0]);\n    top.borrow_mut().material = \"wood_oak\".to_string();\n\n    // Four legs\n    let leg_radius = 0.025;\n    let leg_height = 0.74;\n    let leg_positions = [\n        [0.05, 0.0, 0.05],\n        [1.55, 0.0, 0.05],\n        [0.05, 0.0, 0.75],\n        [1.55, 0.0, 0.75],\n    ];\n\n    for (i, pos) in leg_positions.iter().enumerate() {\n        let leg = scene_graph.create_cylinder(\n            format!(\"leg{}\", i + 1),\n            leg_radius,\n            leg_height,\n            Some(desk.clone()),\n        );\n        leg.borrow_mut().set_position(*pos);\n        leg.borrow_mut().material = \"metal_chrome\".to_string();\n    }\n\n    // Verify structure\n    assert!(scene_graph.exists(\"desk.top\"));\n    assert!(scene_graph.exists(\"desk.leg1\"));\n    assert!(scene_graph.exists(\"desk.leg2\"));\n    assert!(scene_graph.exists(\"desk.leg3\"));\n    assert!(scene_graph.exists(\"desk.leg4\"));\n    assert_eq!(scene_graph.mesh_count(), 5);\n\n    // Export and verify\n    let scene3ds = scene_graph.to_scene();\n    assert_eq!(scene3ds.meshes.len(), 5);\n\n    let glb = scene_to_glb(&scene3ds).expect(\"GLB export should succeed\");\n    assert!(glb.len() > 1000); // Should be substantial\n}\n\n/// Test variant selection affecting geometry\n#[test]\nfn test_variant_selection_geometry() {\n    use ofml_lib::article::{Variant, VariantGroup};\n\n    // Define size variants\n    let mut sizes = VariantGroup::new(\"size\", \"Desk Size\");\n    sizes.add_variant(\n        Variant::new(\"small\", \"Small (1200x600)\")\n            .with_property(\"M__BREITE\", 1200i64)\n            .with_property(\"M__TIEFE\", 600i64),\n    );\n    sizes.add_variant(\n        Variant::new(\"medium\", \"Medium (1600x800)\")\n            .with_property(\"M__BREITE\", 1600i64)\n            .with_property(\"M__TIEFE\", 800i64),\n    );\n    sizes.add_variant(\n        Variant::new(\"large\", \"Large (1800x900)\")\n            .with_property(\"M__BREITE\", 1800i64)\n            .with_property(\"M__TIEFE\", 900i64),\n    );\n\n    // Select variant\n    sizes.select(\"large\").expect(\"Selection should succeed\");\n    let selected = sizes.get_selected().expect(\"Should have selection\");\n\n    // Apply variant to article\n    let mut article = ArticleConfig::new(\"desk\", \"desk_odb\");\n    for (name, value) in &selected.properties {\n        article.set(name.clone(), value.clone());\n    }\n\n    // Verify variant applied\n    assert_eq!(article.get_int(\"M__BREITE\", 0), 1800);\n    assert_eq!(article.get_int(\"M__TIEFE\", 0), 900);\n\n    // Evaluate expression with variant properties\n    let ctor = r#\"\"desk\" ${M__BREITE:-1000} 1000 / ${M__TIEFE:-600} 1000 / 1 imp\"#;\n    let props = article.to_f64_map();\n\n    let mut evaluator = EbaseEvaluator::new();\n    let result = evaluator.evaluate(ctor, &props).expect(\"Should evaluate\");\n\n    match result {\n        EbaseResult::Import { scale, .. } => {\n            assert!((scale[0] - 1.8).abs() < 0.01);\n            assert!((scale[1] - 0.9).abs() < 0.01);\n        }\n        _ => panic!(\"Expected Import result\"),\n    }\n}\n\n/// Test GLB with embedded texture\n#[test]\nfn test_glb_with_texture() {\n    // Create texture\n    let wood_texture =\n        create_solid_color(\"wood_texture\", 139, 90, 43, 255).expect(\"Should create texture\");\n\n    // Create simple mesh\n    let mesh = Mesh {\n        name: \"box\".to_string(),\n        vertices: vec![\n            Vertex {\n                x: 0.0,\n                y: 0.0,\n                z: 0.0,\n            },\n            Vertex {\n                x: 1.0,\n                y: 0.0,\n                z: 0.0,\n            },\n            Vertex {\n                x: 1.0,\n                y: 1.0,\n                z: 0.0,\n            },\n            Vertex {\n                x: 0.0,\n                y: 1.0,\n                z: 0.0,\n            },\n        ],\n        normals: Vec::new(),\n        faces: vec![\n            Face {\n                a: 0,\n                b: 1,\n                c: 2,\n                flags: 0,\n            },\n            Face {\n                a: 0,\n                b: 2,\n                c: 3,\n                flags: 0,\n            },\n        ],\n        tex_coords: Vec::new(),\n        material_name: Some(\"wood_mat\".to_string()),\n        transform: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0],\n        coord_system: CoordSystem::YupGltf,\n    };\n\n    // Create material with texture reference\n    let mut materials = HashMap::new();\n    materials.insert(\n        \"wood_mat\".to_string(),\n        Material3DS {\n            name: \"wood_mat\".to_string(),\n            ambient: [0.1, 0.1, 0.1],\n            diffuse: [0.8, 0.6, 0.4],\n            specular: [0.3, 0.3, 0.3],\n            texture: Some(\"wood_texture\".to_string()),\n            metallic: 0.0,\n            roughness: 0.7,\n        },\n    );\n\n    // Create scene with texture\n    let scene = Scene3DS {\n        meshes: vec![mesh],\n        materials,\n        textures: vec![EmbeddedTexture {\n            name: wood_texture.name.clone(),\n            data: wood_texture.png_data.clone(),\n            width: wood_texture.width,\n            height: wood_texture.height,\n        }],\n    };\n\n    // Export to GLB\n    let glb = scene_to_glb(&scene).expect(\"GLB export should succeed\");\n\n    // Verify GLB is valid\n    assert!(glb.len() > 100);\n    assert_eq!(&glb[0..4], b\"glTF\");\n\n    // GLB should be larger due to embedded texture\n    assert!(glb.len() > 200);\n}\n\n/// Test conditional geometry based on article properties\n#[test]\nfn test_conditional_geometry_expression() {\n    let mut evaluator = EbaseEvaluator::new();\n\n    // Test conditional: if width > 1500, use large geometry\n    let ctor = r#\"${WIDTH:-1000} 1500 > { \"desk_large\" } { \"desk_small\" } ifelse 1 1 1 imp\"#;\n\n    // Width = 1600 (> 1500)\n    let mut props = HashMap::new();\n    props.insert(\"WIDTH\".to_string(), 1600.0);\n\n    let result = evaluator.evaluate(ctor, &props).expect(\"Should evaluate\");\n    match result {\n        EbaseResult::Import { filename, .. } => {\n            assert_eq!(filename, \"desk_large\");\n        }\n        _ => panic!(\"Expected Import result\"),\n    }\n\n    // Width = 1200 (< 1500)\n    props.insert(\"WIDTH\".to_string(), 1200.0);\n    let result = evaluator.evaluate(ctor, &props).expect(\"Should evaluate\");\n    match result {\n        EbaseResult::Import { filename, .. } => {\n            assert_eq!(filename, \"desk_small\");\n        }\n        _ => panic!(\"Expected Import result\"),\n    }\n}\n\n/// Test clsref result with parameters\n#[test]\nfn test_clsref_with_article_params() {\n    let mut article = ArticleConfig::new(\"test\", \"test\");\n    article.set(\"M__BREITE\", 1600i64);\n    article.set(\"M__TIEFE\", 800i64);\n    article.set(\"M__HOEHE\", 740i64);\n\n    let props = article.to_f64_map();\n\n    let ctor = r#\"${M__BREITE:-1000} 1000 / ${M__TIEFE:-600} 1000 / ${M__HOEHE:-740} 1000 / \"::ofml::go::GoYLTrans\" clsref\"#;\n\n    let mut evaluator = EbaseEvaluator::new();\n    let result = evaluator.evaluate(ctor, &props).expect(\"Should evaluate\");\n\n    match result {\n        EbaseResult::ClsRef { class, params } => {\n            assert_eq!(class, \"::ofml::go::GoYLTrans\");\n            assert_eq!(params.len(), 3);\n            assert!((params[0] - 1.6).abs() < 0.01);\n            assert!((params[1] - 0.8).abs() < 0.01);\n            assert!((params[2] - 0.74).abs() < 0.01);\n        }\n        _ => panic!(\"Expected ClsRef result\"),\n    }\n}\n\n/// Test complete material workflow\n#[test]\nfn test_material_workflow() {\n    let mut resolver = MaterialResolver::new();\n\n    // Register custom material\n    let wood_mat = MaterialDef::new(\"wood_oak\")\n        .with_diffuse(0.6, 0.4, 0.2, 1.0)\n        .with_specular(0.3, 0.3, 0.3, 1.0)\n        .with_shininess(32.0);\n\n    resolver.register(wood_mat);\n\n    // Resolve by name\n    let resolved = resolver.resolve(\"wood_oak\");\n    assert!((resolved.diffuse[0] - 0.6).abs() < 0.01);\n\n    // Fallback for unknown materials\n    let unknown = resolver.resolve(\"unknown_material\");\n    assert!((unknown.diffuse[0] - 0.8).abs() < 0.01); // Magenta fallback\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","ebase_expr_tests.rs"],"content":"//! Integration tests for EBASE expression evaluation.\n//!\n//! These tests verify the complete expression evaluation pipeline.\n\nuse ofml_lib::ebase_expr::{EbaseEvaluator, EbaseResult};\nuse std::collections::HashMap;\n\n/// Test basic expression evaluation (T034)\n#[test]\nfn test_basic_expression_evaluation() {\n    // Test a simple arithmetic expression\n    let expr = \"10 20 +\";\n    let vars: HashMap<String, f64> = HashMap::new();\n\n    let mut evaluator = EbaseEvaluator::new();\n    let result = evaluator.evaluate(expr, &vars);\n\n    assert!(result.is_ok(), \"Evaluation should succeed\");\n}\n\n/// Test import expression\n#[test]\nfn test_import_expression() {\n    // Format: \"filename\" sx sy sz imp\n    let expr = r#\"\"geometry/desk.3ds\" 1.0 1.0 1.0 imp\"#;\n    let vars: HashMap<String, f64> = HashMap::new();\n\n    let mut evaluator = EbaseEvaluator::new();\n    let result = evaluator\n        .evaluate(expr, &vars)\n        .expect(\"Evaluation should succeed\");\n\n    match result {\n        EbaseResult::Import { filename, scale } => {\n            assert_eq!(filename, \"geometry/desk.3ds\");\n            assert!((scale[0] - 1.0).abs() < 0.01);\n            assert!((scale[1] - 1.0).abs() < 0.01);\n            assert!((scale[2] - 1.0).abs() < 0.01);\n        }\n        _ => panic!(\"Expected Import result, got {:?}\", result),\n    }\n}\n\n/// Test scaled import expression\n#[test]\nfn test_scaled_import_expression() {\n    // Format: \"filename\" sx sy sz imp\n    let expr = r#\"\"geometry/desk.3ds\" 1.8 0.72 0.9 imp\"#;\n    let vars: HashMap<String, f64> = HashMap::new();\n\n    let mut evaluator = EbaseEvaluator::new();\n    let result = evaluator\n        .evaluate(expr, &vars)\n        .expect(\"Evaluation should succeed\");\n\n    match result {\n        EbaseResult::Import { filename, scale } => {\n            assert_eq!(filename, \"geometry/desk.3ds\");\n            assert!((scale[0] - 1.8).abs() < 0.01);\n            assert!((scale[1] - 0.72).abs() < 0.01);\n            assert!((scale[2] - 0.9).abs() < 0.01);\n        }\n        _ => panic!(\"Expected Import result\"),\n    }\n}\n\n/// Test variable substitution\n#[test]\nfn test_variable_substitution() {\n    let expr = \"${WIDTH:-1000} 1000 /\";\n    let mut vars: HashMap<String, f64> = HashMap::new();\n    vars.insert(\"WIDTH\".to_string(), 1800.0);\n\n    let mut evaluator = EbaseEvaluator::new();\n    let result = evaluator.evaluate(expr, &vars);\n    assert!(result.is_ok(), \"Variable substitution should succeed\");\n}\n\n/// Test default values for missing variables\n#[test]\nfn test_default_values() {\n    let expr = \"${MISSING:-500} 1000 /\";\n    let vars: HashMap<String, f64> = HashMap::new();\n\n    let mut evaluator = EbaseEvaluator::new();\n    let result = evaluator.evaluate(expr, &vars);\n    assert!(\n        result.is_ok(),\n        \"Default values should work for missing variables\"\n    );\n}\n\n/// Test clsref operator\n#[test]\nfn test_clsref_operator() {\n    // Format: params... \"ClassName\" clsref\n    let expr = r#\"1.0 0.5 0.8 \"components/leg.cls\" clsref\"#;\n    let vars: HashMap<String, f64> = HashMap::new();\n\n    let mut evaluator = EbaseEvaluator::new();\n    let result = evaluator\n        .evaluate(expr, &vars)\n        .expect(\"Evaluation should succeed\");\n\n    match result {\n        EbaseResult::ClsRef { class, params } => {\n            assert_eq!(class, \"components/leg.cls\");\n            assert_eq!(params.len(), 3);\n            assert!((params[0] - 1.0).abs() < 0.01);\n            assert!((params[1] - 0.5).abs() < 0.01);\n            assert!((params[2] - 0.8).abs() < 0.01);\n        }\n        _ => panic!(\"Expected ClsRef result\"),\n    }\n}\n\n/// Test egms operator\n#[test]\nfn test_egms_operator() {\n    let expr = r#\"\"table_top\" egms\"#;\n    let vars: HashMap<String, f64> = HashMap::new();\n\n    let mut evaluator = EbaseEvaluator::new();\n    let result = evaluator\n        .evaluate(expr, &vars)\n        .expect(\"Evaluation should succeed\");\n\n    match result {\n        EbaseResult::Egms { name } => {\n            assert_eq!(name, \"table_top\");\n        }\n        _ => panic!(\"Expected Egms result\"),\n    }\n}\n\n/// Test arithmetic operations\n#[test]\nfn test_arithmetic_operations() {\n    // Addition\n    let mut evaluator = EbaseEvaluator::new();\n    let vars: HashMap<String, f64> = HashMap::new();\n    let _ = evaluator.evaluate(\"10 5 +\", &vars);\n\n    // Subtraction\n    let _ = evaluator.evaluate(\"10 5 -\", &vars);\n\n    // Multiplication\n    let _ = evaluator.evaluate(\"10 5 *\", &vars);\n\n    // Division\n    let _ = evaluator.evaluate(\"10 5 /\", &vars);\n\n    // Negation\n    let _ = evaluator.evaluate(\"10 neg\", &vars);\n}\n\n/// Test comparison operators\n#[test]\nfn test_comparison_operators() {\n    let mut evaluator = EbaseEvaluator::new();\n    let vars: HashMap<String, f64> = HashMap::new();\n\n    // Equal\n    let _ = evaluator.evaluate(\"10 10 ==\", &vars);\n\n    // Not equal\n    let _ = evaluator.evaluate(\"10 5 !=\", &vars);\n\n    // Less than\n    let _ = evaluator.evaluate(\"5 10 <\", &vars);\n\n    // Greater than\n    let _ = evaluator.evaluate(\"10 5 >\", &vars);\n\n    // Less than or equal\n    let _ = evaluator.evaluate(\"10 10 <=\", &vars);\n\n    // Greater than or equal\n    let _ = evaluator.evaluate(\"10 10 >=\", &vars);\n}\n\n/// Test conditional execution with comparison producing boolean\n#[test]\nfn test_conditional_if() {\n    // condition { proc } if - use comparison for boolean\n    let expr = \"1 1 == { 42 } if\";\n    let vars: HashMap<String, f64> = HashMap::new();\n\n    let mut evaluator = EbaseEvaluator::new();\n    let result = evaluator.evaluate(expr, &vars);\n    assert!(\n        result.is_ok(),\n        \"If conditional should succeed: {:?}\",\n        result\n    );\n}\n\n/// Test conditional ifelse with comparison producing boolean\n#[test]\nfn test_conditional_ifelse() {\n    // condition { then } { else } ifelse - use comparison for boolean\n    let expr = \"1 1 == { 42 } { 0 } ifelse\";\n    let vars: HashMap<String, f64> = HashMap::new();\n\n    let mut evaluator = EbaseEvaluator::new();\n    let result = evaluator.evaluate(expr, &vars);\n    assert!(\n        result.is_ok(),\n        \"Ifelse conditional should succeed: {:?}\",\n        result\n    );\n}\n\n/// Test logical operators\n#[test]\nfn test_logical_operators() {\n    let mut evaluator = EbaseEvaluator::new();\n    let vars: HashMap<String, f64> = HashMap::new();\n\n    // And - need booleans from comparisons\n    let _ = evaluator.evaluate(\"1 1 == 2 2 == and\", &vars);\n\n    // Or - need booleans from comparisons\n    let _ = evaluator.evaluate(\"1 1 == 1 2 == or\", &vars);\n\n    // Not - need boolean from comparison\n    let _ = evaluator.evaluate(\"1 2 == not\", &vars);\n}\n\n/// Test stack operations\n#[test]\nfn test_stack_operations() {\n    let mut evaluator = EbaseEvaluator::new();\n    let vars: HashMap<String, f64> = HashMap::new();\n\n    // Dup\n    let _ = evaluator.evaluate(\"5 dup +\", &vars);\n\n    // Pop\n    let _ = evaluator.evaluate(\"5 10 pop\", &vars);\n\n    // Exch\n    let _ = evaluator.evaluate(\"5 10 exch -\", &vars);\n}\n\n/// Test None result (no geometry)\n#[test]\nfn test_none_result() {\n    let expr = \"5 10 +\"; // Arithmetic only, no geometry operation\n    let vars: HashMap<String, f64> = HashMap::new();\n\n    let mut evaluator = EbaseEvaluator::new();\n    let result = evaluator\n        .evaluate(expr, &vars)\n        .expect(\"Evaluation should succeed\");\n\n    // Result should be None (no geometry operation)\n    assert!(matches!(result, EbaseResult::None));\n}\n\n/// Test complex expression with variables\n#[test]\nfn test_complex_expression_with_variables() {\n    // Format: \"filename\" sx sy sz imp (with variable calculations)\n    let expr = r#\"\"geometry/desk.3ds\" ${WIDTH:-1600} 1000 / ${HEIGHT:-750} 1000 / ${DEPTH:-800} 1000 / imp\"#;\n\n    let mut vars: HashMap<String, f64> = HashMap::new();\n    vars.insert(\"WIDTH\".to_string(), 1800.0);\n    vars.insert(\"HEIGHT\".to_string(), 720.0);\n    vars.insert(\"DEPTH\".to_string(), 900.0);\n\n    let mut evaluator = EbaseEvaluator::new();\n    let result = evaluator\n        .evaluate(expr, &vars)\n        .expect(\"Evaluation should succeed\");\n\n    match result {\n        EbaseResult::Import { filename, scale } => {\n            assert_eq!(filename, \"geometry/desk.3ds\");\n            assert!((scale[0] - 1.8).abs() < 0.01);\n            assert!((scale[1] - 0.72).abs() < 0.01);\n            assert!((scale[2] - 0.9).abs() < 0.01);\n        }\n        _ => panic!(\"Expected Import result\"),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","framery_binary_analysis.rs"],"content":"use std::fs::File;\nuse std::io::{Read, Seek, SeekFrom};\nuse std::path::Path;\n\n#[test]\nfn analyze_framery_binary_corruption() {\n    let path = Path::new(\"/reference/ofmldata/framery/frmr_one_compact/ANY/1/db/pdata.ebase\");\n\n    let mut file = File::open(path).expect(\"Failed to open file\");\n\n    // Record 13 is at offset 0x34d8 (13528 decimal)\n    // Record size is 56 bytes\n    let record_offset = 0x34d8u64;\n\n    println!(\"\\n=== Binary Analysis of Record 13 ===\");\n    println!(\"Record offset: 0x{:08x} ({})\", record_offset, record_offset);\n\n    // Read the entire record\n    file.seek(SeekFrom::Start(record_offset)).unwrap();\n    let mut record_data = [0u8; 56];\n    file.read_exact(&mut record_data).unwrap();\n\n    println!(\"\\nRaw record bytes:\");\n    for (i, chunk) in record_data.chunks(16).enumerate() {\n        print!(\"  {:04x}: \", i * 16);\n        for byte in chunk {\n            print!(\"{:02x} \", byte);\n        }\n        println!();\n    }\n\n    // Parse the string offsets according to schema\n    let article_nr_offset = u32::from_be_bytes([\n        record_data[4],\n        record_data[5],\n        record_data[6],\n        record_data[7],\n    ]);\n    let var_cond_offset = u32::from_be_bytes([\n        record_data[8],\n        record_data[9],\n        record_data[10],\n        record_data[11],\n    ]);\n    let price_type_offset = u32::from_be_bytes([\n        record_data[12],\n        record_data[13],\n        record_data[14],\n        record_data[15],\n    ]);\n    let price_level_offset = u32::from_be_bytes([\n        record_data[16],\n        record_data[17],\n        record_data[18],\n        record_data[19],\n    ]);\n    let price_rule_offset = u32::from_be_bytes([\n        record_data[20],\n        record_data[21],\n        record_data[22],\n        record_data[23],\n    ]);\n    let price_textnr_offset = u32::from_be_bytes([\n        record_data[24],\n        record_data[25],\n        record_data[26],\n        record_data[27],\n    ]);\n    let price_float = f32::from_be_bytes([\n        record_data[28],\n        record_data[29],\n        record_data[30],\n        record_data[31],\n    ]);\n    let is_fix = u32::from_be_bytes([\n        record_data[32],\n        record_data[33],\n        record_data[34],\n        record_data[35],\n    ]);\n    let currency_offset = u32::from_be_bytes([\n        record_data[36],\n        record_data[37],\n        record_data[38],\n        record_data[39],\n    ]);\n    let date_from_offset = u32::from_be_bytes([\n        record_data[40],\n        record_data[41],\n        record_data[42],\n        record_data[43],\n    ]);\n    let date_to_offset = u32::from_be_bytes([\n        record_data[44],\n        record_data[45],\n        record_data[46],\n        record_data[47],\n    ]);\n    let scale_quantity = u32::from_be_bytes([\n        record_data[48],\n        record_data[49],\n        record_data[50],\n        record_data[51],\n    ]);\n    let rounding_id_offset = u32::from_be_bytes([\n        record_data[52],\n        record_data[53],\n        record_data[54],\n        record_data[55],\n    ]);\n\n    println!(\"\\n=== Parsed Field Offsets ===\");\n    println!(\n        \"  article_nr (offset 4):    0x{:08x} ({})\",\n        article_nr_offset, article_nr_offset\n    );\n    println!(\n        \"  var_cond (offset 8):      0x{:08x} ({})\",\n        var_cond_offset, var_cond_offset\n    );\n    println!(\n        \"  price_type (offset 12):   0x{:08x} ({})\",\n        price_type_offset, price_type_offset\n    );\n    println!(\n        \"  price_level (offset 16):  0x{:08x} ({})\",\n        price_level_offset, price_level_offset\n    );\n    println!(\n        \"  price_rule (offset 20):   0x{:08x} ({})\",\n        price_rule_offset, price_rule_offset\n    );\n    println!(\n        \"  price_textnr (offset 24): 0x{:08x} ({})\",\n        price_textnr_offset, price_textnr_offset\n    );\n    println!(\n        \"  price (offset 28):        {} (raw bytes: {:02x} {:02x} {:02x} {:02x})\",\n        price_float, record_data[28], record_data[29], record_data[30], record_data[31]\n    );\n    println!(\"  is_fix (offset 32):       {}\", is_fix);\n    println!(\n        \"  currency (offset 36):     0x{:08x} ({})\",\n        currency_offset, currency_offset\n    );\n    println!(\n        \"  date_from (offset 40):    0x{:08x} ({})\",\n        date_from_offset, date_from_offset\n    );\n    println!(\n        \"  date_to (offset 44):      0x{:08x} ({})\",\n        date_to_offset, date_to_offset\n    );\n    println!(\"  scale_quantity (offset 48): {}\", scale_quantity);\n    println!(\n        \"  rounding_id (offset 52):  0x{:08x} ({})\",\n        rounding_id_offset, rounding_id_offset\n    );\n\n    // Read strings from string pool\n    fn read_string_at(file: &mut File, offset: u32) -> String {\n        if offset == 0 || offset == 1 {\n            return String::from(\"(empty)\");\n        }\n\n        file.seek(SeekFrom::Start(offset as u64)).unwrap();\n        let mut len_bytes = [0u8; 2];\n        if file.read_exact(&mut len_bytes).is_err() {\n            return String::from(\"(read error)\");\n        }\n        let str_len = u16::from_be_bytes(len_bytes) as usize;\n\n        if str_len == 0 || str_len > 1000 {\n            return format!(\"(invalid length: {})\", str_len);\n        }\n\n        let mut data = vec![0u8; str_len];\n        if file.read_exact(&mut data).is_err() {\n            return String::from(\"(read error)\");\n        }\n\n        String::from_utf8(data)\n            .unwrap_or_else(|_| String::from(\"(utf8 error)\"))\n            .trim_end_matches('\\0')\n            .to_string()\n    }\n\n    println!(\"\\n=== String Values from String Pool ===\");\n    println!(\n        \"  article_nr:    \\\"{}\\\"\",\n        read_string_at(&mut file, article_nr_offset)\n    );\n    println!(\n        \"  var_cond:      \\\"{}\\\"\",\n        read_string_at(&mut file, var_cond_offset)\n    );\n    println!(\n        \"  price_type:    \\\"{}\\\"\",\n        read_string_at(&mut file, price_type_offset)\n    );\n    println!(\n        \"  price_level:   \\\"{}\\\"\",\n        read_string_at(&mut file, price_level_offset)\n    );\n    println!(\n        \"  price_rule:    \\\"{}\\\"\",\n        read_string_at(&mut file, price_rule_offset)\n    );\n    println!(\n        \"  price_textnr:  \\\"{}\\\"\",\n        read_string_at(&mut file, price_textnr_offset)\n    );\n    println!(\n        \"  currency:      \\\"{}\\\"\",\n        read_string_at(&mut file, currency_offset)\n    );\n    println!(\n        \"  date_from:     \\\"{}\\\"\",\n        read_string_at(&mut file, date_from_offset)\n    );\n    println!(\n        \"  date_to:       \\\"{}\\\"\",\n        read_string_at(&mut file, date_to_offset)\n    );\n    println!(\n        \"  rounding_id:   \\\"{}\\\"\",\n        read_string_at(&mut file, rounding_id_offset)\n    );\n\n    // Now compare with record 0 (ONE_COMPACT_ESSENTIALS at 13800 EUR)\n    println!(\"\\n=== Comparison with Record 0 (ONE_COMPACT_ESSENTIALS) ===\");\n    let record0_offset = 0x34d8u64 - (13 * 56);\n    file.seek(SeekFrom::Start(record0_offset)).unwrap();\n    let mut record0_data = [0u8; 56];\n    file.read_exact(&mut record0_data).unwrap();\n\n    let r0_article_offset = u32::from_be_bytes([\n        record0_data[4],\n        record0_data[5],\n        record0_data[6],\n        record0_data[7],\n    ]);\n    let r0_price = f32::from_be_bytes([\n        record0_data[28],\n        record0_data[29],\n        record0_data[30],\n        record0_data[31],\n    ]);\n\n    println!(\"Record 0 offset: 0x{:08x}\", record0_offset);\n    println!(\n        \"Record 0 article_nr: \\\"{}\\\"\",\n        read_string_at(&mut file, r0_article_offset)\n    );\n    println!(\"Record 0 price: {} EUR\", r0_price);\n\n    println!(\"\\n=== ANALYSIS ===\");\n    println!(\"The record appears to be MISSING the first 4 bytes (record ID field).\");\n    println!(\"All string pointers are shifted by 4 bytes, causing:\");\n    println!(\"  - article_nr (offset 4) reads from var_cond position\");\n    println!(\"  - var_cond (offset 8) reads from price_type position\");\n    println!(\"  - price_type (offset 12) reads from price_level position\");\n    println!(\"  - And so on...\");\n    println!(\"\\nThe actual data SHOULD be:\");\n    println!(\"  article_nr:   \\\"ONE_COMPACT_BASE\\\" (from offset 0x91a2)\");\n    println!(\"  var_cond:     \\\"\\\" (empty)\");\n    println!(\"  price_type:   \\\"S\\\"\");\n    println!(\"  price_level:  \\\"B\\\"\");\n    println!(\"  price:        ??? (corrupted float value)\");\n\n    // Try to find what the price should be by looking at surrounding data\n    println!(\"\\n=== Looking for Missing Price Data ===\");\n    println!(\"Searching for price pattern around record 13...\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","framery_four_investigation.rs"],"content":"//! Investigation into Framery Four pricing issues\r\n\r\nuse std::path::Path;\r\n\r\nuse ofml_lib::oap::engine::ConfigurationEngine;\r\nuse ofml_lib::oap::families::{FamilyConfiguration, FamilyLoader};\r\nuse ofml_lib::oap::ocd_properties::clear_property_cache;\r\nuse ofml_lib::oap::ocd_relation::RelationRuleReader;\r\n\r\n#[test]\r\nfn investigate_framery_four_pricing() {\r\n    clear_property_cache();\r\n\r\n    let path = Path::new(\"/reference/ofmldata\");\r\n    let mfr_path = Path::new(\"/reference/ofmldata/framery\");\r\n\r\n    if !mfr_path.exists() {\r\n        eprintln!(\"Framery not available\");\r\n        return;\r\n    }\r\n\r\n    let loader = FamilyLoader::load(mfr_path, \"DE\");\r\n\r\n    // Find FRMR_FOUR family\r\n    let family = loader\r\n        .get_families()\r\n        .iter()\r\n        .find(|f| f.series.to_uppercase() == \"FRMR_FOUR\")\r\n        .cloned();\r\n\r\n    if family.is_none() {\r\n        eprintln!(\"FRMR_FOUR not found!\");\r\n        return;\r\n    }\r\n    let family = family.unwrap();\r\n\r\n    println!(\"\\n=== FRMR_FOUR Investigation ===\");\r\n    println!(\"Family: {} - {}\", family.id, family.name);\r\n    println!(\"Base article: {}\", family.base_article_nr);\r\n\r\n    // Check for relation rules\r\n    let pdata_path = Path::new(\"/reference/ofmldata/framery/frmr_four/ANY/1/db/pdata.ebase\");\r\n    if pdata_path.exists() {\r\n        if let Some(reader) = RelationRuleReader::from_ebase(pdata_path) {\r\n            println!(\"\\n=== Relation Rules ({}) ===\", reader.varcond_rules.len());\r\n            for rule in &reader.varcond_rules {\r\n                println!(\"  {} -> {:?}\", rule.var_cond, rule.condition);\r\n            }\r\n        } else {\r\n            println!(\"\\nNo relation rules found in pdata.ebase!\");\r\n        }\r\n    } else {\r\n        println!(\"\\npdata.ebase not found at expected path!\");\r\n    }\r\n\r\n    let props = loader.get_properties_for_family(&family);\r\n\r\n    println!(\"\\n=== Properties with multiple options ===\");\r\n    for prop in &props {\r\n        if prop.options.len() > 1 {\r\n            let values: Vec<&str> = prop.options.iter().map(|o| o.value.as_str()).collect();\r\n            println!(\"  {} ({} options): {:?}\", prop.key, prop.options.len(), values);\r\n        }\r\n    }\r\n\r\n    println!(\"\\n=== Single-option properties ===\");\r\n    for prop in &props {\r\n        if prop.options.len() == 1 {\r\n            println!(\"  {} = {}\", prop.key, prop.options[0].value);\r\n        }\r\n    }\r\n\r\n    let mut config = FamilyConfiguration::new(&family.id, &props);\r\n    let engine = ConfigurationEngine::new(path);\r\n    let today = chrono::Local::now().date_naive();\r\n\r\n    // Test which relation rules match with default config\r\n    println!(\"\\n=== Testing Relation Rule Matches ===\");\r\n    if let Some(reader) = RelationRuleReader::from_ebase(pdata_path) {\r\n        use std::collections::HashMap;\r\n        let mut props: HashMap<String, String> = config\r\n            .selections\r\n            .iter()\r\n            .map(|(k, v)| {\r\n                let key = k.to_uppercase();\r\n                let prop_key = if key.starts_with(\"M_\") { key } else { format!(\"M_{}\", key) };\r\n                (prop_key, v.to_uppercase())\r\n            })\r\n            .collect();\r\n        props.insert(\"M_ARTNO\".to_string(), family.base_article_nr.to_uppercase());\r\n\r\n        println!(\"Property map for evaluation:\");\r\n        for (k, v) in props.iter().filter(|(k, _)| k.contains(\"LAN\") || k.contains(\"WHITEBOARD\") || k.contains(\"MOV\") || k.contains(\"ARTNO\")) {\r\n            println!(\"  {} = {}\", k, v);\r\n        }\r\n\r\n        let matched = reader.evaluate(&props);\r\n        println!(\"\\nMatched var_conds: {:?}\", matched);\r\n    }\r\n\r\n    // Default price\r\n    println!(\"\\n=== Pricing Tests ===\");\r\n    let price1 = engine.calculate_family_price(\"framery\", &family, &config, today);\r\n    println!(\r\n        \"Default: {} EUR ({} surcharges)\",\r\n        price1.as_ref().map(|p| p.total_price.to_string()).unwrap_or(\"None\".to_string()),\r\n        price1.as_ref().map(|p| p.surcharges.len()).unwrap_or(0)\r\n    );\r\n    if let Some(ref p) = price1 {\r\n        for s in &p.surcharges {\r\n            println!(\"  + {}: {} EUR\", s.name, s.amount);\r\n        }\r\n    }\r\n\r\n    // Try changing properties that should affect price\r\n    println!(\"\\n=== Testing property changes ===\");\r\n\r\n    // Test M_LAN\r\n    let m_lan_opts: Vec<String> = props.iter()\r\n        .find(|p| p.key == \"M_LAN\")\r\n        .map(|p| p.options.iter().map(|o| o.value.clone()).collect())\r\n        .unwrap_or_default();\r\n    println!(\"M_LAN options: {:?}\", m_lan_opts);\r\n\r\n    if m_lan_opts.len() > 1 {\r\n        let current = config.get(\"M_LAN\").unwrap_or(\"?\").to_string();\r\n        let new_val = if current == \"YES\" { \"NO\" } else { \"YES\" };\r\n        println!(\"Changing M_LAN: {} -> {}\", current, new_val);\r\n        config.set(\"M_LAN\", new_val);\r\n        let price2 = engine.calculate_family_price(\"framery\", &family, &config, today);\r\n        println!(\r\n            \"After M_LAN={}: {} EUR ({} surcharges)\",\r\n            new_val,\r\n            price2.as_ref().map(|p| p.total_price.to_string()).unwrap_or(\"None\".to_string()),\r\n            price2.as_ref().map(|p| p.surcharges.len()).unwrap_or(0)\r\n        );\r\n    } else {\r\n        println!(\"M_LAN has only {} option(s), cannot toggle\", m_lan_opts.len());\r\n    }\r\n\r\n    // Test M_MOVABILITY_KIT\r\n    let m_mov_opts: Vec<String> = props.iter()\r\n        .find(|p| p.key == \"M_MOVABILITY_KIT\")\r\n        .map(|p| p.options.iter().map(|o| o.value.clone()).collect())\r\n        .unwrap_or_default();\r\n    println!(\"\\nM_MOVABILITY_KIT options: {:?}\", m_mov_opts);\r\n\r\n    if m_mov_opts.contains(&\"YES\".to_string()) {\r\n        config.set(\"M_MOVABILITY_KIT\", \"YES\");\r\n        let price3 = engine.calculate_family_price(\"framery\", &family, &config, today);\r\n        println!(\r\n            \"After M_MOVABILITY_KIT=YES: {} EUR ({} surcharges)\",\r\n            price3.as_ref().map(|p| p.total_price.to_string()).unwrap_or(\"None\".to_string()),\r\n            price3.as_ref().map(|p| p.surcharges.len()).unwrap_or(0)\r\n        );\r\n        if let Some(ref p) = price3 {\r\n            for s in &p.surcharges {\r\n                println!(\"  + {}: {} EUR\", s.name, s.amount);\r\n            }\r\n        }\r\n    }\r\n}\r\n\n#[test]\nfn check_frmr_four_propvalue2varcond() {\n    use ofml_lib::ebase::EBaseReader;\n    use std::path::Path;\n\n    let pdata_path = Path::new(\"/reference/ofmldata/framery/frmr_four/ANY/1/db/pdata.ebase\");\n    if !pdata_path.exists() {\n        return;\n    }\n\n    let mut reader = EBaseReader::open(pdata_path).expect(\"Should open\");\n\n    // Check for propvalue2varcond table\n    if let Ok(records) = reader.read_records(\"ocd_propvalue2varcond\", None) {\n        println!(\"\\n=== FRMR_FOUR propvalue2varcond ({} records) ===\", records.len());\n        for record in records.iter().take(10) {\n            println!(\"  {:?}\", record);\n        }\n    } else {\n        println!(\"\\n=== No propvalue2varcond table in FRMR_FOUR ===\");\n    }\n}\n\n#[test]\nfn dump_frmr_four_raw_relations() {\n    use ofml_lib::ebase::EBaseReader;\n    use std::path::Path;\n\n    let pdata_path = Path::new(\"/reference/ofmldata/framery/frmr_four/ANY/1/db/pdata.ebase\");\n    if !pdata_path.exists() {\n        return;\n    }\n\n    let mut reader = EBaseReader::open(pdata_path).expect(\"Should open\");\n\n    // Check ocd_relationobj\n    println!(\"\\n=== ocd_relationobj ===\");\n    if let Ok(records) = reader.read_records(\"ocd_relationobj\", None) {\n        for record in &records {\n            let rel_name = record.get(\"rel_name\").and_then(|v| v.as_str()).unwrap_or(\"?\");\n            let rel_domain = record.get(\"rel_domain\").and_then(|v| v.as_str()).unwrap_or(\"?\");\n            if rel_domain.contains('P') {\n                println!(\"  {} (domain={})\", rel_name, rel_domain);\n            }\n        }\n    }\n\n    // Check ocd_relation for MOVABILITY\n    println!(\"\\n=== ocd_relation (searching for MOVABILITY) ===\");\n    if let Ok(records) = reader.read_records(\"ocd_relation\", None) {\n        for record in &records {\n            let rel_block = record.get(\"rel_block\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            if rel_block.to_uppercase().contains(\"MOVABILITY\") || rel_block.to_uppercase().contains(\"PG_MOV\") {\n                let rel_name = record.get(\"rel_name\").and_then(|v| v.as_str()).unwrap_or(\"?\");\n                println!(\"  [{}] {}\", rel_name, rel_block);\n            }\n        }\n        println!(\"  (searched {} relation blocks)\", records.len());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","framery_price_investigation.rs"],"content":"use ofml_lib::ebase::{EBaseReader, Value};\nuse std::path::Path;\n\n#[test]\nfn investigate_framery_price_corruption() {\n    let path = Path::new(\"/reference/ofmldata/framery/frmr_one_compact/ANY/1/db/pdata.ebase\");\n\n    let mut reader = EBaseReader::open(path).expect(\"Failed to open Framery ONE COMPACT data\");\n\n    println!(\"\\n=== Framery ONE COMPACT Price Investigation ===\");\n    println!(\"Version: {}.{}\", reader.major_version, reader.minor_version);\n\n    // Examine ocd_price table structure\n    let table = reader\n        .get_table(\"ocd_price\")\n        .expect(\"No ocd_price table found\")\n        .clone();\n\n    println!(\"\\n=== ocd_price Table Schema ===\");\n    println!(\"Record count: {}\", table.record_count);\n    println!(\"Record size: {} bytes\", table.record_size);\n    println!(\"\\nColumns:\");\n    for (i, col) in table.columns.iter().enumerate() {\n        let col_type = col\n            .column_type()\n            .map(|t| format!(\"{:?}\", t))\n            .unwrap_or_else(|| format!(\"Unknown({})\", col.type_id));\n        println!(\n            \"  [{}] {:20} type={:20} offset={:4} size={:4} flags={}\",\n            i, col.name, col_type, col.offset, col.size, col.flags\n        );\n    }\n\n    // Read all price records\n    let records = reader\n        .read_records(\"ocd_price\", None)\n        .expect(\"Failed to read records\");\n\n    println!(\"\\n=== All Price Records ({} total) ===\", records.len());\n    for (idx, record) in records.iter().enumerate() {\n        println!(\"\\n--- Record {} ---\", idx);\n\n        // Print all fields\n        for (key, value) in record {\n            match value {\n                Value::String(s) => println!(\"  {:20} = \\\"{}\\\"\", key, s),\n                Value::Float(f) => println!(\"  {:20} = {}\", key, f),\n                Value::Int(i) => println!(\"  {:20} = {}\", key, i),\n                Value::UInt(u) => println!(\"  {:20} = {}\", key, u),\n                Value::Null => println!(\"  {:20} = (null)\", key),\n                Value::Blob(b) => println!(\"  {:20} = Blob({})\", key, b),\n            }\n        }\n    }\n\n    // Now let's examine the raw binary data for record 13\n    println!(\"\\n=== Raw Binary Analysis for Record 13 ===\");\n    if records.len() > 13 {\n        let record_offset = table.data_offset as u64 + (13 * table.record_size as u64);\n        println!(\n            \"Record offset in file: 0x{:08x} ({})\",\n            record_offset, record_offset\n        );\n        println!(\"Record size: {} bytes\", table.record_size);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","framery_recovery_test.rs"],"content":"use std::fs::File;\nuse std::io::{Read, Seek, SeekFrom};\nuse std::path::Path;\n\n#[test]\nfn recover_all_corrupted_framery_prices() {\n    let path = Path::new(\"/reference/ofmldata/framery/frmr_one_compact/ANY/1/db/pdata.ebase\");\n    let mut file = File::open(path).expect(\"Failed to open file\");\n\n    println!(\"\\n=== Framery Price Recovery from Corrupted Records ===\\n\");\n\n    // Records 9-14 are corrupted (missing first 4 bytes)\n    // Record size: 56 bytes\n    // First record offset: 0x3200\n    let first_record_offset = 0x3200u64;\n    let record_size = 56u64;\n\n    // Helper function to read string from pool\n    fn read_string(file: &mut File, offset: u32) -> String {\n        if offset == 0 || offset == 1 {\n            return String::new();\n        }\n        if file.seek(SeekFrom::Start(offset as u64)).is_err() {\n            return String::new();\n        }\n        let mut len_bytes = [0u8; 2];\n        if file.read_exact(&mut len_bytes).is_err() {\n            return String::new();\n        }\n        let len = u16::from_be_bytes(len_bytes) as usize;\n        if len == 0 || len > 1000 {\n            return String::new();\n        }\n        let mut data = vec![0u8; len];\n        if file.read_exact(&mut data).is_err() {\n            return String::new();\n        }\n        String::from_utf8_lossy(&data)\n            .trim_end_matches('\\0')\n            .to_string()\n    }\n\n    // Process corrupted records 9-14\n    for record_num in 9..=14 {\n        let record_offset = first_record_offset + (record_num * record_size);\n\n        file.seek(SeekFrom::Start(record_offset)).unwrap();\n        let mut record_data = [0u8; 56];\n        file.read_exact(&mut record_data).unwrap();\n\n        // Account for the missing 4 bytes - shift all offsets by 4\n        // The data is shifted, so field at offset N actually contains data for offset N+4\n\n        // Correct field positions after accounting for shift:\n        // What we read at offset 4 is actually var_cond (should be at 8)\n        // What we read at offset 8 is actually price_type (should be at 12)\n        // What we read at offset 12 is actually price_level (should be at 16)\n        // etc.\n\n        // But we need the article_nr which would have been at offset 4\n        // Due to the shift, we need to look at what SHOULD have been at offset 0-3\n        // which is the missing record ID. The article_nr is in price_type position.\n\n        let article_nr_offset = u32::from_be_bytes([\n            record_data[12],\n            record_data[13],\n            record_data[14],\n            record_data[15],\n        ]);\n        let var_cond_offset = u32::from_be_bytes([\n            record_data[16],\n            record_data[17],\n            record_data[18],\n            record_data[19],\n        ]);\n        let price_type_offset = u32::from_be_bytes([\n            record_data[20],\n            record_data[21],\n            record_data[22],\n            record_data[23],\n        ]);\n        let price_level_offset = u32::from_be_bytes([\n            record_data[24],\n            record_data[25],\n            record_data[26],\n            record_data[27],\n        ]);\n\n        // Price is at offset 28, but shifted to 36 (8-byte shift, not 4)\n        let price_bytes = [\n            record_data[36],\n            record_data[37],\n            record_data[38],\n            record_data[39],\n        ];\n        let price = f32::from_be_bytes(price_bytes);\n\n        // Currency would be at offset 36, shifted to 40\n        let currency_offset = u32::from_be_bytes([\n            record_data[40],\n            record_data[41],\n            record_data[42],\n            record_data[43],\n        ]);\n\n        // Date_from at offset 40, shifted to 44\n        let date_from_offset = u32::from_be_bytes([\n            record_data[44],\n            record_data[45],\n            record_data[46],\n            record_data[47],\n        ]);\n\n        // Date_to at offset 44, shifted to 48\n        let date_to_offset = u32::from_be_bytes([\n            record_data[48],\n            record_data[49],\n            record_data[50],\n            record_data[51],\n        ]);\n\n        let article_nr = read_string(&mut file, article_nr_offset);\n        let var_cond = read_string(&mut file, var_cond_offset);\n        let price_type = read_string(&mut file, price_type_offset);\n        let price_level = read_string(&mut file, price_level_offset);\n        let currency = read_string(&mut file, currency_offset);\n        let date_from = read_string(&mut file, date_from_offset);\n        let date_to = read_string(&mut file, date_to_offset);\n\n        println!(\"--- Record {} (RECOVERED) ---\", record_num);\n        println!(\n            \"  article_nr:    {:?}\",\n            if article_nr.is_empty() {\n                \"*\"\n            } else {\n                &article_nr\n            }\n        );\n        println!(\"  var_cond:      {:?}\", var_cond);\n        println!(\"  price_type:    {:?}\", price_type);\n        println!(\"  price_level:   {:?}\", price_level);\n        println!(\"  price:         {:.2} {}\", price, currency);\n        println!(\"  date_from:     {:?}\", date_from);\n        println!(\"  date_to:       {:?}\", date_to);\n\n        if record_num == 13 {\n            println!(\n                \"\\n  *** ONE_COMPACT_BASE BASE PRICE: {:.2} EUR ***\\n\",\n                price\n            );\n            assert!(\n                (price - 12280.0).abs() < 1.0,\n                \"Expected ONE_COMPACT_BASE price to be ~12280 EUR, got {}\",\n                price\n            );\n        }\n    }\n\n    println!(\"\\n=== Summary of Recovered Prices ===\");\n    println!(\"All 6 corrupted records (9-14) successfully recovered by accounting for the 4-byte offset.\");\n    println!(\"Main finding: ONE_COMPACT_BASE base price = 12,280 EUR\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","framery_relation_test.rs"],"content":"//! Test for FRMR_ONE pricing using ocd_relation rules\r\n\r\nuse std::collections::HashMap;\r\nuse std::path::Path;\r\n\r\nuse ofml_lib::oap::ocd_relation::RelationRuleReader;\r\n\r\n#[test]\r\nfn test_frmr_one_relation_rules_load() {\r\n    let path = Path::new(\"/reference/ofmldata/framery/frmr_one/ANY/1/db/pdata.ebase\");\r\n    if !path.exists() {\r\n        eprintln!(\"Skipping: path not found\");\r\n        return;\r\n    }\r\n\r\n    let reader = RelationRuleReader::from_ebase(path).expect(\"Should load relations\");\r\n\r\n    println!(\"\\n=== FRMR_ONE Relation Rules ===\\n\");\r\n    assert!(reader.has_pricing_rules(), \"Should have pricing rules\");\r\n    println!(\"Loaded {} var_cond rules\", reader.varcond_rules.len());\r\n\r\n    for rule in &reader.varcond_rules {\r\n        println!(\"  VarCond: {} -> {:?}\", rule.var_cond, rule.condition);\r\n    }\r\n}\r\n\r\n#[test]\r\nfn test_frmr_one_relation_evaluation_seat() {\r\n    let path = Path::new(\"/reference/ofmldata/framery/frmr_one/ANY/1/db/pdata.ebase\");\r\n    if !path.exists() {\r\n        eprintln!(\"Skipping: path not found\");\r\n        return;\r\n    }\r\n\r\n    let reader = RelationRuleReader::from_ebase(path).expect(\"Should load relations\");\r\n\r\n    // Test: ONE with adjustable seat enabled\r\n    let mut props = HashMap::new();\r\n    props.insert(\"M_ARTNO\".to_string(), \"ONE\".to_string());\r\n    props.insert(\"M_SEAT\".to_string(), \"YES\".to_string());\r\n\r\n    let matched = reader.evaluate(&props);\r\n    println!(\"\\n=== ONE with M_SEAT=YES ===\");\r\n    println!(\"Matched var_conds: {:?}\", matched);\r\n\r\n    assert!(matched.contains(&\"PG_ADJUSTABLE_SEAT\".to_string()),\r\n        \"Should match PG_ADJUSTABLE_SEAT when M_ARTNO=ONE and M_SEAT=YES\");\r\n}\r\n\r\n#[test]\r\nfn test_frmr_one_relation_evaluation_lan() {\r\n    let path = Path::new(\"/reference/ofmldata/framery/frmr_one/ANY/1/db/pdata.ebase\");\r\n    if !path.exists() {\r\n        eprintln!(\"Skipping: path not found\");\r\n        return;\r\n    }\r\n\r\n    let reader = RelationRuleReader::from_ebase(path).expect(\"Should load relations\");\r\n\r\n    // Test: LAN enabled\r\n    let mut props = HashMap::new();\r\n    props.insert(\"M_ARTNO\".to_string(), \"ONE_PREMIUM\".to_string());\r\n    props.insert(\"M_LAN\".to_string(), \"YES\".to_string());\r\n\r\n    let matched = reader.evaluate(&props);\r\n    println!(\"\\n=== ONE_PREMIUM with M_LAN=YES ===\");\r\n    println!(\"Matched var_conds: {:?}\", matched);\r\n\r\n    assert!(matched.contains(&\"PG_LAN\".to_string()),\r\n        \"Should match PG_LAN when M_LAN=YES\");\r\n}\r\n\r\n#[test]\r\nfn test_frmr_one_relation_evaluation_non_standard_colors() {\r\n    let path = Path::new(\"/reference/ofmldata/framery/frmr_one/ANY/1/db/pdata.ebase\");\r\n    if !path.exists() {\r\n        eprintln!(\"Skipping: path not found\");\r\n        return;\r\n    }\r\n\r\n    let reader = RelationRuleReader::from_ebase(path).expect(\"Should load relations\");\r\n\r\n    // Test: ONE with non-standard exterior color\r\n    let mut props = HashMap::new();\r\n    props.insert(\"M_ARTNO\".to_string(), \"ONE\".to_string());\r\n    props.insert(\"M_EXTERIOR\".to_string(), \"CUSTOM_BLUE\".to_string()); // Not in standard list\r\n\r\n    let matched = reader.evaluate(&props);\r\n    println!(\"\\n=== ONE with custom exterior color ===\");\r\n    println!(\"Matched var_conds: {:?}\", matched);\r\n\r\n    assert!(matched.contains(&\"PG_EXTERIOR_PANEL_OPTION_COLOR\".to_string()),\r\n        \"Should match PG_EXTERIOR_PANEL_OPTION_COLOR for non-standard color\");\r\n}\r\n\r\n#[test]\r\nfn test_frmr_one_relation_evaluation_standard_colors() {\r\n    let path = Path::new(\"/reference/ofmldata/framery/frmr_one/ANY/1/db/pdata.ebase\");\r\n    if !path.exists() {\r\n        eprintln!(\"Skipping: path not found\");\r\n        return;\r\n    }\r\n\r\n    let reader = RelationRuleReader::from_ebase(path).expect(\"Should load relations\");\r\n\r\n    // Test: ONE with STANDARD exterior color (RAL9016MAT is in the standard list)\r\n    let mut props = HashMap::new();\r\n    props.insert(\"M_ARTNO\".to_string(), \"ONE\".to_string());\r\n    props.insert(\"M_EXTERIOR\".to_string(), \"RAL9016MAT\".to_string()); // Standard\r\n\r\n    let matched = reader.evaluate(&props);\r\n    println!(\"\\n=== ONE with standard exterior color ===\");\r\n    println!(\"Matched var_conds: {:?}\", matched);\r\n\r\n    // Should NOT have the surcharge for standard colors\r\n    assert!(!matched.contains(&\"PG_EXTERIOR_PANEL_OPTION_COLOR\".to_string()),\r\n        \"Should NOT match PG_EXTERIOR_PANEL_OPTION_COLOR for standard RAL9016MAT color\");\r\n}\r\n\r\n#[test]\r\nfn test_frmr_one_relation_evaluation_multiple_options() {\r\n    let path = Path::new(\"/reference/ofmldata/framery/frmr_one/ANY/1/db/pdata.ebase\");\r\n    if !path.exists() {\r\n        eprintln!(\"Skipping: path not found\");\r\n        return;\r\n    }\r\n\r\n    let reader = RelationRuleReader::from_ebase(path).expect(\"Should load relations\");\r\n\r\n    // Test: ONE with multiple upgrades\r\n    let mut props = HashMap::new();\r\n    props.insert(\"M_ARTNO\".to_string(), \"ONE\".to_string());\r\n    props.insert(\"M_SEAT\".to_string(), \"YES\".to_string());\r\n    props.insert(\"M_LAN\".to_string(), \"YES\".to_string());\r\n    props.insert(\"M_FILTER\".to_string(), \"YES\".to_string());\r\n    props.insert(\"M_SERVICE_KIT\".to_string(), \"YES\".to_string());\r\n    props.insert(\"M_EXTERIOR\".to_string(), \"CUSTOM_GREEN\".to_string()); // Non-standard\r\n\r\n    let matched = reader.evaluate(&props);\r\n    println!(\"\\n=== ONE with multiple upgrades ===\");\r\n    println!(\"Matched var_conds: {:?}\", matched);\r\n\r\n    // Should have all the expected surcharges\r\n    assert!(matched.contains(&\"PG_ADJUSTABLE_SEAT\".to_string()), \"Should have seat surcharge\");\r\n    assert!(matched.contains(&\"PG_LAN\".to_string()), \"Should have LAN surcharge\");\r\n    assert!(matched.contains(&\"PG_ACTIVATED_CARBON_FILTER\".to_string()), \"Should have filter surcharge\");\r\n    assert!(matched.contains(&\"PG_SERVICE_KIT\".to_string()), \"Should have service kit surcharge\");\r\n    assert!(matched.contains(&\"PG_EXTERIOR_PANEL_OPTION_COLOR\".to_string()), \"Should have exterior color surcharge\");\r\n\r\n    println!(\"Total surcharges matched: {}\", matched.len());\r\n}\r\n\r\n#[test]\r\nfn test_frmr_one_relation_evaluation_one_lounge() {\r\n    let path = Path::new(\"/reference/ofmldata/framery/frmr_one/ANY/1/db/pdata.ebase\");\r\n    if !path.exists() {\r\n        eprintln!(\"Skipping: path not found\");\r\n        return;\r\n    }\r\n\r\n    let reader = RelationRuleReader::from_ebase(path).expect(\"Should load relations\");\r\n\r\n    // Test: ONE_LOUNGE with adjustable table\r\n    let mut props = HashMap::new();\r\n    props.insert(\"M_ARTNO\".to_string(), \"ONE_LOUNGE\".to_string());\r\n    props.insert(\"M_TABLE\".to_string(), \"ADJUSTABLE_TABLE\".to_string());\r\n\r\n    let matched = reader.evaluate(&props);\r\n    println!(\"\\n=== ONE_LOUNGE with adjustable table ===\");\r\n    println!(\"Matched var_conds: {:?}\", matched);\r\n\r\n    assert!(matched.contains(&\"PG_ADJUSTABLE_TABLE\".to_string()),\r\n        \"Should match PG_ADJUSTABLE_TABLE for ONE_LOUNGE with adjustable table\");\r\n\r\n    // Seat surcharge should NOT apply to ONE_LOUNGE (condition is M_ARTNO = 'ONE')\r\n    props.insert(\"M_SEAT\".to_string(), \"YES\".to_string());\r\n    let matched2 = reader.evaluate(&props);\r\n    assert!(!matched2.contains(&\"PG_ADJUSTABLE_SEAT\".to_string()),\r\n        \"Should NOT match PG_ADJUSTABLE_SEAT for ONE_LOUNGE (only for ONE)\");\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","frmr_one_e2e_test.rs"],"content":"//! End-to-end test for FRMR_ONE pricing with relation rules\r\n\r\nuse std::path::Path;\r\n\r\nuse ofml_lib::oap::engine::ConfigurationEngine;\r\nuse ofml_lib::oap::families::{FamilyConfiguration, FamilyLoader};\r\nuse ofml_lib::oap::ocd_properties::clear_property_cache;\r\n\r\n#[test]\r\nfn test_frmr_one_default_pricing() {\r\n    clear_property_cache();\r\n\r\n    let path = Path::new(\"/reference/ofmldata\");\r\n    let mfr_path = Path::new(\"/reference/ofmldata/framery\");\r\n\r\n    if !mfr_path.exists() {\r\n        eprintln!(\"Framery not available\");\r\n        return;\r\n    }\r\n\r\n    let loader = FamilyLoader::load(mfr_path, \"DE\");\r\n\r\n    // Find FRMR_ONE family\r\n    let one_family = loader.get_families().iter()\r\n        .find(|f| f.series.to_uppercase() == \"FRMR_ONE\")\r\n        .cloned();\r\n\r\n    if one_family.is_none() {\r\n        eprintln!(\"FRMR_ONE family not found\");\r\n        return;\r\n    }\r\n    let family = one_family.unwrap();\r\n\r\n    println!(\"\\n=== FRMR_ONE Default Pricing ===\");\r\n    println!(\"Family: {} - {}\", family.id, family.name);\r\n    println!(\"Base article: {}\", family.base_article_nr);\r\n\r\n    let props = loader.get_properties_for_family(&family);\r\n    let config = FamilyConfiguration::new(&family.id, &props);\r\n\r\n    // Debug: show ALL property keys\r\n    println!(\"ALL Config selections:\");\r\n    for (k, v) in config.selections.iter() {\r\n        println!(\"  {} = {}\", k, v);\r\n    }\r\n\r\n    // Show all property option counts\r\n    println!(\"\\nProperty option counts:\");\r\n    let mut single_option = Vec::new();\r\n    let mut multi_option = Vec::new();\r\n    for prop in &props {\r\n        if prop.options.len() == 1 {\r\n            single_option.push(&prop.key);\r\n        } else {\r\n            multi_option.push(format!(\"{} ({} options)\", prop.key, prop.options.len()));\r\n        }\r\n    }\r\n    println!(\"  Single option (not toggleable): {:?}\", single_option);\r\n    println!(\"  Multi option (toggleable): {:?}\", multi_option);\r\n\r\n    let engine = ConfigurationEngine::new(path);\r\n    let today = chrono::Local::now().date_naive();\r\n\r\n    let price = engine.calculate_family_price(\"framery\", &family, &config, today);\r\n    println!(\"Price result: {:?}\", price);\r\n\r\n    // FRMR_ONE should return a price (base may be 0 but result should exist)\r\n    assert!(price.is_some(), \"FRMR_ONE should return a price result\");\r\n}\r\n\r\n#[test]\r\nfn test_frmr_one_with_seat_surcharge() {\r\n    clear_property_cache();\r\n\r\n    let path = Path::new(\"/reference/ofmldata\");\r\n    let mfr_path = Path::new(\"/reference/ofmldata/framery\");\r\n\r\n    if !mfr_path.exists() {\r\n        eprintln!(\"Framery not available\");\r\n        return;\r\n    }\r\n\r\n    let loader = FamilyLoader::load(mfr_path, \"DE\");\r\n    let one_family = loader.get_families().iter()\r\n        .find(|f| f.series.to_uppercase() == \"FRMR_ONE\")\r\n        .cloned();\r\n\r\n    if one_family.is_none() {\r\n        return;\r\n    }\r\n    let family = one_family.unwrap();\r\n\r\n    let props = loader.get_properties_for_family(&family);\r\n    let mut config = FamilyConfiguration::new(&family.id, &props);\r\n\r\n    // Enable adjustable seat - should trigger PG_ADJUSTABLE_SEAT surcharge\r\n    config.selections.insert(\"M_SEAT\".to_string(), \"YES\".to_string());\r\n\r\n    let engine = ConfigurationEngine::new(path);\r\n    let today = chrono::Local::now().date_naive();\r\n\r\n    let price = engine.calculate_family_price(\"framery\", &family, &config, today);\r\n\r\n    println!(\"\\n=== FRMR_ONE with M_SEAT=YES ===\");\r\n    println!(\"Price result: {:?}\", price);\r\n\r\n    if let Some(p) = &price {\r\n        println!(\"  Surcharges: {:?}\", p.surcharges);\r\n\r\n        // Check for adjustable seat surcharge (should be 1420 EUR)\r\n        let seat_surcharge = p.surcharges.iter()\r\n            .find(|s| s.name.contains(\"SEAT\"));\r\n\r\n        if seat_surcharge.is_some() {\r\n            println!(\"  Found seat surcharge: {:?}\", seat_surcharge);\r\n        }\r\n    }\r\n\r\n    assert!(price.is_some(), \"Should have price\");\r\n}\r\n\r\n#[test]\r\nfn test_frmr_one_with_lan_surcharge() {\r\n    clear_property_cache();\r\n\r\n    let path = Path::new(\"/reference/ofmldata\");\r\n    let mfr_path = Path::new(\"/reference/ofmldata/framery\");\r\n\r\n    if !mfr_path.exists() {\r\n        return;\r\n    }\r\n\r\n    let loader = FamilyLoader::load(mfr_path, \"DE\");\r\n    let one_family = loader.get_families().iter()\r\n        .find(|f| f.series.to_uppercase() == \"FRMR_ONE\")\r\n        .cloned();\r\n\r\n    if one_family.is_none() {\r\n        return;\r\n    }\r\n    let family = one_family.unwrap();\r\n\r\n    let props = loader.get_properties_for_family(&family);\r\n    let mut config = FamilyConfiguration::new(&family.id, &props);\r\n\r\n    // Enable LAN - should trigger PG_LAN surcharge\r\n    config.selections.insert(\"M_LAN\".to_string(), \"YES\".to_string());\r\n\r\n    let engine = ConfigurationEngine::new(path);\r\n    let today = chrono::Local::now().date_naive();\r\n\r\n    let price = engine.calculate_family_price(\"framery\", &family, &config, today);\r\n\r\n    println!(\"\\n=== FRMR_ONE with M_LAN=YES ===\");\r\n    println!(\"Price result: {:?}\", price);\r\n\r\n    if let Some(p) = &price {\r\n        println!(\"  Surcharges: {:?}\", p.surcharges);\r\n    }\r\n\r\n    assert!(price.is_some(), \"Should have price\");\r\n}\r\n\r\n#[test]\r\nfn test_frmr_one_multiple_surcharges() {\r\n    clear_property_cache();\r\n\r\n    let path = Path::new(\"/reference/ofmldata\");\r\n    let mfr_path = Path::new(\"/reference/ofmldata/framery\");\r\n\r\n    if !mfr_path.exists() {\r\n        return;\r\n    }\r\n\r\n    let loader = FamilyLoader::load(mfr_path, \"DE\");\r\n    let one_family = loader.get_families().iter()\r\n        .find(|f| f.series.to_uppercase() == \"FRMR_ONE\")\r\n        .cloned();\r\n\r\n    if one_family.is_none() {\r\n        return;\r\n    }\r\n    let family = one_family.unwrap();\r\n\r\n    let props = loader.get_properties_for_family(&family);\r\n    let mut config = FamilyConfiguration::new(&family.id, &props);\r\n\r\n    // Enable multiple options\r\n    config.selections.insert(\"M_SEAT\".to_string(), \"YES\".to_string());\r\n    config.selections.insert(\"M_LAN\".to_string(), \"YES\".to_string());\r\n    config.selections.insert(\"M_FILTER\".to_string(), \"YES\".to_string());\r\n    config.selections.insert(\"M_SERVICE_KIT\".to_string(), \"YES\".to_string());\r\n\r\n    let engine = ConfigurationEngine::new(path);\r\n    let today = chrono::Local::now().date_naive();\r\n\r\n    let price = engine.calculate_family_price(\"framery\", &family, &config, today);\r\n\r\n    println!(\"\\n=== FRMR_ONE with Multiple Options ===\");\r\n    println!(\"Price result: {:?}\", price);\r\n\r\n    if let Some(p) = &price {\r\n        println!(\"  Total: {} EUR\", p.total_price);\r\n        println!(\"  Surcharges ({}):\", p.surcharges.len());\r\n        for s in &p.surcharges {\r\n            println!(\"    - {}: {} EUR\", s.name, s.amount);\r\n        }\r\n    }\r\n\r\n    assert!(price.is_some(), \"Should have price\");\r\n}\r\n\r\n#[test]\r\nfn test_frmr_one_price_changes_on_property_change() {\r\n    clear_property_cache();\r\n\r\n    let path = Path::new(\"/reference/ofmldata\");\r\n    let mfr_path = Path::new(\"/reference/ofmldata/framery\");\r\n\r\n    if !mfr_path.exists() {\r\n        return;\r\n    }\r\n\r\n    let loader = FamilyLoader::load(mfr_path, \"DE\");\r\n    let one_family = loader.get_families().iter()\r\n        .find(|f| f.series.to_uppercase() == \"FRMR_ONE\")\r\n        .cloned();\r\n\r\n    if one_family.is_none() {\r\n        return;\r\n    }\r\n    let family = one_family.unwrap();\r\n\r\n    let props = loader.get_properties_for_family(&family);\r\n    let mut config = FamilyConfiguration::new(&family.id, &props);\r\n\r\n    let engine = ConfigurationEngine::new(path);\r\n    let today = chrono::Local::now().date_naive();\r\n\r\n    // Default has M_LAN=YES\r\n    println!(\"\\n=== Price Changes Test ===\");\r\n    println!(\"Default M_LAN = {}\", config.get(\"M_LAN\").unwrap_or(\"?\"));\r\n    let price_with_lan = engine.calculate_family_price(\"framery\", &family, &config, today);\r\n    println!(\"With LAN: {} EUR, {} surcharges\",\r\n        price_with_lan.as_ref().map(|p| p.total_price.to_string()).unwrap_or(\"?\".to_string()),\r\n        price_with_lan.as_ref().map(|p| p.surcharges.len()).unwrap_or(0));\r\n\r\n    // Change M_LAN to NO\r\n    config.set(\"M_LAN\", \"NO\");\r\n    println!(\"After change M_LAN = {}\", config.get(\"M_LAN\").unwrap_or(\"?\"));\r\n    let price_without_lan = engine.calculate_family_price(\"framery\", &family, &config, today);\r\n    println!(\"Without LAN: {} EUR, {} surcharges\",\r\n        price_without_lan.as_ref().map(|p| p.total_price.to_string()).unwrap_or(\"?\".to_string()),\r\n        price_without_lan.as_ref().map(|p| p.surcharges.len()).unwrap_or(0));\r\n\r\n    // Verify prices are different\r\n    if let (Some(p1), Some(p2)) = (&price_with_lan, &price_without_lan) {\r\n        let diff = p1.total_price - p2.total_price;\r\n        println!(\"Difference: {} EUR\", diff);\r\n        assert!(diff > rust_decimal::Decimal::ZERO,\r\n            \"Price should decrease when LAN is disabled, diff={}\", diff);\r\n    }\r\n}\r\n\r\n#[test]\r\nfn test_frmr_one_filter_option_changes_price() {\r\n    // This tests a property that HAS both YES/NO options (unlike M_LAN which only has YES)\r\n    clear_property_cache();\r\n\r\n    let path = Path::new(\"/reference/ofmldata\");\r\n    let mfr_path = Path::new(\"/reference/ofmldata/framery\");\r\n\r\n    if !mfr_path.exists() {\r\n        return;\r\n    }\r\n\r\n    let loader = FamilyLoader::load(mfr_path, \"DE\");\r\n    let family = loader.get_families().iter()\r\n        .find(|f| f.series.to_uppercase() == \"FRMR_ONE\")\r\n        .cloned().unwrap();\r\n\r\n    let props = loader.get_properties_for_family(&family);\r\n    let mut config = FamilyConfiguration::new(&family.id, &props);\r\n\r\n    let engine = ConfigurationEngine::new(path);\r\n    let today = chrono::Local::now().date_naive();\r\n\r\n    // Default has M_FILTER=NO\r\n    println!(\"\\n=== M_FILTER Price Changes Test ===\");\r\n    println!(\"Default M_FILTER = {}\", config.get(\"M_FILTER\").unwrap_or(\"?\"));\r\n    let price_without_filter = engine.calculate_family_price(\"framery\", &family, &config, today);\r\n    println!(\"Without filter: {} EUR\",\r\n        price_without_filter.as_ref().map(|p| p.total_price.to_string()).unwrap_or(\"?\".to_string()));\r\n\r\n    // Change M_FILTER to YES\r\n    config.set(\"M_FILTER\", \"YES\");\r\n    println!(\"After change M_FILTER = {}\", config.get(\"M_FILTER\").unwrap_or(\"?\"));\r\n    let price_with_filter = engine.calculate_family_price(\"framery\", &family, &config, today);\r\n    println!(\"With filter: {} EUR\",\r\n        price_with_filter.as_ref().map(|p| p.total_price.to_string()).unwrap_or(\"?\".to_string()));\r\n\r\n    // Verify price increased\r\n    if let (Some(p1), Some(p2)) = (&price_without_filter, &price_with_filter) {\r\n        let diff = p2.total_price - p1.total_price;\r\n        println!(\"Difference: {} EUR (should be ~325 EUR for carbon filter)\", diff);\r\n        assert!(diff > rust_decimal::Decimal::ZERO,\r\n            \"Price should increase when filter is enabled\");\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","geometry2d_tests.rs"],"content":"//! Integration tests for 2D geometry processing.\n//!\n//! These tests verify the 2D representation generation pipeline.\n\nuse ofml_lib::geometry2d::{\n    Arc2D, Circle2D, Ellipse2D, FillStyle, G2DAttributes, G2DCompound, G2DPrimitive, Line2D,\n    LineStyle, Point2D, Rect2D, Text2D, TextAnchor, Transform2D,\n};\n\n/// Test creating 2D primitives\n#[test]\nfn test_2d_primitives_creation() {\n    // Points\n    let points = vec![\n        Point2D { x: 0.0, y: 0.0 },\n        Point2D { x: 1.0, y: 0.0 },\n        Point2D { x: 1.0, y: 1.0 },\n    ];\n    let primitive = G2DPrimitive::Points(points);\n    assert!(matches!(primitive, G2DPrimitive::Points(_)));\n\n    // Lines\n    let lines = vec![Line2D {\n        start: Point2D { x: 0.0, y: 0.0 },\n        end: Point2D { x: 1.0, y: 1.0 },\n    }];\n    let primitive = G2DPrimitive::Lines(lines);\n    assert!(matches!(primitive, G2DPrimitive::Lines(_)));\n\n    // Rectangle\n    let rect = Rect2D {\n        x: 0.0,\n        y: 0.0,\n        width: 2.0,\n        height: 1.5,\n    };\n    let primitive = G2DPrimitive::Rectangle(rect);\n    assert!(matches!(primitive, G2DPrimitive::Rectangle(_)));\n\n    // Circle\n    let circle = Circle2D {\n        center: Point2D { x: 0.5, y: 0.5 },\n        radius: 0.25,\n    };\n    let primitive = G2DPrimitive::Circle(circle);\n    assert!(matches!(primitive, G2DPrimitive::Circle(_)));\n}\n\n/// Test ellipse and arc primitives\n#[test]\nfn test_2d_ellipse_arc() {\n    // Ellipse\n    let ellipse = Ellipse2D {\n        center: Point2D { x: 1.0, y: 1.0 },\n        rx: 0.5,\n        ry: 0.3,\n    };\n    let primitive = G2DPrimitive::Ellipse(ellipse);\n    assert!(matches!(primitive, G2DPrimitive::Ellipse(_)));\n\n    // Arc\n    let arc = Arc2D {\n        center: Point2D { x: 0.0, y: 0.0 },\n        radius: 0.5,\n        start_angle: 0.0,\n        end_angle: std::f64::consts::FRAC_PI_2,\n    };\n    let primitive = G2DPrimitive::Arc(arc);\n    assert!(matches!(primitive, G2DPrimitive::Arc(_)));\n}\n\n/// Test text primitive\n#[test]\nfn test_2d_text() {\n    let text = Text2D {\n        position: Point2D { x: 0.0, y: 0.0 },\n        text: \"Test\".to_string(),\n        font_size: 12.0,\n        anchor: TextAnchor::Start,\n    };\n    let primitive = G2DPrimitive::Text(text);\n    assert!(matches!(primitive, G2DPrimitive::Text(_)));\n}\n\n/// Test 2D compound structure\n#[test]\nfn test_2d_compound() {\n    let mut compound = G2DCompound::new();\n\n    // Add primitives directly to the vector\n    let rect = Rect2D {\n        x: 0.0,\n        y: 0.0,\n        width: 1.0,\n        height: 1.0,\n    };\n    compound.primitives.push(G2DPrimitive::Rectangle(rect));\n\n    let circle = Circle2D {\n        center: Point2D { x: 0.5, y: 0.5 },\n        radius: 0.25,\n    };\n    compound.primitives.push(G2DPrimitive::Circle(circle));\n\n    assert_eq!(compound.primitives.len(), 2);\n}\n\n/// Test 2D transforms\n#[test]\nfn test_2d_transforms() {\n    // Identity transform\n    let transform = Transform2D::default();\n    assert!((transform.translation[0] - 0.0).abs() < 0.01);\n    assert!((transform.translation[1] - 0.0).abs() < 0.01);\n    assert!((transform.scale[0] - 1.0).abs() < 0.01);\n    assert!((transform.scale[1] - 1.0).abs() < 0.01);\n    assert!((transform.rotation - 0.0).abs() < 0.01);\n\n    // Custom transform\n    let mut transform = Transform2D::default();\n    transform.translation = [10.0, 20.0];\n    transform.scale = [2.0, 2.0];\n    transform.rotation = std::f64::consts::FRAC_PI_4;\n\n    assert!((transform.translation[0] - 10.0).abs() < 0.01);\n    assert!((transform.translation[1] - 20.0).abs() < 0.01);\n    assert!((transform.scale[0] - 2.0).abs() < 0.01);\n    assert!((transform.rotation - std::f64::consts::FRAC_PI_4).abs() < 0.01);\n}\n\n/// Test SVG export\n#[test]\nfn test_svg_export() {\n    let mut compound = G2DCompound::new();\n\n    // Add a rectangle\n    let rect = Rect2D {\n        x: 10.0,\n        y: 10.0,\n        width: 80.0,\n        height: 60.0,\n    };\n    compound.primitives.push(G2DPrimitive::Rectangle(rect));\n\n    // Add a circle\n    let circle = Circle2D {\n        center: Point2D { x: 50.0, y: 40.0 },\n        radius: 20.0,\n    };\n    compound.primitives.push(G2DPrimitive::Circle(circle));\n\n    // Export to SVG\n    let svg = compound.to_svg();\n\n    // Verify SVG structure\n    assert!(svg.contains(\"<svg\"));\n    assert!(svg.contains(\"</svg>\"));\n    assert!(svg.contains(\"<rect\") || svg.contains(\"rect\"));\n    assert!(svg.contains(\"<circle\") || svg.contains(\"circle\"));\n}\n\n/// Test polygon primitives\n#[test]\nfn test_polygon_primitives() {\n    let vertices = vec![\n        Point2D { x: 0.0, y: 0.0 },\n        Point2D { x: 1.0, y: 0.0 },\n        Point2D { x: 1.0, y: 1.0 },\n        Point2D { x: 0.0, y: 1.0 },\n    ];\n    let primitive = G2DPrimitive::Polygon(vertices.clone());\n\n    if let G2DPrimitive::Polygon(v) = primitive {\n        assert_eq!(v.len(), 4);\n    } else {\n        panic!(\"Expected Polygon\");\n    }\n}\n\n/// Test line strip and line loop\n#[test]\nfn test_line_strip_and_loop() {\n    let points = vec![\n        Point2D { x: 0.0, y: 0.0 },\n        Point2D { x: 1.0, y: 0.5 },\n        Point2D { x: 2.0, y: 0.0 },\n        Point2D { x: 2.0, y: 1.0 },\n    ];\n\n    let strip = G2DPrimitive::LineStrip(points.clone());\n    assert!(matches!(strip, G2DPrimitive::LineStrip(_)));\n\n    let loop_prim = G2DPrimitive::LineLoop(points);\n    assert!(matches!(loop_prim, G2DPrimitive::LineLoop(_)));\n}\n\n/// Test attributes\n#[test]\nfn test_2d_attributes() {\n    let mut attrs = G2DAttributes::default();\n    attrs.color = [1.0, 0.5, 0.0, 1.0];\n    attrs.fill_color = Some([0.0, 1.0, 0.5, 0.8]);\n    attrs.line_width = 3.0;\n    attrs.line_style = LineStyle::Dashed;\n    attrs.fill_style = FillStyle::Solid;\n    attrs.layer = \"layer_5\".to_string();\n\n    assert!((attrs.color[0] - 1.0).abs() < 0.01);\n    assert!(attrs.fill_color.is_some());\n    assert!((attrs.line_width - 3.0).abs() < 0.01);\n    assert_eq!(attrs.layer, \"layer_5\");\n}\n\n/// Test compound with transform\n#[test]\nfn test_compound_with_transform() {\n    let mut compound = G2DCompound::new();\n\n    // Apply a transform to the compound\n    compound.transform.translation = [50.0, 50.0];\n    compound.transform.scale = [2.0, 2.0];\n\n    // Add a simple shape\n    let rect = Rect2D {\n        x: 0.0,\n        y: 0.0,\n        width: 10.0,\n        height: 10.0,\n    };\n    compound.primitives.push(G2DPrimitive::Rectangle(rect));\n\n    let svg = compound.to_svg();\n\n    // Should contain transform in SVG\n    assert!(svg.contains(\"<svg\") || svg.contains(\"transform=\"));\n}\n\n/// Test nested compounds\n#[test]\nfn test_nested_compounds() {\n    let mut parent = G2DCompound::new();\n    let mut child = G2DCompound::new();\n\n    // Add primitive to child\n    let circle = Circle2D {\n        center: Point2D { x: 0.0, y: 0.0 },\n        radius: 1.0,\n    };\n    child.primitives.push(G2DPrimitive::Circle(circle));\n\n    // Add child to parent\n    parent.children.push(child);\n\n    assert_eq!(parent.children.len(), 1);\n    assert_eq!(parent.children[0].primitives.len(), 1);\n}\n\n/// Test line styles\n#[test]\nfn test_line_styles() {\n    let styles = [\n        LineStyle::Solid,\n        LineStyle::Dashed,\n        LineStyle::Dotted,\n        LineStyle::DashDot,\n    ];\n\n    for style in styles {\n        // All styles should have a valid dasharray (or None for solid)\n        let _ = style.to_svg_dasharray();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","geometry_tests.rs"],"content":"//! Integration tests for geometry loading and processing.\n//!\n//! These tests verify the geometry loading pipeline.\n\nuse ofml_lib::scene::{FrameDimensions, Geometry, SceneGraph};\n\n/// Test creating various geometry primitives\n#[test]\nfn test_create_all_primitives() {\n    let mut scene = SceneGraph::new();\n\n    // Create block\n    let block = scene.create_block(\"block\".to_string(), [1.0, 2.0, 0.5], None);\n    assert!(matches!(\n        block.borrow().geometry,\n        Geometry::Block { width, height, depth }\n        if (width - 1.0).abs() < 0.01 && (height - 2.0).abs() < 0.01 && (depth - 0.5).abs() < 0.01\n    ));\n\n    // Create cylinder\n    let cylinder = scene.create_cylinder(\"cylinder\".to_string(), 0.5, 1.0, None);\n    assert!(matches!(\n        cylinder.borrow().geometry,\n        Geometry::Cylinder { radius, height }\n        if (radius - 0.5).abs() < 0.01 && (height - 1.0).abs() < 0.01\n    ));\n\n    // Create sphere\n    let sphere = scene.create_sphere(\"sphere\".to_string(), 0.3, None);\n    assert!(matches!(\n        sphere.borrow().geometry,\n        Geometry::Sphere { radius }\n        if (radius - 0.3).abs() < 0.01\n    ));\n\n    // Create ellipsoid\n    let ellipsoid = scene.create_ellipsoid(\"ellipsoid\".to_string(), 1.0, 0.5, 0.75, None);\n    assert!(matches!(\n        ellipsoid.borrow().geometry,\n        Geometry::Ellipsoid { rx, ry, rz }\n        if (rx - 1.0).abs() < 0.01 && (ry - 0.5).abs() < 0.01 && (rz - 0.75).abs() < 0.01\n    ));\n\n    // Create polygon\n    let vertices = vec![[0.0, 0.0], [1.0, 0.0], [0.5, 1.0]];\n    let polygon = scene.create_polygon(\"polygon\".to_string(), vertices.clone(), 0.1, None);\n    assert!(matches!(\n        &polygon.borrow().geometry,\n        Geometry::Polygon { vertices: v, thickness }\n        if v.len() == 3 && (*thickness - 0.1).abs() < 0.01\n    ));\n\n    // Create frame\n    let frame_dims = FrameDimensions {\n        outer_width: 2.0,\n        outer_height: 1.5,\n        inner_width: 1.6,\n        inner_height: 1.1,\n        depth: 0.05,\n    };\n    let frame = scene.create_frame(\"frame\".to_string(), frame_dims, None);\n    assert!(matches!(\n        &frame.borrow().geometry,\n        Geometry::Frame(dims) if (dims.outer_width - 2.0).abs() < 0.01\n            && (dims.outer_height - 1.5).abs() < 0.01\n            && (dims.inner_width - 1.6).abs() < 0.01\n            && (dims.inner_height - 1.1).abs() < 0.01\n            && (dims.depth - 0.05).abs() < 0.01\n    ));\n\n    // Create rotation\n    let profile = vec![[0.0, 0.0], [0.5, 0.0], [0.5, 1.0], [0.3, 1.0]];\n    let rotation = scene.create_rotation(\n        \"rotation\".to_string(),\n        profile.clone(),\n        32,\n        std::f32::consts::TAU,\n        None,\n    );\n    assert!(matches!(\n        &rotation.borrow().geometry,\n        Geometry::Rotation { profile: p, segments, angle }\n        if p.len() == 4 && *segments == 32 && (*angle - std::f32::consts::TAU).abs() < 0.01\n    ));\n\n    // Create sweep\n    let sweep_profile = vec![[0.0, 0.0], [0.1, 0.0], [0.1, 0.1], [0.0, 0.1]];\n    let path = vec![[0.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 1.0, 1.0]];\n    let sweep = scene.create_sweep(\n        \"sweep\".to_string(),\n        sweep_profile.clone(),\n        path.clone(),\n        false,\n        None,\n    );\n    assert!(matches!(\n        &sweep.borrow().geometry,\n        Geometry::Sweep { profile: p, path: pa, scale_along_path }\n        if p.len() == 4 && pa.len() == 3 && !*scale_along_path\n    ));\n}\n\n/// Test scene hierarchy and world position calculation\n#[test]\nfn test_scene_hierarchy() {\n    let mut scene = SceneGraph::new();\n\n    // Create a simple desk structure\n    let desk = scene.create_part(\"desk\".to_string(), None);\n    desk.borrow_mut().set_position([0.0, 0.0, 0.0]);\n\n    let top = scene.create_block(\"top\".to_string(), [1.6, 0.025, 0.8], Some(desk.clone()));\n    top.borrow_mut().set_position([0.0, 0.75, 0.0]);\n\n    let leg1 = scene.create_cylinder(\"leg1\".to_string(), 0.025, 0.75, Some(desk.clone()));\n    leg1.borrow_mut().set_position([0.1, 0.0, 0.1]);\n\n    let leg2 = scene.create_cylinder(\"leg2\".to_string(), 0.025, 0.75, Some(desk.clone()));\n    leg2.borrow_mut().set_position([1.5, 0.0, 0.1]);\n\n    // Verify hierarchy\n    assert!(scene.exists(\"desk.top\"));\n    assert!(scene.exists(\"desk.leg1\"));\n    assert!(scene.exists(\"desk.leg2\"));\n\n    // Verify world positions\n    let top_pos = top.borrow().get_world_position();\n    assert!((top_pos[1] - 0.75).abs() < 0.01);\n\n    let leg1_pos = leg1.borrow().get_world_position();\n    assert!((leg1_pos[0] - 0.1).abs() < 0.01);\n    assert!((leg1_pos[2] - 0.1).abs() < 0.01);\n}\n\n/// Test bounding box calculations for primitives\n#[test]\nfn test_bounding_boxes() {\n    let mut scene = SceneGraph::new();\n\n    // Block bounds\n    let block = scene.create_block(\"block\".to_string(), [2.0, 1.0, 0.5], None);\n    let bounds = block.borrow().get_local_bounds();\n    assert!((bounds[1][0] - 2.0).abs() < 0.01);\n    assert!((bounds[1][1] - 1.0).abs() < 0.01);\n    assert!((bounds[1][2] - 0.5).abs() < 0.01);\n\n    // Sphere bounds\n    let sphere = scene.create_sphere(\"sphere\".to_string(), 0.5, None);\n    let bounds = sphere.borrow().get_local_bounds();\n    assert!((bounds[0][0] - (-0.5)).abs() < 0.01);\n    assert!((bounds[1][0] - 0.5).abs() < 0.01);\n\n    // Ellipsoid bounds\n    let ellipsoid = scene.create_ellipsoid(\"ellipsoid\".to_string(), 1.0, 0.5, 0.75, None);\n    let bounds = ellipsoid.borrow().get_local_bounds();\n    assert!((bounds[0][0] - (-1.0)).abs() < 0.01);\n    assert!((bounds[1][0] - 1.0).abs() < 0.01);\n    assert!((bounds[0][1] - (-0.5)).abs() < 0.01);\n    assert!((bounds[1][1] - 0.5).abs() < 0.01);\n}\n\n/// Test scene export to Scene3DS\n#[test]\nfn test_scene_export() {\n    let mut scene = SceneGraph::new();\n\n    // Create a simple scene\n    let root = scene.create_part(\"root\".to_string(), None);\n    let _block = scene.create_block(\"geo\".to_string(), [1.0, 1.0, 1.0], Some(root.clone()));\n\n    // Export to Scene3DS\n    let scene3ds = scene.to_scene();\n\n    // Should have at least one mesh\n    assert!(!scene3ds.meshes.is_empty());\n\n    // The mesh should have vertices and faces\n    let mesh = &scene3ds.meshes[0];\n    assert!(!mesh.vertices.is_empty());\n    assert!(!mesh.faces.is_empty());\n}\n\n/// Test primitive mesh generation\n#[test]\nfn test_primitive_mesh_generation() {\n    let mut scene = SceneGraph::new();\n\n    // Create primitives of each type\n    let root = scene.create_part(\"root\".to_string(), None);\n    let _sphere = scene.create_sphere(\"sphere\".to_string(), 0.5, Some(root.clone()));\n    let _cylinder = scene.create_cylinder(\"cylinder\".to_string(), 0.25, 1.0, Some(root.clone()));\n    let _ellipsoid =\n        scene.create_ellipsoid(\"ellipsoid\".to_string(), 0.3, 0.2, 0.4, Some(root.clone()));\n\n    // Export and verify meshes are generated\n    let scene3ds = scene.to_scene();\n\n    // Should have 3 meshes\n    assert_eq!(scene3ds.meshes.len(), 3);\n\n    // Each mesh should have valid geometry\n    for mesh in &scene3ds.meshes {\n        assert!(!mesh.vertices.is_empty(), \"Mesh should have vertices\");\n        assert!(!mesh.faces.is_empty(), \"Mesh should have faces\");\n    }\n}\n\n/// Test mesh count tracking\n#[test]\nfn test_mesh_count() {\n    let mut scene = SceneGraph::new();\n\n    // Start with empty scene\n    assert_eq!(scene.mesh_count(), 0);\n\n    // Add primitives\n    let _block = scene.create_block(\"block\".to_string(), [1.0, 1.0, 1.0], None);\n    assert_eq!(scene.mesh_count(), 1);\n\n    let _sphere = scene.create_sphere(\"sphere\".to_string(), 0.5, None);\n    assert_eq!(scene.mesh_count(), 2);\n\n    let _cylinder = scene.create_cylinder(\"cylinder\".to_string(), 0.3, 1.0, None);\n    assert_eq!(scene.mesh_count(), 3);\n}\n\n/// Test node removal\n#[test]\nfn test_node_removal() {\n    let mut scene = SceneGraph::new();\n\n    let root = scene.create_part(\"root\".to_string(), None);\n    let child = scene.create_block(\"child\".to_string(), [1.0, 1.0, 1.0], Some(root.clone()));\n\n    assert!(scene.exists(\"root.child\"));\n    assert_eq!(scene.mesh_count(), 1);\n\n    // Remove the child node\n    let child_id = child.borrow().id;\n    scene.remove_node(child_id);\n\n    assert!(!scene.exists(\"root.child\"));\n    assert_eq!(scene.mesh_count(), 0);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","integration","cli_configure_test.rs"],"content":"//! Integration tests for CLI configure command (T017)\r\n\r\nuse std::process::Command;\r\n\r\n/// Helper to run the ofml binary with arguments\r\nfn run_ofml(args: &[&str]) -> (i32, String, String) {\r\n    let output = Command::new(\"cargo\")\r\n        .args([\"run\", \"--quiet\", \"--\"])\r\n        .args(args)\r\n        .output()\r\n        .expect(\"Failed to execute command\");\r\n\r\n    let exit_code = output.status.code().unwrap_or(-1);\r\n    let stdout = String::from_utf8_lossy(&output.stdout).to_string();\r\n    let stderr = String::from_utf8_lossy(&output.stderr).to_string();\r\n\r\n    (exit_code, stdout, stderr)\r\n}\r\n\r\n#[test]\r\nfn test_manufacturers_command_exists() {\r\n    let (code, stdout, _stderr) = run_ofml(&[\"manufacturers\", \"--help\"]);\r\n    assert_eq!(code, 0);\r\n    assert!(stdout.contains(\"List available manufacturers\"));\r\n}\r\n\r\n#[test]\r\nfn test_articles_command_exists() {\r\n    let (code, stdout, _stderr) = run_ofml(&[\"articles\", \"--help\"]);\r\n    assert_eq!(code, 0);\r\n    assert!(stdout.contains(\"List articles\"));\r\n}\r\n\r\n#[test]\r\nfn test_configure_command_exists() {\r\n    let (code, stdout, _stderr) = run_ofml(&[\"configure\", \"--help\"]);\r\n    assert_eq!(code, 0);\r\n    assert!(stdout.contains(\"Configure a product\"));\r\n}\r\n\r\n#[test]\r\nfn test_configure_command_has_json_flag() {\r\n    let (code, stdout, _stderr) = run_ofml(&[\"configure\", \"--help\"]);\r\n    assert_eq!(code, 0);\r\n    assert!(stdout.contains(\"--json\"));\r\n}\r\n\r\n#[test]\r\nfn test_configure_command_has_export_flag() {\r\n    let (code, stdout, _stderr) = run_ofml(&[\"configure\", \"--help\"]);\r\n    assert_eq!(code, 0);\r\n    assert!(stdout.contains(\"--export\"));\r\n}\r\n\r\n#[test]\r\nfn test_configure_command_has_price_date_flag() {\r\n    let (code, stdout, _stderr) = run_ofml(&[\"configure\", \"--help\"]);\r\n    assert_eq!(code, 0);\r\n    assert!(stdout.contains(\"--price-date\"));\r\n}\r\n\r\n#[test]\r\nfn test_configure_command_has_list_properties_flag() {\r\n    let (code, stdout, _stderr) = run_ofml(&[\"configure\", \"--help\"]);\r\n    assert_eq!(code, 0);\r\n    assert!(stdout.contains(\"--list-properties\"));\r\n}\r\n\r\n#[test]\r\nfn test_tui_command_exists() {\r\n    let (code, stdout, _stderr) = run_ofml(&[\"tui\", \"--help\"]);\r\n    assert_eq!(code, 0);\r\n    assert!(stdout.contains(\"Terminal UI\"));\r\n}\r\n\r\n#[test]\r\nfn test_version_flag() {\r\n    let (code, stdout, _stderr) = run_ofml(&[\"--version\"]);\r\n    assert_eq!(code, 0);\r\n    assert!(stdout.contains(\"ofml\"));\r\n}\r\n\r\n#[test]\r\nfn test_help_flag() {\r\n    let (code, stdout, _stderr) = run_ofml(&[\"--help\"]);\r\n    assert_eq!(code, 0);\r\n    assert!(stdout.contains(\"manufacturers\"));\r\n    assert!(stdout.contains(\"articles\"));\r\n    assert!(stdout.contains(\"configure\"));\r\n    assert!(stdout.contains(\"tui\"));\r\n}\r\n\r\n#[test]\r\nfn test_verbose_flag_exists() {\r\n    let (code, stdout, _stderr) = run_ofml(&[\"--help\"]);\r\n    assert_eq!(code, 0);\r\n    assert!(stdout.contains(\"-v\") || stdout.contains(\"--verbose\"));\r\n}\r\n\r\n// Tests that require actual OFML data\r\n#[cfg(feature = \"integration_with_data\")]\r\nmod with_ofml_data {\r\n    use super::*;\r\n\r\n    const DATA_PATH: &str = \"/workspace/ofmldata\";\r\n\r\n    #[test]\r\n    fn test_manufacturers_lists_vitra() {\r\n        let (code, stdout, _stderr) = run_ofml(&[\"manufacturers\", DATA_PATH]);\r\n        assert_eq!(code, 0);\r\n        assert!(stdout.contains(\"vitra\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_manufacturers_json_output() {\r\n        let (code, stdout, _stderr) = run_ofml(&[\"manufacturers\", DATA_PATH, \"--json\"]);\r\n        assert_eq!(code, 0);\r\n        assert!(stdout.contains(\"\\\"manufacturers\\\"\"));\r\n        assert!(stdout.starts_with(\"{\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_articles_for_vitra() {\r\n        let (code, stdout, _stderr) = run_ofml(&[\"articles\", DATA_PATH, \"vitra\"]);\r\n        assert_eq!(code, 0);\r\n        assert!(stdout.contains(\"Artikel\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_articles_invalid_manufacturer() {\r\n        let (code, _stdout, stderr) = run_ofml(&[\"articles\", DATA_PATH, \"nonexistent\"]);\r\n        assert_ne!(code, 0);\r\n        assert!(stderr.contains(\"nicht gefunden\") || stderr.contains(\"not found\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_configure_list_properties() {\r\n        let (code, stdout, _stderr) = run_ofml(&[\r\n            \"configure\",\r\n            DATA_PATH,\r\n            \"vitra\",\r\n            \"OiBlock\",\r\n            \"--list-properties\",\r\n        ]);\r\n        assert_eq!(code, 0);\r\n        assert!(stdout.contains(\"Properties\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_configure_json_output() {\r\n        let (code, stdout, _stderr) = run_ofml(&[\r\n            \"configure\",\r\n            DATA_PATH,\r\n            \"vitra\",\r\n            \"OiBlock\",\r\n            \"--json\",\r\n        ]);\r\n        assert_eq!(code, 0);\r\n        assert!(stdout.contains(\"\\\"manufacturer_id\\\"\"));\r\n        assert!(stdout.contains(\"\\\"article_id\\\"\"));\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","material_tests.rs"],"content":"//! Integration tests for material system.\n//!\n//! These tests verify material loading and resolution.\n\nuse ofml_lib::material::{\n    MatParser, MaterialDef, MaterialResolver, TextureDef, TextureProjection,\n};\n\n/// Test parsing standard MAT file format\n#[test]\nfn test_mat_file_parsing() {\n    let mat_content = r#\"\n        amb 0.1 0.1 0.1 1.0\n        dif 0.8 0.6 0.4 1.0\n        spe 0.5 0.5 0.5 1.0\n        shi 32\n        tra 0.0\n    \"#;\n\n    let result = MatParser::parse(mat_content, \"test_material\");\n    assert!(result.is_ok(), \"MAT content should parse\");\n\n    let material = result.unwrap();\n\n    // Check diffuse - primary color component\n    assert!((material.diffuse[0] - 0.8).abs() < 0.01);\n    assert!((material.diffuse[1] - 0.6).abs() < 0.01);\n    assert!((material.diffuse[2] - 0.4).abs() < 0.01);\n}\n\n/// Test inline material definition parsing ($ syntax)\n#[test]\nfn test_inline_material_parsing() {\n    let inline = \"$ amb 0.2 0.2 0.2 1.0; dif 0.7 0.5 0.3 1.0\";\n\n    let result = MatParser::parse_inline(inline, \"inline_test\");\n    assert!(result.is_ok(), \"Inline material should parse: {:?}\", result);\n\n    let material = result.unwrap();\n    assert!((material.diffuse[0] - 0.7).abs() < 0.01);\n}\n\n/// Test texture projection modes\n#[test]\nfn test_texture_projection_modes() {\n    // All projection modes should be constructible\n    let modes = [\n        TextureProjection::ProjectX,\n        TextureProjection::ProjectY,\n        TextureProjection::ProjectZ,\n        TextureProjection::Cylindrical,\n        TextureProjection::Spherical,\n        TextureProjection::Conical,\n        TextureProjection::Circle,\n    ];\n\n    for mode in modes {\n        // Just verify they can be created\n        let _ = format!(\"{:?}\", mode);\n    }\n}\n\n/// Test texture definition\n#[test]\nfn test_texture_definition() {\n    let texture = TextureDef::new(\"wood.png\")\n        .with_projection(TextureProjection::ProjectY)\n        .with_scale(2.0, 2.0)\n        .with_offset(0.5, 0.5)\n        .with_rotation(45.0);\n\n    assert_eq!(texture.filename, \"wood.png\");\n    assert!(matches!(texture.projection, TextureProjection::ProjectY));\n    assert!((texture.u_scale - 2.0).abs() < 0.01);\n    assert!((texture.u_offset - 0.5).abs() < 0.01);\n    assert!((texture.rotation - 45.0).abs() < 0.01);\n}\n\n/// Test material resolver caching\n#[test]\nfn test_material_resolver_caching() {\n    let mut resolver = MaterialResolver::new();\n\n    // Create and register a material\n    let material = MaterialDef::new(\"grey\").with_diffuse(0.7, 0.7, 0.7, 1.0);\n\n    resolver.register(material);\n\n    // Resolve the material\n    let resolved = resolver.resolve(\"grey\");\n    assert!((resolved.diffuse[0] - 0.7).abs() < 0.01);\n\n    // Check material exists\n    assert!(resolver.contains(\"grey\"));\n}\n\n/// Test fallback material for unknowns\n#[test]\nfn test_fallback_material() {\n    let resolver = MaterialResolver::new();\n\n    // Resolve unknown material - should return fallback\n    let resolved = resolver.resolve(\"unknown_material\");\n\n    // Fallback is magenta (0.8, 0.0, 0.8) for visibility\n    assert!((resolved.diffuse[0] - 0.8).abs() < 0.01);\n    assert!((resolved.diffuse[1] - 0.0).abs() < 0.01);\n    assert!((resolved.diffuse[2] - 0.8).abs() < 0.01);\n}\n\n/// Test resolve_or_create for color-based materials\n#[test]\nfn test_resolve_or_create() {\n    let resolver = MaterialResolver::new();\n\n    // Resolve with color name should create material\n    let material = resolver.resolve_or_create(\"::test::material::grey\");\n\n    // Should have grey-ish diffuse color\n    let avg = (material.diffuse[0] + material.diffuse[1] + material.diffuse[2]) / 3.0;\n    assert!(\n        avg > 0.3 && avg < 0.7,\n        \"Grey material should have mid-range color\"\n    );\n}\n\n/// Test MaterialDef builder pattern\n#[test]\nfn test_material_def_builder() {\n    let material = MaterialDef::new(\"test_material\")\n        .with_ambient(0.1, 0.1, 0.1, 1.0)\n        .with_diffuse(0.8, 0.6, 0.4, 1.0)\n        .with_specular(0.5, 0.5, 0.5, 1.0)\n        .with_shininess(32.0);\n\n    assert_eq!(material.name, \"test_material\");\n    assert!((material.diffuse[0] - 0.8).abs() < 0.01);\n    assert!((material.shininess - 32.0).abs() < 0.01);\n}\n\n/// Test material from color name\n#[test]\nfn test_material_from_color_name() {\n    // Common color names should produce appropriate materials\n    let color_tests = [(\"grey\", 0.5), (\"white\", 0.9), (\"black\", 0.1)];\n\n    for (name, expected_brightness) in color_tests {\n        let material = MaterialDef::from_color_name(name);\n        let avg = (material.diffuse[0] + material.diffuse[1] + material.diffuse[2]) / 3.0;\n        assert!(\n            (avg - expected_brightness).abs() < 0.3,\n            \"Color '{}' brightness mismatch: got {}, expected ~{}\",\n            name,\n            avg,\n            expected_brightness\n        );\n    }\n}\n\n/// Test material names collection\n#[test]\nfn test_material_names() {\n    let mut resolver = MaterialResolver::new();\n\n    resolver.register(MaterialDef::new(\"material_a\"));\n    resolver.register(MaterialDef::new(\"material_b\"));\n    resolver.register(MaterialDef::new(\"material_c\"));\n\n    let names = resolver.names();\n    assert_eq!(names.len(), 3);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","multi_manufacturer_price_test.rs"],"content":"//! Multi-manufacturer price matching tests\n//!\n//! This test verifies that the price matching logic works correctly\n//! across different manufacturers with varying data formats.\n\nuse ofml_lib::oap::engine::ConfigurationEngine;\nuse ofml_lib::oap::families::{FamilyConfiguration, FamilyLoader};\nuse std::path::Path;\n\nconst OFMLDATA_BASE: &str = \"/reference/ofmldata\";\n\nfn ofmldata_exists() -> bool {\n    Path::new(OFMLDATA_BASE).exists()\n}\n\n/// Test price calculation for a single manufacturer\nfn test_manufacturer_pricing(mfr_id: &str) -> (bool, String) {\n    let mfr_path = Path::new(OFMLDATA_BASE).join(mfr_id);\n    if !mfr_path.exists() {\n        return (true, format!(\"{}: skipped (not found)\", mfr_id));\n    }\n\n    let loader = FamilyLoader::load(&mfr_path, \"DE\");\n    let families = loader.get_families();\n\n    if families.is_empty() {\n        return (true, format!(\"{}: skipped (no families)\", mfr_id));\n    }\n\n    let engine = ConfigurationEngine::new(OFMLDATA_BASE);\n    let price_date = chrono::Local::now().date_naive();\n\n    let mut families_with_price = 0;\n    let mut families_with_surcharges = 0;\n    let mut total_families_tested = 0;\n\n    // Test first 3 families with properties (reduced for faster tests)\n    for family in families.iter().take(3) {\n        let properties = loader.get_properties_for_family(family);\n        if properties.is_empty() {\n            continue;\n        }\n\n        total_families_tested += 1;\n        let config = FamilyConfiguration::new(&family.id, &properties);\n\n        if let Some(price) = engine.calculate_family_price(mfr_id, family, &config, price_date) {\n            families_with_price += 1;\n            if !price.surcharges.is_empty() {\n                families_with_surcharges += 1;\n            }\n        }\n    }\n\n    let result = format!(\n        \"{}: {} families, {}/{} with price, {} with surcharges\",\n        mfr_id,\n        families.len(),\n        families_with_price,\n        total_families_tested,\n        families_with_surcharges\n    );\n\n    // Consider it a success if we found at least one family with pricing\n    (\n        families_with_price > 0 || total_families_tested == 0,\n        result,\n    )\n}\n\n/// Quick smoke test with a smaller set of manufacturers\n#[test]\nfn test_price_matching_all_manufacturers() {\n    if !ofmldata_exists() {\n        eprintln!(\"Skipping: ofmldata not found\");\n        return;\n    }\n\n    // Test only core manufacturers for quick validation\n    let manufacturers = [\n        \"sex\",   // Sedus - known to have S_XXX style surcharges\n        \"vitra\", // Vitra - major manufacturer\n        \"kn\",    // Knoll\n    ];\n\n    println!(\"\\n=== Multi-Manufacturer Price Matching Test ===\\n\");\n\n    let mut successes = 0;\n\n    for mfr in &manufacturers {\n        let (success, msg) = test_manufacturer_pricing(mfr);\n        println!(\"{}\", msg);\n        if success {\n            successes += 1;\n        }\n    }\n\n    println!(\"\\n=== Summary: {}/{} succeeded ===\", successes, manufacturers.len());\n\n    // At least 2 should work\n    assert!(\n        successes >= 2,\n        \"Too many manufacturers failed price matching\"\n    );\n}\n\n/// Extended test with all manufacturers - marked as ignored for CI\n#[test]\n#[ignore = \"Long running test - run with: cargo test -- --ignored\"]\nfn test_price_matching_extended() {\n    if !ofmldata_exists() {\n        eprintln!(\"Skipping: ofmldata not found\");\n        return;\n    }\n\n    let manufacturers = [\n        \"sex\", \"vitra\", \"kn\", \"sbu\", \"haw\", \"aix\", \"arper\", \"cassina\", \"cor\", \"framery\",\n    ];\n\n    println!(\"\\n=== Extended Multi-Manufacturer Price Matching Test ===\\n\");\n\n    let mut successes = 0;\n    let mut failures = 0;\n\n    for mfr in &manufacturers {\n        let (success, msg) = test_manufacturer_pricing(mfr);\n        println!(\"{}\", msg);\n        if success {\n            successes += 1;\n        } else {\n            failures += 1;\n        }\n    }\n\n    println!(\"\\n=== Summary ===\");\n    println!(\"Successes: {}/{}\", successes, manufacturers.len());\n    println!(\"Failures: {}\", failures);\n\n    assert!(\n        successes >= manufacturers.len() / 2,\n        \"Too many manufacturers failed price matching\"\n    );\n}\n\n#[test]\nfn test_price_changes_on_property_change() {\n    if !ofmldata_exists() {\n        eprintln!(\"Skipping: ofmldata not found\");\n        return;\n    }\n\n    println!(\"\\n=== Price Change Detection Test ===\\n\");\n\n    let manufacturers = [\"sex\", \"vitra\", \"kn\", \"sbu\"];\n    let mut found_price_change = false;\n\n    for mfr_id in &manufacturers {\n        let mfr_path = Path::new(OFMLDATA_BASE).join(mfr_id);\n        if !mfr_path.exists() {\n            continue;\n        }\n\n        let loader = FamilyLoader::load(&mfr_path, \"DE\");\n        let engine = ConfigurationEngine::new(OFMLDATA_BASE);\n        let price_date = chrono::Local::now().date_naive();\n\n        // Find a family with multiple property options\n        for family in loader.get_families().iter().take(5) {\n            let properties = loader.get_properties_for_family(family);\n\n            // Find a property with at least 3 options\n            let multi_option_prop = properties.iter().find(|p| p.options.len() >= 3);\n            if multi_option_prop.is_none() {\n                continue;\n            }\n            let prop = multi_option_prop.unwrap();\n\n            // Calculate price with first option\n            let mut config1 = FamilyConfiguration::new(&family.id, &properties);\n            config1.set(&prop.key, &prop.options[0].value);\n            let price1 = engine.calculate_family_price(mfr_id, family, &config1, price_date);\n\n            // Calculate price with last option\n            let mut config2 = FamilyConfiguration::new(&family.id, &properties);\n            config2.set(&prop.key, &prop.options.last().unwrap().value);\n            let price2 = engine.calculate_family_price(mfr_id, family, &config2, price_date);\n\n            if let (Some(p1), Some(p2)) = (&price1, &price2) {\n                if p1.total_price != p2.total_price || p1.surcharges.len() != p2.surcharges.len() {\n                    println!(\"{} / {} / {}:\", mfr_id, family.name, prop.key);\n                    println!(\n                        \"  Option '{}' -> {:.2} {} ({} surcharges)\",\n                        prop.options[0].value,\n                        p1.total_price,\n                        p1.currency,\n                        p1.surcharges.len()\n                    );\n                    println!(\n                        \"  Option '{}' -> {:.2} {} ({} surcharges)\",\n                        prop.options.last().unwrap().value,\n                        p2.total_price,\n                        p2.currency,\n                        p2.surcharges.len()\n                    );\n                    found_price_change = true;\n                }\n            }\n        }\n    }\n\n    if !found_price_change {\n        println!(\"Note: No price changes detected when changing properties.\");\n        println!(\"This may be expected if surcharge codes don't match available property values.\");\n    }\n}\n\n#[test]\nfn test_sedus_surcharge_matching_detailed() {\n    if !ofmldata_exists() {\n        eprintln!(\"Skipping: ofmldata not found\");\n        return;\n    }\n\n    let path = Path::new(\"/reference/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        eprintln!(\"Skipping: Sedus AI not found\");\n        return;\n    }\n\n    println!(\"\\n=== Sedus AI Surcharge Matching Detail ===\\n\");\n\n    let mfr_path = Path::new(\"/reference/ofmldata/sex\");\n    let loader = FamilyLoader::load(mfr_path, \"DE\");\n    let engine = ConfigurationEngine::new(OFMLDATA_BASE);\n    let price_date = chrono::Local::now().date_naive();\n\n    // Find AI family\n    let ai_family = loader\n        .get_families()\n        .iter()\n        .find(|f| f.base_article_nr.contains(\"AI\"));\n\n    if let Some(family) = ai_family {\n        let properties = loader.get_properties_for_family(family);\n\n        println!(\"Family: {} ({})\", family.name, family.base_article_nr);\n        println!(\"Properties with options: {}\", properties.len());\n\n        // Test default configuration\n        let config = FamilyConfiguration::new(&family.id, &properties);\n        let price = engine.calculate_family_price(\"sex\", family, &config, price_date);\n\n        if let Some(p) = &price {\n            println!(\"\\nDefault configuration:\");\n            println!(\"  Base price: {:.2} {}\", p.base_price, p.currency);\n            println!(\"  Surcharges: {}\", p.surcharges.len());\n            for s in &p.surcharges {\n                println!(\"    {} = {:.2}\", s.name, s.amount);\n            }\n            println!(\"  Total: {:.2} {}\", p.total_price, p.currency);\n        }\n\n        // Test with different fabric options - prefer GABRIEL which has embedded codes\n        let fabric_prop = properties\n            .iter()\n            .find(|p| p.key == \"S_STOFF_FRONT_GABRIEL\")\n            .or_else(|| properties.iter().find(|p| p.key.contains(\"GABRIEL\")))\n            .or_else(|| properties.iter().find(|p| p.key.contains(\"STOFF\")));\n\n        if let Some(prop) = fabric_prop {\n            println!(\"\\nTesting {} variations:\", prop.key);\n\n            for (i, opt) in prop.options.iter().take(5).enumerate() {\n                let mut test_config = FamilyConfiguration::new(&family.id, &properties);\n                test_config.set(&prop.key, &opt.value);\n\n                if let Some(p) =\n                    engine.calculate_family_price(\"sex\", family, &test_config, price_date)\n                {\n                    let surcharge_names: Vec<_> =\n                        p.surcharges.iter().map(|s| s.name.as_str()).collect();\n                    println!(\n                        \"  [{}] {} -> {:.2} {} (surcharges: {:?})\",\n                        i, opt.value, p.total_price, p.currency, surcharge_names\n                    );\n                }\n            }\n\n            // Verify that values with embedded codes trigger surcharges\n            let codes_with_166 = prop\n                .options\n                .iter()\n                .filter(|o| o.value.contains(\"166\"))\n                .count();\n            let codes_with_168 = prop\n                .options\n                .iter()\n                .filter(|o| o.value.contains(\"168\"))\n                .count();\n            println!(\"\\n  Values containing '166': {}\", codes_with_166);\n            println!(\"  Values containing '168': {}\", codes_with_168);\n\n            // Test a specific value with embedded code if available\n            if let Some(opt_166) = prop.options.iter().find(|o| o.value.contains(\"166\")) {\n                let mut test_config = FamilyConfiguration::new(&family.id, &properties);\n                test_config.set(&prop.key, &opt_166.value);\n\n                if let Some(p) =\n                    engine.calculate_family_price(\"sex\", family, &test_config, price_date)\n                {\n                    println!(\"\\n  Testing embedded code '166' in {}:\", opt_166.value);\n                    println!(\n                        \"    Total: {:.2} {} (surcharges: {})\",\n                        p.total_price,\n                        p.currency,\n                        p.surcharges.len()\n                    );\n                    assert!(\n                        !p.surcharges.is_empty() || p.total_price > p.base_price,\n                        \"Expected surcharge S_166 to match value containing '166'\"\n                    );\n                }\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","multi_manufacturer_tests.rs"],"content":"//! Multi-manufacturer integration tests for the OFML interpreter.\n//!\n//! These tests verify that the interpreter can parse and process OFML data\n//! from multiple furniture manufacturers, ensuring the implementation is\n//! truly generic and not tied to any specific product.\n\nuse ofml_lib::ebase::EBaseReader;\nuse ofml_lib::ofml::{extract_3ds_from_alb, extract_cls_from_alb, AlbArchive};\nuse std::path::PathBuf;\n\n/// Get the path to a test fixture file\nfn fixture_path(manufacturer: &str, product: &str, filename: &str) -> PathBuf {\n    PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"))\n        .join(\"tests/fixtures\")\n        .join(manufacturer)\n        .join(product)\n        .join(filename)\n}\n\n/// Check if a fixture exists\n#[allow(dead_code)]\nfn fixture_exists(manufacturer: &str, product: &str, filename: &str) -> bool {\n    fixture_path(manufacturer, product, filename).exists()\n}\n\n// ============================================================================\n// ALB Archive Tests - Multiple Manufacturers\n// ============================================================================\n\n#[test]\nfn test_vitra_alb_archive() {\n    let alb_path = fixture_path(\"vitra\", \"workit\", \"vitra_workit_1.alb\");\n    if !alb_path.exists() {\n        eprintln!(\"Skipping test: fixture not found at {:?}\", alb_path);\n        return;\n    }\n\n    let archive = AlbArchive::open(&alb_path).expect(\"Should open Vitra ALB\");\n\n    let files = archive.list_files();\n    assert!(!files.is_empty(), \"Vitra ALB should contain files\");\n\n    let cls_files = archive.get_cls_files();\n    assert!(!cls_files.is_empty(), \"Vitra ALB should contain CLS files\");\n\n    let ds_files = archive.get_3ds_files();\n    assert!(!ds_files.is_empty(), \"Vitra ALB should contain 3DS files\");\n}\n\n#[test]\nfn test_kn_alb_archive() {\n    let alb_path = fixture_path(\"kn\", \"conline\", \"kn_conline_2.alb\");\n    if !alb_path.exists() {\n        eprintln!(\"Skipping test: fixture not found at {:?}\", alb_path);\n        return;\n    }\n\n    let archive = AlbArchive::open(&alb_path).expect(\"Should open KN ALB\");\n\n    let files = archive.list_files();\n    assert!(!files.is_empty(), \"KN ALB should contain files\");\n\n    // KN products should have CLS files\n    let cls_files = archive.get_cls_files();\n    println!(\"KN Conline CLS files: {:?}\", cls_files.len());\n}\n\n#[test]\nfn test_cassina_alb_archive() {\n    let alb_path = fixture_path(\"cassina\", \"abc\", \"cassina_abc_1.alb\");\n    if !alb_path.exists() {\n        eprintln!(\"Skipping test: fixture not found at {:?}\", alb_path);\n        return;\n    }\n\n    let archive = AlbArchive::open(&alb_path).expect(\"Should open Cassina ALB\");\n\n    let files = archive.list_files();\n    assert!(!files.is_empty(), \"Cassina ALB should contain files\");\n\n    println!(\"Cassina ABC total files: {}\", files.len());\n}\n\n#[test]\nfn test_bordbar_alb_archive() {\n    let alb_path = fixture_path(\"bordbar\", \"basic\", \"bordbar_basic_1.alb\");\n    if !alb_path.exists() {\n        eprintln!(\"Skipping test: fixture not found at {:?}\", alb_path);\n        return;\n    }\n\n    let archive = AlbArchive::open(&alb_path).expect(\"Should open Bordbar ALB\");\n\n    let files = archive.list_files();\n    assert!(!files.is_empty(), \"Bordbar ALB should contain files\");\n\n    println!(\"Bordbar Basic total files: {}\", files.len());\n}\n\n// ============================================================================\n// CLS Extraction Tests - Multiple Manufacturers\n// ============================================================================\n\n#[test]\nfn test_vitra_cls_extraction() {\n    let alb_path = fixture_path(\"vitra\", \"workit\", \"vitra_workit_1.alb\");\n    if !alb_path.exists() {\n        return;\n    }\n\n    let mut archive = AlbArchive::open(&alb_path).expect(\"Should open ALB\");\n\n    let cls_files = archive.get_cls_files();\n    if !cls_files.is_empty() {\n        let content = archive\n            .extract_cls(&cls_files[0])\n            .expect(\"Should extract CLS\");\n        assert!(!content.is_empty(), \"CLS content should not be empty\");\n        // CLS files should contain valid OFML syntax\n        assert!(\n            content.contains(\"class\") || content.contains(\"//\") || content.contains(\"package\"),\n            \"CLS should contain OFML constructs\"\n        );\n    }\n}\n\n#[test]\nfn test_kn_cls_extraction() {\n    let alb_path = fixture_path(\"kn\", \"conline\", \"kn_conline_2.alb\");\n    if !alb_path.exists() {\n        return;\n    }\n\n    let mut archive = AlbArchive::open(&alb_path).expect(\"Should open ALB\");\n\n    let cls_files = archive.get_cls_files();\n    for cls_name in cls_files.iter().take(3) {\n        let content = archive.extract_cls(cls_name).expect(\"Should extract CLS\");\n        assert!(!content.is_empty(), \"CLS {} should have content\", cls_name);\n    }\n}\n\n#[test]\nfn test_cassina_cls_extraction() {\n    let alb_path = fixture_path(\"cassina\", \"abc\", \"cassina_abc_1.alb\");\n    if !alb_path.exists() {\n        return;\n    }\n\n    let mut archive = AlbArchive::open(&alb_path).expect(\"Should open ALB\");\n\n    let cls_files = archive.get_cls_files();\n    for cls_name in cls_files.iter().take(3) {\n        let content = archive.extract_cls(cls_name).expect(\"Should extract CLS\");\n        assert!(!content.is_empty(), \"CLS {} should have content\", cls_name);\n    }\n}\n\n// ============================================================================\n// 3DS Geometry Extraction Tests\n// ============================================================================\n\n#[test]\nfn test_vitra_3ds_extraction() {\n    let alb_path = fixture_path(\"vitra\", \"workit\", \"vitra_workit_1.alb\");\n    if !alb_path.exists() {\n        return;\n    }\n\n    let mut archive = AlbArchive::open(&alb_path).expect(\"Should open ALB\");\n\n    let files = archive.get_3ds_files();\n    if !files.is_empty() {\n        let scene = archive.extract_3ds(&files[0]).expect(\"Should extract 3DS\");\n        assert!(!scene.meshes.is_empty(), \"3DS should have meshes\");\n\n        // Verify mesh structure\n        for mesh in &scene.meshes {\n            assert!(\n                !mesh.vertices.is_empty(),\n                \"Mesh {} should have vertices\",\n                mesh.name\n            );\n            assert!(\n                !mesh.faces.is_empty(),\n                \"Mesh {} should have faces\",\n                mesh.name\n            );\n        }\n    }\n}\n\n#[test]\nfn test_kn_3ds_extraction() {\n    let alb_path = fixture_path(\"kn\", \"conline\", \"kn_conline_2.alb\");\n    if !alb_path.exists() {\n        return;\n    }\n\n    let mut archive = AlbArchive::open(&alb_path).expect(\"Should open ALB\");\n\n    let files = archive.get_3ds_files();\n    for file_name in files.iter().take(5) {\n        if let Ok(scene) = archive.extract_3ds(file_name) {\n            assert!(\n                !scene.meshes.is_empty(),\n                \"KN 3DS {} should have meshes\",\n                file_name\n            );\n        }\n    }\n}\n\n// ============================================================================\n// EBASE Database Tests - Multiple Manufacturers\n// ============================================================================\n\n#[test]\nfn test_vitra_odb_ebase() {\n    let ebase_path = fixture_path(\"vitra\", \"workit\", \"odb.ebase\");\n    if !ebase_path.exists() {\n        return;\n    }\n\n    let reader = EBaseReader::open(&ebase_path).expect(\"Should open Vitra ODB\");\n    let tables = reader.table_names();\n    assert!(!tables.is_empty(), \"Vitra ODB should have tables\");\n\n    println!(\"Vitra ODB tables: {:?}\", tables);\n}\n\n#[test]\nfn test_kn_odb_ebase() {\n    let ebase_path = fixture_path(\"kn\", \"conline\", \"odb.ebase\");\n    if !ebase_path.exists() {\n        return;\n    }\n\n    let reader = EBaseReader::open(&ebase_path).expect(\"Should open KN ODB\");\n    let tables = reader.table_names();\n    assert!(!tables.is_empty(), \"KN ODB should have tables\");\n\n    println!(\"KN ODB tables: {:?}\", tables);\n}\n\n#[test]\nfn test_kn_product_ebase() {\n    let ebase_path = fixture_path(\"kn\", \"conline\", \"conline.ebase\");\n    if !ebase_path.exists() {\n        return;\n    }\n\n    let reader = EBaseReader::open(&ebase_path).expect(\"Should open KN Conline EBASE\");\n    let tables = reader.table_names();\n    assert!(!tables.is_empty(), \"KN Conline EBASE should have tables\");\n\n    println!(\"KN Conline product tables: {:?}\", tables);\n}\n\n#[test]\nfn test_cassina_odb_ebase() {\n    let ebase_path = fixture_path(\"cassina\", \"abc\", \"odb.ebase\");\n    if !ebase_path.exists() {\n        return;\n    }\n\n    let reader = EBaseReader::open(&ebase_path).expect(\"Should open Cassina ODB\");\n    let tables = reader.table_names();\n    assert!(!tables.is_empty(), \"Cassina ODB should have tables\");\n\n    println!(\"Cassina ODB tables: {:?}\", tables);\n}\n\n// ============================================================================\n// Full CLS Parsing Tests\n// ============================================================================\n\n#[test]\nfn test_vitra_full_cls_parsing() {\n    let alb_path = fixture_path(\"vitra\", \"workit\", \"vitra_workit_1.alb\");\n    if !alb_path.exists() {\n        return;\n    }\n\n    let cls_files = extract_cls_from_alb(&alb_path).expect(\"Should extract CLS files\");\n    assert!(!cls_files.is_empty(), \"Should have CLS files\");\n\n    // Try to parse each CLS file\n    let mut parsed_count = 0;\n    for (name, content) in &cls_files {\n        match ofml_lib::parser::Parser::new(content) {\n            Ok(mut parser) => match parser.parse() {\n                Ok(_) => parsed_count += 1,\n                Err(e) => {\n                    eprintln!(\"Parse error in {}: {}\", name, e);\n                }\n            },\n            Err(e) => {\n                eprintln!(\"Lexer error in {}: {}\", name, e);\n            }\n        }\n    }\n\n    println!(\n        \"Vitra Workit: Parsed {}/{} CLS files\",\n        parsed_count,\n        cls_files.len()\n    );\n    // We expect at least some files to parse successfully\n    assert!(parsed_count > 0, \"Should parse at least some CLS files\");\n}\n\n#[test]\nfn test_kn_full_cls_parsing() {\n    let alb_path = fixture_path(\"kn\", \"conline\", \"kn_conline_2.alb\");\n    if !alb_path.exists() {\n        return;\n    }\n\n    let cls_files = extract_cls_from_alb(&alb_path).expect(\"Should extract CLS files\");\n\n    let mut parsed_count = 0;\n\n    for (_name, content) in &cls_files {\n        if let Ok(mut parser) = ofml_lib::parser::Parser::new(content) {\n            if parser.parse().is_ok() {\n                parsed_count += 1;\n            }\n        }\n    }\n\n    println!(\n        \"KN Conline: Parsed {}/{} CLS files\",\n        parsed_count,\n        cls_files.len()\n    );\n}\n\n#[test]\nfn test_cassina_full_cls_parsing() {\n    let alb_path = fixture_path(\"cassina\", \"abc\", \"cassina_abc_1.alb\");\n    if !alb_path.exists() {\n        return;\n    }\n\n    let cls_files = extract_cls_from_alb(&alb_path).expect(\"Should extract CLS files\");\n\n    let mut parsed_count = 0;\n\n    for (_name, content) in &cls_files {\n        if let Ok(mut parser) = ofml_lib::parser::Parser::new(content) {\n            if parser.parse().is_ok() {\n                parsed_count += 1;\n            }\n        }\n    }\n\n    println!(\n        \"Cassina ABC: Parsed {}/{} CLS files\",\n        parsed_count,\n        cls_files.len()\n    );\n}\n\n// ============================================================================\n// Full 3DS Extraction Tests\n// ============================================================================\n\n#[test]\nfn test_vitra_full_3ds_extraction() {\n    let alb_path = fixture_path(\"vitra\", \"workit\", \"vitra_workit_1.alb\");\n    if !alb_path.exists() {\n        return;\n    }\n\n    let scenes = extract_3ds_from_alb(&alb_path).expect(\"Should extract 3DS files\");\n    assert!(!scenes.is_empty(), \"Should have 3DS scenes\");\n\n    let mut total_meshes = 0;\n    let mut total_vertices = 0;\n\n    for (_name, scene) in &scenes {\n        for mesh in &scene.meshes {\n            total_meshes += 1;\n            total_vertices += mesh.vertices.len();\n        }\n    }\n\n    println!(\n        \"Vitra Workit: {} scenes, {} meshes, {} vertices\",\n        scenes.len(),\n        total_meshes,\n        total_vertices\n    );\n\n    assert!(total_meshes > 0, \"Should have meshes\");\n}\n\n#[test]\nfn test_kn_full_3ds_extraction() {\n    let alb_path = fixture_path(\"kn\", \"conline\", \"kn_conline_2.alb\");\n    if !alb_path.exists() {\n        return;\n    }\n\n    let scenes = extract_3ds_from_alb(&alb_path).expect(\"Should extract 3DS files\");\n\n    let mut total_meshes = 0;\n\n    for (_name, scene) in &scenes {\n        total_meshes += scene.meshes.len();\n    }\n\n    println!(\n        \"KN Conline: {} scenes, {} meshes\",\n        scenes.len(),\n        total_meshes\n    );\n}\n\n// ============================================================================\n// Cross-Manufacturer Compatibility Tests\n// ============================================================================\n\n/// Test that all manufacturers' ALB files can be opened with the same API\n#[test]\nfn test_all_manufacturers_alb_compatible() {\n    let manufacturers = [\n        (\"vitra\", \"workit\", \"vitra_workit_1.alb\"),\n        (\"kn\", \"conline\", \"kn_conline_2.alb\"),\n        (\"cassina\", \"abc\", \"cassina_abc_1.alb\"),\n        (\"bordbar\", \"basic\", \"bordbar_basic_1.alb\"),\n    ];\n\n    let mut success_count = 0;\n\n    for (mfr, product, filename) in &manufacturers {\n        let path = fixture_path(mfr, product, filename);\n        if !path.exists() {\n            continue;\n        }\n\n        match AlbArchive::open(&path) {\n            Ok(archive) => {\n                let files = archive.list_files();\n                println!(\"{}/{}: {} files\", mfr, product, files.len());\n                success_count += 1;\n            }\n            Err(e) => {\n                eprintln!(\"Failed to open {}/{}: {}\", mfr, product, e);\n            }\n        }\n    }\n\n    assert!(\n        success_count >= 3,\n        \"Should open at least 3 manufacturer ALBs\"\n    );\n}\n\n/// Test that EBASE files from different manufacturers use compatible formats\n#[test]\nfn test_all_manufacturers_ebase_compatible() {\n    let ebase_files = [\n        (\"vitra\", \"workit\", \"odb.ebase\"),\n        (\"kn\", \"conline\", \"odb.ebase\"),\n        (\"cassina\", \"abc\", \"odb.ebase\"),\n    ];\n\n    let mut success_count = 0;\n\n    for (mfr, product, filename) in &ebase_files {\n        let path = fixture_path(mfr, product, filename);\n        if !path.exists() {\n            continue;\n        }\n\n        match EBaseReader::open(&path) {\n            Ok(reader) => {\n                let tables = reader.table_names();\n                println!(\"{}/{} {}: {} tables\", mfr, product, filename, tables.len());\n                success_count += 1;\n            }\n            Err(e) => {\n                eprintln!(\"Failed to open {}/{} {}: {}\", mfr, product, filename, e);\n            }\n        }\n    }\n\n    assert!(\n        success_count >= 2,\n        \"Should open at least 2 manufacturer EBASE files\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","ofmldata_integration_tests.rs"],"content":"//! Integration tests using actual OFML data from /workspace/ofmldata.\n//!\n//! These tests verify the interpreter works with real-world data from multiple manufacturers.\n//! Tests are designed to skip gracefully if data is not available.\n\nuse ofml_lib::ebase::EBaseReader;\nuse ofml_lib::ofml::AlbArchive;\nuse ofml_lib::operations::{self, ProductConfig};\nuse std::path::{Path, PathBuf};\n\n/// Base path to OFML data directory\nconst OFMLDATA_BASE: &str = \"/reference/ofmldata\";\n\n/// Get path to a manufacturer's product directory\nfn product_path(manufacturer: &str, product: &str) -> PathBuf {\n    PathBuf::from(OFMLDATA_BASE)\n        .join(manufacturer)\n        .join(product)\n}\n\n/// Get path to version 1 of a product\nfn product_v1_path(manufacturer: &str, product: &str) -> PathBuf {\n    product_path(manufacturer, product).join(\"1\")\n}\n\n/// Check if ofmldata exists\nfn ofmldata_exists() -> bool {\n    Path::new(OFMLDATA_BASE).exists()\n}\n\n/// Check if a specific product exists\nfn product_exists(manufacturer: &str, product: &str) -> bool {\n    product_v1_path(manufacturer, product)\n        .join(\"odb.ebase\")\n        .exists()\n}\n\n/// Find first available product for a manufacturer\nfn find_first_product(manufacturer: &str) -> Option<String> {\n    let mfr_path = PathBuf::from(OFMLDATA_BASE).join(manufacturer);\n    if !mfr_path.exists() {\n        return None;\n    }\n\n    if let Ok(entries) = std::fs::read_dir(&mfr_path) {\n        for entry in entries.filter_map(|e| e.ok()) {\n            let prod = entry.file_name().to_string_lossy().to_string();\n            if product_exists(manufacturer, &prod) {\n                return Some(prod);\n            }\n        }\n    }\n    None\n}\n\n/// Find ALB file in product directory\nfn find_alb_file(manufacturer: &str, product: &str) -> Option<PathBuf> {\n    let dir = product_v1_path(manufacturer, product);\n    if let Ok(entries) = std::fs::read_dir(&dir) {\n        for entry in entries.filter_map(|e| e.ok()) {\n            let path = entry.path();\n            if path.extension().map(|e| e == \"alb\").unwrap_or(false) {\n                return Some(path);\n            }\n        }\n    }\n    None\n}\n\n// ============================================================================\n// EBASE Database Tests\n// ============================================================================\n\nmacro_rules! test_manufacturer_ebase {\n    ($name:ident, $mfr:expr) => {\n        #[test]\n        fn $name() {\n            if !ofmldata_exists() {\n                eprintln!(\"Skipping: ofmldata not found\");\n                return;\n            }\n\n            let product = match find_first_product($mfr) {\n                Some(p) => p,\n                None => {\n                    eprintln!(\"Skipping: no products found for {}\", $mfr);\n                    return;\n                }\n            };\n\n            let odb_path = product_v1_path($mfr, &product).join(\"odb.ebase\");\n            let reader = EBaseReader::open(&odb_path)\n                .expect(&format!(\"Should open {}/{} odb.ebase\", $mfr, product));\n\n            let tables = reader.table_names();\n\n            // Some manufacturers may have empty or minimal EBASE files\n            let has_odb3d = tables\n                .iter()\n                .any(|t| t.contains(\"odb3d\") || t.contains(\"ODB3D\"));\n\n            println!(\n                \"{}/{}: {} tables, odb3d={}\",\n                $mfr,\n                product,\n                tables.len(),\n                has_odb3d\n            );\n\n            // Just verify we could read the file, don't require tables\n            // (some products may have minimal EBASE files)\n        }\n    };\n}\n\n// Test EBASE for multiple manufacturers\ntest_manufacturer_ebase!(test_vitra_ebase, \"vitra\");\ntest_manufacturer_ebase!(test_sbu_ebase, \"sbu\");\ntest_manufacturer_ebase!(test_kn_ebase, \"kn\");\ntest_manufacturer_ebase!(test_gsx_ebase, \"gsx\");\ntest_manufacturer_ebase!(test_cassina_ebase, \"cassina\");\ntest_manufacturer_ebase!(test_buzzispace_ebase, \"buzzispace\");\ntest_manufacturer_ebase!(test_aix_ebase, \"aix\");\ntest_manufacturer_ebase!(test_arper_ebase, \"arper\");\ntest_manufacturer_ebase!(test_cor_ebase, \"cor\");\ntest_manufacturer_ebase!(test_framery_ebase, \"framery\");\n\n// ============================================================================\n// ALB Archive Tests\n// ============================================================================\n\nmacro_rules! test_manufacturer_alb {\n    ($name:ident, $mfr:expr) => {\n        #[test]\n        fn $name() {\n            if !ofmldata_exists() {\n                eprintln!(\"Skipping: ofmldata not found\");\n                return;\n            }\n\n            let product = match find_first_product($mfr) {\n                Some(p) => p,\n                None => {\n                    eprintln!(\"Skipping: no products found for {}\", $mfr);\n                    return;\n                }\n            };\n\n            let alb_path = match find_alb_file($mfr, &product) {\n                Some(p) => p,\n                None => {\n                    eprintln!(\"Skipping: no ALB found for {}/{}\", $mfr, product);\n                    return;\n                }\n            };\n\n            let archive = AlbArchive::open(&alb_path)\n                .expect(&format!(\"Should open {}/{} ALB\", $mfr, product));\n\n            let files = archive.list_files();\n            let cls_files = archive.get_cls_files();\n            let geo_files = archive.get_3ds_files();\n\n            println!(\n                \"{}/{}: {} total files, {} CLS, {} 3DS\",\n                $mfr,\n                product,\n                files.len(),\n                cls_files.len(),\n                geo_files.len()\n            );\n\n            assert!(!files.is_empty(), \"{} ALB should have files\", $mfr);\n        }\n    };\n}\n\n// Test ALB archives for multiple manufacturers\ntest_manufacturer_alb!(test_vitra_alb, \"vitra\");\ntest_manufacturer_alb!(test_sbu_alb, \"sbu\");\ntest_manufacturer_alb!(test_kn_alb, \"kn\");\ntest_manufacturer_alb!(test_gsx_alb, \"gsx\");\ntest_manufacturer_alb!(test_cassina_alb, \"cassina\");\ntest_manufacturer_alb!(test_buzzispace_alb, \"buzzispace\");\ntest_manufacturer_alb!(test_aix_alb, \"aix\");\ntest_manufacturer_alb!(test_arper_alb, \"arper\");\ntest_manufacturer_alb!(test_cor_alb, \"cor\");\ntest_manufacturer_alb!(test_framery_alb, \"framery\");\n\n// ============================================================================\n// Product Assembly Tests\n// ============================================================================\n\nmacro_rules! test_manufacturer_product_assembly {\n    ($name:ident, $mfr:expr) => {\n        #[test]\n        fn $name() {\n            if !ofmldata_exists() {\n                eprintln!(\"Skipping: ofmldata not found\");\n                return;\n            }\n\n            let product = match find_first_product($mfr) {\n                Some(p) => p,\n                None => {\n                    eprintln!(\"Skipping: no products found for {}\", $mfr);\n                    return;\n                }\n            };\n\n            let product_dir = product_v1_path($mfr, &product);\n            let config = ProductConfig::default();\n\n            match operations::assemble_product(&product_dir, &config) {\n                Ok(result) => {\n                    println!(\n                        \"{}/{}: {} meshes, {} articles, {} geometry loaded\",\n                        $mfr,\n                        product,\n                        result.scene.meshes.len(),\n                        result.articles_found.len(),\n                        result.geometry_loaded\n                    );\n\n                    // Verify scene is valid if we got geometry\n                    if !result.scene.meshes.is_empty() {\n                        let validation = operations::validate_geometry(&result.scene);\n                        assert!(\n                            validation.vertex_count > 0,\n                            \"{} product should have vertices\",\n                            $mfr\n                        );\n                    }\n                }\n                Err(e) => {\n                    // Some products may not have geometry, that's okay\n                    eprintln!(\n                        \"{}/{}: assembly error (may be expected): {}\",\n                        $mfr, product, e\n                    );\n                }\n            }\n        }\n    };\n}\n\n// Test product assembly for multiple manufacturers\ntest_manufacturer_product_assembly!(test_vitra_product_assembly, \"vitra\");\ntest_manufacturer_product_assembly!(test_sbu_product_assembly, \"sbu\");\ntest_manufacturer_product_assembly!(test_kn_product_assembly, \"kn\");\ntest_manufacturer_product_assembly!(test_gsx_product_assembly, \"gsx\");\ntest_manufacturer_product_assembly!(test_cassina_product_assembly, \"cassina\");\ntest_manufacturer_product_assembly!(test_arper_product_assembly, \"arper\");\n\n// ============================================================================\n// GLB Export Tests\n// ============================================================================\n\n#[test]\nfn test_multi_manufacturer_glb_export() {\n    if !ofmldata_exists() {\n        eprintln!(\"Skipping: ofmldata not found\");\n        return;\n    }\n\n    let manufacturers = [\"vitra\", \"sbu\", \"kn\", \"gsx\", \"cassina\"];\n    let mut successful_exports = 0;\n\n    for mfr in &manufacturers {\n        let product = match find_first_product(mfr) {\n            Some(p) => p,\n            None => continue,\n        };\n\n        let product_dir = product_v1_path(mfr, &product);\n        let config = ProductConfig::default();\n\n        if let Ok(result) = operations::assemble_product(&product_dir, &config) {\n            if !result.scene.meshes.is_empty() {\n                match operations::export_to_glb(&result.scene) {\n                    Ok(glb_data) => {\n                        // Verify GLB magic number\n                        assert_eq!(\n                            &glb_data[0..4],\n                            b\"glTF\",\n                            \"{} GLB should have valid header\",\n                            mfr\n                        );\n                        println!(\"{}/{}: GLB export {} bytes\", mfr, product, glb_data.len());\n                        successful_exports += 1;\n                    }\n                    Err(e) => {\n                        eprintln!(\"{}/{}: GLB export error: {}\", mfr, product, e);\n                    }\n                }\n            }\n        }\n    }\n\n    println!(\n        \"GLB export: {}/{} manufacturers succeeded\",\n        successful_exports,\n        manufacturers.len()\n    );\n}\n\n// ============================================================================\n// CLS Parsing Tests\n// ============================================================================\n\n#[test]\nfn test_multi_manufacturer_cls_parsing() {\n    if !ofmldata_exists() {\n        eprintln!(\"Skipping: ofmldata not found\");\n        return;\n    }\n\n    let manufacturers = [\"vitra\", \"sbu\", \"kn\", \"gsx\", \"cassina\", \"buzzispace\"];\n    let mut total_parsed = 0;\n    let mut total_files = 0;\n\n    for mfr in &manufacturers {\n        let product = match find_first_product(mfr) {\n            Some(p) => p,\n            None => continue,\n        };\n\n        let alb_path = match find_alb_file(mfr, &product) {\n            Some(p) => p,\n            None => continue,\n        };\n\n        let mut archive = match AlbArchive::open(&alb_path) {\n            Ok(a) => a,\n            Err(_) => continue,\n        };\n\n        let cls_files = archive.get_cls_files();\n        let mut parsed = 0;\n\n        for cls_name in cls_files.iter().take(5) {\n            if let Ok(content) = archive.extract_cls(cls_name) {\n                if let Ok(mut parser) = ofml_lib::parser::Parser::new(&content) {\n                    if parser.parse().is_ok() {\n                        parsed += 1;\n                    }\n                }\n            }\n        }\n\n        total_parsed += parsed;\n        total_files += cls_files.len().min(5);\n        println!(\n            \"{}/{}: parsed {}/{} CLS files\",\n            mfr,\n            product,\n            parsed,\n            cls_files.len().min(5)\n        );\n    }\n\n    println!(\"Total CLS parsing: {}/{}\", total_parsed, total_files);\n    assert!(total_parsed > 0, \"Should parse at least some CLS files\");\n}\n\n// ============================================================================\n// Geometry Loading Tests\n// ============================================================================\n\n#[test]\nfn test_multi_manufacturer_geometry_loading() {\n    if !ofmldata_exists() {\n        eprintln!(\"Skipping: ofmldata not found\");\n        return;\n    }\n\n    let manufacturers = [\"vitra\", \"sbu\", \"kn\", \"gsx\"];\n    let mut total_meshes = 0;\n    let mut total_vertices = 0;\n\n    for mfr in &manufacturers {\n        let product = match find_first_product(mfr) {\n            Some(p) => p,\n            None => continue,\n        };\n\n        let alb_path = match find_alb_file(mfr, &product) {\n            Some(p) => p,\n            None => continue,\n        };\n\n        let mut archive = match AlbArchive::open(&alb_path) {\n            Ok(a) => a,\n            Err(_) => continue,\n        };\n\n        let geo_files_3ds = archive.get_3ds_files();\n        let geo_files_obj = archive.get_obj_files();\n        let mut mfr_meshes = 0;\n        let mut mfr_vertices = 0;\n\n        // Try 3DS files\n        for geo_name in geo_files_3ds.iter().take(3) {\n            if let Ok(scene) = archive.extract_3ds(geo_name) {\n                for mesh in &scene.meshes {\n                    mfr_meshes += 1;\n                    mfr_vertices += mesh.vertices.len();\n                }\n            }\n        }\n\n        // Try OBJ files if no 3DS\n        if mfr_meshes == 0 {\n            for geo_name in geo_files_obj.iter().take(3) {\n                if let Ok(scene) = archive.extract_obj(geo_name) {\n                    for mesh in &scene.meshes {\n                        mfr_meshes += 1;\n                        mfr_vertices += mesh.vertices.len();\n                    }\n                }\n            }\n        }\n\n        total_meshes += mfr_meshes;\n        total_vertices += mfr_vertices;\n        println!(\n            \"{}/{}: {} meshes, {} vertices from {} 3DS + {} OBJ files\",\n            mfr,\n            product,\n            mfr_meshes,\n            mfr_vertices,\n            geo_files_3ds.len(),\n            geo_files_obj.len()\n        );\n    }\n\n    println!(\n        \"Total geometry: {} meshes, {} vertices\",\n        total_meshes, total_vertices\n    );\n    // Some products may not have embedded geometry (use external files)\n    // Don't fail if no geometry found, just report\n    if total_meshes == 0 {\n        eprintln!(\"Note: No embedded geometry found in tested manufacturers\");\n    }\n}\n\n// ============================================================================\n// Comprehensive Manufacturer Coverage Test\n// ============================================================================\n\n#[test]\nfn test_comprehensive_manufacturer_coverage() {\n    if !ofmldata_exists() {\n        eprintln!(\"Skipping: ofmldata not found\");\n        return;\n    }\n\n    // Test many manufacturers to ensure broad compatibility\n    let all_manufacturers = [\n        \"vitra\",\n        \"sbu\",\n        \"kn\",\n        \"gsx\",\n        \"cassina\",\n        \"buzzispace\",\n        \"aix\",\n        \"arper\",\n        \"cor\",\n        \"framery\",\n        \"hay\",\n        \"rosc\",\n        \"brx\",\n        \"kix\",\n        \"opx\",\n        \"cpx\",\n        \"materia\",\n        \"maul\",\n        \"muellermoebel\",\n        \"noti\",\n        \"prost\",\n        \"rim\",\n        \"thx\",\n        \"vario\",\n        \"wkx\",\n        \"extremis\",\n        \"bisley\",\n        \"casala\",\n    ];\n\n    let mut manufacturers_with_data = 0;\n    let mut manufacturers_with_alb = 0;\n    let mut manufacturers_with_geometry = 0;\n\n    for mfr in &all_manufacturers {\n        let product = match find_first_product(mfr) {\n            Some(p) => p,\n            None => continue,\n        };\n\n        manufacturers_with_data += 1;\n\n        if let Some(alb_path) = find_alb_file(mfr, &product) {\n            if let Ok(archive) = AlbArchive::open(&alb_path) {\n                manufacturers_with_alb += 1;\n\n                if !archive.get_3ds_files().is_empty() || !archive.get_obj_files().is_empty() {\n                    manufacturers_with_geometry += 1;\n                }\n            }\n        }\n    }\n\n    println!(\"Manufacturer coverage:\");\n    println!(\n        \"  With OFML data: {}/{}\",\n        manufacturers_with_data,\n        all_manufacturers.len()\n    );\n    println!(\"  With valid ALB: {}\", manufacturers_with_alb);\n    println!(\"  With geometry: {}\", manufacturers_with_geometry);\n\n    assert!(\n        manufacturers_with_data >= 10,\n        \"Should have at least 10 manufacturers with data\"\n    );\n}\n\n// ============================================================================\n// Stress Test - Multiple Products per Manufacturer\n// ============================================================================\n\n#[test]\nfn test_sbu_multiple_products() {\n    if !ofmldata_exists() {\n        eprintln!(\"Skipping: ofmldata not found\");\n        return;\n    }\n\n    let mfr = \"sbu\";\n    let mfr_path = PathBuf::from(OFMLDATA_BASE).join(mfr);\n\n    if !mfr_path.exists() {\n        eprintln!(\"Skipping: SBU not found\");\n        return;\n    }\n\n    let mut products_tested = 0;\n    let mut products_with_geometry = 0;\n\n    if let Ok(entries) = std::fs::read_dir(&mfr_path) {\n        for entry in entries.filter_map(|e| e.ok()).take(10) {\n            let product = entry.file_name().to_string_lossy().to_string();\n\n            if !product_exists(mfr, &product) {\n                continue;\n            }\n\n            products_tested += 1;\n\n            let product_dir = product_v1_path(mfr, &product);\n            let config = ProductConfig::default();\n\n            if let Ok(result) = operations::assemble_product(&product_dir, &config) {\n                if !result.scene.meshes.is_empty() {\n                    products_with_geometry += 1;\n                }\n            }\n        }\n    }\n\n    println!(\n        \"SBU: tested {} products, {} with geometry\",\n        products_tested, products_with_geometry\n    );\n\n    assert!(products_tested >= 5, \"Should test at least 5 SBU products\");\n}\n\n#[test]\nfn test_find_manufacturer_names_in_datapool() {\n    let path = Path::new(\"/workspace/ofmldata/pCon.update/DataPool/etc/Manufacturers.ebase\");\n    if !path.exists() {\n        eprintln!(\"Skipping test: Manufacturers.ebase not found\");\n        return;\n    }\n\n    let mut reader = EBaseReader::open(path).expect(\"Failed to open Manufacturers.ebase\");\n    let records = reader\n        .read_records(\"Manufacturers\", None)\n        .expect(\"Failed to read records\");\n\n    println!(\n        \"\\n=== Searching for sex/Sedus in {} records ===\\n\",\n        records.len()\n    );\n\n    for record in &records {\n        let man = record.get(\"man\").and_then(|v| v.as_str()).unwrap_or(\"\");\n        let man_id = record.get(\"man-id\").and_then(|v| v.as_str()).unwrap_or(\"\");\n        let man_name = record\n            .get(\"man-name\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"\");\n\n        if man == \"sex\"\n            || man.to_lowercase().contains(\"sedus\")\n            || man_name.to_lowercase().contains(\"sedus\")\n        {\n            println!(\n                \"FOUND: man='{}', man-id='{}', man-name='{}'\",\n                man, man_id, man_name\n            );\n        }\n    }\n\n    // Also print a few sample records to understand the format\n    println!(\"\\n=== First 5 records ===\\n\");\n    for (i, record) in records.iter().take(5).enumerate() {\n        let man = record.get(\"man\").and_then(|v| v.as_str()).unwrap_or(\"\");\n        let man_id = record.get(\"man-id\").and_then(|v| v.as_str()).unwrap_or(\"\");\n        let man_name = record\n            .get(\"man-name\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"\");\n        println!(\n            \"Record {}: man='{}', man-id='{}', man-name='{}'\",\n            i, man, man_id, man_name\n        );\n    }\n}\n\n#[test]\nfn test_find_sex_manufacturer() {\n    let path = Path::new(\"/workspace/ofmldata/pCon.update/DataPool/etc/Manufacturers.ebase\");\n    if !path.exists() {\n        eprintln!(\"Skipping test: Manufacturers.ebase not found\");\n        return;\n    }\n\n    let mut reader = EBaseReader::open(path).expect(\"Failed to open Manufacturers.ebase\");\n    let records = reader\n        .read_records(\"Manufacturers\", None)\n        .expect(\"Failed to read records\");\n\n    println!(\"\\n=== Looking for 'sex' directory ===\\n\");\n\n    for record in &records {\n        let man = record.get(\"man\").and_then(|v| v.as_str()).unwrap_or(\"\");\n        let man_id = record.get(\"man-id\").and_then(|v| v.as_str()).unwrap_or(\"\");\n        let man_name = record\n            .get(\"man-name\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"\");\n\n        if man == \"sex\" {\n            println!(\n                \"FOUND 'sex': man='{}', man-id='{}', man-name='{}'\",\n                man, man_id, man_name\n            );\n        }\n    }\n}\n\n#[test]\nfn test_search_all_sex_sedus() {\n    let path = Path::new(\"/workspace/ofmldata/pCon.update/DataPool/etc/Manufacturers.ebase\");\n    if !path.exists() {\n        eprintln!(\"Skipping test: Manufacturers.ebase not found\");\n        return;\n    }\n\n    let mut reader = EBaseReader::open(path).expect(\"Failed to open Manufacturers.ebase\");\n    let records = reader\n        .read_records(\"Manufacturers\", None)\n        .expect(\"Failed to read records\");\n\n    println!(\"\\n=== All records containing 'sex' or 'sedus' in any field ===\\n\");\n\n    for (i, record) in records.iter().enumerate() {\n        let man = record.get(\"man\").and_then(|v| v.as_str()).unwrap_or(\"\");\n        let man_id = record.get(\"man-id\").and_then(|v| v.as_str()).unwrap_or(\"\");\n        let man_name = record\n            .get(\"man-name\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"\");\n        let concern_id = record\n            .get(\"concern-id\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"\");\n\n        let all = format!(\"{} {} {} {}\", man, man_id, man_name, concern_id).to_lowercase();\n        if all.contains(\"sex\") || all.contains(\"sedus\") {\n            println!(\n                \"Record {}: man='{}', man-id='{}', man-name='{}', concern-id='{}'\",\n                i, man, man_id, man_name, concern_id\n            );\n        }\n    }\n}\n\n#[test]\nfn test_search_dataclient_manufacturers() {\n    let path = Path::new(\"/workspace/ofmldata/pCon.update/DataClient/etc/Manufacturers.ebase\");\n    if !path.exists() {\n        eprintln!(\"Skipping test: DataClient Manufacturers.ebase not found\");\n        return;\n    }\n\n    let mut reader = EBaseReader::open(path).expect(\"Failed to open Manufacturers.ebase\");\n    let records = reader\n        .read_records(\"Manufacturers\", None)\n        .expect(\"Failed to read records\");\n\n    println!(\"\\n=== DataClient: All records containing 'sex' or 'sedus' in any field ===\\n\");\n\n    for (i, record) in records.iter().enumerate() {\n        let man = record.get(\"man\").and_then(|v| v.as_str()).unwrap_or(\"\");\n        let man_id = record.get(\"man-id\").and_then(|v| v.as_str()).unwrap_or(\"\");\n        let man_name = record\n            .get(\"man-name\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"\");\n        let concern_id = record\n            .get(\"concern-id\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"\");\n\n        let all = format!(\"{} {} {} {}\", man, man_id, man_name, concern_id).to_lowercase();\n        if all.contains(\"sex\") || all.contains(\"sedus\") {\n            println!(\n                \"Record {}: man='{}', man-id='{}', man-name='{}', concern-id='{}'\",\n                i, man, man_id, man_name, concern_id\n            );\n        }\n    }\n}\n\n#[test]\nfn test_check_concerns_table() {\n    let path = Path::new(\"/workspace/ofmldata/pCon.update/DataPool/etc/Manufacturers.ebase\");\n    if !path.exists() {\n        eprintln!(\"Skipping test: Manufacturers.ebase not found\");\n        return;\n    }\n\n    let mut reader = EBaseReader::open(path).expect(\"Failed to open Manufacturers.ebase\");\n    let records = reader\n        .read_records(\"Concerns\", None)\n        .expect(\"Failed to read records\");\n\n    println!(\"\\n=== Concerns table - looking for SE ===\\n\");\n\n    for record in &records {\n        let concern = record.get(\"concern\").and_then(|v| v.as_str()).unwrap_or(\"\");\n        let concern_name = record\n            .get(\"concern-name\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"\");\n\n        if concern == \"SE\"\n            || concern.to_lowercase().contains(\"sedus\")\n            || concern_name.to_lowercase().contains(\"sedus\")\n        {\n            println!(\"concern='{}', concern-name='{}'\", concern, concern_name);\n        }\n    }\n\n    println!(\"\\n=== First 10 concerns ===\\n\");\n    for record in records.iter().take(10) {\n        let concern = record.get(\"concern\").and_then(|v| v.as_str()).unwrap_or(\"\");\n        let concern_name = record\n            .get(\"concern-name\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"\");\n        println!(\"concern='{}', concern-name='{}'\", concern, concern_name);\n    }\n}\n\n// ============================================================================\n// OCD Price Table Tests\n// ============================================================================\n\n#[test]\nfn test_ocd_price_columns_sedus() {\n    let path = Path::new(\"/reference/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        eprintln!(\n            \"Skipping test: Sedus AI pdata.ebase not found at {:?}\",\n            path\n        );\n        return;\n    }\n\n    let reader = EBaseReader::open(path).expect(\"Failed to open pdata.ebase\");\n\n    println!(\"\\n=== OCD Price Table Structure ===\\n\");\n\n    if let Some(table) = reader.tables.get(\"ocd_price\") {\n        println!(\"ocd_price table: {} records\", table.record_count);\n        println!(\"\\nColumns:\");\n        for col in &table.columns {\n            println!(\"  {} (type_id={})\", col.name, col.type_id);\n        }\n    } else {\n        eprintln!(\"No ocd_price table found!\");\n    }\n}\n\n#[test]\nfn test_ocd_price_reading_with_price_level() {\n    use ofml_lib::oap::ocd::OcdReader;\n\n    let path = Path::new(\"/reference/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        eprintln!(\"Skipping test: Sedus AI pdata.ebase not found\");\n        return;\n    }\n\n    let reader = OcdReader::from_ebase(path).expect(\"Failed to load OCD\");\n\n    println!(\"\\n=== OCD Price Reading Test ===\\n\");\n    println!(\"Total prices: {}\", reader.prices.len());\n\n    // Count by price_level\n    let base_prices: Vec<_> = reader\n        .prices\n        .iter()\n        .filter(|p| p.price_level == \"B\")\n        .collect();\n    let surcharges: Vec<_> = reader\n        .prices\n        .iter()\n        .filter(|p| p.price_level == \"X\")\n        .collect();\n    let discounts: Vec<_> = reader\n        .prices\n        .iter()\n        .filter(|p| p.price_level == \"D\")\n        .collect();\n    let empty_level: Vec<_> = reader\n        .prices\n        .iter()\n        .filter(|p| p.price_level.is_empty())\n        .collect();\n\n    println!(\"  Base prices (level='B'): {}\", base_prices.len());\n    println!(\"  Surcharges (level='X'): {}\", surcharges.len());\n    println!(\"  Discounts (level='D'): {}\", discounts.len());\n    println!(\"  Empty level: {}\", empty_level.len());\n\n    // Show some sample prices\n    println!(\"\\n=== Sample Prices ===\\n\");\n\n    // Sample base price\n    if let Some(base) = base_prices.first() {\n        println!(\"Base price example:\");\n        println!(\"  article_nr: {}\", base.article_nr);\n        println!(\"  var_cond: '{}'\", base.var_cond);\n        println!(\"  price_level: '{}'\", base.price_level);\n        println!(\"  is_fix: {}\", base.is_fix);\n        println!(\"  price: {:.2} {}\", base.price, base.currency);\n    }\n\n    // Sample surcharge\n    if let Some(surcharge) = surcharges.first() {\n        println!(\"\\nSurcharge example:\");\n        println!(\"  article_nr: {}\", surcharge.article_nr);\n        println!(\"  var_cond: '{}'\", surcharge.var_cond);\n        println!(\"  price_level: '{}'\", surcharge.price_level);\n        println!(\"  is_fix: {}\", surcharge.is_fix);\n        println!(\"  price: {:.2} {}\", surcharge.price, surcharge.currency);\n    }\n\n    // Test get_base_price\n    if !reader.articles.is_empty() {\n        let first_article = &reader.articles[0].article_nr;\n        println!(\"\\n=== get_base_price test for {} ===\\n\", first_article);\n\n        if let Some(base) = reader.get_base_price(first_article) {\n            println!(\"Found base price:\");\n            println!(\"  price_level: '{}'\", base.price_level);\n            println!(\"  price: {:.2} {}\", base.price, base.currency);\n        } else {\n            println!(\"No base price found\");\n        }\n\n        // Test get_surcharges\n        let surcharges = reader.get_surcharges(first_article);\n        println!(\"\\nSurcharges for {}: {}\", first_article, surcharges.len());\n        for s in surcharges.iter().take(5) {\n            println!(\n                \"  var_cond='{}' price={:.2} is_fix={}\",\n                s.var_cond, s.price, s.is_fix\n            );\n        }\n    }\n}\n\n#[test]\nfn test_multi_manufacturer_price_reading() {\n    use ofml_lib::oap::ocd::OcdReader;\n\n    if !ofmldata_exists() {\n        eprintln!(\"Skipping: ofmldata not found\");\n        return;\n    }\n\n    let manufacturers = [\"sex\", \"vitra\", \"kn\", \"sbu\", \"haw\", \"aix\"];\n\n    println!(\"\\n=== Multi-Manufacturer Price Reading ===\\n\");\n\n    for mfr in &manufacturers {\n        // Find pdata.ebase files\n        let mfr_path = PathBuf::from(OFMLDATA_BASE).join(mfr);\n        if !mfr_path.exists() {\n            continue;\n        }\n\n        let pdata_files = find_pdata_files_recursive(&mfr_path);\n        if pdata_files.is_empty() {\n            continue;\n        }\n\n        // Read first pdata.ebase\n        let pdata_path = &pdata_files[0];\n        match OcdReader::from_ebase(pdata_path) {\n            Ok(reader) => {\n                let base_count = reader\n                    .prices\n                    .iter()\n                    .filter(|p| p.price_level == \"B\")\n                    .count();\n                let surcharge_count = reader\n                    .prices\n                    .iter()\n                    .filter(|p| p.price_level == \"X\")\n                    .count();\n                let empty_count = reader\n                    .prices\n                    .iter()\n                    .filter(|p| p.price_level.is_empty())\n                    .count();\n\n                println!(\n                    \"{}: {} prices (B:{}, X:{}, empty:{})\",\n                    mfr,\n                    reader.prices.len(),\n                    base_count,\n                    surcharge_count,\n                    empty_count\n                );\n\n                // Show if price_level field is being used\n                if base_count > 0 || surcharge_count > 0 {\n                    println!(\"  ‚úì price_level field is populated\");\n                } else if empty_count > 0 {\n                    println!(\"  ‚ö† price_level field is empty (using var_cond fallback)\");\n                }\n            }\n            Err(e) => {\n                println!(\"{}: Error reading pdata - {}\", mfr, e);\n            }\n        }\n    }\n}\n\n/// Find all pdata.ebase files recursively\nfn find_pdata_files_recursive(path: &Path) -> Vec<PathBuf> {\n    let mut files = Vec::new();\n    if let Ok(entries) = std::fs::read_dir(path) {\n        for entry in entries.flatten() {\n            let entry_path = entry.path();\n            if entry_path.is_dir() {\n                files.extend(find_pdata_files_recursive(&entry_path));\n            } else if entry_path.file_name().map_or(false, |n| n == \"pdata.ebase\") {\n                files.push(entry_path);\n            }\n        }\n    }\n    files\n}\n\n#[test]\nfn test_debug_variant_matching() {\n    use ofml_lib::oap::families::{FamilyConfiguration, FamilyLoader};\n    use ofml_lib::oap::ocd::OcdReader;\n\n    let path = Path::new(\"/reference/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        eprintln!(\"Skipping: Sedus AI not found\");\n        return;\n    }\n\n    let reader = OcdReader::from_ebase(path).expect(\"load\");\n\n    // Get prices for AI-121\n    let prices = reader.get_prices(\"AI-121\");\n\n    println!(\"\\n=== AI-121 Prices ===\");\n    println!(\"Total: {}\", prices.len());\n\n    // Show base price\n    if let Some(base) = prices.iter().find(|p| p.price_level == \"B\") {\n        println!(\n            \"\\nBase price: {:.2} EUR (var_cond='{}')\",\n            base.price, base.var_cond\n        );\n    }\n\n    // Show all unique var_cond patterns\n    println!(\"\\nAll unique var_cond patterns:\");\n    let mut var_conds: Vec<_> = prices.iter().map(|p| p.var_cond.as_str()).collect();\n    var_conds.sort();\n    var_conds.dedup();\n    for vc in &var_conds {\n        let price = prices.iter().find(|p| &p.var_cond == vc).unwrap();\n        println!(\n            \"  '{}' -> {:.2} EUR (level='{}')\",\n            vc, price.price, price.price_level\n        );\n    }\n\n    // Now check what the variant code looks like\n    let mfr_path = Path::new(\"/reference/ofmldata/sex\");\n    let loader = FamilyLoader::load(mfr_path, \"DE\");\n\n    // Find AI family\n    for family in loader.get_families() {\n        if family.base_article_nr.starts_with(\"AI-\") {\n            println!(\"\\n=== Family: {} ===\", family.name);\n            println!(\"Base article: {}\", family.base_article_nr);\n\n            let properties = loader.get_properties_for_family(family);\n            println!(\"Properties: {}\", properties.len());\n\n            for prop in &properties {\n                println!(\n                    \"  {} ({} options): default={:?}\",\n                    prop.key,\n                    prop.options.len(),\n                    prop.default_value\n                );\n                for opt in prop.options.iter().take(5) {\n                    println!(\"    - '{}' ({})\", opt.value, opt.label);\n                }\n                if prop.options.len() > 5 {\n                    println!(\"    ... and {} more\", prop.options.len() - 5);\n                }\n            }\n\n            let config = FamilyConfiguration::new(&family.id, &properties);\n            println!(\"\\nGenerated variant_code: '{}'\", config.variant_code);\n\n            // Show selections\n            println!(\"\\nSelections:\");\n            for (k, v) in &config.selections {\n                println!(\"  {}='{}'\", k, v);\n            }\n\n            break;\n        }\n    }\n}\n\n#[test]\nfn test_sedus_price_mapping_tables() {\n    let path = Path::new(\"/reference/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        eprintln!(\"Skipping: Sedus AI not found\");\n        return;\n    }\n\n    let mut reader = EBaseReader::open(path).expect(\"load\");\n\n    println!(\"\\n=== All Tables in pdata.ebase ===\\n\");\n    for (table_name, table) in &reader.tables {\n        println!(\"{}: {} records\", table_name, table.record_count);\n    }\n\n    // Look at ocd_relation table - contains the mapping logic\n    println!(\"\\n=== ocd_relation Sample Records ===\\n\");\n    if let Ok(records) = reader.read_records(\"ocd_relation\", None) {\n        // Find records referencing surcharge codes\n        let surcharge_codes = [\"S_1801\", \"S_166\", \"S_1513\", \"S_PGX\"];\n\n        for code in &surcharge_codes {\n            println!(\"Looking for rel_name containing '{}':\", code);\n            for rec in records\n                .iter()\n                .filter(|r| {\n                    r.get(\"rel_name\")\n                        .and_then(|v| v.as_str())\n                        .map_or(false, |s| s.contains(code))\n                })\n                .take(5)\n            {\n                let rel_name = rec.get(\"rel_name\").and_then(|v| v.as_str()).unwrap_or(\"\");\n                let rel_blocknr = rec.get(\"rel_blocknr\").and_then(|v| v.as_i64()).unwrap_or(0);\n                let rel_block = rec.get(\"rel_block\").and_then(|v| v.as_str()).unwrap_or(\"\");\n                println!(\n                    \"  rel_name='{}' blocknr={} block='{}'\",\n                    rel_name, rel_blocknr, rel_block\n                );\n            }\n            println!();\n        }\n\n        // Look at first few relations to understand structure\n        println!(\"First 10 ocd_relation records:\");\n        for rec in records.iter().take(10) {\n            let rel_name = rec.get(\"rel_name\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            let rel_blocknr = rec.get(\"rel_blocknr\").and_then(|v| v.as_i64()).unwrap_or(0);\n            let rel_block = rec.get(\"rel_block\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            println!(\n                \"  rel_name='{}' blocknr={} block='{}'\",\n                rel_name, rel_blocknr, rel_block\n            );\n        }\n    }\n\n    // Look at ocd_price - check the actual var_cond format\n    println!(\"\\n=== ocd_price Surcharge Codes ===\\n\");\n    if let Ok(records) = reader.read_records(\"ocd_price\", None) {\n        for rec in records\n            .iter()\n            .filter(|r| {\n                r.get(\"price_level\")\n                    .and_then(|v| v.as_str())\n                    .map_or(false, |s| s == \"X\")\n            })\n            .take(15)\n        {\n            let article_nr = rec.get(\"article_nr\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            let var_cond = rec.get(\"var_cond\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            let price = rec.get(\"price\").and_then(|v| v.as_f64()).unwrap_or(0.0);\n            println!(\n                \"  article='{}' var_cond='{}' price={:.2}\",\n                article_nr, var_cond, price\n            );\n        }\n    }\n\n    // Check ocd_propertyvalue for rel_obj that might link to surcharges\n    println!(\"\\n=== ocd_propertyvalue with rel_obj ===\\n\");\n    if let Ok(records) = reader.read_records(\"ocd_propertyvalue\", None) {\n        // Show records with non-zero rel_obj\n        for rec in records\n            .iter()\n            .filter(|r| {\n                r.get(\"rel_obj\")\n                    .and_then(|v| v.as_i64())\n                    .map_or(false, |i| i != 0)\n            })\n            .take(20)\n        {\n            let prop_class = rec.get(\"prop_class\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            let property = rec.get(\"property\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            let rel_obj = rec.get(\"rel_obj\").and_then(|v| v.as_i64()).unwrap_or(0);\n            println!(\n                \"  prop_class='{}' property='{}' rel_obj={}\",\n                prop_class, property, rel_obj\n            );\n        }\n\n        // Also show fabric/color related properties\n        println!(\"\\nS_STOFF property values:\");\n        for rec in records\n            .iter()\n            .filter(|r| {\n                r.get(\"property\")\n                    .and_then(|v| v.as_str())\n                    .map_or(false, |s| s.starts_with(\"S_STOFF\") || s == \"S_FUSSFARBE\")\n            })\n            .take(10)\n        {\n            let prop_class = rec.get(\"prop_class\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            let property = rec.get(\"property\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            let rel_obj = rec.get(\"rel_obj\").and_then(|v| v.as_i64()).unwrap_or(0);\n            let pos_pval = rec.get(\"pos_pval\").and_then(|v| v.as_i64()).unwrap_or(0);\n            println!(\n                \"  prop_class='{}' property='{}' pos={} rel_obj={}\",\n                prop_class, property, pos_pval, rel_obj\n            );\n        }\n    }\n\n    // Look at ocd_relationobj with Domain='P' for pricing\n    println!(\"\\n=== ocd_relationobj (pricing) ===\\n\");\n    if let Ok(records) = reader.read_records(\"ocd_relationobj\", None) {\n        println!(\"First 10 relationobj records:\");\n        for rec in records.iter().take(10) {\n            for (k, v) in rec {\n                print!(\"{}='{:?}' \", k, v);\n            }\n            println!();\n        }\n    }\n}\n\n#[test]\nfn test_sedus_article_base_prices() {\n    use ofml_lib::oap::ocd::OcdReader;\n\n    let path = Path::new(\"/reference/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        eprintln!(\"Skipping: Sedus AI not found\");\n        return;\n    }\n\n    let reader = OcdReader::from_ebase(path).expect(\"load\");\n\n    println!(\"\\n=== Base Prices for Different Articles ===\\n\");\n\n    // Get all articles\n    let articles = &reader.articles;\n    println!(\"Total articles in OCD: {}\", articles.len());\n\n    for art in articles {\n        println!(\"\\nArticle: {}\", art.article_nr);\n\n        // Get base price (level='B')\n        if let Some(base) = reader.get_base_price(&art.article_nr) {\n            println!(\n                \"  Base price: {:.2} {} (level='{}', var_cond='{}')\",\n                base.price, base.currency, base.price_level, base.var_cond\n            );\n        } else {\n            println!(\"  No base price found\");\n        }\n\n        // Count surcharges\n        let surcharges = reader.get_surcharges(&art.article_nr);\n        println!(\"  Surcharges: {} entries\", surcharges.len());\n\n        // Show unique var_cond codes\n        let codes: std::collections::HashSet<_> =\n            surcharges.iter().map(|s| s.var_cond.as_str()).collect();\n        if !codes.is_empty() {\n            println!(\"  Surcharge codes: {:?}\", codes);\n        }\n    }\n}\n\n#[test]\nfn test_sedus_price_rules() {\n    let path = Path::new(\"/reference/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        eprintln!(\"Skipping: Sedus AI not found\");\n        return;\n    }\n\n    let mut reader = EBaseReader::open(path).expect(\"load\");\n\n    println!(\"\\n=== ocd_price with price_rule ===\\n\");\n    if let Ok(records) = reader.read_records(\"ocd_price\", None) {\n        for rec in records.iter().take(20) {\n            let article_nr = rec.get(\"article_nr\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            let var_cond = rec.get(\"var_cond\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            let price_rule = rec.get(\"price_rule\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            let price_level = rec\n                .get(\"price_level\")\n                .and_then(|v| v.as_str())\n                .unwrap_or(\"\");\n            let price = rec.get(\"price\").and_then(|v| v.as_f64()).unwrap_or(0.0);\n\n            if !price_rule.is_empty() || price_level == \"X\" {\n                println!(\n                    \"article='{}' var_cond='{}' level='{}' price={:.2} rule='{}'\",\n                    article_nr, var_cond, price_level, price, price_rule\n                );\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","price_validation_test.rs"],"content":"//! Price Validation Tests\r\n//!\r\n//! This module implements multi-layered price validation:\r\n//! 1. Sanity checks - detect obviously wrong prices\r\n//! 2. Spot checks - compare against known reference values\r\n//! 3. Structural checks - verify price data integrity\r\n\r\nuse std::collections::HashMap;\r\nuse std::path::Path;\r\n\r\n/// Known reference prices from manual verification against manufacturer catalogs\r\n/// Format: (manufacturer, series, article_nr, expected_base_price_eur, tolerance_percent)\r\nconst REFERENCE_PRICES: &[(&str, &str, &str, f64, f64)] = &[\r\n    // Framery phone booths (verified against Framery price lists)\r\n    (\"framery\", \"frmr_2q\", \"2Q_HUDDLE\", 44140.0, 0.0),  // Framery 2Q Huddle\r\n    (\"framery\", \"frmr_one\", \"ONE\", 12280.0, 0.0),        // Framery One\r\n    (\"framery\", \"frmr_one\", \"ONE_PREMIUM\", 15640.0, 0.0), // Framery One Premium\r\n    (\"framery\", \"frmr_q\", \"Q\", 8140.0, 0.0),             // Framery Q\r\n    (\"framery\", \"frmr_four\", \"FOUR\", 18500.0, 5.0),      // Framery Four (approx)\r\n\r\n    // Sedus chairs (verified against Sedus price lists)\r\n    (\"sex\", \"ai\", \"SE:AI-102\", 599.0, 0.0),              // Sedus se:motion basic\r\n    (\"sex\", \"ai\", \"SE:AI-121\", 647.0, 0.0),              // Sedus se:motion with armrests\r\n\r\n    // TODO: Add more reference prices as we verify them\r\n];\r\n\r\n/// Price sanity bounds by product category\r\n/// These catch obviously wrong prices (corruption, parsing errors)\r\nstruct SanityBounds {\r\n    /// Minimum reasonable price in EUR\r\n    min: f64,\r\n    /// Maximum reasonable price in EUR\r\n    max: f64,\r\n    /// Category description\r\n    category: &'static str,\r\n}\r\n\r\nconst SANITY_BOUNDS: &[(&str, SanityBounds)] = &[\r\n    // Phone booths / pods\r\n    (\"frmr_\", SanityBounds { min: 5000.0, max: 100000.0, category: \"Framery pod\" }),\r\n\r\n    // Office chairs\r\n    (\"ai\", SanityBounds { min: 200.0, max: 5000.0, category: \"Sedus chair\" }),\r\n    (\"se:\", SanityBounds { min: 200.0, max: 5000.0, category: \"Sedus chair\" }),\r\n\r\n    // Tables\r\n    (\"table\", SanityBounds { min: 100.0, max: 20000.0, category: \"Table\" }),\r\n    (\"desk\", SanityBounds { min: 100.0, max: 20000.0, category: \"Desk\" }),\r\n\r\n    // General furniture fallback\r\n    (\"\", SanityBounds { min: 1.0, max: 500000.0, category: \"General furniture\" }),\r\n];\r\n\r\nfn get_sanity_bounds(article_nr: &str, series: &str) -> &'static SanityBounds {\r\n    let article_lower = article_nr.to_lowercase();\r\n    let series_lower = series.to_lowercase();\r\n\r\n    for (pattern, bounds) in SANITY_BOUNDS {\r\n        if !pattern.is_empty() &&\r\n           (article_lower.contains(pattern) || series_lower.contains(pattern)) {\r\n            return bounds;\r\n        }\r\n    }\r\n\r\n    // Return general fallback\r\n    &SANITY_BOUNDS.last().unwrap().1\r\n}\r\n\r\n/// Validate a price against sanity bounds\r\nfn validate_price_sanity(price: f64, article_nr: &str, series: &str) -> Result<(), String> {\r\n    let bounds = get_sanity_bounds(article_nr, series);\r\n\r\n    if price < bounds.min {\r\n        return Err(format!(\r\n            \"{} price {:.2} EUR is below minimum {:.2} EUR for {}\",\r\n            article_nr, price, bounds.min, bounds.category\r\n        ));\r\n    }\r\n\r\n    if price > bounds.max {\r\n        return Err(format!(\r\n            \"{} price {:.2} EUR exceeds maximum {:.2} EUR for {}\",\r\n            article_nr, price, bounds.max, bounds.category\r\n        ));\r\n    }\r\n\r\n    Ok(())\r\n}\r\n\r\n/// Validate a price against known reference value\r\nfn validate_price_reference(\r\n    price: f64,\r\n    expected: f64,\r\n    tolerance_percent: f64,\r\n    article_nr: &str,\r\n) -> Result<(), String> {\r\n    let tolerance = expected * (tolerance_percent / 100.0);\r\n    let diff = (price - expected).abs();\r\n\r\n    if diff > tolerance {\r\n        let diff_percent = (diff / expected) * 100.0;\r\n        return Err(format!(\r\n            \"{}: got {:.2} EUR, expected {:.2} EUR (diff: {:.2}%, allowed: {:.2}%)\",\r\n            article_nr, price, expected, diff_percent, tolerance_percent\r\n        ));\r\n    }\r\n\r\n    Ok(())\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use ofml_lib::oap::engine::ConfigurationEngine;\r\n    use ofml_lib::oap::families::{FamilyConfiguration, FamilyLoader};\r\n\r\n    const OFMLDATA_BASE: &str = \"/reference/ofmldata\";\r\n\r\n    fn ofmldata_exists() -> bool {\r\n        Path::new(OFMLDATA_BASE).exists()\r\n    }\r\n\r\n    /// Test sanity bounds for Framery products\r\n    #[test]\r\n    fn test_framery_price_sanity() {\r\n        // Valid Framery prices\r\n        assert!(validate_price_sanity(12280.0, \"ONE\", \"frmr_one\").is_ok());\r\n        assert!(validate_price_sanity(44140.0, \"2Q_HUDDLE\", \"frmr_2q\").is_ok());\r\n\r\n        // Invalid: too cheap for a phone booth\r\n        let result = validate_price_sanity(265.0, \"ONE_COMPACT_BASE\", \"frmr_one_compact\");\r\n        assert!(result.is_err());\r\n        println!(\"Expected error: {}\", result.unwrap_err());\r\n\r\n        // Invalid: too expensive\r\n        let result = validate_price_sanity(500000.0, \"ONE\", \"frmr_one\");\r\n        assert!(result.is_err());\r\n    }\r\n\r\n    /// Test sanity bounds for Sedus chairs\r\n    #[test]\r\n    fn test_sedus_price_sanity() {\r\n        // Valid chair prices\r\n        assert!(validate_price_sanity(599.0, \"SE:AI-102\", \"ai\").is_ok());\r\n        assert!(validate_price_sanity(1500.0, \"SE:AI-200\", \"ai\").is_ok());\r\n\r\n        // Invalid: chair can't cost 50,000 EUR\r\n        let result = validate_price_sanity(50000.0, \"SE:AI-102\", \"ai\");\r\n        assert!(result.is_err());\r\n    }\r\n\r\n    /// Spot check: Verify Framery 2Q Huddle price matches reference\r\n    #[test]\r\n    fn test_spot_check_framery_2q() {\r\n        if !ofmldata_exists() {\r\n            eprintln!(\"Skipping: ofmldata not found\");\r\n            return;\r\n        }\r\n\r\n        let mfr_path = Path::new(OFMLDATA_BASE).join(\"framery\");\r\n        let loader = FamilyLoader::load(&mfr_path, \"DE\");\r\n        let engine = ConfigurationEngine::new(OFMLDATA_BASE);\r\n        let price_date = chrono::Local::now().date_naive();\r\n\r\n        // Find 2Q family\r\n        let family = loader.get_families().iter()\r\n            .find(|f| f.id.to_lowercase().contains(\"2q\"))\r\n            .expect(\"Should find Framery 2Q family\");\r\n\r\n        let properties = loader.get_properties_for_family(family);\r\n        let config = FamilyConfiguration::new(&family.id, &properties);\r\n\r\n        let price = engine.calculate_family_price(\"framery\", family, &config, price_date);\r\n\r\n        assert!(price.is_some(), \"Should calculate price for Framery 2Q\");\r\n        let price = price.unwrap();\r\n\r\n        println!(\"Framery 2Q Huddle: {:.2} EUR\", price.base_price);\r\n\r\n        // Validate against reference\r\n        let result = validate_price_reference(\r\n            price.base_price.to_string().parse().unwrap(),\r\n            44140.0,\r\n            0.0,\r\n            \"2Q_HUDDLE\"\r\n        );\r\n        assert!(result.is_ok(), \"Price mismatch: {:?}\", result);\r\n\r\n        // Validate sanity\r\n        let sanity = validate_price_sanity(\r\n            price.base_price.to_string().parse().unwrap(),\r\n            &family.base_article_nr,\r\n            \"frmr_2q\"\r\n        );\r\n        assert!(sanity.is_ok(), \"Sanity check failed: {:?}\", sanity);\r\n    }\r\n\r\n    /// Debug: Trace the 265 EUR problem for specific products\r\n    #[test]\r\n    fn test_debug_265_eur_problem() {\r\n        if !ofmldata_exists() {\r\n            eprintln!(\"Skipping: ofmldata not found\");\r\n            return;\r\n        }\r\n\r\n        use ofml_lib::oap::ocd::{find_pdata_files, get_ocd_reader};\r\n\r\n        let mfr_path = Path::new(OFMLDATA_BASE).join(\"framery\");\r\n        let loader = FamilyLoader::load(&mfr_path, \"DE\");\r\n        let engine = ConfigurationEngine::new(OFMLDATA_BASE);\r\n        let price_date = chrono::Local::now().date_naive();\r\n\r\n        println!(\"\\n=== Debugging 265 EUR Problem ===\\n\");\r\n\r\n        // First, let's check each pdata.ebase file for prices\r\n        println!(\"=== Price files analysis ===\\n\");\r\n        let pdata_files = find_pdata_files(&mfr_path);\r\n        for pdata_path in &pdata_files {\r\n            if let Some(reader) = get_ocd_reader(pdata_path) {\r\n                let series = pdata_path.parent()\r\n                    .and_then(|p| p.parent())\r\n                    .and_then(|p| p.parent())\r\n                    .and_then(|p| p.parent())\r\n                    .and_then(|p| p.file_name())\r\n                    .and_then(|n| n.to_str())\r\n                    .unwrap_or(\"unknown\");\r\n\r\n                let base_prices: Vec<_> = reader.prices.iter()\r\n                    .filter(|p| p.price_level == \"B\")\r\n                    .collect();\r\n                let surcharges: Vec<_> = reader.prices.iter()\r\n                    .filter(|p| p.price_level == \"X\")\r\n                    .collect();\r\n\r\n                println!(\"{}: {} base prices, {} surcharges\",\r\n                    series, base_prices.len(), surcharges.len());\r\n\r\n                // Show any 265 EUR prices\r\n                for p in reader.prices.iter() {\r\n                    if (p.price - 265.0).abs() < 1.0 {\r\n                        println!(\"  FOUND 265: article='{}' var_cond='{}' level='{}' price={}\",\r\n                            p.article_nr, p.var_cond, p.price_level, p.price);\r\n                    }\r\n                }\r\n\r\n                // Show base prices\r\n                for p in base_prices.iter().take(3) {\r\n                    println!(\"  BASE: article='{}' var_cond='{}' price={}\",\r\n                        p.article_nr, p.var_cond, p.price);\r\n                }\r\n\r\n                // Show articles in the file\r\n                if !reader.articles.is_empty() {\r\n                    let art_nrs: Vec<_> = reader.articles.iter().map(|a| &a.article_nr).collect();\r\n                    println!(\"  ARTICLES: {:?}\", art_nrs);\r\n                }\r\n            }\r\n        }\r\n        println!();\r\n\r\n        // These products show 265 EUR incorrectly\r\n        let problem_articles = [\"ONE\", \"FRMR_FOUR_ACCESSIBLE\", \"FRMR_SIX_BASE\"];\r\n\r\n        for family in loader.get_families() {\r\n            if !problem_articles.iter().any(|a| family.base_article_nr.contains(a) || family.id.contains(a)) {\r\n                continue;\r\n            }\r\n\r\n            println!(\"=== Family: {} ===\", family.name);\r\n            println!(\"  ID: {}\", family.id);\r\n            println!(\"  Base article: {}\", family.base_article_nr);\r\n            println!(\"  All articles: {:?}\", family.article_nrs);\r\n            println!(\"  Property classes: {:?}\", family.prop_classes);\r\n\r\n            let properties = loader.get_properties_for_family(&family);\r\n            println!(\"  Properties: {} total\", properties.len());\r\n\r\n            let config = FamilyConfiguration::new(&family.id, &properties);\r\n            println!(\"  Config selections: {} entries\", config.selections.len());\r\n\r\n            let price = engine.calculate_family_price(\"framery\", &family, &config, price_date);\r\n\r\n            // Show variant code for debugging\r\n            println!(\"  Variant code: {}\", config.variant_code);\r\n\r\n            if let Some(p) = &price {\r\n                println!(\"  RESULT: base={:.2} total={:.2} {} surcharges={}\",\r\n                    p.base_price, p.total_price, p.currency, p.surcharges.len());\r\n                for s in &p.surcharges {\r\n                    println!(\"    + {} {:.2} EUR\", s.name, s.amount);\r\n                }\r\n            } else {\r\n                println!(\"  RESULT: No price found!\");\r\n            }\r\n            println!();\r\n        }\r\n    }\r\n\r\n    /// Spot check: Verify Framery One Compact - THIS IS KNOWN TO BE BROKEN\r\n    #[test]\r\n    fn test_spot_check_framery_one_compact() {\r\n        if !ofmldata_exists() {\r\n            eprintln!(\"Skipping: ofmldata not found\");\r\n            return;\r\n        }\r\n\r\n        let mfr_path = Path::new(OFMLDATA_BASE).join(\"framery\");\r\n        let loader = FamilyLoader::load(&mfr_path, \"DE\");\r\n        let engine = ConfigurationEngine::new(OFMLDATA_BASE);\r\n        let price_date = chrono::Local::now().date_naive();\r\n\r\n        // Find One Compact family\r\n        let family = loader.get_families().iter()\r\n            .find(|f| f.id.to_lowercase().contains(\"one_compact\"))\r\n            .expect(\"Should find Framery One Compact family\");\r\n\r\n        let properties = loader.get_properties_for_family(family);\r\n        let config = FamilyConfiguration::new(&family.id, &properties);\r\n\r\n        let price = engine.calculate_family_price(\"framery\", family, &config, price_date);\r\n\r\n        println!(\"Framery One Compact:\");\r\n        println!(\"  Family: {} ({})\", family.name, family.id);\r\n        println!(\"  Base article: {}\", family.base_article_nr);\r\n\r\n        if let Some(p) = &price {\r\n            println!(\"  Base price: {:.2} EUR\", p.base_price);\r\n            println!(\"  Total: {:.2} EUR\", p.total_price);\r\n            println!(\"  Surcharges: {}\", p.surcharges.len());\r\n\r\n            // Sanity check - One Compact should be ~10,000-15,000 EUR\r\n            let sanity = validate_price_sanity(\r\n                p.base_price.to_string().parse().unwrap(),\r\n                &family.base_article_nr,\r\n                \"frmr_one_compact\"\r\n            );\r\n\r\n            if sanity.is_err() {\r\n                println!(\"  SANITY CHECK FAILED: {}\", sanity.unwrap_err());\r\n                println!(\"  WARNING: This indicates corrupted price data!\");\r\n            }\r\n        } else {\r\n            println!(\"  No price calculated - missing data\");\r\n        }\r\n    }\r\n\r\n    /// Validate ALL Framery products have sane prices\r\n    #[test]\r\n    fn test_framery_all_products_sanity() {\r\n        if !ofmldata_exists() {\r\n            eprintln!(\"Skipping: ofmldata not found\");\r\n            return;\r\n        }\r\n\r\n        let mfr_path = Path::new(OFMLDATA_BASE).join(\"framery\");\r\n        let loader = FamilyLoader::load(&mfr_path, \"DE\");\r\n        let engine = ConfigurationEngine::new(OFMLDATA_BASE);\r\n        let price_date = chrono::Local::now().date_naive();\r\n\r\n        println!(\"\\n=== Framery Price Validation Report ===\\n\");\r\n\r\n        let mut passed = 0;\r\n        let mut failed = 0;\r\n        let mut no_price = 0;\r\n\r\n        for family in loader.get_families() {\r\n            let properties = loader.get_properties_for_family(&family);\r\n            let config = FamilyConfiguration::new(&family.id, &properties);\r\n\r\n            let price = engine.calculate_family_price(\"framery\", &family, &config, price_date);\r\n\r\n            if let Some(p) = price {\r\n                let price_value: f64 = p.base_price.to_string().parse().unwrap_or(0.0);\r\n                let sanity = validate_price_sanity(price_value, &family.base_article_nr, &family.id);\r\n\r\n                let status = if sanity.is_ok() { \"‚úì\" } else { \"‚úó\" };\r\n                println!(\"{} {} ({}): {:.2} EUR\",\r\n                    status, family.name, family.base_article_nr, price_value);\r\n\r\n                if sanity.is_err() {\r\n                    println!(\"   ERROR: {}\", sanity.unwrap_err());\r\n                    failed += 1;\r\n                } else {\r\n                    passed += 1;\r\n                }\r\n            } else {\r\n                println!(\"? {} ({}): No price\", family.name, family.base_article_nr);\r\n                no_price += 1;\r\n            }\r\n        }\r\n\r\n        println!(\"\\n=== Summary ===\");\r\n        println!(\"Passed: {}\", passed);\r\n        println!(\"Failed: {}\", failed);\r\n        println!(\"No price: {}\", no_price);\r\n\r\n        // For now, just report - don't fail the test until we fix the issues\r\n        if failed > 0 {\r\n            println!(\"\\nWARNING: {} products have invalid prices!\", failed);\r\n        }\r\n    }\r\n\r\n    /// Validate surcharge consistency\r\n    /// Example: 4x power + HDMI should NOT cost same as 2x USB\r\n    #[test]\r\n    fn test_surcharge_consistency() {\r\n        if !ofmldata_exists() {\r\n            eprintln!(\"Skipping: ofmldata not found\");\r\n            return;\r\n        }\r\n\r\n        // This test validates that surcharge amounts are reasonable\r\n        // based on the option being selected\r\n\r\n        let mfr_path = Path::new(OFMLDATA_BASE).join(\"framery\");\r\n        let loader = FamilyLoader::load(&mfr_path, \"DE\");\r\n        let engine = ConfigurationEngine::new(OFMLDATA_BASE);\r\n        let price_date = chrono::Local::now().date_naive();\r\n\r\n        println!(\"\\n=== Surcharge Consistency Check ===\\n\");\r\n\r\n        for family in loader.get_families().iter().take(3) {\r\n            let properties = loader.get_properties_for_family(family);\r\n\r\n            // Find power-related properties\r\n            let power_props: Vec<_> = properties.iter()\r\n                .filter(|p| p.key.contains(\"POWER\") || p.key.contains(\"USB\") || p.key.contains(\"HDMI\"))\r\n                .collect();\r\n\r\n            if power_props.is_empty() {\r\n                continue;\r\n            }\r\n\r\n            println!(\"Family: {}\", family.name);\r\n\r\n            for prop in power_props {\r\n                println!(\"  Property: {} ({} options)\", prop.key, prop.options.len());\r\n\r\n                for opt in &prop.options {\r\n                    let mut config = FamilyConfiguration::new(&family.id, &properties);\r\n                    config.set(&prop.key, &opt.value);\r\n\r\n                    if let Some(price) = engine.calculate_family_price(\"framery\", family, &config, price_date) {\r\n                        let surcharge_total: f64 = price.surcharges.iter()\r\n                            .map(|s| s.amount.to_string().parse::<f64>().unwrap_or(0.0))\r\n                            .sum();\r\n\r\n                        println!(\"    {} -> {:.2} EUR surcharges\", opt.value, surcharge_total);\r\n                    }\r\n                }\r\n            }\r\n            println!();\r\n        }\r\n    }\r\n\r\n    /// Full multi-manufacturer validation\r\n    #[test]\r\n    fn test_multi_manufacturer_price_validation() {\r\n        if !ofmldata_exists() {\r\n            eprintln!(\"Skipping: ofmldata not found\");\r\n            return;\r\n        }\r\n\r\n        let manufacturers = [\"framery\", \"sex\", \"vitra\", \"sbu\", \"haw\"];\r\n        let engine = ConfigurationEngine::new(OFMLDATA_BASE);\r\n        let price_date = chrono::Local::now().date_naive();\r\n\r\n        println!(\"\\n=== Multi-Manufacturer Price Validation ===\\n\");\r\n\r\n        let mut total_passed = 0;\r\n        let mut total_failed = 0;\r\n\r\n        for mfr_id in &manufacturers {\r\n            let mfr_path = Path::new(OFMLDATA_BASE).join(mfr_id);\r\n            if !mfr_path.exists() {\r\n                continue;\r\n            }\r\n\r\n            let loader = FamilyLoader::load(&mfr_path, \"DE\");\r\n            let families = loader.get_families();\r\n\r\n            let mut mfr_passed = 0;\r\n            let mut mfr_failed = 0;\r\n\r\n            for family in families.iter().take(5) {\r\n                let properties = loader.get_properties_for_family(family);\r\n                let config = FamilyConfiguration::new(&family.id, &properties);\r\n\r\n                if let Some(price) = engine.calculate_family_price(mfr_id, family, &config, price_date) {\r\n                    let price_value: f64 = price.base_price.to_string().parse().unwrap_or(0.0);\r\n\r\n                    // Basic sanity: price should be > 0 and < 500,000 EUR\r\n                    if price_value > 0.0 && price_value < 500000.0 {\r\n                        mfr_passed += 1;\r\n                    } else {\r\n                        println!(\"  ‚úó {}/{}: {:.2} EUR (suspicious)\", mfr_id, family.base_article_nr, price_value);\r\n                        mfr_failed += 1;\r\n                    }\r\n                }\r\n            }\r\n\r\n            println!(\"{}: {}/{} products passed sanity check\", mfr_id, mfr_passed, mfr_passed + mfr_failed);\r\n            total_passed += mfr_passed;\r\n            total_failed += mfr_failed;\r\n        }\r\n\r\n        println!(\"\\nTotal: {}/{} passed\", total_passed, total_passed + total_failed);\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","relation_investigation.rs"],"content":"//! Investigation test for ocd_relation rules\r\n\r\nuse std::path::Path;\r\n\r\nuse ofml_lib::ebase::{EBaseReader, Value};\r\n\r\n/// Convert a Value to a displayable string\r\nfn value_to_string(v: &Value) -> String {\r\n    match v {\r\n        Value::Int(i) => i.to_string(),\r\n        Value::UInt(u) => u.to_string(),\r\n        Value::Float(f) => f.to_string(),\r\n        Value::String(s) => s.clone(),\r\n        Value::Blob(b) => format!(\"<blob:{}>\", b),\r\n        Value::Null => String::new(),\r\n    }\r\n}\r\n\r\nfn get_str(record: &std::collections::HashMap<String, Value>, key: &str) -> String {\r\n    record.get(key).map(value_to_string).unwrap_or_default()\r\n}\r\n\r\n#[test]\r\nfn test_dump_framery_relations() {\r\n    let path = Path::new(\"/reference/ofmldata/framery/frmr_one/ANY/1/db/pdata.ebase\");\r\n    if !path.exists() {\r\n        eprintln!(\"Skipping: path not found\");\r\n        return;\r\n    }\r\n\r\n    let mut reader = EBaseReader::open(path).expect(\"Failed to open ebase\");\r\n\r\n    println!(\"\\n=== ocd_relation records ===\\n\");\r\n    match reader.read_records(\"ocd_relation\", None) {\r\n        Ok(records) => {\r\n            for (i, record) in records.iter().enumerate() {\r\n                let rel_name = get_str(record, \"rel_name\");\r\n                let rel_blocknr = get_str(record, \"rel_blocknr\");\r\n                let rel_block = get_str(record, \"rel_block\");\r\n                println!(\"  [{}] name='{}' blocknr={}\", i, rel_name, rel_blocknr);\r\n                println!(\"      block: {}\", rel_block);\r\n            }\r\n            println!(\"  Total: {} relation rules\", records.len());\r\n        }\r\n        Err(e) => println!(\"  Table 'ocd_relation' error: {}\", e),\r\n    }\r\n\r\n    println!(\"\\n=== ocd_relationobj records ===\\n\");\r\n    match reader.read_records(\"ocd_relationobj\", None) {\r\n        Ok(records) => {\r\n            for (i, record) in records.iter().enumerate() {\r\n                let rel_obj = get_str(record, \"rel_obj\");\r\n                let position = get_str(record, \"position\");\r\n                let rel_name = get_str(record, \"rel_name\");\r\n                let rel_type = get_str(record, \"rel_type\");\r\n                let rel_domain = get_str(record, \"rel_domain\");\r\n                println!(\"  [{}] obj={} pos={} name='{}' type='{}' domain='{}'\",\r\n                    i, rel_obj, position, rel_name, rel_type, rel_domain);\r\n            }\r\n        }\r\n        Err(e) => println!(\"  Table 'ocd_relationobj' error: {}\", e),\r\n    }\r\n\r\n    // Check if pricing domain relations exist\r\n    println!(\"\\n=== Pricing domain analysis ===\\n\");\r\n    match reader.read_records(\"ocd_relationobj\", None) {\r\n        Ok(records) => {\r\n            let mut pricing_count = 0;\r\n            for record in &records {\r\n                let rel_domain = get_str(record, \"rel_domain\");\r\n                if rel_domain.contains(\"P\") {\r\n                    pricing_count += 1;\r\n                    let rel_name = get_str(record, \"rel_name\");\r\n                    println!(\"  PRICING relation: {}\", rel_name);\r\n                }\r\n            }\r\n            println!(\"\\n  Total pricing relations: {}\", pricing_count);\r\n        }\r\n        Err(_) => {}\r\n    }\r\n}\r\n\r\n#[test]\r\nfn test_dump_framery_2q_relations() {\r\n    // Compare with frmr_2q which has working prices\r\n    let path = Path::new(\"/reference/ofmldata/framery/frmr_2q/ANY/1/db/pdata.ebase\");\r\n    if !path.exists() {\r\n        eprintln!(\"Skipping: path not found\");\r\n        return;\r\n    }\r\n\r\n    let mut reader = EBaseReader::open(path).expect(\"Failed to open ebase\");\r\n\r\n    println!(\"\\n=== frmr_2q ocd_relation records ===\\n\");\r\n    match reader.read_records(\"ocd_relation\", Some(10)) {\r\n        Ok(records) => {\r\n            for record in &records {\r\n                let rel_name = get_str(record, \"rel_name\");\r\n                let rel_block = get_str(record, \"rel_block\");\r\n                println!(\"  name='{}' block: {}\", rel_name, rel_block);\r\n            }\r\n        }\r\n        Err(e) => println!(\"  Error: {}\", e),\r\n    }\r\n}\r\n\r\n#[test]\r\nfn test_check_propertyvalue_relobjid() {\r\n    // Check if propertyvalues have rel_obj IDs that link to pricing rules\r\n    let path = Path::new(\"/reference/ofmldata/framery/frmr_one/ANY/1/db/pdata.ebase\");\r\n    if !path.exists() {\r\n        eprintln!(\"Skipping: path not found\");\r\n        return;\r\n    }\r\n\r\n    let mut reader = EBaseReader::open(path).expect(\"Failed to open ebase\");\r\n\r\n    println!(\"\\n=== ocd_propertyvalue with rel_obj ===\\n\");\r\n    match reader.read_records(\"ocd_propertyvalue\", Some(100)) {\r\n        Ok(records) => {\r\n            let mut with_rel_obj = 0;\r\n            for record in &records {\r\n                let rel_obj = get_str(record, \"rel_obj\");\r\n                let prop_value = get_str(record, \"prop_value\");\r\n                let property = get_str(record, \"property\");\r\n\r\n                if !rel_obj.is_empty() && rel_obj != \"0\" {\r\n                    with_rel_obj += 1;\r\n                    println!(\"  {} = {} -> rel_obj={}\", property, prop_value, rel_obj);\r\n                }\r\n            }\r\n            println!(\"\\n  Values with rel_obj: {}\", with_rel_obj);\r\n        }\r\n        Err(e) => println!(\"  Error: {}\", e),\r\n    }\r\n}\r\n\r\n#[test]\r\nfn test_analyze_framery_pricing_rules() {\r\n    // Try to understand how Framery determines surcharges\r\n    let path = Path::new(\"/reference/ofmldata/framery/frmr_one/ANY/1/db/pdata.ebase\");\r\n    if !path.exists() {\r\n        eprintln!(\"Skipping: path not found\");\r\n        return;\r\n    }\r\n\r\n    let mut reader = EBaseReader::open(path).expect(\"Failed to open ebase\");\r\n\r\n    println!(\"\\n=== Framery Pricing Analysis ===\\n\");\r\n\r\n    // Get all surcharges\r\n    println!(\"Surcharges (level='X'):\");\r\n    match reader.read_records(\"ocd_price\", None) {\r\n        Ok(records) => {\r\n            for record in &records {\r\n                let level = get_str(record, \"price_level\");\r\n                if level == \"X\" {\r\n                    let var_cond = get_str(record, \"var_cond\");\r\n                    let price = get_str(record, \"price\");\r\n                    println!(\"  {} = {} EUR\", var_cond, price);\r\n                }\r\n            }\r\n        }\r\n        Err(e) => println!(\"  Error: {}\", e),\r\n    }\r\n\r\n    // Check ocd_pricetext for var_cond descriptions\r\n    println!(\"\\nPrice text descriptions:\");\r\n    match reader.read_records(\"ocd_pricetext\", Some(30)) {\r\n        Ok(records) => {\r\n            for record in &records {\r\n                let textnr = get_str(record, \"textnr\");\r\n                let text = get_str(record, \"text\");\r\n                let language = get_str(record, \"language\");\r\n                if language.to_uppercase().contains(\"EN\") || language.to_uppercase().contains(\"DE\") {\r\n                    println!(\"  [{}] {} = {}\", language, textnr, text);\r\n                }\r\n            }\r\n        }\r\n        Err(e) => println!(\"  Error: {}\", e),\r\n    }\r\n}\r\n\r\n#[test]\r\nfn test_analyze_frmr_one_property_classes() {\r\n    // Check what property classes map to FRMR_ONE articles\r\n    let path = Path::new(\"/reference/ofmldata/framery/frmr_one/ANY/1/db/pdata.ebase\");\r\n    if !path.exists() {\r\n        eprintln!(\"Skipping: path not found\");\r\n        return;\r\n    }\r\n\r\n    let mut reader = EBaseReader::open(path).expect(\"Failed to open ebase\");\r\n\r\n    println!(\"\\n=== FRMR_ONE Property Classes ===\\n\");\r\n\r\n    // Check ocd_article first\r\n    println!(\"Articles:\");\r\n    match reader.read_records(\"ocd_article\", None) {\r\n        Ok(records) => {\r\n            for record in &records {\r\n                let art_nr = get_str(record, \"article_nr\");\r\n                let prop_class = get_str(record, \"prop_class\");\r\n                println!(\"  {} -> prop_class={}\", art_nr, prop_class);\r\n            }\r\n        }\r\n        Err(e) => println!(\"  Error: {}\", e),\r\n    }\r\n\r\n    // Check property class definitions\r\n    println!(\"\\nProperty class definitions:\");\r\n    match reader.read_records(\"ocd_propertyclass\", None) {\r\n        Ok(records) => {\r\n            for record in &records {\r\n                let prop_class = get_str(record, \"prop_class\");\r\n                let property = get_str(record, \"property\");\r\n                let position = get_str(record, \"position\");\r\n                println!(\"  {} pos={} property={}\", prop_class, position, property);\r\n            }\r\n        }\r\n        Err(e) => println!(\"  Error: {}\", e),\r\n    }\r\n\r\n    // Check price entries\r\n    println!(\"\\nPrice entries:\");\r\n    match reader.read_records(\"ocd_price\", None) {\r\n        Ok(records) => {\r\n            for record in &records {\r\n                let art_nr = get_str(record, \"article_nr\");\r\n                let level = get_str(record, \"price_level\");\r\n                let var_cond = get_str(record, \"var_cond\");\r\n                let price = get_str(record, \"price\");\r\n                println!(\"  art={} level={} var_cond={} price={}\", art_nr, level, var_cond, price);\r\n            }\r\n        }\r\n        Err(e) => println!(\"  Error: {}\", e),\r\n    }\r\n}\r\n\r\n#[test]\r\nfn test_frmr_one_varcond_structure() {\r\n    // Deep dive: understand how Framery assigns var_cond for pricing\r\n    let path = Path::new(\"/reference/ofmldata/framery/frmr_one/ANY/1/db/pdata.ebase\");\r\n    if !path.exists() {\r\n        eprintln!(\"Skipping: path not found\");\r\n        return;\r\n    }\r\n\r\n    let mut reader = EBaseReader::open(path).expect(\"Failed to open ebase\");\r\n\r\n    println!(\"\\n=== FRMR_ONE Variant Condition Analysis ===\\n\");\r\n\r\n    // Check if property values have var_cond assignments\r\n    println!(\"Property values with var_cond:\");\r\n    match reader.read_records(\"ocd_propertyvalue\", None) {\r\n        Ok(records) => {\r\n            for record in &records {\r\n                let property = get_str(record, \"property\");\r\n                let prop_value = get_str(record, \"prop_value\");\r\n                let var_cond = get_str(record, \"var_cond\");\r\n\r\n                if !var_cond.is_empty() {\r\n                    println!(\"  {}.{} -> var_cond={}\", property, prop_value, var_cond);\r\n                }\r\n            }\r\n            println!(\"  Total property values: {}\", records.len());\r\n        }\r\n        Err(e) => println!(\"  Error: {}\", e),\r\n    }\r\n\r\n    // Check propvalue2varcond table\r\n    println!(\"\\npropvalue2varcond table:\");\r\n    match reader.read_records(\"ocd_propvalue2varcond\", None) {\r\n        Ok(records) => {\r\n            for record in &records {\r\n                let prop_class = get_str(record, \"prop_class\");\r\n                let property = get_str(record, \"property\");\r\n                let prop_value = get_str(record, \"prop_value\");\r\n                let var_cond = get_str(record, \"var_cond\");\r\n                println!(\"  {}.{}.{} -> {}\", prop_class, property, prop_value, var_cond);\r\n            }\r\n            println!(\"  Total mappings: {}\", records.len());\r\n        }\r\n        Err(e) => println!(\"  propvalue2varcond: {}\", e),\r\n    }\r\n\r\n    // Check varcond2amount table\r\n    println!(\"\\nvarcond2amount table:\");\r\n    match reader.read_records(\"ocd_varcond2amount\", None) {\r\n        Ok(records) => {\r\n            for record in &records {\r\n                let var_cond = get_str(record, \"var_cond\");\r\n                let amount = get_str(record, \"amount\");\r\n                let table_name = get_str(record, \"table_name\");\r\n                println!(\"  {} -> amount={} table={}\", var_cond, amount, table_name);\r\n            }\r\n            println!(\"  Total varcond2amount entries: {}\", records.len());\r\n        }\r\n        Err(e) => println!(\"  varcond2amount: {}\", e),\r\n    }\r\n}\r\n\r\n#[test]\r\nfn test_list_all_tables() {\r\n    // List all tables in the FRMR_ONE database to understand its structure\r\n    let path = Path::new(\"/reference/ofmldata/framery/frmr_one/ANY/1/db/pdata.ebase\");\r\n    if !path.exists() {\r\n        eprintln!(\"Skipping: path not found\");\r\n        return;\r\n    }\r\n\r\n    let reader = EBaseReader::open(path).expect(\"Failed to open ebase\");\r\n\r\n    println!(\"\\n=== Tables in FRMR_ONE pdata.ebase ===\\n\");\r\n    let tables = reader.table_names();\r\n    for name in &tables {\r\n        if let Some(table) = reader.tables.get(*name) {\r\n            println!(\"  {} ({} records, {} columns)\",\r\n                name, table.record_count, table.columns.len());\r\n        }\r\n    }\r\n    println!(\"\\n  Total: {} tables\", tables.len());\r\n}\r\n\r\n#[test]\r\nfn test_compare_frmr_2q_structure() {\r\n    // Compare frmr_2q structure (has base prices) with frmr_one\r\n    let path = Path::new(\"/reference/ofmldata/framery/frmr_2q/ANY/1/db/pdata.ebase\");\r\n    if !path.exists() {\r\n        eprintln!(\"Skipping: path not found\");\r\n        return;\r\n    }\r\n\r\n    let mut reader = EBaseReader::open(path).expect(\"Failed to open ebase\");\r\n\r\n    println!(\"\\n=== FRMR_2Q Structure Analysis ===\\n\");\r\n\r\n    // Check articles\r\n    println!(\"Articles:\");\r\n    match reader.read_records(\"ocd_article\", None) {\r\n        Ok(records) => {\r\n            for record in &records {\r\n                let art_nr = get_str(record, \"article_nr\");\r\n                let prop_class = get_str(record, \"prop_class\");\r\n                println!(\"  {} -> prop_class={}\", art_nr, prop_class);\r\n            }\r\n        }\r\n        Err(e) => println!(\"  Error: {}\", e),\r\n    }\r\n\r\n    // Check base prices\r\n    println!(\"\\nBase prices (level='B'):\");\r\n    match reader.read_records(\"ocd_price\", None) {\r\n        Ok(records) => {\r\n            for record in &records {\r\n                let level = get_str(record, \"price_level\");\r\n                if level == \"B\" {\r\n                    let art_nr = get_str(record, \"article_nr\");\r\n                    let var_cond = get_str(record, \"var_cond\");\r\n                    let price = get_str(record, \"price\");\r\n                    println!(\"  art={} var_cond={} price={}\", art_nr, var_cond, price);\r\n                }\r\n            }\r\n        }\r\n        Err(e) => println!(\"  Error: {}\", e),\r\n    }\r\n\r\n    // Check surcharges\r\n    println!(\"\\nSurcharges (level='X'):\");\r\n    match reader.read_records(\"ocd_price\", None) {\r\n        Ok(records) => {\r\n            for record in &records {\r\n                let level = get_str(record, \"price_level\");\r\n                if level == \"X\" {\r\n                    let art_nr = get_str(record, \"article_nr\");\r\n                    let var_cond = get_str(record, \"var_cond\");\r\n                    let price = get_str(record, \"price\");\r\n                    println!(\"  art={} var_cond={} price={}\", art_nr, var_cond, price);\r\n                }\r\n            }\r\n        }\r\n        Err(e) => println!(\"  Error: {}\", e),\r\n    }\r\n\r\n    // Check ocd_relationobj for pricing domain\r\n    println!(\"\\nRelation objects:\");\r\n    match reader.read_records(\"ocd_relationobj\", None) {\r\n        Ok(records) => {\r\n            for record in &records {\r\n                let rel_name = get_str(record, \"rel_name\");\r\n                let rel_domain = get_str(record, \"rel_domain\");\r\n                let rel_type = get_str(record, \"rel_type\");\r\n                println!(\"  name={} domain={} type={}\", rel_name, rel_domain, rel_type);\r\n            }\r\n        }\r\n        Err(e) => println!(\"  Error: {}\", e),\r\n    }\r\n}\r\n\r\n#[test]\r\nfn test_frmr_one_with_frmr_o_base_prices() {\r\n    // Check if FRMR_ONE base prices might come from frmr_o series\r\n    let paths = [\r\n        \"/reference/ofmldata/framery/frmr_o/ANY/1/db/pdata.ebase\",\r\n        \"/reference/ofmldata/framery/frmr_o/DE/1/db/pdata.ebase\",\r\n    ];\r\n\r\n    for path_str in &paths {\r\n        let path = Path::new(path_str);\r\n        if !path.exists() {\r\n            continue;\r\n        }\r\n\r\n        let mut reader = EBaseReader::open(path).expect(\"Failed to open ebase\");\r\n\r\n        println!(\"\\n=== {} ===\\n\", path_str);\r\n\r\n        // Check if it has ONE article prices\r\n        println!(\"Articles containing 'ONE':\");\r\n        match reader.read_records(\"ocd_article\", None) {\r\n            Ok(records) => {\r\n                for record in &records {\r\n                    let art_nr = get_str(record, \"article_nr\");\r\n                    if art_nr.contains(\"ONE\") {\r\n                        let prop_class = get_str(record, \"prop_class\");\r\n                        println!(\"  {} -> prop_class={}\", art_nr, prop_class);\r\n                    }\r\n                }\r\n            }\r\n            Err(e) => println!(\"  Error: {}\", e),\r\n        }\r\n\r\n        // Check base prices for ONE\r\n        println!(\"\\nBase prices (level='B') for ONE:\");\r\n        match reader.read_records(\"ocd_price\", None) {\r\n            Ok(records) => {\r\n                for record in &records {\r\n                    let level = get_str(record, \"price_level\");\r\n                    let art_nr = get_str(record, \"article_nr\");\r\n                    if level == \"B\" && (art_nr.contains(\"ONE\") || art_nr == \"*\") {\r\n                        let var_cond = get_str(record, \"var_cond\");\r\n                        let price = get_str(record, \"price\");\r\n                        println!(\"  art={} var_cond={} price={}\", art_nr, var_cond, price);\r\n                    }\r\n                }\r\n            }\r\n            Err(e) => println!(\"  Error: {}\", e),\r\n        }\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","texture_tests.rs"],"content":"//! Integration tests for texture loading system.\n//!\n//! These tests verify texture loading, caching, and GLB integration.\n\nuse ofml_lib::geometry::{scene_to_glb, EmbeddedTexture, Material3DS, Scene3DS};\nuse ofml_lib::texture::{create_checkerboard, create_solid_color, TextureCache};\nuse std::collections::HashMap;\n\n/// Test creating solid color textures\n#[test]\nfn test_solid_color_texture() {\n    let tex = create_solid_color(\"red\", 255, 0, 0, 255).unwrap();\n    assert_eq!(tex.name, \"red\");\n    assert_eq!(tex.width, 1);\n    assert_eq!(tex.height, 1);\n    assert!(!tex.png_data.is_empty());\n    assert_eq!(tex.mime_type(), \"image/png\");\n}\n\n/// Test creating checkerboard textures\n#[test]\nfn test_checkerboard_texture() {\n    let tex = create_checkerboard(\"checker\", 64, [255, 255, 255, 255], [0, 0, 0, 255]).unwrap();\n    assert_eq!(tex.name, \"checker\");\n    assert_eq!(tex.width, 64);\n    assert_eq!(tex.height, 64);\n    assert!(tex.byte_size() > 0);\n}\n\n/// Test texture cache operations\n#[test]\nfn test_texture_cache() {\n    let mut cache = TextureCache::new();\n\n    // Cache should be initially empty\n    assert!(cache.is_empty());\n    assert_eq!(cache.len(), 0);\n\n    // Add textures\n    let tex1 = create_solid_color(\"white\", 255, 255, 255, 255).unwrap();\n    let tex2 = create_solid_color(\"black\", 0, 0, 0, 255).unwrap();\n\n    cache.insert(tex1);\n    cache.insert(tex2);\n\n    // Check cache state\n    assert_eq!(cache.len(), 2);\n    assert!(!cache.is_empty());\n    assert!(cache.contains(\"white\"));\n    assert!(cache.contains(\"black\"));\n    assert!(!cache.contains(\"red\"));\n\n    // Retrieve textures\n    let white = cache.get(\"white\").unwrap();\n    assert_eq!(white.name, \"white\");\n}\n\n/// Test texture iteration\n#[test]\nfn test_texture_cache_iteration() {\n    let mut cache = TextureCache::new();\n\n    cache.insert(create_solid_color(\"red\", 255, 0, 0, 255).unwrap());\n    cache.insert(create_solid_color(\"green\", 0, 255, 0, 255).unwrap());\n    cache.insert(create_solid_color(\"blue\", 0, 0, 255, 255).unwrap());\n\n    // Check names\n    let names: Vec<_> = cache.names().into_iter().collect();\n    assert_eq!(names.len(), 3);\n\n    // Check all textures\n    let count = cache.all().count();\n    assert_eq!(count, 3);\n}\n\n/// Test cache clear\n#[test]\nfn test_texture_cache_clear() {\n    let mut cache = TextureCache::new();\n\n    cache.insert(create_solid_color(\"test\", 128, 128, 128, 255).unwrap());\n    assert!(!cache.is_empty());\n\n    cache.clear();\n    assert!(cache.is_empty());\n}\n\n/// Test Scene3DS with embedded textures\n#[test]\nfn test_scene_with_textures() {\n    // Create a texture\n    let tex = create_solid_color(\"wood\", 139, 90, 43, 255).unwrap();\n\n    // Create scene with texture\n    let mut scene = Scene3DS::default();\n    scene.textures.push(EmbeddedTexture {\n        name: tex.name.clone(),\n        data: tex.png_data.clone(),\n        width: tex.width,\n        height: tex.height,\n    });\n\n    // Add a material that references the texture\n    scene.materials.insert(\n        \"wood_material\".to_string(),\n        Material3DS {\n            name: \"wood_material\".to_string(),\n            ambient: [0.1, 0.1, 0.1],\n            diffuse: [0.8, 0.6, 0.4],\n            specular: [0.3, 0.3, 0.3],\n            texture: Some(\"wood\".to_string()),\n            metallic: 0.0,\n            roughness: 0.7,\n        },\n    );\n\n    // Verify scene state\n    assert_eq!(scene.textures.len(), 1);\n    assert_eq!(scene.materials.len(), 1);\n\n    // The material should reference the texture\n    let mat = scene.materials.get(\"wood_material\").unwrap();\n    assert_eq!(mat.texture.as_ref().unwrap(), \"wood\");\n}\n\n/// Test GLB export with textures\n#[test]\nfn test_glb_export_with_textures() {\n    use ofml_lib::geometry::{CoordSystem, Face, Mesh, Vertex};\n\n    // Create texture\n    let tex = create_solid_color(\"test_tex\", 200, 150, 100, 255).unwrap();\n\n    // Create a simple cube mesh\n    let vertices = vec![\n        Vertex {\n            x: 0.0,\n            y: 0.0,\n            z: 0.0,\n        },\n        Vertex {\n            x: 1.0,\n            y: 0.0,\n            z: 0.0,\n        },\n        Vertex {\n            x: 1.0,\n            y: 1.0,\n            z: 0.0,\n        },\n        Vertex {\n            x: 0.0,\n            y: 1.0,\n            z: 0.0,\n        },\n        Vertex {\n            x: 0.0,\n            y: 0.0,\n            z: 1.0,\n        },\n        Vertex {\n            x: 1.0,\n            y: 0.0,\n            z: 1.0,\n        },\n        Vertex {\n            x: 1.0,\n            y: 1.0,\n            z: 1.0,\n        },\n        Vertex {\n            x: 0.0,\n            y: 1.0,\n            z: 1.0,\n        },\n    ];\n\n    let faces = vec![\n        Face {\n            a: 0,\n            b: 1,\n            c: 2,\n            flags: 0,\n        },\n        Face {\n            a: 0,\n            b: 2,\n            c: 3,\n            flags: 0,\n        },\n        Face {\n            a: 4,\n            b: 6,\n            c: 5,\n            flags: 0,\n        },\n        Face {\n            a: 4,\n            b: 7,\n            c: 6,\n            flags: 0,\n        },\n    ];\n\n    let mesh = Mesh {\n        name: \"cube\".to_string(),\n        vertices,\n        normals: Vec::new(),\n        faces,\n        tex_coords: Vec::new(),\n        material_name: Some(\"textured_material\".to_string()),\n        transform: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0],\n        coord_system: CoordSystem::YupGltf,\n    };\n\n    // Create scene with texture and material\n    let mut materials = HashMap::new();\n    materials.insert(\n        \"textured_material\".to_string(),\n        Material3DS {\n            name: \"textured_material\".to_string(),\n            ambient: [0.1, 0.1, 0.1],\n            diffuse: [1.0, 1.0, 1.0],\n            specular: [0.5, 0.5, 0.5],\n            texture: Some(\"test_tex\".to_string()),\n            metallic: 0.0,\n            roughness: 0.5,\n        },\n    );\n\n    let scene = Scene3DS {\n        meshes: vec![mesh],\n        materials,\n        textures: vec![EmbeddedTexture {\n            name: tex.name.clone(),\n            data: tex.png_data.clone(),\n            width: tex.width,\n            height: tex.height,\n        }],\n    };\n\n    // Export to GLB\n    let glb = scene_to_glb(&scene).expect(\"GLB export should succeed\");\n\n    // Verify GLB header\n    assert!(glb.len() > 12, \"GLB should have header\");\n    assert_eq!(&glb[0..4], b\"glTF\", \"Should have glTF magic\");\n\n    // Version should be 2\n    let version = u32::from_le_bytes([glb[4], glb[5], glb[6], glb[7]]);\n    assert_eq!(version, 2, \"Version should be 2\");\n\n    // GLB should be larger because of embedded texture\n    assert!(glb.len() > 500, \"GLB with texture should be substantial\");\n}\n\n/// Test material with PBR properties\n#[test]\nfn test_material_pbr_properties() {\n    let mat = Material3DS {\n        name: \"metallic_mat\".to_string(),\n        ambient: [0.1, 0.1, 0.1],\n        diffuse: [0.8, 0.8, 0.8],\n        specular: [1.0, 1.0, 1.0],\n        texture: None,\n        metallic: 0.9,\n        roughness: 0.1,\n    };\n\n    assert_eq!(mat.name, \"metallic_mat\");\n    assert!((mat.metallic - 0.9).abs() < 0.01);\n    assert!((mat.roughness - 0.1).abs() < 0.01);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","unit","oap_actions_test.rs"],"content":"//! Unit tests for OAP actions (T054, T055)\n\nuse ofml_lib::oap::actions::{\n    OAPAction, OAPActionProcessor, OAPActionResult, OAPCreateObjectAction, OAPPropEditAction,\n    OAPShowMediaAction,\n};\nuse ofml_lib::oap::config::Configuration;\nuse ofml_lib::property::PropertyValue;\n\n// =============================================================================\n// T054: Unit test for OAPCreateObjectAction\n// =============================================================================\n\n#[test]\nfn test_create_object_action_structure() {\n    let action = OAPCreateObjectAction {\n        class_name: \"ChildPart\".to_string(),\n        properties: vec![\n            (\"color\".to_string(), \"white\".to_string()),\n            (\"height\".to_string(), \"720\".to_string()),\n        ],\n        relationship: \"child\".to_string(),\n    };\n\n    assert_eq!(action.class_name, \"ChildPart\");\n    assert_eq!(action.properties.len(), 2);\n    assert_eq!(action.relationship, \"child\");\n}\n\n#[test]\nfn test_create_object_action_processing() {\n    let processor = OAPActionProcessor::new();\n    let mut parent = Configuration::new(\"ParentArticle\".to_string(), \"vitra\".to_string());\n\n    let action = OAPAction::CreateObject(OAPCreateObjectAction {\n        class_name: \"ChildPart\".to_string(),\n        properties: vec![(\"color\".to_string(), \"white\".to_string())],\n        relationship: \"child\".to_string(),\n    });\n\n    let result = processor.process(&action, &mut parent);\n\n    assert!(result.success);\n    assert_eq!(result.action_type, \"create\");\n    assert!(result.created_object.is_some());\n    assert!(result.error_message.is_none());\n}\n\n#[test]\nfn test_create_object_adds_to_sub_articles() {\n    let processor = OAPActionProcessor::new();\n    let mut parent = Configuration::new(\"ParentArticle\".to_string(), \"vitra\".to_string());\n\n    assert!(parent.sub_articles.is_empty());\n\n    let action = OAPAction::CreateObject(OAPCreateObjectAction {\n        class_name: \"ChildPart\".to_string(),\n        properties: vec![],\n        relationship: \"child\".to_string(),\n    });\n\n    processor.process(&action, &mut parent);\n\n    assert_eq!(parent.sub_articles.len(), 1);\n    assert_eq!(parent.sub_articles[0].article_id, \"ChildPart\");\n}\n\n#[test]\nfn test_create_object_sets_properties() {\n    let processor = OAPActionProcessor::new();\n    let mut parent = Configuration::new(\"Parent\".to_string(), \"vitra\".to_string());\n\n    let action = OAPAction::CreateObject(OAPCreateObjectAction {\n        class_name: \"Child\".to_string(),\n        properties: vec![\n            (\"height\".to_string(), \"720\".to_string()),\n            (\"enabled\".to_string(), \"true\".to_string()),\n        ],\n        relationship: \"child\".to_string(),\n    });\n\n    let result = processor.process(&action, &mut parent);\n\n    assert!(result.success);\n    let child = result.created_object.unwrap();\n\n    // Check properties were set\n    assert!(child.properties.values.contains_key(\"height\"));\n    assert!(child.properties.values.contains_key(\"enabled\"));\n}\n\n#[test]\nfn test_create_multiple_sub_articles() {\n    let processor = OAPActionProcessor::new();\n    let mut parent = Configuration::new(\"Parent\".to_string(), \"vitra\".to_string());\n\n    for i in 0..3 {\n        let action = OAPAction::CreateObject(OAPCreateObjectAction {\n            class_name: format!(\"Child{}\", i),\n            properties: vec![],\n            relationship: \"child\".to_string(),\n        });\n        processor.process(&action, &mut parent);\n    }\n\n    assert_eq!(parent.sub_articles.len(), 3);\n}\n\n// =============================================================================\n// T055: Unit test for OAPPropEditAction\n// =============================================================================\n\n#[test]\nfn test_prop_edit_action_structure() {\n    let action = OAPPropEditAction {\n        property_name: \"height\".to_string(),\n        value_expression: \"720\".to_string(),\n        condition: Some(\"color == 'white'\".to_string()),\n    };\n\n    assert_eq!(action.property_name, \"height\");\n    assert_eq!(action.value_expression, \"720\");\n    assert!(action.condition.is_some());\n}\n\n#[test]\nfn test_prop_edit_action_processing() {\n    let processor = OAPActionProcessor::new();\n    let mut config = Configuration::new(\"Article\".to_string(), \"vitra\".to_string());\n\n    let action = OAPAction::PropEdit(OAPPropEditAction {\n        property_name: \"height\".to_string(),\n        value_expression: \"720\".to_string(),\n        condition: None,\n    });\n\n    let result = processor.process(&action, &mut config);\n\n    assert!(result.success);\n    assert_eq!(result.action_type, \"edit\");\n    assert_eq!(result.modified_properties, vec![\"height\"]);\n}\n\n#[test]\nfn test_prop_edit_sets_int_value() {\n    let processor = OAPActionProcessor::new();\n    let mut config = Configuration::new(\"Article\".to_string(), \"vitra\".to_string());\n\n    let action = OAPAction::PropEdit(OAPPropEditAction {\n        property_name: \"height\".to_string(),\n        value_expression: \"720\".to_string(),\n        condition: None,\n    });\n\n    processor.process(&action, &mut config);\n\n    let value = config.properties.values.get(\"height\");\n    assert!(value.is_some());\n    assert_eq!(value.unwrap(), &PropertyValue::Int(720));\n}\n\n#[test]\nfn test_prop_edit_sets_float_value() {\n    let processor = OAPActionProcessor::new();\n    let mut config = Configuration::new(\"Article\".to_string(), \"vitra\".to_string());\n\n    let action = OAPAction::PropEdit(OAPPropEditAction {\n        property_name: \"width\".to_string(),\n        value_expression: \"1.5\".to_string(),\n        condition: None,\n    });\n\n    processor.process(&action, &mut config);\n\n    let value = config.properties.values.get(\"width\");\n    assert!(value.is_some());\n    assert_eq!(value.unwrap(), &PropertyValue::Float(1.5));\n}\n\n#[test]\nfn test_prop_edit_sets_bool_true() {\n    let processor = OAPActionProcessor::new();\n    let mut config = Configuration::new(\"Article\".to_string(), \"vitra\".to_string());\n\n    let action = OAPAction::PropEdit(OAPPropEditAction {\n        property_name: \"enabled\".to_string(),\n        value_expression: \"true\".to_string(),\n        condition: None,\n    });\n\n    processor.process(&action, &mut config);\n\n    let value = config.properties.values.get(\"enabled\");\n    assert!(value.is_some());\n    assert_eq!(value.unwrap(), &PropertyValue::Bool(true));\n}\n\n#[test]\nfn test_prop_edit_sets_bool_false() {\n    let processor = OAPActionProcessor::new();\n    let mut config = Configuration::new(\"Article\".to_string(), \"vitra\".to_string());\n\n    let action = OAPAction::PropEdit(OAPPropEditAction {\n        property_name: \"enabled\".to_string(),\n        value_expression: \"false\".to_string(),\n        condition: None,\n    });\n\n    processor.process(&action, &mut config);\n\n    let value = config.properties.values.get(\"enabled\");\n    assert!(value.is_some());\n    assert_eq!(value.unwrap(), &PropertyValue::Bool(false));\n}\n\n#[test]\nfn test_prop_edit_sets_string_value() {\n    let processor = OAPActionProcessor::new();\n    let mut config = Configuration::new(\"Article\".to_string(), \"vitra\".to_string());\n\n    let action = OAPAction::PropEdit(OAPPropEditAction {\n        property_name: \"description\".to_string(),\n        value_expression: \"Test description\".to_string(),\n        condition: None,\n    });\n\n    processor.process(&action, &mut config);\n\n    let value = config.properties.values.get(\"description\");\n    assert!(value.is_some());\n    assert_eq!(\n        value.unwrap(),\n        &PropertyValue::String(\"Test description\".to_string())\n    );\n}\n\n#[test]\nfn test_prop_edit_updates_existing_property() {\n    let processor = OAPActionProcessor::new();\n    let mut config = Configuration::new(\"Article\".to_string(), \"vitra\".to_string());\n\n    // Set initial value\n    config\n        .properties\n        .values\n        .insert(\"height\".to_string(), PropertyValue::Int(620));\n\n    // Update via action\n    let action = OAPAction::PropEdit(OAPPropEditAction {\n        property_name: \"height\".to_string(),\n        value_expression: \"720\".to_string(),\n        condition: None,\n    });\n\n    processor.process(&action, &mut config);\n\n    let value = config.properties.values.get(\"height\");\n    assert_eq!(value.unwrap(), &PropertyValue::Int(720));\n}\n\n#[test]\nfn test_prop_edit_updates_variant_code() {\n    let processor = OAPActionProcessor::new();\n    let mut config = Configuration::new(\"Article\".to_string(), \"vitra\".to_string());\n\n    let old_variant = config.variant_code.clone();\n\n    let action = OAPAction::PropEdit(OAPPropEditAction {\n        property_name: \"height\".to_string(),\n        value_expression: \"720\".to_string(),\n        condition: None,\n    });\n\n    processor.process(&action, &mut config);\n\n    // Variant code should be updated (even if it was empty before)\n    // The actual content depends on property definitions\n    assert!(config.variant_code != old_variant || config.variant_code.is_empty());\n}\n\n// =============================================================================\n// Additional action tests\n// =============================================================================\n\n#[test]\nfn test_show_media_action() {\n    let processor = OAPActionProcessor::new();\n    let mut config = Configuration::new(\"Article\".to_string(), \"vitra\".to_string());\n\n    let action = OAPAction::ShowMedia(OAPShowMediaAction {\n        media_type: \"image\".to_string(),\n        media_path: \"/images/preview.jpg\".to_string(),\n    });\n\n    let result = processor.process(&action, &mut config);\n\n    assert!(result.success);\n    assert_eq!(result.action_type, \"media\");\n    assert_eq!(\n        result.media_reference,\n        Some(\"/images/preview.jpg\".to_string())\n    );\n}\n\n#[test]\nfn test_action_result_failure() {\n    let result = OAPActionResult::failure(\"create\", \"Class not found\".to_string());\n\n    assert!(!result.success);\n    assert_eq!(result.action_type, \"create\");\n    assert_eq!(result.error_message, Some(\"Class not found\".to_string()));\n    assert!(result.created_object.is_none());\n}\n\n#[test]\nfn test_action_result_create_object_success() {\n    let config = Configuration::new(\"Child\".to_string(), \"vitra\".to_string());\n    let result = OAPActionResult::create_object_success(config);\n\n    assert!(result.success);\n    assert_eq!(result.action_type, \"create\");\n    assert!(result.created_object.is_some());\n    assert!(result.error_message.is_none());\n}\n\n#[test]\nfn test_action_result_prop_edit_success() {\n    let result =\n        OAPActionResult::prop_edit_success(vec![\"height\".to_string(), \"width\".to_string()]);\n\n    assert!(result.success);\n    assert_eq!(result.action_type, \"edit\");\n    assert_eq!(result.modified_properties.len(), 2);\n    assert!(result.created_object.is_none());\n}\n\n#[test]\nfn test_action_result_show_media_success() {\n    let result = OAPActionResult::show_media_success(\"/images/test.jpg\".to_string());\n\n    assert!(result.success);\n    assert_eq!(result.action_type, \"media\");\n    assert_eq!(result.media_reference, Some(\"/images/test.jpg\".to_string()));\n}\n\n#[test]\nfn test_action_processor_default() {\n    let processor = OAPActionProcessor::default();\n    let mut config = Configuration::new(\"Test\".to_string(), \"vitra\".to_string());\n\n    // Should work the same as ::new()\n    let action = OAPAction::PropEdit(OAPPropEditAction {\n        property_name: \"test\".to_string(),\n        value_expression: \"value\".to_string(),\n        condition: None,\n    });\n\n    let result = processor.process(&action, &mut config);\n    assert!(result.success);\n}\n\n#[test]\nfn test_oap_action_enum_variants() {\n    // Verify all variants can be created\n    let _create = OAPAction::CreateObject(OAPCreateObjectAction {\n        class_name: \"Test\".to_string(),\n        properties: vec![],\n        relationship: \"child\".to_string(),\n    });\n\n    let _edit = OAPAction::PropEdit(OAPPropEditAction {\n        property_name: \"test\".to_string(),\n        value_expression: \"value\".to_string(),\n        condition: None,\n    });\n\n    let _media = OAPAction::ShowMedia(OAPShowMediaAction {\n        media_type: \"image\".to_string(),\n        media_path: \"/test.jpg\".to_string(),\n    });\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","unit","oap_export_test.rs"],"content":"//! Unit tests for ExportData serialization (T049, T054)\r\n\r\nuse chrono::NaiveDate;\r\nuse rust_decimal::Decimal;\r\nuse serde_json::json;\r\nuse std::collections::HashMap;\r\n\r\nuse ofml_lib::oap::config::Configuration;\r\nuse ofml_lib::oap::{\r\n    ExportConfiguration, ExportData, ExportDiscountItem, ExportPricing, ExportSurcharge,\r\n    ExportSurchargeItem, ExportWarning, PriceResult, Surcharge,\r\n};\r\nuse ofml_lib::property::PropertyValue;\r\n\r\n#[test]\r\nfn test_export_data_serialization() {\r\n    let mut properties = HashMap::new();\r\n    properties.insert(\"height\".to_string(), json!(\"720\"));\r\n    properties.insert(\"diameter\".to_string(), json!(\"1200\"));\r\n    properties.insert(\"color\".to_string(), json!(\"white\"));\r\n\r\n    let export = ExportData {\r\n        manufacturer: \"vitra\".to_string(),\r\n        article: \"ViTable_Round\".to_string(),\r\n        article_number: Some(\"48-123-456\".to_string()),\r\n        variant_code: \"H720_D1200_white\".to_string(),\r\n        properties,\r\n        base_price: Some(\"1.234,56\".to_string()),\r\n        surcharges: Some(vec![]),\r\n        total_price: Some(\"1.234,56\".to_string()),\r\n        currency: Some(\"EUR\".to_string()),\r\n        price_date: Some(\"2025-12-24\".to_string()),\r\n        sub_articles: vec![],\r\n        exported_at: \"2025-12-24T10:30:00Z\".to_string(),\r\n    };\r\n\r\n    let json = serde_json::to_string_pretty(&export).unwrap();\r\n\r\n    assert!(json.contains(\"\\\"manufacturer\\\": \\\"vitra\\\"\"));\r\n    assert!(json.contains(\"\\\"article\\\": \\\"ViTable_Round\\\"\"));\r\n    assert!(json.contains(\"\\\"variant_code\\\": \\\"H720_D1200_white\\\"\"));\r\n    assert!(json.contains(\"\\\"base_price\\\": \\\"1.234,56\\\"\"));\r\n    assert!(json.contains(\"\\\"currency\\\": \\\"EUR\\\"\"));\r\n}\r\n\r\n#[test]\r\nfn test_export_data_deserialization() {\r\n    let json = r#\"{\r\n        \"manufacturer\": \"vitra\",\r\n        \"article\": \"ViTable\",\r\n        \"article_number\": null,\r\n        \"variant_code\": \"H720\",\r\n        \"properties\": {\"height\": \"720\"},\r\n        \"base_price\": \"100,00\",\r\n        \"surcharges\": [],\r\n        \"total_price\": \"100,00\",\r\n        \"currency\": \"EUR\",\r\n        \"price_date\": \"2025-12-24\",\r\n        \"sub_articles\": [],\r\n        \"exported_at\": \"2025-12-24T10:30:00Z\"\r\n    }\"#;\r\n\r\n    let export: ExportData = serde_json::from_str(json).unwrap();\r\n\r\n    assert_eq!(export.manufacturer, \"vitra\");\r\n    assert_eq!(export.article, \"ViTable\");\r\n    assert_eq!(export.variant_code, \"H720\");\r\n    assert!(export.properties.contains_key(\"height\"));\r\n}\r\n\r\n#[test]\r\nfn test_export_data_with_surcharges() {\r\n    let export = ExportData {\r\n        manufacturer: \"vitra\".to_string(),\r\n        article: \"ViTable\".to_string(),\r\n        article_number: None,\r\n        variant_code: \"H720\".to_string(),\r\n        properties: Default::default(),\r\n        base_price: Some(\"100,00\".to_string()),\r\n        surcharges: Some(vec![\r\n            ExportSurcharge {\r\n                name: \"Materialaufpreis\".to_string(),\r\n                amount: \"25,00\".to_string(),\r\n                is_percentage: false,\r\n            },\r\n            ExportSurcharge {\r\n                name: \"10% Aufschlag\".to_string(),\r\n                amount: \"10\".to_string(),\r\n                is_percentage: true,\r\n            },\r\n        ]),\r\n        total_price: Some(\"135,00\".to_string()),\r\n        currency: Some(\"EUR\".to_string()),\r\n        price_date: Some(\"2025-12-24\".to_string()),\r\n        sub_articles: vec![],\r\n        exported_at: \"2025-12-24T10:30:00Z\".to_string(),\r\n    };\r\n\r\n    let json = serde_json::to_string(&export).unwrap();\r\n\r\n    assert!(json.contains(\"Materialaufpreis\"));\r\n    // Note: is_percentage is skipped when false (skip_serializing_if)\r\n    assert!(json.contains(\"\\\"is_percentage\\\":true\"));\r\n}\r\n\r\n#[test]\r\nfn test_export_data_with_sub_articles() {\r\n    let sub_article = ExportData {\r\n        manufacturer: \"vitra\".to_string(),\r\n        article: \"Leg\".to_string(),\r\n        article_number: None,\r\n        variant_code: \"chrome\".to_string(),\r\n        properties: Default::default(),\r\n        base_price: Some(\"50,00\".to_string()),\r\n        surcharges: Some(vec![]),\r\n        total_price: Some(\"50,00\".to_string()),\r\n        currency: Some(\"EUR\".to_string()),\r\n        price_date: Some(\"2025-12-24\".to_string()),\r\n        sub_articles: vec![],\r\n        exported_at: \"2025-12-24T10:30:00Z\".to_string(),\r\n    };\r\n\r\n    let export = ExportData {\r\n        manufacturer: \"vitra\".to_string(),\r\n        article: \"Table\".to_string(),\r\n        article_number: None,\r\n        variant_code: \"H720\".to_string(),\r\n        properties: Default::default(),\r\n        base_price: Some(\"100,00\".to_string()),\r\n        surcharges: Some(vec![]),\r\n        total_price: Some(\"100,00\".to_string()),\r\n        currency: Some(\"EUR\".to_string()),\r\n        price_date: Some(\"2025-12-24\".to_string()),\r\n        sub_articles: vec![sub_article],\r\n        exported_at: \"2025-12-24T10:30:00Z\".to_string(),\r\n    };\r\n\r\n    let json = serde_json::to_string_pretty(&export).unwrap();\r\n\r\n    assert!(json.contains(\"\\\"sub_articles\\\"\"));\r\n    assert!(json.contains(\"\\\"article\\\": \\\"Leg\\\"\"));\r\n}\r\n\r\n#[test]\r\nfn test_configuration_to_export_data() {\r\n    let mut config = Configuration::new(\"TestArticle\".to_string(), \"vitra\".to_string());\r\n    config.article_number = Some(\"48-001\".to_string());\r\n    config.variant_code = \"H720_white\".to_string();\r\n\r\n    config\r\n        .properties\r\n        .values\r\n        .insert(\"height\".to_string(), PropertyValue::Int(720));\r\n    config.properties.values.insert(\r\n        \"color\".to_string(),\r\n        PropertyValue::Symbol(\"white\".to_string()),\r\n    );\r\n\r\n    // Set a price\r\n    config.price = Some(PriceResult::new(\r\n        Decimal::new(10000, 2),\r\n        vec![Surcharge {\r\n            name: \"Test\".to_string(),\r\n            amount: Decimal::new(500, 2),\r\n            is_percentage: false,\r\n        }],\r\n        \"EUR\".to_string(),\r\n        NaiveDate::from_ymd_opt(2025, 12, 24).unwrap(),\r\n        NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\r\n        None,\r\n    ));\r\n\r\n    let export = config.to_export_data();\r\n\r\n    assert_eq!(export.manufacturer, \"vitra\");\r\n    assert_eq!(export.article, \"TestArticle\");\r\n    assert_eq!(export.article_number, Some(\"48-001\".to_string()));\r\n    assert_eq!(export.variant_code, \"H720_white\");\r\n    assert_eq!(export.currency, Some(\"EUR\".to_string()));\r\n    assert!(export.surcharges.is_some());\r\n    assert!(!export.surcharges.unwrap().is_empty());\r\n}\r\n\r\n#[test]\r\nfn test_export_surcharge_structure() {\r\n    // Test with is_percentage = true (to verify serialization)\r\n    let surcharge = ExportSurcharge {\r\n        name: \"Aufpreis\".to_string(),\r\n        amount: \"45,00\".to_string(),\r\n        is_percentage: true,\r\n    };\r\n\r\n    let json = serde_json::to_string(&surcharge).unwrap();\r\n    assert!(json.contains(\"\\\"name\\\":\\\"Aufpreis\\\"\"));\r\n    assert!(json.contains(\"\\\"amount\\\":\\\"45,00\\\"\"));\r\n    assert!(json.contains(\"\\\"is_percentage\\\":true\"));\r\n\r\n    // Test with is_percentage = false (it's skipped in serialization)\r\n    let surcharge_no_percent = ExportSurcharge {\r\n        name: \"Fixed\".to_string(),\r\n        amount: \"10,00\".to_string(),\r\n        is_percentage: false,\r\n    };\r\n\r\n    let json_no_percent = serde_json::to_string(&surcharge_no_percent).unwrap();\r\n    assert!(json_no_percent.contains(\"\\\"name\\\":\\\"Fixed\\\"\"));\r\n    assert!(json_no_percent.contains(\"\\\"amount\\\":\\\"10,00\\\"\"));\r\n    // is_percentage is skipped when false due to skip_serializing_if\r\n    assert!(!json_no_percent.contains(\"is_percentage\"));\r\n}\r\n\r\n#[test]\r\nfn test_export_data_all_fields_present() {\r\n    let export = ExportData {\r\n        manufacturer: \"test\".to_string(),\r\n        article: \"test\".to_string(),\r\n        article_number: Some(\"123\".to_string()),\r\n        variant_code: \"V1\".to_string(),\r\n        properties: Default::default(),\r\n        base_price: Some(\"0,00\".to_string()),\r\n        surcharges: Some(vec![]),\r\n        total_price: Some(\"0,00\".to_string()),\r\n        currency: Some(\"EUR\".to_string()),\r\n        price_date: Some(\"2025-01-01\".to_string()),\r\n        sub_articles: vec![],\r\n        exported_at: \"2025-01-01T00:00:00Z\".to_string(),\r\n    };\r\n\r\n    let json = serde_json::to_string(&export).unwrap();\r\n\r\n    // Verify all required fields are in the JSON\r\n    assert!(json.contains(\"manufacturer\"));\r\n    assert!(json.contains(\"article\"));\r\n    assert!(json.contains(\"article_number\"));\r\n    assert!(json.contains(\"variant_code\"));\r\n    assert!(json.contains(\"properties\"));\r\n    assert!(json.contains(\"base_price\"));\r\n    assert!(json.contains(\"surcharges\"));\r\n    assert!(json.contains(\"total_price\"));\r\n    assert!(json.contains(\"currency\"));\r\n    assert!(json.contains(\"price_date\"));\r\n    assert!(json.contains(\"exported_at\"));\r\n}\r\n\r\n#[test]\r\nfn test_export_data_roundtrip() {\r\n    let mut properties = HashMap::new();\r\n    properties.insert(\"height\".to_string(), json!(\"720\"));\r\n\r\n    let original = ExportData {\r\n        manufacturer: \"vitra\".to_string(),\r\n        article: \"Table\".to_string(),\r\n        article_number: Some(\"48-123\".to_string()),\r\n        variant_code: \"H720_D1200\".to_string(),\r\n        properties,\r\n        base_price: Some(\"1.234,56\".to_string()),\r\n        surcharges: Some(vec![ExportSurcharge {\r\n            name: \"Test\".to_string(),\r\n            amount: \"10,00\".to_string(),\r\n            is_percentage: false,\r\n        }]),\r\n        total_price: Some(\"1.244,56\".to_string()),\r\n        currency: Some(\"EUR\".to_string()),\r\n        price_date: Some(\"2025-12-24\".to_string()),\r\n        sub_articles: vec![],\r\n        exported_at: \"2025-12-24T10:30:00Z\".to_string(),\r\n    };\r\n\r\n    // Serialize\r\n    let json = serde_json::to_string(&original).unwrap();\r\n\r\n    // Deserialize\r\n    let restored: ExportData = serde_json::from_str(&json).unwrap();\r\n\r\n    // Verify equality\r\n    assert_eq!(original.manufacturer, restored.manufacturer);\r\n    assert_eq!(original.article, restored.article);\r\n    assert_eq!(original.variant_code, restored.variant_code);\r\n    assert_eq!(original.base_price, restored.base_price);\r\n    assert_eq!(original.total_price, restored.total_price);\r\n}\r\n\r\n// === T054: Schema Validation Tests for ExportConfiguration ===\r\n\r\n#[test]\r\nfn test_export_configuration_schema_compliance() {\r\n    // Test that ExportConfiguration matches contracts/export-schema.json structure\r\n    let mut config = HashMap::new();\r\n    config.insert(\"S_STOFF\".to_string(), \"GABRIEL_166\".to_string());\r\n    config.insert(\"S_GESTELL\".to_string(), \"SCHWARZ\".to_string());\r\n\r\n    let export = ExportConfiguration {\r\n        article_nr: \"SE:AI-102\".to_string(),\r\n        manufacturer: \"sex\".to_string(),\r\n        series: \"ai\".to_string(),\r\n        variant_code: Some(\"AI-102_GABRIEL_166_SCHWARZ\".to_string()),\r\n        description: Some(\"Sedus AI B√ºrostuhl\".to_string()),\r\n        configuration: config,\r\n        property_details: vec![],\r\n        pricing: ExportPricing {\r\n            base: 1234.56,\r\n            surcharges: vec![ExportSurchargeItem {\r\n                var_cond: \"S_166\".to_string(),\r\n                description: Some(\"Stoffgruppe 166\".to_string()),\r\n                amount: 45.00,\r\n                is_percentage: false,\r\n            }],\r\n            discounts: vec![],\r\n            net: 1279.56,\r\n            taxes: vec![],\r\n            total: 1279.56,\r\n            currency: \"EUR\".to_string(),\r\n            price_date: Some(\"2025-12-24\".to_string()),\r\n            valid_from: Some(\"2025-01-01\".to_string()),\r\n            valid_to: Some(\"2025-12-31\".to_string()),\r\n        },\r\n        warnings: vec![],\r\n        exported_at: \"2025-12-24T10:30:00+00:00\".to_string(),\r\n    };\r\n\r\n    let json = serde_json::to_string_pretty(&export).unwrap();\r\n\r\n    // Verify required schema fields per contracts/export-schema.json\r\n    assert!(json.contains(\"\\\"article_nr\\\"\"));\r\n    assert!(json.contains(\"\\\"manufacturer\\\"\"));\r\n    assert!(json.contains(\"\\\"series\\\"\"));\r\n    assert!(json.contains(\"\\\"configuration\\\"\"));\r\n    assert!(json.contains(\"\\\"pricing\\\"\"));\r\n    assert!(json.contains(\"\\\"exported_at\\\"\"));\r\n\r\n    // Verify pricing sub-structure\r\n    assert!(json.contains(\"\\\"base\\\"\"));\r\n    assert!(json.contains(\"\\\"surcharges\\\"\"));\r\n    assert!(json.contains(\"\\\"discounts\\\"\"));\r\n    assert!(json.contains(\"\\\"total\\\"\"));\r\n    assert!(json.contains(\"\\\"currency\\\"\"));\r\n\r\n    // Verify surcharge structure\r\n    assert!(json.contains(\"\\\"var_cond\\\"\"));\r\n    assert!(json.contains(\"\\\"is_percentage\\\"\"));\r\n}\r\n\r\n#[test]\r\nfn test_export_configuration_with_warnings() {\r\n    let export = ExportConfiguration {\r\n        article_nr: \"FRM:ONE\".to_string(),\r\n        manufacturer: \"framery\".to_string(),\r\n        series: \"one\".to_string(),\r\n        variant_code: None,\r\n        description: None,\r\n        configuration: HashMap::new(),\r\n        property_details: vec![],\r\n        pricing: ExportPricing {\r\n            base: 12280.0,\r\n            surcharges: vec![],\r\n            discounts: vec![],\r\n            net: 12280.0,\r\n            taxes: vec![],\r\n            total: 12280.0,\r\n            currency: \"EUR\".to_string(),\r\n            price_date: None,\r\n            valid_from: None,\r\n            valid_to: None,\r\n        },\r\n        warnings: vec![ExportWarning {\r\n            severity: \"warning\".to_string(),\r\n            code: \"CORRUPTED_RECORD\".to_string(),\r\n            message: \"Price record at offset 1234 appears corrupted, recovered via 8-byte shift\"\r\n                .to_string(),\r\n            source: Some(\"pdata.ebase\".to_string()),\r\n        }],\r\n        exported_at: \"2025-12-24T10:30:00+00:00\".to_string(),\r\n    };\r\n\r\n    let json = serde_json::to_string_pretty(&export).unwrap();\r\n\r\n    // Verify warning structure per schema\r\n    assert!(json.contains(\"\\\"warnings\\\"\"));\r\n    assert!(json.contains(\"\\\"severity\\\"\"));\r\n    assert!(json.contains(\"\\\"code\\\"\"));\r\n    assert!(json.contains(\"\\\"message\\\"\"));\r\n    assert!(json.contains(\"\\\"source\\\"\"));\r\n    assert!(json.contains(\"\\\"warning\\\"\")); // severity value\r\n    assert!(json.contains(\"CORRUPTED_RECORD\"));\r\n}\r\n\r\n#[test]\r\nfn test_export_configuration_with_discounts() {\r\n    let export = ExportConfiguration {\r\n        article_nr: \"TEST-001\".to_string(),\r\n        manufacturer: \"test\".to_string(),\r\n        series: \"test\".to_string(),\r\n        variant_code: None,\r\n        description: None,\r\n        configuration: HashMap::new(),\r\n        property_details: vec![],\r\n        pricing: ExportPricing {\r\n            base: 1000.0,\r\n            surcharges: vec![],\r\n            discounts: vec![ExportDiscountItem {\r\n                var_cond: \"D_RABATT\".to_string(),\r\n                description: Some(\"Mengenrabatt 10%\".to_string()),\r\n                amount: 100.0,\r\n                rule: \"percent_of_base\".to_string(),\r\n            }],\r\n            net: 900.0,\r\n            taxes: vec![],\r\n            total: 900.0,\r\n            currency: \"EUR\".to_string(),\r\n            price_date: None,\r\n            valid_from: None,\r\n            valid_to: None,\r\n        },\r\n        warnings: vec![],\r\n        exported_at: \"2025-12-24T10:30:00+00:00\".to_string(),\r\n    };\r\n\r\n    let json = serde_json::to_string_pretty(&export).unwrap();\r\n\r\n    // Verify discount structure\r\n    assert!(json.contains(\"\\\"discounts\\\"\"));\r\n    assert!(json.contains(\"\\\"rule\\\"\"));\r\n    assert!(json.contains(\"percent_of_base\"));\r\n}\r\n\r\n#[test]\r\nfn test_export_configuration_roundtrip() {\r\n    let mut config = HashMap::new();\r\n    config.insert(\"prop1\".to_string(), \"value1\".to_string());\r\n\r\n    let original = ExportConfiguration {\r\n        article_nr: \"ART-001\".to_string(),\r\n        manufacturer: \"mfr\".to_string(),\r\n        series: \"ser\".to_string(),\r\n        variant_code: Some(\"VAR123\".to_string()),\r\n        description: Some(\"Test Article\".to_string()),\r\n        configuration: config,\r\n        property_details: vec![],\r\n        pricing: ExportPricing {\r\n            base: 500.0,\r\n            surcharges: vec![ExportSurchargeItem {\r\n                var_cond: \"S_TEST\".to_string(),\r\n                description: None,\r\n                amount: 50.0,\r\n                is_percentage: false,\r\n            }],\r\n            discounts: vec![],\r\n            net: 550.0,\r\n            taxes: vec![],\r\n            total: 550.0,\r\n            currency: \"CHF\".to_string(),\r\n            price_date: Some(\"2025-12-24\".to_string()),\r\n            valid_from: Some(\"2025-01-01\".to_string()),\r\n            valid_to: None,\r\n        },\r\n        warnings: vec![],\r\n        exported_at: \"2025-12-24T10:30:00+00:00\".to_string(),\r\n    };\r\n\r\n    // Serialize\r\n    let json = serde_json::to_string(&original).unwrap();\r\n\r\n    // Deserialize\r\n    let restored: ExportConfiguration = serde_json::from_str(&json).unwrap();\r\n\r\n    // Verify round-trip\r\n    assert_eq!(original.article_nr, restored.article_nr);\r\n    assert_eq!(original.manufacturer, restored.manufacturer);\r\n    assert_eq!(original.series, restored.series);\r\n    assert_eq!(original.pricing.base, restored.pricing.base);\r\n    assert_eq!(original.pricing.total, restored.pricing.total);\r\n    assert_eq!(original.pricing.currency, restored.pricing.currency);\r\n    assert_eq!(\r\n        original.pricing.surcharges.len(),\r\n        restored.pricing.surcharges.len()\r\n    );\r\n}\r\n\r\n#[test]\r\nfn test_export_json_batch() {\r\n    use ofml_lib::oap::export_json_batch;\r\n\r\n    // Create two configurations\r\n    let config1 = Configuration::new(\"Article1\".to_string(), \"mfr1\".to_string());\r\n    let config2 = Configuration::new(\"Article2\".to_string(), \"mfr2\".to_string());\r\n\r\n    let json = export_json_batch(&[config1, config2]);\r\n\r\n    // Should produce a JSON array\r\n    assert!(json.starts_with('['));\r\n    assert!(json.ends_with(']'));\r\n    assert!(json.contains(\"Article1\"));\r\n    assert!(json.contains(\"Article2\"));\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","unit","oap_price_test.rs"],"content":"//! Unit tests for price lookup (T016)\n\nuse chrono::NaiveDate;\nuse rust_decimal::Decimal;\n\nuse ofml_lib::oap::price::{PriceError, PriceLookup, PriceQuery};\nuse ofml_lib::oap::{\n    format_german_price, format_german_price_with_currency, PriceResult, Surcharge,\n};\n\n/// Test data path for OFML data\nconst TEST_DATA_PATH: &str = \"/reference/ofmldata\";\n\n#[test]\nfn test_price_query_creation() {\n    let query = PriceQuery::new(\n        \"vitra\".to_string(),\n        \"48-123-456\".to_string(),\n        \"H720_D1200\".to_string(),\n        NaiveDate::from_ymd_opt(2025, 12, 24).unwrap(),\n    );\n\n    assert_eq!(query.manufacturer, \"vitra\");\n    assert_eq!(query.article_number, \"48-123-456\");\n    assert_eq!(query.variant_code, \"H720_D1200\");\n    assert_eq!(\n        query.price_date,\n        NaiveDate::from_ymd_opt(2025, 12, 24).unwrap()\n    );\n}\n\n#[test]\nfn test_price_lookup_real_article() {\n    let lookup = PriceLookup::new(TEST_DATA_PATH);\n    let query = PriceQuery::new(\n        \"sex\".to_string(),\n        \"AI-121\".to_string(),\n        \"\".to_string(),\n        NaiveDate::from_ymd_opt(2025, 12, 24).unwrap(),\n    );\n\n    // This test requires real OFML data to be present\n    let result = lookup.lookup(&query);\n    if let Ok(price) = result {\n        assert!(price.base_price >= Decimal::ZERO);\n        assert!(!price.currency.is_empty());\n    }\n    // If data not available, test passes silently\n}\n\n#[test]\nfn test_price_lookup_manufacturer_not_found() {\n    let lookup = PriceLookup::new(\"/nonexistent/path\");\n    let query = PriceQuery::new(\n        \"fakemfr\".to_string(),\n        \"FAKE-123\".to_string(),\n        \"\".to_string(),\n        NaiveDate::from_ymd_opt(2025, 12, 24).unwrap(),\n    );\n\n    let result = lookup.lookup(&query);\n    assert!(result.is_err());\n    assert!(matches!(result, Err(PriceError::PriceTableNotFound(_))));\n}\n\n#[test]\nfn test_price_lookup_article_not_found() {\n    let lookup = PriceLookup::new(TEST_DATA_PATH);\n    let query = PriceQuery::new(\n        \"sex\".to_string(), // Valid manufacturer\n        \"NONEXISTENT-ARTICLE-12345\".to_string(),\n        \"\".to_string(),\n        NaiveDate::from_ymd_opt(2025, 12, 24).unwrap(),\n    );\n\n    let result = lookup.lookup(&query);\n    // May be either table not found (if manufacturer path doesn't exist) or article not found\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_price_result_total_no_surcharges() {\n    let price = PriceResult::new(\n        Decimal::new(10000, 2), // 100.00\n        vec![],\n        \"EUR\".to_string(),\n        NaiveDate::from_ymd_opt(2025, 12, 24).unwrap(),\n        NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n        None,\n    );\n\n    // total_price is computed during PriceResult::new\n    assert_eq!(price.total_price, Decimal::new(10000, 2)); // 100.00\n}\n\n#[test]\nfn test_price_result_total_with_fixed_surcharge() {\n    let price = PriceResult::new(\n        Decimal::new(10000, 2), // 100.00\n        vec![Surcharge {\n            name: \"Aufpreis\".to_string(),\n            amount: Decimal::new(2500, 2), // 25.00\n            is_percentage: false,\n        }],\n        \"EUR\".to_string(),\n        NaiveDate::from_ymd_opt(2025, 12, 24).unwrap(),\n        NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n        None,\n    );\n\n    assert_eq!(price.total_price, Decimal::new(12500, 2)); // 125.00\n}\n\n#[test]\nfn test_price_result_total_with_percentage_surcharge() {\n    let price = PriceResult::new(\n        Decimal::new(10000, 2), // 100.00\n        vec![Surcharge {\n            name: \"10% Aufschlag\".to_string(),\n            amount: Decimal::new(10, 0), // 10%\n            is_percentage: true,\n        }],\n        \"EUR\".to_string(),\n        NaiveDate::from_ymd_opt(2025, 12, 24).unwrap(),\n        NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n        None,\n    );\n\n    assert_eq!(price.total_price, Decimal::new(11000, 2)); // 110.00\n}\n\n#[test]\nfn test_price_result_total_mixed_surcharges() {\n    let price = PriceResult::new(\n        Decimal::new(10000, 2), // 100.00\n        vec![\n            Surcharge {\n                name: \"Fixed\".to_string(),\n                amount: Decimal::new(1000, 2), // 10.00\n                is_percentage: false,\n            },\n            Surcharge {\n                name: \"10%\".to_string(),\n                amount: Decimal::new(10, 0), // 10%\n                is_percentage: true,\n            },\n        ],\n        \"EUR\".to_string(),\n        NaiveDate::from_ymd_opt(2025, 12, 24).unwrap(),\n        NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n        None,\n    );\n\n    // 100.00 + 10.00 + 10% of 100.00 = 100.00 + 10.00 + 10.00 = 120.00\n    assert_eq!(price.total_price, Decimal::new(12000, 2));\n}\n\n#[test]\nfn test_format_german_price() {\n    assert_eq!(format_german_price(Decimal::new(123456, 2)), \"1.234,56\");\n    assert_eq!(format_german_price(Decimal::new(100, 2)), \"1,00\");\n    assert_eq!(format_german_price(Decimal::new(0, 2)), \"0,00\");\n    assert_eq!(format_german_price(Decimal::new(1000000, 2)), \"10.000,00\");\n}\n\n#[test]\nfn test_format_german_price_with_currency() {\n    assert_eq!(\n        format_german_price_with_currency(Decimal::new(123456, 2), \"EUR\"),\n        \"1.234,56 EUR\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","unit","oap_variant_test.rs"],"content":"//! Unit tests for variant code generation (T015)\n\nuse ofml_lib::oap::variant::{\n    generate_variant_code, truncate_variant_code, validate_variant_code_length,\n};\nuse ofml_lib::property::{\n    PropertyDef, PropertyManager, PropertyState, PropertyType, PropertyValue,\n};\n\n/// Create a test PropertyManager with sample properties\nfn create_test_properties() -> PropertyManager {\n    let mut pm = PropertyManager::new();\n\n    // Add definitions with sort orders\n    pm.definitions.insert(\n        \"height\".to_string(),\n        PropertyDef {\n            name: \"height\".to_string(),\n            label: \"H√∂he\".to_string(),\n            prop_type: PropertyType::Int {\n                min: Some(620),\n                max: Some(820),\n            },\n            state: PropertyState::Enabled,\n            sort_order: 1,\n            description: None,\n            category: None,\n        },\n    );\n\n    pm.definitions.insert(\n        \"diameter\".to_string(),\n        PropertyDef {\n            name: \"diameter\".to_string(),\n            label: \"Durchmesser\".to_string(),\n            prop_type: PropertyType::Int {\n                min: Some(800),\n                max: Some(1600),\n            },\n            state: PropertyState::Enabled,\n            sort_order: 2,\n            description: None,\n            category: None,\n        },\n    );\n\n    pm.definitions.insert(\n        \"color\".to_string(),\n        PropertyDef {\n            name: \"color\".to_string(),\n            label: \"Farbe\".to_string(),\n            prop_type: PropertyType::Choice {\n                options: vec![\"white\".to_string(), \"black\".to_string(), \"oak\".to_string()],\n            },\n            state: PropertyState::Enabled,\n            sort_order: 3,\n            description: None,\n            category: None,\n        },\n    );\n\n    // Property with sort_order 0 should NOT appear in variant code\n    pm.definitions.insert(\n        \"internal\".to_string(),\n        PropertyDef {\n            name: \"internal\".to_string(),\n            label: \"Internal\".to_string(),\n            prop_type: PropertyType::String,\n            state: PropertyState::Hidden,\n            sort_order: 0,\n            description: None,\n            category: None,\n        },\n    );\n\n    // Add values\n    pm.values\n        .insert(\"height\".to_string(), PropertyValue::Int(720));\n    pm.values\n        .insert(\"diameter\".to_string(), PropertyValue::Int(1200));\n    pm.values.insert(\n        \"color\".to_string(),\n        PropertyValue::Symbol(\"white\".to_string()),\n    );\n    pm.values.insert(\n        \"internal\".to_string(),\n        PropertyValue::String(\"test\".to_string()),\n    );\n\n    pm\n}\n\n#[test]\nfn test_generate_variant_code_basic() {\n    let pm = create_test_properties();\n    let code = generate_variant_code(&pm);\n\n    // Properties should be ordered by sort_order: height(1), diameter(2), color(3)\n    // internal(0) should be excluded\n    assert_eq!(code, \"720_1200_white\");\n}\n\n#[test]\nfn test_generate_variant_code_empty() {\n    let pm = PropertyManager::new();\n    let code = generate_variant_code(&pm);\n    assert_eq!(code, \"\");\n}\n\n#[test]\nfn test_generate_variant_code_single_property() {\n    let mut pm = PropertyManager::new();\n\n    pm.definitions.insert(\n        \"height\".to_string(),\n        PropertyDef {\n            name: \"height\".to_string(),\n            label: \"H√∂he\".to_string(),\n            prop_type: PropertyType::Int {\n                min: None,\n                max: None,\n            },\n            state: PropertyState::Enabled,\n            sort_order: 1,\n            description: None,\n            category: None,\n        },\n    );\n    pm.values\n        .insert(\"height\".to_string(), PropertyValue::Int(720));\n\n    let code = generate_variant_code(&pm);\n    assert_eq!(code, \"720\");\n}\n\n#[test]\nfn test_generate_variant_code_excludes_zero_sort_order() {\n    let mut pm = PropertyManager::new();\n\n    // Only add property with sort_order 0\n    pm.definitions.insert(\n        \"hidden\".to_string(),\n        PropertyDef {\n            name: \"hidden\".to_string(),\n            label: \"Hidden\".to_string(),\n            prop_type: PropertyType::String,\n            state: PropertyState::Hidden,\n            sort_order: 0,\n            description: None,\n            category: None,\n        },\n    );\n    pm.values.insert(\n        \"hidden\".to_string(),\n        PropertyValue::String(\"secret\".to_string()),\n    );\n\n    let code = generate_variant_code(&pm);\n    assert_eq!(code, \"\");\n}\n\n#[test]\nfn test_generate_variant_code_float_whole_number() {\n    let mut pm = PropertyManager::new();\n\n    pm.definitions.insert(\n        \"width\".to_string(),\n        PropertyDef {\n            name: \"width\".to_string(),\n            label: \"Breite\".to_string(),\n            prop_type: PropertyType::Float {\n                min: None,\n                max: None,\n            },\n            state: PropertyState::Enabled,\n            sort_order: 1,\n            description: None,\n            category: None,\n        },\n    );\n    pm.values\n        .insert(\"width\".to_string(), PropertyValue::Float(100.0));\n\n    let code = generate_variant_code(&pm);\n    // Whole numbers should not have decimal point\n    assert_eq!(code, \"100\");\n}\n\n#[test]\nfn test_generate_variant_code_float_with_decimal() {\n    let mut pm = PropertyManager::new();\n\n    pm.definitions.insert(\n        \"width\".to_string(),\n        PropertyDef {\n            name: \"width\".to_string(),\n            label: \"Breite\".to_string(),\n            prop_type: PropertyType::Float {\n                min: None,\n                max: None,\n            },\n            state: PropertyState::Enabled,\n            sort_order: 1,\n            description: None,\n            category: None,\n        },\n    );\n    pm.values\n        .insert(\"width\".to_string(), PropertyValue::Float(100.5));\n\n    let code = generate_variant_code(&pm);\n    assert_eq!(code, \"100.5\");\n}\n\n#[test]\nfn test_generate_variant_code_bool() {\n    let mut pm = PropertyManager::new();\n\n    pm.definitions.insert(\n        \"enabled\".to_string(),\n        PropertyDef {\n            name: \"enabled\".to_string(),\n            label: \"Aktiviert\".to_string(),\n            prop_type: PropertyType::Bool,\n            state: PropertyState::Enabled,\n            sort_order: 1,\n            description: None,\n            category: None,\n        },\n    );\n    pm.values\n        .insert(\"enabled\".to_string(), PropertyValue::Bool(true));\n\n    let code = generate_variant_code(&pm);\n    assert_eq!(code, \"1\");\n\n    pm.values\n        .insert(\"enabled\".to_string(), PropertyValue::Bool(false));\n    let code = generate_variant_code(&pm);\n    assert_eq!(code, \"0\");\n}\n\n#[test]\nfn test_validate_variant_code_length_valid() {\n    assert!(validate_variant_code_length(\"H720_D1200_CWH\", 50));\n    assert!(validate_variant_code_length(\"\", 50));\n    assert!(validate_variant_code_length(\"A\", 1));\n}\n\n#[test]\nfn test_validate_variant_code_length_invalid() {\n    assert!(!validate_variant_code_length(\"H720_D1200\", 5));\n    assert!(!validate_variant_code_length(\"AB\", 1));\n}\n\n#[test]\nfn test_truncate_variant_code_within_limit() {\n    let code = \"H720_D1200\";\n    assert_eq!(truncate_variant_code(code, 50), code);\n}\n\n#[test]\nfn test_truncate_variant_code_exceeds_limit() {\n    let code = \"H720_D1200_CWH_FCR_MAT001\";\n    let truncated = truncate_variant_code(code, 10);\n    assert!(truncated.len() <= 10);\n    assert!(truncated.ends_with(\"...\"));\n}\n\n#[test]\nfn test_variant_code_sort_order_respected() {\n    let mut pm = PropertyManager::new();\n\n    // Add in reverse sort order to verify sorting works\n    pm.definitions.insert(\n        \"c\".to_string(),\n        PropertyDef {\n            name: \"c\".to_string(),\n            label: \"C\".to_string(),\n            prop_type: PropertyType::String,\n            state: PropertyState::Enabled,\n            sort_order: 3,\n            description: None,\n            category: None,\n        },\n    );\n    pm.definitions.insert(\n        \"a\".to_string(),\n        PropertyDef {\n            name: \"a\".to_string(),\n            label: \"A\".to_string(),\n            prop_type: PropertyType::String,\n            state: PropertyState::Enabled,\n            sort_order: 1,\n            description: None,\n            category: None,\n        },\n    );\n    pm.definitions.insert(\n        \"b\".to_string(),\n        PropertyDef {\n            name: \"b\".to_string(),\n            label: \"B\".to_string(),\n            prop_type: PropertyType::String,\n            state: PropertyState::Enabled,\n            sort_order: 2,\n            description: None,\n            category: None,\n        },\n    );\n\n    pm.values\n        .insert(\"c\".to_string(), PropertyValue::String(\"C\".to_string()));\n    pm.values\n        .insert(\"a\".to_string(), PropertyValue::String(\"A\".to_string()));\n    pm.values\n        .insert(\"b\".to_string(), PropertyValue::String(\"B\".to_string()));\n\n    let code = generate_variant_code(&pm);\n    // Should be sorted by sort_order, not alphabetically\n    assert_eq!(code, \"A_B_C\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","unit","ocd_features_test.rs"],"content":"//! Unit tests for OCD features (tax, rounding, packaging, composites)\r\n\r\nuse std::path::Path;\r\n\r\nuse ofml_lib::oap::ocd_properties::{load_manufacturer_properties, clear_property_cache};\r\n\r\n#[test]\r\nfn test_get_data_version() {\r\n    clear_property_cache();\r\n\r\n    // Test with a manufacturer that should have version data\r\n    let path = Path::new(\"/reference/ofmldata/vitra\");\r\n    if !path.exists() {\r\n        return; // Skip if test data not available\r\n    }\r\n\r\n    let reader = load_manufacturer_properties(path);\r\n    let version = reader.get_data_version();\r\n\r\n    // Version may or may not exist, but the method should work\r\n    if let Some(v) = version {\r\n        assert!(!v.data_version.is_empty() || !v.format_version.is_empty());\r\n    }\r\n}\r\n\r\n#[test]\r\nfn test_get_packaging() {\r\n    clear_property_cache();\r\n\r\n    // Test with a manufacturer that should have packaging data\r\n    let path = Path::new(\"/reference/ofmldata/sedus\");\r\n    if !path.exists() {\r\n        return; // Skip if test data not available\r\n    }\r\n\r\n    let reader = load_manufacturer_properties(path);\r\n\r\n    // Try to find any article with packaging\r\n    for (article_nr, _) in reader.packaging.iter().take(1) {\r\n        let packaging = reader.get_packaging(article_nr);\r\n        assert!(!packaging.is_empty(), \"Should have packaging for {}\", article_nr);\r\n\r\n        let pkg = packaging[0];\r\n        // Verify package has some dimension data\r\n        assert!(\r\n            pkg.width >= 0.0 && pkg.depth >= 0.0 && pkg.height >= 0.0,\r\n            \"Package dimensions should be non-negative\"\r\n        );\r\n    }\r\n}\r\n\r\n#[test]\r\nfn test_data_validity_warning() {\r\n    clear_property_cache();\r\n\r\n    let path = Path::new(\"/reference/ofmldata/vitra\");\r\n    if !path.exists() {\r\n        return; // Skip if test data not available\r\n    }\r\n\r\n    let reader = load_manufacturer_properties(path);\r\n\r\n    // Test with a date far in the future\r\n    let future_date = chrono::NaiveDate::from_ymd_opt(2099, 1, 1).unwrap();\r\n    let warning = reader.get_data_validity_warning(future_date);\r\n    // A warning about expired data may or may not be returned depending on the data\r\n    // Just verify the method runs without error\r\n    let _ = warning;\r\n\r\n    // Test with current date\r\n    let today = chrono::Local::now().date_naive();\r\n    let _ = reader.get_data_validity_warning(today);\r\n}\r\n\r\n#[test]\r\nfn test_format_variant_code() {\r\n    clear_property_cache();\r\n\r\n    let path = Path::new(\"/reference/ofmldata/sedus\");\r\n    if !path.exists() {\r\n        return; // Skip if test data not available\r\n    }\r\n\r\n    let reader = load_manufacturer_properties(path);\r\n\r\n    // Test variant code formatting\r\n    let input = \"STOFF_2G3\";\r\n    let formatted = reader.format_variant_code(input);\r\n\r\n    // The formatted code should at least contain the property values\r\n    assert!(formatted.contains(\"STOFF\") || formatted.contains(\"2G3\"));\r\n}\r\n\r\n#[test]\r\nfn test_get_composite() {\r\n    clear_property_cache();\r\n\r\n    // Vitra has composite products\r\n    let path = Path::new(\"/reference/ofmldata/vitra\");\r\n    if !path.exists() {\r\n        return; // Skip if test data not available\r\n    }\r\n\r\n    let reader = load_manufacturer_properties(path);\r\n\r\n    // Just verify the method works\r\n    // Check if any composite exists\r\n    if !reader.composites.is_empty() {\r\n        let (composite_id, _) = reader.composites.iter().next().unwrap();\r\n        let composite = reader.get_composite(composite_id);\r\n        assert!(composite.is_some(), \"Should find composite {}\", composite_id);\r\n    }\r\n}\r\n\r\n#[test]\r\nfn test_get_bill_of_items() {\r\n    clear_property_cache();\r\n\r\n    let path = Path::new(\"/reference/ofmldata/vitra\");\r\n    if !path.exists() {\r\n        return; // Skip if test data not available\r\n    }\r\n\r\n    let reader = load_manufacturer_properties(path);\r\n\r\n    // Check if any bill of items exists\r\n    if !reader.bill_of_items.is_empty() {\r\n        let (composite_id, _) = reader.bill_of_items.iter().next().unwrap();\r\n        let items = reader.get_bill_of_items(composite_id);\r\n        assert!(!items.is_empty(), \"Should have items for {}\", composite_id);\r\n\r\n        // Verify item structure\r\n        let item = items[0];\r\n        assert!(!item.item_id.is_empty(), \"Item ID should not be empty\");\r\n        assert!(item.quantity >= 0.0, \"Quantity should be non-negative\");\r\n    }\r\n}\r\n\r\n#[test]\r\nfn test_get_tax_scheme() {\r\n    clear_property_cache();\r\n\r\n    // Try to find a manufacturer with tax data\r\n    for mfr in &[\"vitra\", \"sedus\", \"bisley\"] {\r\n        let path = Path::new(\"/reference/ofmldata\").join(mfr);\r\n        if !path.exists() {\r\n            continue;\r\n        }\r\n\r\n        let reader = load_manufacturer_properties(&path);\r\n\r\n        // Check if any tax scheme exists\r\n        if !reader.tax_schemes.is_empty() {\r\n            let (scheme_id, _) = reader.tax_schemes.iter().next().unwrap();\r\n            let scheme = reader.get_tax_scheme(scheme_id);\r\n            assert!(scheme.is_some(), \"Should find tax scheme {}\", scheme_id);\r\n\r\n            let s = scheme.unwrap();\r\n            assert!(!s.tax_id.is_empty(), \"Tax ID should not be empty\");\r\n            return; // Test passed\r\n        }\r\n    }\r\n\r\n    // If no tax data found in any manufacturer, that's okay\r\n    // The feature just won't be used\r\n}\r\n\r\n#[test]\r\nfn test_get_rounding_rules() {\r\n    clear_property_cache();\r\n\r\n    for mfr in &[\"vitra\", \"sedus\", \"bisley\"] {\r\n        let path = Path::new(\"/reference/ofmldata\").join(mfr);\r\n        if !path.exists() {\r\n            continue;\r\n        }\r\n\r\n        let reader = load_manufacturer_properties(&path);\r\n\r\n        // Check if any rounding rules exist\r\n        if !reader.rounding_rules.is_empty() {\r\n            let (rule_id, _) = reader.rounding_rules.iter().next().unwrap();\r\n            let rules = reader.get_rounding_rules(rule_id);\r\n\r\n            // If rules exist, verify they have valid data\r\n            if !rules.is_empty() {\r\n                let rule = rules[0];\r\n                // Precision should be a reasonable value\r\n                assert!(rule.precision <= 10, \"Precision should be reasonable\");\r\n                return; // Test passed\r\n            }\r\n        }\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","unit","ocd_snapshot_test.rs"],"content":"//! Snapshot tests for OCD data parsing\r\n//!\r\n//! Uses insta for snapshot testing to detect regressions in OCD parsing.\r\n\r\nuse insta::assert_json_snapshot;\r\nuse ofml_lib::oap::ocd::OcdReader;\r\nuse serde::Serialize;\r\nuse std::path::Path;\r\n\r\nconst SEDUS_AI_PATH: &str = \"/reference/ofmldata/sex/ai/DE/1/db/pdata.ebase\";\r\n\r\n/// Simplified article for snapshot (to avoid internal details)\r\n#[derive(Serialize)]\r\nstruct ArticleSnapshot {\r\n    article_nr: String,\r\n    series: String,\r\n    art_type: String,\r\n}\r\n\r\n/// Simplified price for snapshot\r\n#[derive(Serialize)]\r\nstruct PriceSnapshot {\r\n    article_nr: String,\r\n    price_level: String,\r\n    var_cond: String,\r\n    amount: f32,\r\n    currency: String,\r\n}\r\n\r\nfn sedus_ai_exists() -> bool {\r\n    Path::new(SEDUS_AI_PATH).exists()\r\n}\r\n\r\n#[test]\r\nfn snapshot_sedus_ai_articles() {\r\n    if !sedus_ai_exists() {\r\n        eprintln!(\"Skipping: Sedus AI data not found\");\r\n        return;\r\n    }\r\n\r\n    let reader = OcdReader::from_ebase(Path::new(SEDUS_AI_PATH)).unwrap();\r\n\r\n    // Take first 5 articles for snapshot\r\n    let articles: Vec<ArticleSnapshot> = reader\r\n        .articles\r\n        .iter()\r\n        .take(5)\r\n        .map(|a| ArticleSnapshot {\r\n            article_nr: a.article_nr.clone(),\r\n            series: a.series.clone(),\r\n            art_type: a.art_type.clone(),\r\n        })\r\n        .collect();\r\n\r\n    assert_json_snapshot!(\"sedus_ai_articles\", articles);\r\n}\r\n\r\n#[test]\r\nfn snapshot_sedus_ai_base_prices() {\r\n    if !sedus_ai_exists() {\r\n        eprintln!(\"Skipping: Sedus AI data not found\");\r\n        return;\r\n    }\r\n\r\n    let reader = OcdReader::from_ebase(Path::new(SEDUS_AI_PATH)).unwrap();\r\n\r\n    // Get base prices (level B) for first 5 articles\r\n    let prices: Vec<PriceSnapshot> = reader\r\n        .prices\r\n        .iter()\r\n        .filter(|p| p.price_level == \"B\")\r\n        .take(5)\r\n        .map(|p| PriceSnapshot {\r\n            article_nr: p.article_nr.clone(),\r\n            price_level: p.price_level.clone(),\r\n            var_cond: p.var_cond.clone(),\r\n            amount: p.price,\r\n            currency: p.currency.clone(),\r\n        })\r\n        .collect();\r\n\r\n    assert_json_snapshot!(\"sedus_ai_base_prices\", prices);\r\n}\r\n\r\n#[test]\r\nfn snapshot_sedus_ai_surcharges() {\r\n    if !sedus_ai_exists() {\r\n        eprintln!(\"Skipping: Sedus AI data not found\");\r\n        return;\r\n    }\r\n\r\n    let reader = OcdReader::from_ebase(Path::new(SEDUS_AI_PATH)).unwrap();\r\n\r\n    // Get surcharges (level X) - first 10\r\n    let surcharges: Vec<PriceSnapshot> = reader\r\n        .prices\r\n        .iter()\r\n        .filter(|p| p.price_level == \"X\")\r\n        .take(10)\r\n        .map(|p| PriceSnapshot {\r\n            article_nr: p.article_nr.clone(),\r\n            price_level: p.price_level.clone(),\r\n            var_cond: p.var_cond.clone(),\r\n            amount: p.price,\r\n            currency: p.currency.clone(),\r\n        })\r\n        .collect();\r\n\r\n    assert_json_snapshot!(\"sedus_ai_surcharges\", surcharges);\r\n}\r\n\r\n#[test]\r\nfn snapshot_ocd_reader_stats() {\r\n    if !sedus_ai_exists() {\r\n        eprintln!(\"Skipping: Sedus AI data not found\");\r\n        return;\r\n    }\r\n\r\n    let reader = OcdReader::from_ebase(Path::new(SEDUS_AI_PATH)).unwrap();\r\n\r\n    #[derive(Serialize)]\r\n    struct OcdStats {\r\n        article_count: usize,\r\n        price_count: usize,\r\n        base_price_count: usize,\r\n        surcharge_count: usize,\r\n        short_text_count: usize,\r\n        propvalue2varcond_count: usize,\r\n        unique_currencies: Vec<String>,\r\n    }\r\n\r\n    let mut currencies: Vec<String> = reader\r\n        .prices\r\n        .iter()\r\n        .map(|p| p.currency.clone())\r\n        .collect::<std::collections::HashSet<_>>()\r\n        .into_iter()\r\n        .collect();\r\n    currencies.sort();\r\n\r\n    let stats = OcdStats {\r\n        article_count: reader.articles.len(),\r\n        price_count: reader.prices.len(),\r\n        base_price_count: reader.prices.iter().filter(|p| p.price_level == \"B\").count(),\r\n        surcharge_count: reader.prices.iter().filter(|p| p.price_level == \"X\").count(),\r\n        short_text_count: reader.short_texts.len(),\r\n        propvalue2varcond_count: reader.propvalue2varcond.len(),\r\n        unique_currencies: currencies,\r\n    };\r\n\r\n    assert_json_snapshot!(\"sedus_ai_ocd_stats\", stats);\r\n}\r\n\r\n#[test]\r\nfn snapshot_article_property_classes() {\r\n    if !sedus_ai_exists() {\r\n        eprintln!(\"Skipping: Sedus AI data not found\");\r\n        return;\r\n    }\r\n\r\n    let reader = OcdReader::from_ebase(Path::new(SEDUS_AI_PATH)).unwrap();\r\n\r\n    // Get first 5 article -> property class mappings\r\n    let mut mappings: Vec<(String, Vec<String>)> = reader\r\n        .article_prop_classes\r\n        .iter()\r\n        .take(5)\r\n        .map(|(k, v)| (k.clone(), v.clone()))\r\n        .collect();\r\n    mappings.sort_by(|a, b| a.0.cmp(&b.0));\r\n\r\n    assert_json_snapshot!(\"sedus_ai_article_prop_classes\", mappings);\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","unit","propvalue2varcond_test.rs"],"content":"//! Tests for propvalue2varcond table loading and lookup functionality\n\nuse std::path::Path;\n\nuse ofml_lib::oap::ocd::OcdReader;\n\n/// Test that propvalue2varcond table is loaded correctly from Vitra data\n#[test]\nfn test_vitra_propvalue2varcond_loading() {\n    let path = Path::new(\"/reference/ofmldata/vitra/workit/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"Vitra workit pdata.ebase not found, skipping test\");\n        return;\n    }\n\n    let reader = OcdReader::from_ebase(path).expect(\"Should load OCD data\");\n\n    // Vitra workit should have propvalue2varcond mappings\n    assert!(\n        reader.has_varcond_mappings(),\n        \"Vitra workit should have propvalue2varcond mappings\"\n    );\n\n    // Check that we loaded a reasonable number of mappings\n    assert!(\n        reader.propvalue2varcond.len() > 100,\n        \"Should have at least 100 mappings, found {}\",\n        reader.propvalue2varcond.len()\n    );\n\n    println!(\n        \"Loaded {} propvalue2varcond mappings from Vitra workit\",\n        reader.propvalue2varcond.len()\n    );\n}\n\n/// Test that propvalue2varcond lookups work correctly\n#[test]\nfn test_vitra_propvalue2varcond_lookup() {\n    let path = Path::new(\"/reference/ofmldata/vitra/workit/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"Vitra workit pdata.ebase not found, skipping test\");\n        return;\n    }\n\n    let reader = OcdReader::from_ebase(path).expect(\"Should load OCD data\");\n\n    // Based on actual data: prop_value '1AS01' should map to var_cond '83341201_1AS01'\n    let var_cond = reader.lookup_varcond(\"ASY_83341201\", \"1AS01\");\n    assert!(\n        var_cond.is_some(),\n        \"Should find var_cond for prop_value '1AS01'\"\n    );\n\n    if let Some(vc) = var_cond {\n        assert!(\n            vc.contains(\"1AS01\"),\n            \"var_cond '{}' should contain '1AS01'\",\n            vc\n        );\n        println!(\"prop_value '1AS01' -> var_cond '{}'\", vc);\n    }\n}\n\n/// Test that lookup_varconds_for_values returns all matching var_conds\n#[test]\nfn test_vitra_propvalue2varcond_multi_lookup() {\n    let path = Path::new(\"/reference/ofmldata/vitra/workit/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"Vitra workit pdata.ebase not found, skipping test\");\n        return;\n    }\n\n    let reader = OcdReader::from_ebase(path).expect(\"Should load OCD data\");\n\n    // Test looking up multiple values at once\n    let values = vec![\"1AS01\", \"2AS01\"];\n    let var_conds = reader.lookup_varconds_for_values(&values);\n\n    println!(\n        \"Found {} var_conds for values {:?}\",\n        var_conds.len(),\n        values\n    );\n    for vc in &var_conds {\n        println!(\"  -> {}\", vc);\n    }\n\n    // Should find at least one var_cond for each value that has a mapping\n    assert!(\n        !var_conds.is_empty(),\n        \"Should find at least one var_cond for the given values\"\n    );\n}\n\n/// Test that Sedus does NOT have propvalue2varcond (uses pattern matching instead)\n#[test]\nfn test_sedus_no_propvalue2varcond() {\n    let path = Path::new(\"/reference/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"Sedus AI pdata.ebase not found, skipping test\");\n        return;\n    }\n\n    let reader = OcdReader::from_ebase(path).expect(\"Should load OCD data\");\n\n    // Sedus should NOT have propvalue2varcond mappings\n    assert!(\n        !reader.has_varcond_mappings(),\n        \"Sedus AI should NOT have propvalue2varcond mappings\"\n    );\n\n    println!(\"Sedus AI correctly has no propvalue2varcond mappings (uses pattern matching)\");\n}\n\n/// Test that value-only lookup works as fallback\n#[test]\nfn test_propvalue2varcond_value_only_lookup() {\n    let path = Path::new(\"/reference/ofmldata/vitra/workit/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"Vitra workit pdata.ebase not found, skipping test\");\n        return;\n    }\n\n    let reader = OcdReader::from_ebase(path).expect(\"Should load OCD data\");\n\n    // Check that we can look up by value only (without knowing prop_class)\n    if let Some(mappings) = reader.propvalue2varcond_by_value.get(\"1AS01\") {\n        assert!(\n            !mappings.is_empty(),\n            \"Should find mappings for value '1AS01'\"\n        );\n        println!(\"Found {} mappings for value '1AS01':\", mappings.len());\n        for m in mappings {\n            println!(\n                \"  prop_class='{}' prop_value='{}' -> var_cond='{}'\",\n                m.prop_class, m.prop_value, m.var_cond\n            );\n        }\n    }\n}\n\n/// Test that price matching uses direct lookup when available\n#[test]\nfn test_vitra_price_matching_with_direct_lookup() {\n    // Load a Vitra family\n    let path = Path::new(\"/reference/ofmldata/vitra/workit\");\n    if !path.exists() {\n        println!(\"Vitra workit data not found, skipping test\");\n        return;\n    }\n\n    // The test focuses on verifying the direct lookup mechanism is used\n    // For detailed price verification, we check the propvalue2varcond mappings\n\n    let pdata_path = Path::new(\"/reference/ofmldata/vitra/workit/DE/1/db/pdata.ebase\");\n    if !pdata_path.exists() {\n        println!(\"Vitra workit pdata.ebase not found, skipping test\");\n        return;\n    }\n\n    let reader = OcdReader::from_ebase(pdata_path).expect(\"Should load OCD data\");\n\n    // Verify Vitra uses direct lookup\n    assert!(\n        reader.has_varcond_mappings(),\n        \"Vitra should use direct lookup\"\n    );\n\n    // Get an article's prices\n    let articles: Vec<_> = reader\n        .articles\n        .iter()\n        .filter(|a| !a.article_nr.is_empty())\n        .take(5)\n        .collect();\n\n    println!(\"Sample Vitra articles with prices:\");\n    for article in &articles {\n        let prices = reader.get_prices(&article.article_nr);\n        if !prices.is_empty() {\n            println!(\n                \"  {} - {} prices (base: {:.2} {})\",\n                article.article_nr,\n                prices.len(),\n                prices[0].price,\n                prices[0].currency\n            );\n        }\n    }\n}\n\n/// Test mapping data structure contents\n#[test]\nfn test_propvalue2varcond_data_structure() {\n    let path = Path::new(\"/reference/ofmldata/vitra/workit/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"Vitra workit pdata.ebase not found, skipping test\");\n        return;\n    }\n\n    let reader = OcdReader::from_ebase(path).expect(\"Should load OCD data\");\n\n    // Print some sample mappings for verification\n    println!(\"Sample propvalue2varcond mappings:\");\n    let mut count = 0;\n    for ((prop_class, prop_value), mapping) in &reader.propvalue2varcond {\n        if count >= 10 {\n            break;\n        }\n        println!(\n            \"  ({}, {}) -> var_cond='{}' prop_text_add='{}'\",\n            prop_class, prop_value, mapping.var_cond, mapping.prop_text_add\n        );\n        count += 1;\n    }\n\n    // Verify mapping structure\n    for ((prop_class, prop_value), mapping) in reader.propvalue2varcond.iter().take(5) {\n        assert_eq!(prop_class, &mapping.prop_class);\n        assert_eq!(prop_value, &mapping.prop_value);\n        assert!(!mapping.var_cond.is_empty(), \"var_cond should not be empty\");\n    }\n}\n\n/// Test that prices are correctly associated with articles\n#[test]\nfn test_vitra_article_prices() {\n    let path = Path::new(\"/reference/ofmldata/vitra/workit/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"Vitra workit pdata.ebase not found, skipping test\");\n        return;\n    }\n\n    let reader = OcdReader::from_ebase(path).expect(\"Should load OCD data\");\n\n    println!(\"\\nVitra workit price summary:\");\n    println!(\"  Total articles: {}\", reader.articles.len());\n    println!(\"  Total prices: {}\", reader.prices.len());\n    println!(\n        \"  propvalue2varcond mappings: {}\",\n        reader.propvalue2varcond.len()\n    );\n\n    // Count prices by level\n    let base_count = reader\n        .prices\n        .iter()\n        .filter(|p| p.price_level == \"B\")\n        .count();\n    let surcharge_count = reader\n        .prices\n        .iter()\n        .filter(|p| p.price_level == \"X\")\n        .count();\n    let discount_count = reader\n        .prices\n        .iter()\n        .filter(|p| p.price_level == \"D\")\n        .count();\n\n    println!(\"\\n  Price levels:\");\n    println!(\"    Base (B): {}\", base_count);\n    println!(\"    Surcharge (X): {}\", surcharge_count);\n    println!(\"    Discount (D): {}\", discount_count);\n\n    // List unique var_cond values\n    let mut var_conds: Vec<&str> = reader.prices.iter().map(|p| p.var_cond.as_str()).collect();\n    var_conds.sort();\n    var_conds.dedup();\n    println!(\"\\n  Unique var_cond values: {}\", var_conds.len());\n    for vc in var_conds.iter().take(10) {\n        println!(\"    '{}'\", vc);\n    }\n    if var_conds.len() > 10 {\n        println!(\"    ... and {} more\", var_conds.len() - 10);\n    }\n}\n\n/// Integration test demonstrating direct lookup vs pattern matching\n#[test]\nfn test_direct_lookup_vs_pattern_matching() {\n    // Test Vitra (uses direct lookup via propvalue2varcond)\n    let vitra_path = Path::new(\"/reference/ofmldata/vitra/workit/DE/1/db/pdata.ebase\");\n    let sedus_path = Path::new(\"/reference/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n\n    if !vitra_path.exists() || !sedus_path.exists() {\n        println!(\"Test data not found, skipping\");\n        return;\n    }\n\n    let vitra_reader = OcdReader::from_ebase(vitra_path).expect(\"Load Vitra\");\n    let sedus_reader = OcdReader::from_ebase(sedus_path).expect(\"Load Sedus\");\n\n    println!(\"\\n=== Pricing Strategy Comparison ===\\n\");\n\n    // Vitra uses direct lookup\n    println!(\"VITRA (propvalue2varcond direct lookup):\");\n    println!(\n        \"  Has mapping table: {}\",\n        vitra_reader.has_varcond_mappings()\n    );\n    println!(\"  Mappings count: {}\", vitra_reader.propvalue2varcond.len());\n\n    // Example: lookup var_cond for property value \"1AS01\"\n    if let Some(var_cond) = vitra_reader.lookup_varcond(\"ASY_83341201\", \"1AS01\") {\n        println!(\"  Example: '1AS01' -> '{}' (DIRECT LOOKUP)\", var_cond);\n    }\n\n    // Sedus uses pattern matching\n    println!(\"\\nSEDUS (pattern matching fallback):\");\n    println!(\n        \"  Has mapping table: {}\",\n        sedus_reader.has_varcond_mappings()\n    );\n    println!(\n        \"  Uses pattern matching for S_XXX codes (e.g., S_166 matches value containing '166')\"\n    );\n\n    // Verify the strategies work\n    assert!(\n        vitra_reader.has_varcond_mappings(),\n        \"Vitra should use direct lookup\"\n    );\n    assert!(\n        !sedus_reader.has_varcond_mappings(),\n        \"Sedus should use pattern matching\"\n    );\n\n    println!(\"\\n=== Both strategies work correctly ===\");\n}\n\n/// Test that var_cond matching works correctly for real surcharges\n#[test]\nfn test_surcharge_matching_with_direct_lookup() {\n    let path = Path::new(\"/reference/ofmldata/vitra/workit/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"Vitra workit pdata.ebase not found, skipping test\");\n        return;\n    }\n\n    let reader = OcdReader::from_ebase(path).expect(\"Should load OCD data\");\n\n    // Get an article with surcharges\n    let article_nr = \"83341201\";\n    let prices = reader.get_prices(article_nr);\n\n    let base_prices: Vec<_> = prices.iter().filter(|p| p.price_level == \"B\").collect();\n    let surcharges: Vec<_> = prices.iter().filter(|p| p.price_level == \"X\").collect();\n\n    println!(\"\\nArticle {} price analysis:\", article_nr);\n    println!(\"  Base prices: {}\", base_prices.len());\n    println!(\"  Surcharges: {}\", surcharges.len());\n\n    if let Some(base) = base_prices.first() {\n        println!(\"  Base price: {:.2} {}\", base.price, base.currency);\n    }\n\n    // Show some surcharges and their matching mappings\n    println!(\"\\n  Sample surcharges and their var_cond mappings:\");\n    for surcharge in surcharges.iter().take(5) {\n        // Check if this var_cond is in our mapping\n        let has_direct_mapping = reader\n            .propvalue2varcond\n            .values()\n            .any(|m| m.var_cond == surcharge.var_cond);\n\n        println!(\n            \"    var_cond='{}' price={:.2} {} (direct_mapping={})\",\n            surcharge.var_cond, surcharge.price, surcharge.currency, has_direct_mapping\n        );\n    }\n\n    // Verify that most surcharges have direct mappings\n    let mapped_count = surcharges\n        .iter()\n        .filter(|s| {\n            reader\n                .propvalue2varcond\n                .values()\n                .any(|m| m.var_cond == s.var_cond)\n        })\n        .count();\n\n    println!(\n        \"\\n  Surcharges with direct mapping: {}/{}\",\n        mapped_count,\n        surcharges.len()\n    );\n    assert!(\n        mapped_count > 0,\n        \"Should have at least some surcharges with direct mappings\"\n    );\n}\n\n/// Test that ocd_pricetext table is loaded correctly\n#[test]\nfn test_vitra_pricetext_loading() {\n    let path = Path::new(\"/reference/ofmldata/vitra/workit/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"Vitra workit pdata.ebase not found, skipping test\");\n        return;\n    }\n\n    let reader = OcdReader::from_ebase(path).expect(\"Should load OCD data\");\n\n    println!(\"\\n=== Vitra workit ocd_pricetext Analysis ===\");\n    println!(\"  Price texts loaded: {}\", reader.price_texts.len());\n\n    // Should have some price texts\n    assert!(\n        !reader.price_texts.is_empty(),\n        \"Vitra workit should have price texts\"\n    );\n\n    // Show sample price texts\n    println!(\"\\n  Sample price texts:\");\n    for (textnr, texts) in reader.price_texts.iter().take(5) {\n        for text in texts {\n            println!(\n                \"    textnr='{}' [{}] '{}'\",\n                textnr, text.language, text.text\n            );\n        }\n    }\n}\n\n/// Test that price description resolution works\n#[test]\nfn test_price_description_resolution() {\n    let path = Path::new(\"/reference/ofmldata/vitra/workit/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"Vitra workit pdata.ebase not found, skipping test\");\n        return;\n    }\n\n    let reader = OcdReader::from_ebase(path).expect(\"Should load OCD data\");\n\n    // Get some prices with text_id\n    let prices_with_text: Vec<_> = reader\n        .prices\n        .iter()\n        .filter(|p| !p.text_id.is_empty())\n        .take(10)\n        .collect();\n\n    println!(\"\\n=== Price Description Resolution Test ===\");\n    println!(\"  Prices with text_id: {}\", prices_with_text.len());\n\n    // Check if we can resolve any descriptions\n    let mut resolved_count = 0;\n    for price in &prices_with_text {\n        let description = reader.get_price_description(price, \"DE\");\n        let is_resolved = description != price.var_cond && description != \"Base price\";\n        if is_resolved {\n            resolved_count += 1;\n        }\n        println!(\n            \"    text_id='{}' var_cond='{}' -> '{}'{}\",\n            price.text_id,\n            price.var_cond,\n            description,\n            if is_resolved { \" [RESOLVED]\" } else { \"\" }\n        );\n    }\n\n    println!(\n        \"\\n  Resolved descriptions: {}/{}\",\n        resolved_count,\n        prices_with_text.len()\n    );\n}\n\n/// Test that Sedus pricetext loading works\n#[test]\nfn test_sedus_pricetext_loading() {\n    let path = Path::new(\"/reference/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"Sedus AI pdata.ebase not found, skipping test\");\n        return;\n    }\n\n    let reader = OcdReader::from_ebase(path).expect(\"Should load OCD data\");\n\n    println!(\"\\n=== Sedus AI ocd_pricetext Analysis ===\");\n    println!(\"  Price texts loaded: {}\", reader.price_texts.len());\n\n    // Show sample price texts\n    if !reader.price_texts.is_empty() {\n        println!(\"\\n  Sample price texts:\");\n        for (textnr, texts) in reader.price_texts.iter().take(5) {\n            for text in texts {\n                println!(\n                    \"    textnr='{}' [{}] '{}'\",\n                    textnr, text.language, text.text\n                );\n            }\n        }\n    } else {\n        println!(\"  No price texts found (manufacturer may use different approach)\");\n    }\n}\n\n/// Test surcharges display with human-readable descriptions\n#[test]\nfn test_surcharge_display_with_descriptions() {\n    let path = Path::new(\"/reference/ofmldata/vitra/workit/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"Vitra workit pdata.ebase not found, skipping test\");\n        return;\n    }\n\n    let reader = OcdReader::from_ebase(path).expect(\"Should load OCD data\");\n\n    // Get an article with surcharges\n    let article_nr = \"83341201\";\n    let surcharges = reader.get_surcharges(article_nr);\n\n    println!(\n        \"\\n=== Article {} Surcharges with Descriptions ===\",\n        article_nr\n    );\n    println!(\"  Total surcharges: {}\", surcharges.len());\n    println!(\"\\n  Surcharges (pcon.basket style display):\");\n\n    for surcharge in surcharges.iter().take(10) {\n        let description = reader.get_price_description(surcharge, \"DE\");\n        println!(\n            \"    {:>8.2} {} - {}\",\n            surcharge.price, surcharge.currency, description\n        );\n    }\n    if surcharges.len() > 10 {\n        println!(\"    ... and {} more\", surcharges.len() - 10);\n    }\n}\n\n/// Test that engine price calculation produces human-readable surcharge names\n#[test]\nfn test_engine_produces_readable_surcharge_names() {\n    use ofml_lib::oap::engine::ConfigurationEngine;\n    use ofml_lib::oap::families::{FamilyConfiguration, FamilyLoader};\n    use std::path::Path;\n\n    let mfr_path = Path::new(\"/reference/ofmldata/vitra/workit\");\n    if !mfr_path.exists() {\n        println!(\"Vitra workit not found, skipping test\");\n        return;\n    }\n\n    let engine = ConfigurationEngine::new(\"/reference/ofmldata\");\n    let loader = FamilyLoader::load(mfr_path, \"DE\");\n    let families = loader.get_families();\n\n    println!(\"\\n=== Engine Surcharge Name Test ===\");\n\n    // Find a family with surcharges\n    for family in families.iter().take(5) {\n        let properties = loader.get_properties_for_family(family);\n        if properties.is_empty() {\n            continue;\n        }\n\n        let config = FamilyConfiguration::new(&family.id, &properties);\n        let price_date = chrono::Local::now().date_naive();\n\n        if let Some(price) = engine.calculate_family_price(\"vitra\", family, &config, price_date) {\n            if !price.surcharges.is_empty() {\n                println!(\"Family: {} ({})\", family.name, family.id);\n                println!(\"  Base: {:.2} {}\", price.base_price, price.currency);\n                println!(\"  Surcharges:\");\n\n                for surcharge in &price.surcharges {\n                    println!(\"    {} = {:.2}\", surcharge.name, surcharge.amount);\n\n                    // Verify surcharge name is human-readable (not just var_cond code)\n                    // Human-readable names should NOT start with article number pattern\n                    let is_var_cond_code = surcharge\n                        .name\n                        .chars()\n                        .next()\n                        .map(|c| c.is_ascii_digit())\n                        .unwrap_or(false)\n                        && surcharge.name.contains('_');\n\n                    if is_var_cond_code {\n                        println!(\n                            \"    WARNING: Surcharge '{}' looks like raw var_cond, not description!\",\n                            surcharge.name\n                        );\n                    }\n                }\n\n                println!(\"  Total: {:.2} {}\", price.total_price, price.currency);\n                return;\n            }\n        }\n    }\n\n    println!(\"No families with surcharges found (may need different test data)\");\n}\n\n/// Debug test to verify Sedus surcharge matching actually works\n#[test]\nfn test_sedus_surcharge_matching_debug() {\n    use ofml_lib::oap::engine::ConfigurationEngine;\n    use ofml_lib::oap::families::{FamilyConfiguration, FamilyLoader};\n    use std::path::Path;\n\n    let mfr_path = Path::new(\"/reference/ofmldata/sex\");\n    if !mfr_path.exists() {\n        println!(\"Sedus not found, skipping test\");\n        return;\n    }\n\n    let engine = ConfigurationEngine::new(\"/reference/ofmldata\");\n    let loader = FamilyLoader::load(mfr_path, \"DE\");\n    let families = loader.get_families();\n\n    println!(\"\\n=== Sedus Surcharge Matching Debug ===\\n\");\n\n    // Find AI family\n    let ai_family = families.iter().find(|f| f.base_article_nr.contains(\"AI-\"));\n    if ai_family.is_none() {\n        println!(\"AI family not found\");\n        return;\n    }\n    let family = ai_family.unwrap();\n\n    println!(\"Family: {} ({})\", family.name, family.id);\n    println!(\"Base article: {}\", family.base_article_nr);\n\n    let properties = loader.get_properties_for_family(family);\n    println!(\"Properties: {}\", properties.len());\n\n    // Show property values that might trigger S_166\n    println!(\"\\nLooking for property values with '166':\");\n    for prop in &properties {\n        for opt in &prop.options {\n            if opt.value.contains(\"166\") {\n                println!(\"  {}={} (label: {})\", prop.key, opt.value, opt.label);\n            }\n        }\n    }\n\n    // Create config and check price\n    let config = FamilyConfiguration::new(&family.id, &properties);\n    println!(\"\\nDefault variant_code: {}\", config.variant_code);\n\n    // Show which values are in the variant code\n    let values: Vec<&str> = config\n        .variant_code\n        .split(';')\n        .filter_map(|p| p.split('=').nth(1))\n        .collect();\n    println!(\"Values in config: {:?}\", values);\n\n    // Check if any value contains \"166\"\n    let has_166 = values.iter().any(|v| v.contains(\"166\"));\n    println!(\"Has value with '166': {}\", has_166);\n\n    let price_date = chrono::Local::now().date_naive();\n    if let Some(price) = engine.calculate_family_price(\"sex\", family, &config, price_date) {\n        println!(\"\\nPrice calculation result:\");\n        println!(\"  Base: {:.2} {}\", price.base_price, price.currency);\n        println!(\"  Total: {:.2} {}\", price.total_price, price.currency);\n        println!(\"  Surcharges: {}\", price.surcharges.len());\n        for s in &price.surcharges {\n            println!(\"    {} = {:.2}\", s.name, s.amount);\n        }\n    } else {\n        println!(\"\\nNo price calculated!\");\n    }\n\n    // Now change a property to trigger S_166\n    println!(\"\\n--- Trying to trigger S_166 ---\");\n    // Use S_STOFF_FRONT_GABRIEL which has option XST244166018\n    let gabriel_prop = properties.iter().find(|p| p.key == \"S_STOFF_FRONT_GABRIEL\");\n    if let Some(prop) = gabriel_prop {\n        println!(\n            \"Found property: {} with {} options\",\n            prop.key,\n            prop.options.len()\n        );\n        let opt_166 = prop.options.iter().find(|o| o.value.contains(\"166\"));\n        if let Some(opt) = opt_166 {\n            println!(\"Setting {}={}\", prop.key, opt.value);\n\n            let mut new_config = FamilyConfiguration::new(&family.id, &properties);\n            new_config.set(&prop.key, &opt.value);\n\n            println!(\"New variant_code: {}\", new_config.variant_code);\n\n            if let Some(price) =\n                engine.calculate_family_price(\"sex\", family, &new_config, price_date)\n            {\n                println!(\"\\nNew price result:\");\n                println!(\"  Base: {:.2} {}\", price.base_price, price.currency);\n                println!(\"  Total: {:.2} {}\", price.total_price, price.currency);\n                println!(\"  Surcharges: {}\", price.surcharges.len());\n                for s in &price.surcharges {\n                    println!(\"    {} = {:.2}\", s.name, s.amount);\n                }\n\n                // Check if S_166 was matched\n                let has_s166 = price\n                    .surcharges\n                    .iter()\n                    .any(|s| s.name.contains(\"166\") || s.amount == rust_decimal::Decimal::from(44));\n                println!(\"\\nS_166 surcharge matched: {}\", has_s166);\n            }\n        } else {\n            println!(\"No option with '166' found in property {}\", prop.key);\n        }\n    } else {\n        println!(\"No GABRIEL/STOFF property found\");\n    }\n}\n\n/// Test that simulates TUI property cycling\n#[test]\nfn test_tui_property_cycling_simulation() {\n    use ofml_lib::oap::engine::ConfigurationEngine;\n    use ofml_lib::oap::families::{FamilyConfiguration, FamilyLoader};\n    use std::path::Path;\n\n    let mfr_path = Path::new(\"/reference/ofmldata/sex\");\n    if !mfr_path.exists() {\n        println!(\"Sedus not found, skipping test\");\n        return;\n    }\n\n    // Simulate TUI initialization (two engines like main.rs + app.rs)\n    let engine = ConfigurationEngine::new(\"/reference/ofmldata\");\n\n    // Load families (simulating main.rs)\n    let families: Vec<_> = {\n        let loader = FamilyLoader::load(mfr_path, \"DE\");\n        loader.get_families().to_vec()\n    };\n    let ai_family = families\n        .iter()\n        .find(|f| f.base_article_nr.contains(\"AI-\"))\n        .cloned();\n\n    if ai_family.is_none() {\n        println!(\"AI family not found\");\n        return;\n    }\n    let family = ai_family.unwrap();\n\n    println!(\"\\n=== TUI Property Cycling Simulation ===\\n\");\n    println!(\"Family: {} ({})\", family.name, family.id);\n\n    // Load properties using FamilyLoader (simulating main.rs)\n    let loader = FamilyLoader::load(mfr_path, \"DE\");\n    let properties = loader.get_properties_for_family(&family);\n    println!(\"Properties loaded: {}\", properties.len());\n\n    // Create initial config\n    let mut config = FamilyConfiguration::new(&family.id, &properties);\n    let price_date = chrono::Local::now().date_naive();\n\n    // Initial price\n    let initial_price = engine.calculate_family_price(\"sex\", &family, &config, price_date);\n    println!(\"\\nInitial state:\");\n    if let Some(p) = &initial_price {\n        println!(\n            \"  Total: {:.2} {} ({} surcharges)\",\n            p.total_price,\n            p.currency,\n            p.surcharges.len()\n        );\n    }\n\n    // Find S_STOFF_FRONT_GABRIEL property\n    let gabriel_prop_idx = properties\n        .iter()\n        .position(|p| p.key == \"S_STOFF_FRONT_GABRIEL\");\n    if gabriel_prop_idx.is_none() {\n        println!(\"S_STOFF_FRONT_GABRIEL property not found\");\n        return;\n    }\n    let prop_idx = gabriel_prop_idx.unwrap();\n    let prop = &properties[prop_idx];\n\n    println!(\"\\nProperty: {} ({} options)\", prop.key, prop.options.len());\n    for (i, opt) in prop.options.iter().enumerate() {\n        let marker = if opt.value.contains(\"166\") {\n            \" <-- has 166\"\n        } else {\n            \"\"\n        };\n        println!(\"  [{}] {} {}\", i, opt.value, marker);\n    }\n\n    // Find option with 166\n    let opt_166_idx = prop.options.iter().position(|o| o.value.contains(\"166\"));\n    if opt_166_idx.is_none() {\n        println!(\"No option with 166\");\n        return;\n    }\n    let target_idx = opt_166_idx.unwrap();\n\n    // Simulate cycling through options\n    println!(\"\\n--- Simulating option cycling ---\");\n\n    let current_value = config.get(&prop.key).unwrap_or_default();\n    let current_idx = prop\n        .options\n        .iter()\n        .position(|o| o.value == current_value)\n        .unwrap_or(0);\n    println!(\"Current: [{}] {}\", current_idx, current_value);\n\n    // Cycle to target option\n    for i in 0..prop.options.len() {\n        let idx = (current_idx + i) % prop.options.len();\n        let new_value = &prop.options[idx].value;\n\n        // Simulate config.set() which is called in app.update()\n        config.set(&prop.key, new_value);\n\n        // Simulate recalculate_price\n        let price = engine.calculate_family_price(\"sex\", &family, &config, price_date);\n\n        if let Some(p) = &price {\n            let surcharge_info = if p.surcharges.is_empty() {\n                \"no surcharges\".to_string()\n            } else {\n                p.surcharges\n                    .iter()\n                    .map(|s| format!(\"{}={:.2}\", s.name, s.amount))\n                    .collect::<Vec<_>>()\n                    .join(\", \")\n            };\n            println!(\n                \"  [{}] {} -> {:.2} {} ({})\",\n                idx, new_value, p.total_price, p.currency, surcharge_info\n            );\n        }\n\n        if idx == target_idx {\n            println!(\"  ^^^ Target option reached\");\n\n            // Verify price changed\n            if let (Some(init), Some(curr)) = (&initial_price, &price) {\n                if curr.total_price != init.total_price {\n                    println!(\n                        \"\\n  SUCCESS: Price changed from {:.2} to {:.2}\",\n                        init.total_price, curr.total_price\n                    );\n                } else {\n                    println!(\"\\n  WARNING: Price did NOT change!\");\n                }\n            }\n            break;\n        }\n    }\n}\n\n/// Test that property value descriptions are loaded from ocd_propvaluetext\n#[test]\nfn test_propvaluetext_loading() {\n    use ofml_lib::oap::ocd_properties::OcdPropertyReader;\n    use std::path::Path;\n\n    let path = Path::new(\"/reference/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"Sedus AI pdata.ebase not found, skipping test\");\n        return;\n    }\n\n    let reader = OcdPropertyReader::from_ebase(path).expect(\"Should load\");\n\n    println!(\"\\n=== Property Value Text Loading Test ===\\n\");\n    println!(\"Property texts (ocd_propertytext): {}\", reader.texts.len());\n    println!(\n        \"Value texts (ocd_propvaluetext): {}\",\n        reader.value_texts.len()\n    );\n\n    // Show sample value texts\n    println!(\"\\nSample value texts:\");\n    for (textnr, texts) in reader.value_texts.iter().take(10) {\n        for text in texts {\n            println!(\"  textnr='{}' [{}] '{}'\", textnr, text.language, text.text);\n        }\n    }\n\n    // Look up S_ACCESSOIRES values\n    let acc_values = reader.get_values_for_property(\"S_ACC_AI\", \"S_ACCESSOIRES\");\n    println!(\"\\nS_ACCESSOIRES options:\");\n    for val in acc_values.iter().take(10) {\n        let label = reader\n            .get_value_label(val, \"DE\")\n            .unwrap_or_else(|| \"NO LABEL\".to_string());\n        println!(\"  {} -> '{}'\", val.value_from, label);\n    }\n}\n\n/// Test to find accessories property class and values\n#[test]\nfn test_find_accessories_property() {\n    use ofml_lib::oap::ocd_properties::OcdPropertyReader;\n    use std::path::Path;\n\n    let path = Path::new(\"/reference/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"Sedus AI pdata.ebase not found, skipping test\");\n        return;\n    }\n\n    let reader = OcdPropertyReader::from_ebase(path).expect(\"Should load\");\n\n    println!(\"\\n=== Finding Accessories Property ===\\n\");\n\n    // Find all properties with \"ACC\" in the name\n    println!(\"Properties with 'ACC' in name:\");\n    for ((prop_class, property), def) in &reader.properties {\n        if property.contains(\"ACC\") || prop_class.contains(\"ACC\") {\n            println!(\n                \"  {}.{} (type: {}, multi_option: {})\",\n                prop_class, property, def.prop_type, def.multi_option\n            );\n        }\n    }\n\n    // Find all S_ACCESSOIRES values across all property classes\n    println!(\"\\nAll property classes with S_ACCESSOIRES values:\");\n    for ((prop_class, property), values) in &reader.values {\n        if property == \"S_ACCESSOIRES\" {\n            println!(\"  Class '{}' has {} values:\", prop_class, values.len());\n            for val in values.iter().take(5) {\n                let label = reader\n                    .get_value_label(val, \"DE\")\n                    .or_else(|| reader.get_value_label(val, \"de\"))\n                    .unwrap_or_else(|| format!(\"(no label, textnr={})\", val.textnr));\n                println!(\"    {} -> '{}'\", val.value_from, label);\n            }\n            if values.len() > 5 {\n                println!(\"    ... and {} more\", values.len() - 5);\n            }\n        }\n    }\n}\n\n/// Test accessory surcharge prices\n#[test]\nfn test_accessory_prices_debug() {\n    use ofml_lib::oap::ocd::OcdReader;\n    use std::path::Path;\n\n    let path = Path::new(\"/reference/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"Sedus AI pdata.ebase not found, skipping test\");\n        return;\n    }\n\n    let reader = OcdReader::from_ebase(path).expect(\"Should load\");\n\n    println!(\"\\n=== Accessory Prices Debug ===\\n\");\n\n    // Look for prices with ACC or accessory-related var_cond\n    let acc_prices: Vec<_> = reader\n        .prices\n        .iter()\n        .filter(|p| {\n            p.var_cond.contains(\"ACC\")\n                || p.var_cond.contains(\"6235\")\n                || p.var_cond.contains(\"6103\")\n                || p.var_cond.contains(\"7007\")\n        })\n        .collect();\n\n    println!(\"Prices with ACC/accessory codes: {}\", acc_prices.len());\n    for p in acc_prices.iter().take(20) {\n        println!(\n            \"  var_cond='{}' price={:.2} {} (level='{}')\",\n            p.var_cond, p.price, p.currency, p.price_level\n        );\n    }\n\n    // Look for ALL prices for article AI-121\n    let ai_prices = reader.get_prices(\"AI-121\");\n    println!(\"\\nAI-121 total prices: {}\", ai_prices.len());\n\n    // Find unique var_cond values\n    let mut var_conds: Vec<_> = ai_prices.iter().map(|p| &p.var_cond).collect();\n    var_conds.sort();\n    var_conds.dedup();\n\n    println!(\"\\nUnique var_cond values for AI-121:\");\n    for vc in var_conds.iter().take(30) {\n        println!(\"  '{}'\", vc);\n    }\n}\n\n/// Test to find all accessory-related prices across ALL articles\n#[test]\nfn test_all_accessory_prices() {\n    use ofml_lib::oap::ocd::OcdReader;\n    use std::path::Path;\n\n    let path = Path::new(\"/reference/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"Sedus AI pdata.ebase not found, skipping test\");\n        return;\n    }\n\n    let reader = OcdReader::from_ebase(path).expect(\"Should load\");\n\n    println!(\"\\n=== All Accessory Prices Search ===\\n\");\n    println!(\"Total prices in database: {}\", reader.prices.len());\n\n    // Search for ANY price that might relate to accessories\n    let accessory_codes = [\n        \"6235\",\n        \"6103\",\n        \"7007\",\n        \"ACC\",\n        \"ACCESSOIRE\",\n        \"Nacken\",\n        \"Kleider\",\n    ];\n\n    for code in &accessory_codes {\n        let matches: Vec<_> = reader\n            .prices\n            .iter()\n            .filter(|p| p.var_cond.contains(code))\n            .collect();\n        if !matches.is_empty() {\n            println!(\"\\nPrices containing '{}': {}\", code, matches.len());\n            for p in matches.iter().take(5) {\n                println!(\n                    \"  article='{}' var_cond='{}' price={:.2}\",\n                    p.article_nr, p.var_cond, p.price\n                );\n            }\n        }\n    }\n\n    // List ALL unique var_cond patterns (first 50)\n    let mut all_var_conds: Vec<_> = reader.prices.iter().map(|p| p.var_cond.as_str()).collect();\n    all_var_conds.sort();\n    all_var_conds.dedup();\n\n    println!(\n        \"\\nAll unique var_cond patterns ({} total):\",\n        all_var_conds.len()\n    );\n    for vc in all_var_conds.iter().take(50) {\n        if !vc.is_empty() {\n            println!(\"  '{}'\", vc);\n        }\n    }\n}\n\n/// Investigate OCD relation system for pricing\n#[test]\nfn test_ocd_relation_system() {\n    use ofml_lib::ebase::EBaseReader;\n    use std::path::Path;\n\n    let path = Path::new(\"/reference/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"Sedus AI pdata.ebase not found, skipping test\");\n        return;\n    }\n\n    let mut reader = EBaseReader::open(path).expect(\"Should open\");\n\n    println!(\"\\n=== OCD Relation System Investigation ===\\n\");\n\n    // Check ocd_relationobj table\n    if reader.tables.contains_key(\"ocd_relationobj\") {\n        let records = reader.read_records(\"ocd_relationobj\", None).expect(\"read\");\n        println!(\"ocd_relationobj: {} records\", records.len());\n\n        // Count by domain\n        let mut domain_counts: std::collections::HashMap<String, usize> =\n            std::collections::HashMap::new();\n        for rec in &records {\n            let domain = rec\n                .get(\"rel_domain\")\n                .and_then(|v| v.as_str())\n                .unwrap_or(\"\")\n                .to_string();\n            *domain_counts.entry(domain).or_default() += 1;\n        }\n\n        println!(\"\\nRelation domains:\");\n        for (domain, count) in &domain_counts {\n            let desc = match domain.as_str() {\n                \"P\" => \"Pricing\",\n                \"C\" => \"Configuration\",\n                \"V\" => \"Validity\",\n                \"G\" => \"Geometry\",\n                \"\" => \"Empty\",\n                _ => \"Unknown\",\n            };\n            println!(\"  '{}' ({}): {} records\", domain, desc, count);\n        }\n\n        // Show sample pricing relations\n        println!(\"\\nSample pricing relations (domain='P'):\");\n        let pricing_rels: Vec<_> = records\n            .iter()\n            .filter(|r| r.get(\"rel_domain\").and_then(|v| v.as_str()) == Some(\"P\"))\n            .take(10)\n            .collect();\n\n        for rec in &pricing_rels {\n            let rel_obj = rec.get(\"rel_obj\").and_then(|v| v.as_i64()).unwrap_or(0);\n            let rel_nr = rec.get(\"rel_nr\").and_then(|v| v.as_i64()).unwrap_or(0);\n            println!(\"  rel_obj={} rel_nr={}\", rel_obj, rel_nr);\n        }\n    }\n\n    // Check ocd_relation table\n    if reader.tables.contains_key(\"ocd_relation\") {\n        let records = reader.read_records(\"ocd_relation\", None).expect(\"read\");\n        println!(\"\\nocd_relation: {} records\", records.len());\n\n        // Show sample relations with their code\n        println!(\"\\nSample relation code:\");\n        for rec in records.iter().take(5) {\n            let rel_obj = rec.get(\"rel_obj\").and_then(|v| v.as_i64()).unwrap_or(0);\n            let rel_nr = rec.get(\"rel_nr\").and_then(|v| v.as_i64()).unwrap_or(0);\n            let rel_code = rec.get(\"rel_code\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            println!(\n                \"  rel_obj={} rel_nr={}: '{}'\",\n                rel_obj,\n                rel_nr,\n                if rel_code.len() > 60 {\n                    &rel_code[..60]\n                } else {\n                    rel_code\n                }\n            );\n        }\n\n        // Look for VARCOND assignments\n        println!(\"\\nRelations containing 'VARCOND':\");\n        let varcond_rels: Vec<_> = records\n            .iter()\n            .filter(|r| {\n                r.get(\"rel_code\")\n                    .and_then(|v| v.as_str())\n                    .map(|s| s.contains(\"VARCOND\"))\n                    .unwrap_or(false)\n            })\n            .take(10)\n            .collect();\n\n        for rec in &varcond_rels {\n            let rel_code = rec.get(\"rel_code\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            println!(\n                \"  '{}'\",\n                if rel_code.len() > 80 {\n                    &rel_code[..80]\n                } else {\n                    rel_code\n                }\n            );\n        }\n    }\n\n    // Check ocd_propertyvalue for rel_obj references\n    if reader.tables.contains_key(\"ocd_propertyvalue\") {\n        let records = reader\n            .read_records(\"ocd_propertyvalue\", None)\n            .expect(\"read\");\n\n        // Find property values with rel_obj > 0 (have relations)\n        let with_relations: Vec<_> = records\n            .iter()\n            .filter(|r| r.get(\"rel_obj\").and_then(|v| v.as_i64()).unwrap_or(0) > 0)\n            .collect();\n\n        println!(\n            \"\\nProperty values with relations: {} / {}\",\n            with_relations.len(),\n            records.len()\n        );\n\n        // Show accessory property values with rel_obj\n        println!(\"\\nS_ACCESSOIRES values with rel_obj:\");\n        for rec in &records {\n            let property = rec.get(\"property\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            if property == \"S_ACCESSOIRES\" {\n                let value = rec.get(\"value_from\").and_then(|v| v.as_str()).unwrap_or(\"\");\n                let rel_obj = rec.get(\"rel_obj\").and_then(|v| v.as_i64()).unwrap_or(0);\n                println!(\"  {} rel_obj={}\", value, rel_obj);\n            }\n        }\n    }\n}\n\n/// Deep dive into OCD relation structure\n#[test]\nfn test_ocd_relation_deep_dive() {\n    use ofml_lib::ebase::EBaseReader;\n    use std::path::Path;\n\n    let path = Path::new(\"/reference/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"Sedus AI pdata.ebase not found, skipping test\");\n        return;\n    }\n\n    let mut reader = EBaseReader::open(path).expect(\"Should open\");\n\n    println!(\"\\n=== Deep Dive: OCD Relation Structure ===\\n\");\n\n    // First, let's see the column names in ocd_relationobj\n    if let Some(table) = reader.tables.get(\"ocd_relationobj\") {\n        println!(\"ocd_relationobj columns:\");\n        for col in &table.columns {\n            println!(\"  - {} (type_id={})\", col.name, col.type_id);\n        }\n    }\n\n    // And ocd_relation\n    if let Some(table) = reader.tables.get(\"ocd_relation\") {\n        println!(\"\\nocd_relation columns:\");\n        for col in &table.columns {\n            println!(\"  - {} (type_id={})\", col.name, col.type_id);\n        }\n    }\n\n    // Read actual relation records and show non-empty ones\n    if reader.tables.contains_key(\"ocd_relation\") {\n        let records = reader.read_records(\"ocd_relation\", None).expect(\"read\");\n\n        // Find non-empty relation codes\n        let non_empty: Vec<_> = records\n            .iter()\n            .filter(|r| {\n                r.get(\"rel_code\")\n                    .and_then(|v| v.as_str())\n                    .map(|s| !s.is_empty())\n                    .unwrap_or(false)\n            })\n            .take(20)\n            .collect();\n\n        println!(\n            \"\\nSample non-empty relation code ({} found):\",\n            non_empty.len()\n        );\n        for rec in &non_empty {\n            let rel_obj = rec.get(\"rel_obj\").and_then(|v| v.as_i64()).unwrap_or(0);\n            let rel_code = rec.get(\"rel_code\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            println!(\"\\n  rel_obj={}\", rel_obj);\n            // Print first 200 chars of code\n            let code_preview = if rel_code.len() > 200 {\n                &rel_code[..200]\n            } else {\n                rel_code\n            };\n            println!(\"  code: {}\", code_preview);\n        }\n    }\n\n    // Check property values with rel_obj > 0 and see what relations they use\n    if reader.tables.contains_key(\"ocd_propertyvalue\") {\n        let pv_records = reader\n            .read_records(\"ocd_propertyvalue\", None)\n            .expect(\"read\");\n\n        // Find values with relations for properties that affect pricing\n        println!(\"\\n\\nProperty values WITH relations (rel_obj > 0):\");\n        let with_rel: Vec<_> = pv_records\n            .iter()\n            .filter(|r| r.get(\"rel_obj\").and_then(|v| v.as_i64()).unwrap_or(0) > 0)\n            .take(20)\n            .collect();\n\n        for rec in &with_rel {\n            let property = rec.get(\"property\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            let value = rec.get(\"value_from\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            let rel_obj = rec.get(\"rel_obj\").and_then(|v| v.as_i64()).unwrap_or(0);\n            println!(\"  {} = {} -> rel_obj={}\", property, value, rel_obj);\n        }\n\n        // Specifically look at S_STOFF_FRONT_GABRIEL which we know affects price\n        println!(\"\\n\\nS_STOFF_FRONT_GABRIEL values:\");\n        for rec in &pv_records {\n            let property = rec.get(\"property\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            if property == \"S_STOFF_FRONT_GABRIEL\" {\n                let value = rec.get(\"value_from\").and_then(|v| v.as_str()).unwrap_or(\"\");\n                let rel_obj = rec.get(\"rel_obj\").and_then(|v| v.as_i64()).unwrap_or(0);\n                println!(\"  {} -> rel_obj={}\", value, rel_obj);\n            }\n        }\n    }\n}\n\n/// Look up specific relation code for S_166 trigger\n#[test]\nfn test_lookup_s166_relation() {\n    use ofml_lib::ebase::EBaseReader;\n    use std::path::Path;\n\n    let path = Path::new(\"/reference/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"Sedus AI pdata.ebase not found, skipping test\");\n        return;\n    }\n\n    let mut reader = EBaseReader::open(path).expect(\"Should open\");\n\n    println!(\"\\n=== Looking Up Relation for S_166 ===\\n\");\n\n    // XST244166018 has rel_obj=1661731 which should set VARCOND to S_166\n    let target_rel_obj = 1661731u64;\n\n    // The ocd_relation uses rel_name to link, not rel_obj directly\n    // First get the rel_name from ocd_relationobj\n    if reader.tables.contains_key(\"ocd_relationobj\") {\n        let records = reader.read_records(\"ocd_relationobj\", None).expect(\"read\");\n\n        // Find relation obj entries for our target\n        println!(\"Looking for rel_obj around {}\", target_rel_obj);\n\n        for rec in &records {\n            let rel_obj = rec.get(\"rel_obj\").and_then(|v| v.as_i64()).unwrap_or(0) as u64;\n            if rel_obj == target_rel_obj\n                || (rel_obj > target_rel_obj - 100 && rel_obj < target_rel_obj + 100)\n            {\n                let rel_name = rec.get(\"rel_name\").and_then(|v| v.as_str()).unwrap_or(\"\");\n                let rel_domain = rec.get(\"rel_domain\").and_then(|v| v.as_str()).unwrap_or(\"\");\n                let rel_type = rec.get(\"rel_type\").and_then(|v| v.as_str()).unwrap_or(\"\");\n                println!(\n                    \"  rel_obj={} rel_name='{}' domain='{}' type='{}'\",\n                    rel_obj, rel_name, rel_domain, rel_type\n                );\n            }\n        }\n    }\n\n    // Now look at ocd_relation to find the actual code\n    if reader.tables.contains_key(\"ocd_relation\") {\n        let records = reader.read_records(\"ocd_relation\", None).expect(\"read\");\n\n        println!(\"\\nLooking for relation blocks containing 'VARCOND' or '166':\");\n\n        for rec in &records {\n            let rel_block = rec.get(\"rel_block\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            if rel_block.contains(\"VARCOND\") || rel_block.contains(\"166\") {\n                let rel_name = rec.get(\"rel_name\").and_then(|v| v.as_str()).unwrap_or(\"\");\n                let rel_blocknr = rec.get(\"rel_blocknr\").and_then(|v| v.as_i64()).unwrap_or(0);\n\n                // Limit output\n                let preview = if rel_block.len() > 100 {\n                    &rel_block[..100]\n                } else {\n                    rel_block\n                };\n                println!(\"  rel_name='{}' blocknr={}\", rel_name, rel_blocknr);\n                println!(\"    block: '{}'...\", preview);\n                println!();\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","unit","table_relation_test.rs"],"content":"//! Tests for TABLE relation support in OCD properties\n\nuse std::collections::HashMap;\nuse std::path::Path;\n\nuse ofml_lib::oap::ocd_properties::{\n    clear_property_cache, load_manufacturer_properties, OcdPropertyReader,\n};\n\n#[test]\nfn test_table_relation_parsing() {\n    // Test parsing TABLE relation expressions\n    let rel_text = \"TABLE WKT_Groesse (Abmessung=Abmessung, Farbe_Rahmen=Farbe_Rahmen, Groesse = $SELF.Groesse)\";\n    let parsed = OcdPropertyReader::parse_table_relation(rel_text);\n\n    assert!(parsed.is_some(), \"Should parse TABLE relation\");\n    let parsed = parsed.unwrap();\n\n    assert_eq!(parsed.table_name, \"WKT_Groesse\");\n    assert_eq!(parsed.column_mappings.len(), 3);\n    assert_eq!(parsed.target_column, Some(\"Groesse\".to_string()));\n}\n\n#[test]\nfn test_table_relation_with_spaces() {\n    let rel_text =\n        \"TABLE  WKT_Artikelnummer  ( Groesse = Groesse , Artikelnummer = $SELF.Artikelnummer )\";\n    let parsed = OcdPropertyReader::parse_table_relation(rel_text);\n\n    assert!(\n        parsed.is_some(),\n        \"Should parse TABLE relation with extra spaces\"\n    );\n    let parsed = parsed.unwrap();\n\n    assert_eq!(parsed.table_name, \"WKT_Artikelnummer\");\n    assert_eq!(parsed.column_mappings.len(), 2);\n    assert_eq!(parsed.target_column, Some(\"Artikelnummer\".to_string()));\n}\n\n#[test]\nfn test_non_table_relation() {\n    let rel_text = \"Abmessung IN ('100X60','140X40','80X80')\";\n    let parsed = OcdPropertyReader::parse_table_relation(rel_text);\n\n    assert!(parsed.is_none(), \"Should not parse non-TABLE relation\");\n}\n\n#[test]\nfn test_fast_wkm_table_relations() {\n    // Clear cache to ensure we get fresh data\n    clear_property_cache();\n\n    let path = Path::new(\"/reference/ofmldata/fast/wkm/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"FAST WKM data not available, skipping test\");\n        return;\n    }\n\n    let reader = OcdPropertyReader::from_ebase(path).expect(\"Should load FAST WKM data\");\n\n    // Check that relations were loaded\n    println!(\"Loaded {} relation objects\", reader.relation_objs.len());\n    println!(\"Loaded {} relation groups\", reader.relations.len());\n    println!(\"Loaded {} custom tables\", reader.custom_tables.len());\n\n    // Check for WKT_Groesse table\n    let wkt_groesse = reader.custom_tables.get(\"wkt_groesse_tbl\");\n    if let Some(table) = wkt_groesse {\n        println!(\n            \"WKT_Groesse table has {} rows (after unpivoting)\",\n            table.len()\n        );\n        assert!(!table.is_empty(), \"WKT_Groesse table should have data\");\n\n        // Check that the table has expected columns (lowercase after unpivoting)\n        if let Some(first_row) = table.first() {\n            let keys: Vec<_> = first_row.keys().collect();\n            println!(\"Columns: {:?}\", keys);\n            // The table should have been unpivoted and have the actual column names\n            // Note: Some tables may have only 1 column after processing\n            assert!(\n                !keys.is_empty(),\n                \"Table should have at least one column, got {:?}\",\n                keys\n            );\n        }\n    }\n\n    // Test getting table values\n    let selections: HashMap<String, String> = HashMap::new();\n    let values = reader.get_table_values(\"Rahmen\", \"Groesse\", &selections);\n\n    println!(\n        \"Got {} values from TABLE relation for Groesse\",\n        values.len()\n    );\n    for val in values.iter().take(5) {\n        println!(\"  - {}\", val.value_from);\n    }\n}\n\n#[test]\nfn test_fast_wkm_property_with_table_relation() {\n    let path = Path::new(\"/reference/ofmldata/fast/wkm/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"FAST WKM data not available, skipping test\");\n        return;\n    }\n\n    let reader = OcdPropertyReader::from_ebase(path).expect(\"Should load FAST WKM data\");\n\n    // Check if Groesse property uses TABLE relation\n    let uses_table = reader.property_uses_table(\"Rahmen\", \"Groesse\");\n    println!(\"Groesse property uses TABLE: {}\", uses_table);\n\n    // Check Farbe_Rahmen as well\n    let farbe_uses_table = reader.property_uses_table(\"Rahmen\", \"Farbe_Rahmen\");\n    println!(\"Farbe_Rahmen property uses TABLE: {}\", farbe_uses_table);\n\n    // Get the property definitions\n    let props = reader.get_properties_for_class(\"Rahmen\");\n    println!(\"Found {} properties in Rahmen class:\", props.len());\n    for prop in &props {\n        println!(\n            \"  - {} (rel_obj={}, scope={})\",\n            prop.property, prop.rel_obj, prop.scope\n        );\n    }\n}\n\n#[test]\nfn test_manufacturer_property_loading_with_tables() {\n    // Clear cache to ensure we get fresh data\n    clear_property_cache();\n\n    let path = Path::new(\"/reference/ofmldata/fast\");\n    if !path.exists() {\n        println!(\"FAST manufacturer data not available, skipping test\");\n        return;\n    }\n\n    let reader = load_manufacturer_properties(path);\n\n    println!(\"Manufacturer-wide stats:\");\n    let (props, vals, classes, texts) = reader.stats();\n    println!(\"  Properties: {}\", props);\n    println!(\"  Values: {}\", vals);\n    println!(\"  Classes: {}\", classes);\n    println!(\"  Texts: {}\", texts);\n    println!(\"  Relation objects: {}\", reader.relation_objs.len());\n    println!(\"  Relation groups: {}\", reader.relations.len());\n    println!(\"  Custom tables: {}\", reader.custom_tables.len());\n\n    // List custom tables\n    println!(\"\\nCustom tables loaded:\");\n    for table_name in reader.custom_tables.keys() {\n        let count = reader\n            .custom_tables\n            .get(table_name)\n            .map(|t| t.len())\n            .unwrap_or(0);\n        println!(\"  - {} ({} rows)\", table_name, count);\n    }\n}\n\n#[test]\nfn test_fast_wkm_tui_display() {\n    use ofml_lib::oap::families::FamilyLoader;\n\n    // Clear cache to ensure we get fresh data\n    clear_property_cache();\n\n    let path = Path::new(\"/reference/ofmldata/fast\");\n    if !path.exists() {\n        println!(\"FAST manufacturer data not available, skipping test\");\n        return;\n    }\n\n    let loader = FamilyLoader::load(path, \"DE\");\n\n    println!(\"\\n=== What TUI shows for FAST WKM ===\\n\");\n\n    // Find WKM family\n    for family in loader.get_families() {\n        if family.series.to_uppercase() == \"WKM\" {\n            println!(\"Family: {} - {}\", family.id, family.name);\n            println!(\"Series: {}\", family.series);\n            println!(\"prop_classes: {:?}\", family.prop_classes);\n\n            // Debug: Show all properties from property class\n            println!(\"\\nAll properties in Rahmen class (before filtering):\");\n            for prop in loader.properties.get_properties_for_class(\"Rahmen\") {\n                let values = loader\n                    .properties\n                    .get_values_for_property(\"Rahmen\", &prop.property);\n                println!(\n                    \"  {} (scope={}, rel_obj={}): {} values in ocd_propertyvalue\",\n                    prop.property,\n                    prop.scope,\n                    prop.rel_obj,\n                    values.len()\n                );\n            }\n\n            let props = loader.get_properties_for_family(family);\n            println!(\n                \"\\nProperties available in TUI (after filtering): {}\",\n                props.len()\n            );\n\n            for prop in &props {\n                println!(\"\\n  {} ({}):\", prop.key, prop.label);\n                println!(\"    Options: {} items\", prop.options.len());\n                for (_i, opt) in prop.options.iter().enumerate().take(5) {\n                    let marker = if opt.is_default { \"*\" } else { \" \" };\n                    println!(\"      {}[{}] {}\", marker, opt.value, opt.label);\n                }\n                if prop.options.len() > 5 {\n                    println!(\"      ... and {} more options\", prop.options.len() - 5);\n                }\n            }\n            println!();\n        }\n    }\n}\n\n#[test]\nfn test_fast_wkm_price_dump() {\n    use ofml_lib::ebase::EBaseReader;\n\n    let path = Path::new(\"/reference/ofmldata/fast/wkm/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"FAST WKM data not available, skipping test\");\n        return;\n    }\n\n    let mut reader = EBaseReader::open(path).expect(\"Should open FAST WKM ebase\");\n\n    println!(\"\\n=== FAST WKM ocd_price records ===\");\n    if let Ok(prices) = reader.read_records(\"ocd_price\", Some(30)) {\n        for p in &prices {\n            let article = p.get(\"article_nr\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            let var_cond = p.get(\"var_cond\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            let level = p.get(\"price_level\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            let price = p.get(\"price\").and_then(|v| v.as_f64()).unwrap_or(0.0);\n            let currency = p.get(\"currency\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            println!(\n                \"  {} | {:30} | {} | {:8.2} {}\",\n                article, var_cond, level, price, currency\n            );\n        }\n    }\n}\n\n#[test]\nfn test_fast_wkm_compute_varcond() {\n    // Clear cache to ensure we get fresh data\n    clear_property_cache();\n\n    let path = Path::new(\"/reference/ofmldata/fast\");\n    if !path.exists() {\n        println!(\"FAST manufacturer data not available, skipping test\");\n        return;\n    }\n\n    let reader = load_manufacturer_properties(path);\n\n    // Check if FAST uses TABLE-based var_cond\n    assert!(\n        reader.uses_table_varcond(),\n        \"FAST should use TABLE-based var_cond\"\n    );\n\n    println!(\"\\n=== Testing var_cond computation for FAST WKM ===\\n\");\n\n    // Debug: Show wkt_groesse_tbl content\n    println!(\"WKT_Groesse table content:\");\n    if let Some(table) = reader.custom_tables.get(\"wkt_groesse_tbl\") {\n        println!(\"  Table has {} rows\", table.len());\n        for (i, row) in table.iter().take(5).enumerate() {\n            println!(\"  Row {}: {:?}\", i, row);\n        }\n        // Show entries with 140X40\n        println!(\"\\n  Entries containing 140X40:\");\n        for row in table {\n            if let Some(abm) = row.get(\"abmessung\") {\n                if abm.to_uppercase().contains(\"140\") {\n                    println!(\"    {:?}\", row);\n                }\n            }\n        }\n    } else {\n        println!(\"  TABLE NOT FOUND!\");\n    }\n\n    // Test case 1: 100X60 with VOLLHOLZ_SCHWARZ should compute to SG-MB-WKM-100X60-HOSW\n    let mut selections1: HashMap<String, String> = HashMap::new();\n    selections1.insert(\"Abmessung\".to_string(), \"100X60\".to_string());\n    selections1.insert(\"Farbe_Rahmen\".to_string(), \"VOLLHOLZ_SCHWARZ\".to_string());\n\n    let varcond1 = reader.compute_varcond_from_selections(\"Rahmen\", &selections1);\n    println!(\"\\nSelections: {:?}\", selections1);\n    println!(\"Computed var_cond: {:?}\", varcond1);\n\n    // Should match SG-MB-WKM-100X60-HOSW (case-insensitive)\n    assert!(\n        varcond1.is_some(),\n        \"Should compute var_cond for 100X60 + VOLLHOLZ_SCHWARZ\"\n    );\n    let vc1 = varcond1.unwrap();\n    assert!(\n        vc1.to_uppercase().contains(\"100X60\") && vc1.to_uppercase().contains(\"HOSW\"),\n        \"Expected var_cond containing 100X60 and HOSW, got: {}\",\n        vc1\n    );\n\n    // Test case 2: 100X60 with VOLLHOLZ_EICHE should compute to SG-MB-WKM-100X60-HOEI\n    let mut selections2: HashMap<String, String> = HashMap::new();\n    selections2.insert(\"Abmessung\".to_string(), \"100X60\".to_string());\n    selections2.insert(\"Farbe_Rahmen\".to_string(), \"VOLLHOLZ_EICHE\".to_string());\n\n    let varcond2 = reader.compute_varcond_from_selections(\"Rahmen\", &selections2);\n    println!(\"\\nSelections: {:?}\", selections2);\n    println!(\"Computed var_cond: {:?}\", varcond2);\n\n    // Should match SG-MB-WKM-100X60-HOEI (case-insensitive)\n    assert!(\n        varcond2.is_some(),\n        \"Should compute var_cond for 100X60 + VOLLHOLZ_EICHE\"\n    );\n    let vc2 = varcond2.unwrap();\n    assert!(\n        vc2.to_uppercase().contains(\"100X60\") && vc2.to_uppercase().contains(\"HOEI\"),\n        \"Expected var_cond containing 100X60 and HOEI, got: {}\",\n        vc2\n    );\n\n    println!(\"\\n=== Basic var_cond computations passed! ===\\n\");\n}\n\n#[test]\nfn test_fast_wkm_price_with_varcond() {\n    use ofml_lib::oap::engine::ConfigurationEngine;\n    use ofml_lib::oap::families::{FamilyConfiguration, FamilyLoader};\n\n    // Clear cache to ensure we get fresh data\n    clear_property_cache();\n\n    let path = Path::new(\"/reference/ofmldata\");\n    if !path.exists() {\n        println!(\"OFML data not available, skipping test\");\n        return;\n    }\n\n    let mfr_path = Path::new(\"/reference/ofmldata/fast\");\n    if !mfr_path.exists() {\n        println!(\"FAST manufacturer data not available, skipping test\");\n        return;\n    }\n\n    // Load families for FAST\n    let loader = FamilyLoader::load(mfr_path, \"DE\");\n\n    // Find WKM family\n    let wkm_family = loader\n        .get_families()\n        .iter()\n        .find(|f| f.series.to_uppercase() == \"WKM\");\n    if wkm_family.is_none() {\n        println!(\"WKM family not found, skipping test\");\n        return;\n    }\n    let wkm_family = wkm_family.unwrap();\n    println!(\"Found WKM family: {} - {}\", wkm_family.id, wkm_family.name);\n    println!(\"Base article: {}\", wkm_family.base_article_nr);\n    println!(\"Property classes: {:?}\", wkm_family.prop_classes);\n\n    // Get properties for the family\n    let props = loader.get_properties_for_family(wkm_family);\n    println!(\"\\nProperties available: {}\", props.len());\n    for prop in &props {\n        println!(\n            \"  {} ({}) - {} options\",\n            prop.key,\n            prop.label,\n            prop.options.len()\n        );\n    }\n\n    // Create configuration\n    let mut config = FamilyConfiguration::new(&wkm_family.id, &props);\n\n    // Set specific values: 100X60 with VOLLHOLZ_SCHWARZ\n    config.set(\"Abmessung\", \"100X60\");\n    config.set(\"Farbe_Rahmen\", \"VOLLHOLZ_SCHWARZ\");\n\n    println!(\"\\n=== Price calculation test ===\");\n    println!(\"Configuration: {:?}\", config.selections);\n    println!(\"Variant code: {}\", config.variant_code);\n\n    // Calculate price\n    let engine = ConfigurationEngine::new(path);\n    let today = chrono::Local::now().date_naive();\n    let price_result = engine.calculate_family_price(\"fast\", wkm_family, &config, today);\n\n    println!(\"\\nPrice result: {:?}\", price_result);\n\n    if let Some(price) = price_result {\n        println!(\"\\n  Base price: {} {}\", price.base_price, price.currency);\n        println!(\"  Total: {} {}\", price.total_price, price.currency);\n        // VOLLHOLZ_SCHWARZ (100X60) should be around 368.91 EUR\n        assert!(\n            price.base_price > rust_decimal::Decimal::from(300)\n                && price.base_price < rust_decimal::Decimal::from(500),\n            \"Price should be in reasonable range for 100X60 VOLLHOLZ_SCHWARZ\"\n        );\n    } else {\n        println!(\"\\nNo price found - checking if prices exist in data...\");\n        // This is not necessarily a failure - the article might not have prices\n    }\n\n    // Test with VOLLHOLZ_EICHE (should have higher price)\n    config.set(\"Farbe_Rahmen\", \"VOLLHOLZ_EICHE\");\n    println!(\"\\n=== Testing with VOLLHOLZ_EICHE (Oak - premium) ===\");\n    println!(\"Configuration: {:?}\", config.selections);\n\n    let price_oak = engine.calculate_family_price(\"fast\", wkm_family, &config, today);\n    println!(\"Price result for oak: {:?}\", price_oak);\n\n    if let Some(price) = price_oak {\n        println!(\n            \"\\n  Base price (oak): {} {}\",\n            price.base_price, price.currency\n        );\n        // Oak (VOLLHOLZ_EICHE) should be around 394.12 EUR (higher than black)\n        assert!(\n            price.base_price > rust_decimal::Decimal::from(350),\n            \"Oak price should be higher than 350 EUR\"\n        );\n    }\n\n    println!(\"\\n=== FAST WKM price test complete! ===\\n\");\n}\n\n#[test]\nfn test_framery_price_debug() {\n    use ofml_lib::ebase::EBaseReader;\n    use ofml_lib::oap::ocd::OcdReader;\n\n    let path = std::path::Path::new(\"/reference/ofmldata/framery/frmr_one/ANY/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"Framery data not available, skipping test\");\n        return;\n    }\n\n    // Check raw ebase prices\n    let mut reader = EBaseReader::open(path).expect(\"Should open Framery ebase\");\n\n    println!(\"\\n=== Framery ocd_price raw records ===\");\n    if let Ok(prices) = reader.read_records(\"ocd_price\", Some(20)) {\n        println!(\"Found {} price records\", prices.len());\n        for p in &prices {\n            let article = p\n                .get(\"article_nr\")\n                .map(|v| format!(\"{:?}\", v))\n                .unwrap_or_default();\n            let var_cond = p\n                .get(\"var_cond\")\n                .map(|v| format!(\"{:?}\", v))\n                .unwrap_or_default();\n            let level = p\n                .get(\"price_level\")\n                .map(|v| format!(\"{:?}\", v))\n                .unwrap_or_default();\n            let price = p.get(\"price\").and_then(|v| v.as_f64()).unwrap_or(0.0);\n            println!(\"  {} | {} | {} | {:.2}\", article, var_cond, level, price);\n        }\n    }\n\n    // Check OcdReader\n    let ocd = OcdReader::from_ebase(path).expect(\"Should load OcdReader\");\n    println!(\"\\n=== OcdReader prices ===\");\n    println!(\"Total prices: {}\", ocd.prices.len());\n\n    // Try to get prices for various articles\n    for article in &[\"ONE\", \"ONE_PREMIUM\", \"*\", \"\"] {\n        let prices = ocd.get_prices(article);\n        println!(\"Prices for '{}': {}\", article, prices.len());\n    }\n\n    // Show all unique article_nrs\n    let mut articles: Vec<_> = ocd.prices.iter().map(|p| p.article_nr.as_str()).collect();\n    articles.sort();\n    articles.dedup();\n    println!(\"\\nUnique article_nrs in prices: {:?}\", articles);\n\n    // Show all price_levels\n    let mut levels: Vec<_> = ocd.prices.iter().map(|p| p.price_level.as_str()).collect();\n    levels.sort();\n    levels.dedup();\n    println!(\"Unique price_levels: {:?}\", levels);\n\n    // Check surcharge-only detection\n    println!(\n        \"\\nSurcharge-only pricing: {}\",\n        ocd.has_surcharge_only_pricing()\n    );\n}\n\n#[test]\nfn test_framery_price_calculation() {\n    use ofml_lib::oap::engine::ConfigurationEngine;\n    use ofml_lib::oap::families::{FamilyConfiguration, FamilyLoader};\n\n    // Clear cache to ensure we get fresh data\n    clear_property_cache();\n\n    let path = Path::new(\"/reference/ofmldata\");\n    if !path.exists() {\n        println!(\"OFML data not available, skipping test\");\n        return;\n    }\n\n    let mfr_path = Path::new(\"/reference/ofmldata/framery\");\n    if !mfr_path.exists() {\n        println!(\"Framery manufacturer data not available, skipping test\");\n        return;\n    }\n\n    // Load families for Framery\n    let loader = FamilyLoader::load(mfr_path, \"DE\");\n    let families = loader.get_families();\n    println!(\"\\n=== Framery families ===\");\n    println!(\"Found {} families\", families.len());\n\n    // Find a family\n    if let Some(family) = families.first() {\n        println!(\"Testing family: {} - {}\", family.id, family.name);\n        println!(\"Base article: {}\", family.base_article_nr);\n        println!(\"Property classes: {:?}\", family.prop_classes);\n\n        // Get properties\n        let props = loader.get_properties_for_family(family);\n        println!(\"Properties: {}\", props.len());\n        for prop in props.iter().take(5) {\n            println!(\n                \"  {} ({}) - {} options\",\n                prop.key,\n                prop.label,\n                prop.options.len()\n            );\n        }\n\n        // Create configuration\n        let config = FamilyConfiguration::new(&family.id, &props);\n        println!(\"\\nConfiguration selections: {:?}\", config.selections);\n\n        // Calculate price\n        let engine = ConfigurationEngine::new(path);\n        let today = chrono::Local::now().date_naive();\n        let price_result = engine.calculate_family_price(\"framery\", family, &config, today);\n\n        println!(\"\\nPrice result: {:?}\", price_result);\n\n        // Framery should now return a price (even if 0 base + 0 surcharges)\n        assert!(\n            price_result.is_some(),\n            \"Framery should return a price result (even if 0)\"\n        );\n\n        if let Some(price) = price_result {\n            println!(\"  Base price: {} {}\", price.base_price, price.currency);\n            println!(\"  Total: {} {}\", price.total_price, price.currency);\n        }\n    }\n}\n\n#[test]\nfn test_fast_kr_price_variations() {\n    use ofml_lib::oap::engine::ConfigurationEngine;\n    use ofml_lib::oap::families::{FamilyConfiguration, FamilyLoader};\n\n    // Clear cache to ensure we get fresh data\n    clear_property_cache();\n\n    let path = Path::new(\"/reference/ofmldata\");\n    let mfr_path = Path::new(\"/reference/ofmldata/fast\");\n    if !mfr_path.exists() {\n        println!(\"FAST manufacturer data not available, skipping test\");\n        return;\n    }\n\n    let loader = FamilyLoader::load(mfr_path, \"DE\");\n\n    // Find KR family (Kreise)\n    let kr_family = loader\n        .get_families()\n        .iter()\n        .find(|f| f.series.to_uppercase() == \"KR\");\n    if kr_family.is_none() {\n        println!(\"KR family not found, skipping test\");\n        return;\n    }\n    let kr_family = kr_family.unwrap();\n    println!(\"\\n=== Testing FAST KR (Kreise) pricing ===\");\n    println!(\"Family: {} - {}\", kr_family.id, kr_family.name);\n    println!(\"Base article: {}\", kr_family.base_article_nr);\n    println!(\"Property classes: {:?}\", kr_family.prop_classes);\n\n    let props = loader.get_properties_for_family(kr_family);\n    println!(\"\\nProperties:\");\n    for prop in &props {\n        println!(\n            \"  {} ({}) - {} options: {:?}\",\n            prop.key,\n            prop.label,\n            prop.options.len(),\n            prop.options.iter().map(|o| &o.value).collect::<Vec<_>>()\n        );\n    }\n\n    let engine = ConfigurationEngine::new(path);\n    let today = chrono::Local::now().date_naive();\n\n    // Test different Abmessung (size) values - this should change prices\n    println!(\"\\n--- Testing Abmessung variations ---\");\n    for size in &[\"100X60\", \"35X35\", \"22X22\"] {\n        let mut config = FamilyConfiguration::new(&kr_family.id, &props);\n        config.set(\"Abmessung\", size);\n\n        println!(\"\\n  Abmessung = {}\", size);\n        let price = engine.calculate_family_price(\"fast\", kr_family, &config, today);\n        if let Some(p) = price {\n            println!(\"  Price: {} {}\", p.total_price, p.currency);\n        } else {\n            println!(\"  Price: None\");\n        }\n    }\n\n    // Test different Farbe_Rahmen (color) values - this should also change prices\n    println!(\"\\n--- Testing Farbe_Rahmen variations ---\");\n    for color in &[\"VOLLHOLZ_SCHWARZ\", \"VOLLHOLZ_EICHE\", \"MDF_WEIS\"] {\n        let mut config = FamilyConfiguration::new(&kr_family.id, &props);\n        config.set(\"Farbe_Rahmen\", color);\n\n        println!(\"\\n  Farbe_Rahmen = {}\", color);\n        let price = engine.calculate_family_price(\"fast\", kr_family, &config, today);\n        if let Some(p) = price {\n            println!(\"  Price: {} {}\", p.total_price, p.currency);\n        } else {\n            println!(\"  Price: None\");\n        }\n    }\n\n    println!(\"\\n=== FAST KR test complete ===\");\n}\n\n#[test]\nfn test_fast_kr_form_options_debug() {\n    use ofml_lib::ebase::EBaseReader;\n\n    let path = std::path::Path::new(\"/reference/ofmldata/fast/kr/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"FAST KR data not available, skipping test\");\n        return;\n    }\n\n    let mut reader = EBaseReader::open(path).expect(\"Should open FAST KR ebase\");\n\n    // Check ocd_propertyvalue for Form property\n    println!(\"\\n=== Form property values in ocd_propertyvalue ===\");\n    if let Ok(values) = reader.read_records(\"ocd_propertyvalue\", Some(100)) {\n        let form_values: Vec<_> = values\n            .iter()\n            .filter(|v| {\n                let prop = v.get(\"property\").and_then(|v| v.as_str()).unwrap_or(\"\");\n                prop.to_uppercase() == \"FORM\"\n            })\n            .collect();\n        println!(\"Form values: {}\", form_values.len());\n        for v in &form_values {\n            let value = v.get(\"value_from\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            let prop_class = v.get(\"prop_class\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            println!(\"  {} = {}\", prop_class, value);\n        }\n    }\n\n    // Check what properties exist\n    println!(\"\\n=== All properties ===\");\n    if let Ok(props) = reader.read_records(\"ocd_property\", Some(50)) {\n        for p in &props {\n            let name = p.get(\"property\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            let prop_class = p.get(\"prop_class\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            let scope = p.get(\"scope\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            println!(\"  {} | {} | scope={}\", prop_class, name, scope);\n        }\n    }\n}\n\n#[test]\nfn test_fast_kr_varcond_debug() {\n    use ofml_lib::oap::ocd_properties::{\n        clear_property_cache, load_manufacturer_properties,\n    };\n\n    clear_property_cache();\n\n    let path = Path::new(\"/reference/ofmldata/fast\");\n    if !path.exists() {\n        println!(\"FAST data not available\");\n        return;\n    }\n\n    let reader = load_manufacturer_properties(path);\n\n    println!(\"\\n=== Testing var_cond computation for KR ===\\n\");\n\n    // Show custom tables\n    println!(\"Custom tables available:\");\n    for (name, data) in &reader.custom_tables {\n        println!(\"  {} ({} rows)\", name, data.len());\n        if name.contains(\"groesse\") || name.contains(\"artikelnummer\") {\n            if let Some(first) = data.first() {\n                println!(\"    Columns: {:?}\", first.keys().collect::<Vec<_>>());\n            }\n        }\n    }\n\n    // Show relations for KR/Rahmen class\n    println!(\"\\nRelations:\");\n    for (name, rels) in &reader.relations {\n        println!(\"  {}:\", name);\n        for rel in rels {\n            println!(\"    {}\", rel.rel_block);\n        }\n    }\n\n    // Test var_cond computation for KR\n    let mut selections: HashMap<String, String> = HashMap::new();\n    selections.insert(\"Abmessung\".to_string(), \"100X60\".to_string());\n    selections.insert(\"Farbe_Rahmen\".to_string(), \"VOLLHOLZ_SCHWARZ\".to_string());\n    selections.insert(\"Moos\".to_string(), \"Kreise\".to_string()); // Try Moos property\n    selections.insert(\"Form\".to_string(), \"KR1\".to_string());\n\n    println!(\"\\nSelections: {:?}\", selections);\n    println!(\"uses_table_varcond: {}\", reader.uses_table_varcond());\n\n    let varcond = reader.compute_varcond_from_selections(\"Rahmen\", &selections);\n    println!(\"Computed var_cond: {:?}\", varcond);\n}\n#[test]\nfn test_frmr_2q_price_debug() {\n    use ofml_lib::ebase::EBaseReader;\n    use ofml_lib::oap::ocd::OcdReader;\n    use std::path::Path;\n\n    let path = Path::new(\"/reference/ofmldata/framery/frmr_2q/ANY/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"frmr_2q not available\");\n        return;\n    }\n\n    let mut reader = EBaseReader::open(path).expect(\"Should open Framery 2Q ebase\");\n\n    println!(\"\\n=== frmr_2q ocd_price raw records ===\");\n    if let Ok(prices) = reader.read_records(\"ocd_price\", Some(25)) {\n        println!(\"Found {} price records\", prices.len());\n        for (i, p) in prices.iter().enumerate() {\n            let article = p.get(\"article_nr\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            let var_cond = p.get(\"var_cond\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            let level = p.get(\"price_level\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            let price = p.get(\"price\").and_then(|v| v.as_f64()).unwrap_or(0.0);\n            let currency = p.get(\"currency\").and_then(|v| v.as_str()).unwrap_or(\"\");\n            println!(\n                \"[{:2}] article={:25} level='{:3}' var_cond={:40} price={:>12.2} {}\",\n                i, article, level, var_cond, price, currency\n            );\n        }\n    }\n\n    println!(\"\\n=== OcdReader prices ===\");\n    let ocd = OcdReader::from_ebase(path).expect(\"Should load OcdReader\");\n    println!(\"Total valid prices: {}\", ocd.prices.len());\n\n    for (i, p) in ocd.prices.iter().enumerate() {\n        println!(\n            \"[{:2}] article={:25} level='{:3}' var_cond={:40} price={:>12.2} {}\",\n            i, p.article_nr, p.price_level, p.var_cond, p.price, p.currency\n        );\n    }\n\n    println!(\"\\n=== Base price lookup ===\");\n    for article in &[\"2Q_HUDDLE\", \"2Q_LOUNGE\", \"2Q_WITHOUT_FURNITURE\"] {\n        if let Some(bp) = ocd.get_base_price(article) {\n            println!(\"{}: {} {}\", article, bp.price, bp.currency);\n        } else {\n            println!(\"{}: NOT FOUND!\", article);\n        }\n    }\n\n    println!(\n        \"\\nhas_surcharge_only_pricing: {}\",\n        ocd.has_surcharge_only_pricing()\n    );\n}\n\n#[test]\nfn test_framery_price_trace() {\n    use ofml_lib::oap::ocd::{find_pdata_files, get_ocd_reader};\n    use ofml_lib::oap::ocd_properties::clear_property_cache;\n    use std::path::Path;\n\n    clear_property_cache();\n\n    let mfr_path = Path::new(\"/reference/ofmldata/framery\");\n\n    println!(\"\\n=== Tracing price lookup for 2Q_HUDDLE ===\\n\");\n\n    let pdata_files = find_pdata_files(mfr_path);\n    println!(\"Found {} pdata.ebase files:\", pdata_files.len());\n    for (i, f) in pdata_files.iter().enumerate() {\n        println!(\"[{:2}] {}\", i, f.display());\n    }\n\n    println!(\"\\n=== Searching for 2Q_HUDDLE prices in each file ===\");\n    for pdata_path in &pdata_files {\n        if let Some(reader) = get_ocd_reader(pdata_path) {\n            let prices = reader.get_prices(\"2Q_HUDDLE\");\n            if !prices.is_empty() {\n                println!(\"\\n‚úì FOUND in {}:\", pdata_path.display());\n                for p in &prices {\n                    println!(\n                        \"  level='{}' var_cond='{}' price={} {}\",\n                        p.price_level, p.var_cond, p.price, p.currency\n                    );\n                }\n            } else {\n                // Check if this file has ANY prices\n                let has_prices = !reader.prices.is_empty();\n                let has_articles = reader.articles.iter().any(|a| a.article_nr.contains(\"2Q\"));\n                println!(\n                    \"‚úó Not in {} (prices={}, has_2Q_articles={})\",\n                    pdata_path.file_name().unwrap().to_str().unwrap(),\n                    reader.prices.len(),\n                    has_articles\n                );\n            }\n        }\n    }\n\n    // Also check wildcard prices\n    println!(\"\\n=== Checking wildcard prices ===\");\n    for pdata_path in &pdata_files {\n        if let Some(reader) = get_ocd_reader(pdata_path) {\n            let prices = reader.get_prices(\"*\");\n            if !prices.is_empty() {\n                let series = pdata_path\n                    .parent()\n                    .unwrap()\n                    .parent()\n                    .unwrap()\n                    .parent()\n                    .unwrap()\n                    .parent()\n                    .unwrap()\n                    .file_name()\n                    .unwrap()\n                    .to_str()\n                    .unwrap();\n                println!(\"{}: {} wildcard prices\", series, prices.len());\n            }\n        }\n    }\n}\n\n#[test]\nfn test_one_compact_prices_debug() {\n    use ofml_lib::oap::ocd::OcdReader;\n    use std::path::Path;\n\n    let path = Path::new(\"/reference/ofmldata/framery/frmr_one_compact/ANY/1/db/pdata.ebase\");\n    if !path.exists() {\n        println!(\"frmr_one_compact not available\");\n        return;\n    }\n\n    let ocd = OcdReader::from_ebase(path).expect(\"Should load OcdReader\");\n\n    println!(\n        \"\\n=== ALL prices in frmr_one_compact ({} total) ===\",\n        ocd.prices.len()\n    );\n    for (i, p) in ocd.prices.iter().enumerate() {\n        println!(\n            \"[{:2}] article={:25} level={} var_cond={:30} price={:>12.2} {}\",\n            i, p.article_nr, p.price_level, p.var_cond, p.price, p.currency\n        );\n    }\n\n    println!(\"\\n=== Base price lookup ===\");\n    for article in &[\"ONE_COMPACT_ESSENTIALS\", \"ONE_COMPACT_BASE\"] {\n        if let Some(bp) = ocd.get_base_price(article) {\n            println!(\"{}: {} {}\", article, bp.price, bp.currency);\n        } else {\n            println!(\"{}: NOT FOUND\", article);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","unit","test_descriptions.rs"],"content":"use ofml_lib::oap::ocd::OcdReader;\nuse std::path::Path;\n\n#[test]\nfn test_abalon_descriptions() {\n    let path = Path::new(\"/workspace/ofmldata/vitra/abalon/DE/1/db/pdata.ebase\");\n    if !path.exists() {\n        return;\n    }\n\n    let reader = OcdReader::from_ebase(path).expect(\"Should load\");\n\n    println!(\"Articles: {}\", reader.articles.len());\n    println!(\"Short texts: {}\", reader.short_texts.len());\n\n    // List all short_texts keys\n    println!(\"\\nShort text keys:\");\n    for key in reader.short_texts.keys().take(10) {\n        println!(\"  '{}'\", key);\n    }\n\n    for article in &reader.articles {\n        let desc = reader.get_short_description(&article.short_textnr, \"DE\");\n        println!(\n            \"\\nArticle {} (textnr='{}')\",\n            article.article_nr, article.short_textnr\n        );\n        println!(\"  Description: {:?}\", desc);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","unit","tui_data_validation_test.rs"],"content":"//! TUI e2e tests for data validation\n//!\n//! These tests verify that the TUI can correctly load and display data\n//! from multiple manufacturers with proper pricing information.\n\n#[cfg(feature = \"tui\")]\nmod tui_data_tests {\n    use ofml_lib::oap::engine::ConfigurationEngine;\n    use ofml_lib::oap::families::{FamilyConfiguration, FamilyLoader};\n    use ofml_lib::oap::manufacturers::get_installed_manufacturers;\n    use ofml_lib::oap::ocd::OcdReader;\n    use std::path::Path;\n\n    const OFMLDATA_BASE: &str = \"/reference/ofmldata\";\n\n    fn ofmldata_exists() -> bool {\n        Path::new(OFMLDATA_BASE).exists()\n    }\n\n    #[test]\n    fn test_manufacturer_loading() {\n        if !ofmldata_exists() {\n            eprintln!(\"Skipping: ofmldata not found\");\n            return;\n        }\n\n        let manufacturers = get_installed_manufacturers(Path::new(OFMLDATA_BASE));\n\n        println!(\"\\n=== Manufacturer Loading Test ===\\n\");\n        println!(\"Total manufacturers found: {}\", manufacturers.len());\n\n        // Should find many manufacturers\n        assert!(\n            manufacturers.len() >= 50,\n            \"Should find at least 50 manufacturers\"\n        );\n\n        // Check some known manufacturers exist\n        let known_mfrs = [\"vitra\", \"sex\", \"kn\", \"sbu\", \"aix\"];\n        for mfr_id in &known_mfrs {\n            let found = manufacturers.iter().any(|m| m.id == *mfr_id);\n            println!(\"  {} found: {}\", mfr_id, found);\n            assert!(found, \"Should find manufacturer {}\", mfr_id);\n        }\n    }\n\n    #[test]\n    fn test_sedus_family_loading() {\n        if !ofmldata_exists() {\n            eprintln!(\"Skipping: ofmldata not found\");\n            return;\n        }\n\n        let mfr_path = Path::new(OFMLDATA_BASE).join(\"sex\");\n        if !mfr_path.exists() {\n            eprintln!(\"Skipping: Sedus not found\");\n            return;\n        }\n\n        let loader = FamilyLoader::load(&mfr_path, \"DE\");\n        let families = loader.get_families();\n\n        println!(\"\\n=== Sedus Family Loading Test ===\\n\");\n        println!(\"Total families: {}\", families.len());\n\n        // Should have at least one family\n        assert!(!families.is_empty(), \"Sedus should have product families\");\n\n        // Print first few families\n        for (i, family) in families.iter().take(5).enumerate() {\n            println!(\n                \"  [{}] {} - {} ({} articles)\",\n                i,\n                family.id,\n                family.name,\n                family.article_nrs.len()\n            );\n        }\n    }\n\n    #[test]\n    fn test_configuration_engine_articles() {\n        if !ofmldata_exists() {\n            eprintln!(\"Skipping: ofmldata not found\");\n            return;\n        }\n\n        let mut engine = ConfigurationEngine::new(OFMLDATA_BASE);\n\n        println!(\"\\n=== Configuration Engine Articles Test ===\\n\");\n\n        let manufacturers = [\"sex\", \"vitra\", \"kn\"];\n        for mfr in &manufacturers {\n            let articles = engine.load_articles(mfr);\n            if articles.is_empty() {\n                println!(\"{}: No articles found\", mfr);\n                continue;\n            }\n\n            let configurable = articles.iter().filter(|a| a.is_configurable).count();\n            println!(\n                \"{}: {} articles ({} configurable)\",\n                mfr,\n                articles.len(),\n                configurable\n            );\n\n            // Show first few articles\n            for article in articles.iter().take(3) {\n                println!(\n                    \"  - {} ({})\",\n                    article.article.article_nr, article.description\n                );\n            }\n        }\n    }\n\n    #[test]\n    fn test_sedus_pricing_display() {\n        if !ofmldata_exists() {\n            eprintln!(\"Skipping: ofmldata not found\");\n            return;\n        }\n\n        let path = Path::new(\"/reference/ofmldata/sex/ai/DE/1/db/pdata.ebase\");\n        if !path.exists() {\n            eprintln!(\"Skipping: Sedus AI pdata.ebase not found\");\n            return;\n        }\n\n        let reader = OcdReader::from_ebase(path).expect(\"Should load OCD\");\n\n        println!(\"\\n=== Sedus Pricing Display Test ===\\n\");\n\n        // Test AI-121 pricing (known test article)\n        let article_nr = \"AI-121\";\n        let base_price = reader.get_base_price(article_nr);\n        let surcharges = reader.get_surcharges(article_nr);\n\n        println!(\"Article: {}\", article_nr);\n\n        if let Some(base) = base_price {\n            println!(\n                \"  Base price: {:.2} {} (level='{}', var_cond='{}')\",\n                base.price, base.currency, base.price_level, base.var_cond\n            );\n            assert_eq!(base.price_level, \"B\", \"Base price should have level 'B'\");\n        } else {\n            panic!(\"Should find base price for {}\", article_nr);\n        }\n\n        println!(\"  Surcharges: {}\", surcharges.len());\n        for s in surcharges.iter().take(5) {\n            println!(\n                \"    {} = {:.2} {} (is_fix={})\",\n                s.var_cond, s.price, s.currency, s.is_fix\n            );\n        }\n\n        // Verify we have surcharges\n        assert!(!surcharges.is_empty(), \"Should have surcharges\");\n    }\n\n    #[test]\n    fn test_family_price_calculation() {\n        if !ofmldata_exists() {\n            eprintln!(\"Skipping: ofmldata not found\");\n            return;\n        }\n\n        let engine = ConfigurationEngine::new(OFMLDATA_BASE);\n        let mfr_path = Path::new(OFMLDATA_BASE).join(\"sex\");\n\n        if !mfr_path.exists() {\n            eprintln!(\"Skipping: Sedus not found\");\n            return;\n        }\n\n        println!(\"\\n=== Family Price Calculation Test ===\\n\");\n\n        let loader = FamilyLoader::load(&mfr_path, \"DE\");\n        let families = loader.get_families();\n\n        // Find a family with articles\n        for family in families.iter().take(5) {\n            let properties = loader.get_properties_for_family(family);\n            let config = FamilyConfiguration::new(&family.id, &properties);\n            let price_date = chrono::Local::now().date_naive();\n            let price = engine.calculate_family_price(\"sex\", family, &config, price_date);\n\n            if let Some(p) = price {\n                println!(\"Family: {} ({})\", family.name, family.id);\n                println!(\"  Base article: {}\", family.base_article_nr);\n                println!(\"  Base price: {:.2} {}\", p.base_price, p.currency);\n                println!(\"  Total: {:.2} {}\", p.total_price, p.currency);\n                if !p.surcharges.is_empty() {\n                    println!(\"  Surcharges: {}\", p.surcharges.len());\n                }\n                return; // Found one with pricing, test passes\n            }\n        }\n\n        // If no prices found, still pass (some data may not have prices)\n        println!(\"No prices found for tested families (may be expected)\");\n    }\n\n    #[test]\n    fn test_multi_manufacturer_data_accessibility() {\n        if !ofmldata_exists() {\n            eprintln!(\"Skipping: ofmldata not found\");\n            return;\n        }\n\n        println!(\"\\n=== Multi-Manufacturer Data Accessibility Test ===\\n\");\n\n        let mut engine = ConfigurationEngine::new(OFMLDATA_BASE);\n\n        let test_manufacturers = [\n            \"sex\", \"vitra\", \"kn\", \"sbu\", \"haw\", \"aix\", \"arper\", \"cassina\",\n        ];\n\n        let mut success_count = 0;\n        let mut family_count = 0;\n        let mut price_count = 0;\n\n        for mfr in &test_manufacturers {\n            let mfr_path = Path::new(OFMLDATA_BASE).join(mfr);\n            if !mfr_path.exists() {\n                continue;\n            }\n\n            // Load families\n            let families: Vec<_> = engine.load_families(mfr).to_vec();\n            if families.is_empty() {\n                println!(\"{}: No families found\", mfr);\n                continue;\n            }\n\n            success_count += 1;\n            family_count += families.len();\n\n            // Check if we can get pricing for any family\n            let price_date = chrono::Local::now().date_naive();\n            let loader = FamilyLoader::load(&mfr_path, \"DE\");\n            for family in families.iter().take(3) {\n                let properties = loader.get_properties_for_family(family);\n                let config = FamilyConfiguration::new(&family.id, &properties);\n                if let Some(_price) =\n                    engine.calculate_family_price(mfr, family, &config, price_date)\n                {\n                    price_count += 1;\n                }\n            }\n\n            println!(\n                \"{}: {} families, pricing available: {}\",\n                mfr,\n                families.len(),\n                price_count > 0\n            );\n        }\n\n        println!(\"\\nSummary:\");\n        println!(\n            \"  Manufacturers with data: {}/{}\",\n            success_count,\n            test_manufacturers.len()\n        );\n        println!(\"  Total families: {}\", family_count);\n        println!(\"  Families with pricing: {}\", price_count);\n\n        assert!(\n            success_count >= 3,\n            \"Should have at least 3 manufacturers with data\"\n        );\n    }\n\n    #[test]\n    fn test_price_level_distribution() {\n        if !ofmldata_exists() {\n            eprintln!(\"Skipping: ofmldata not found\");\n            return;\n        }\n\n        println!(\"\\n=== Price Level Distribution Test ===\\n\");\n\n        let manufacturers = [\"sex\", \"vitra\", \"kn\"];\n\n        for mfr in &manufacturers {\n            let mfr_path = Path::new(OFMLDATA_BASE).join(mfr);\n            if !mfr_path.exists() {\n                continue;\n            }\n\n            // Find first pdata.ebase\n            if let Some(pdata_path) = find_first_pdata(&mfr_path) {\n                match OcdReader::from_ebase(&pdata_path) {\n                    Ok(reader) => {\n                        let base = reader\n                            .prices\n                            .iter()\n                            .filter(|p| p.price_level == \"B\")\n                            .count();\n                        let surcharge = reader\n                            .prices\n                            .iter()\n                            .filter(|p| p.price_level == \"X\")\n                            .count();\n                        let discount = reader\n                            .prices\n                            .iter()\n                            .filter(|p| p.price_level == \"D\")\n                            .count();\n                        let empty = reader\n                            .prices\n                            .iter()\n                            .filter(|p| p.price_level.is_empty())\n                            .count();\n\n                        println!(\"{}: {} prices\", mfr, reader.prices.len());\n                        println!(\"  B (base): {}\", base);\n                        println!(\"  X (surcharge): {}\", surcharge);\n                        println!(\"  D (discount): {}\", discount);\n                        println!(\"  empty: {}\", empty);\n\n                        // Most manufacturers should have at least some prices with levels\n                        if reader.prices.len() > 0 {\n                            let populated_ratio =\n                                (base + surcharge + discount) as f64 / reader.prices.len() as f64;\n                            println!(\"  populated ratio: {:.1}%\", populated_ratio * 100.0);\n                        }\n                    }\n                    Err(e) => {\n                        println!(\"{}: Error - {}\", mfr, e);\n                    }\n                }\n            }\n        }\n    }\n\n    fn find_first_pdata(path: &Path) -> Option<std::path::PathBuf> {\n        fn find_recursive(path: &Path) -> Option<std::path::PathBuf> {\n            if let Ok(entries) = std::fs::read_dir(path) {\n                for entry in entries.flatten() {\n                    let entry_path = entry.path();\n                    if entry_path.is_dir() {\n                        if let Some(found) = find_recursive(&entry_path) {\n                            return Some(found);\n                        }\n                    } else if entry_path.file_name().map_or(false, |n| n == \"pdata.ebase\") {\n                        return Some(entry_path);\n                    }\n                }\n            }\n            None\n        }\n        find_recursive(path)\n    }\n}\n\n#[cfg(not(feature = \"tui\"))]\n#[test]\nfn test_tui_feature_disabled() {\n    // This test passes when TUI feature is disabled\n    println!(\"TUI feature is disabled, skipping TUI tests\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","unit","tui_form_test.rs"],"content":"//! Unit tests for TUI property form validation (T040)\r\n\r\n#[cfg(feature = \"tui\")]\r\nmod form_tests {\r\n    use ofml_lib::property::{PropertyDef, PropertyState, PropertyType, PropertyValue};\r\n    use ofml_lib::tui::widgets::form::PropertyFormState;\r\n\r\n    fn create_int_property() -> PropertyDef {\r\n        PropertyDef {\r\n            name: \"height\".to_string(),\r\n            label: \"H√∂he\".to_string(),\r\n            prop_type: PropertyType::Int {\r\n                min: Some(620),\r\n                max: Some(820),\r\n            },\r\n            state: PropertyState::Enabled,\r\n            sort_order: 1,\r\n            description: None,\r\n            category: None,\r\n        }\r\n    }\r\n\r\n    fn create_float_property() -> PropertyDef {\r\n        PropertyDef {\r\n            name: \"width\".to_string(),\r\n            label: \"Breite\".to_string(),\r\n            prop_type: PropertyType::Float {\r\n                min: Some(0.5),\r\n                max: Some(2.5),\r\n            },\r\n            state: PropertyState::Enabled,\r\n            sort_order: 2,\r\n            description: None,\r\n            category: None,\r\n        }\r\n    }\r\n\r\n    fn create_choice_property() -> PropertyDef {\r\n        PropertyDef {\r\n            name: \"color\".to_string(),\r\n            label: \"Farbe\".to_string(),\r\n            prop_type: PropertyType::Choice {\r\n                options: vec![\"white\".to_string(), \"black\".to_string(), \"oak\".to_string()],\r\n            },\r\n            state: PropertyState::Enabled,\r\n            sort_order: 3,\r\n            description: None,\r\n            category: None,\r\n        }\r\n    }\r\n\r\n    fn create_bool_property() -> PropertyDef {\r\n        PropertyDef {\r\n            name: \"enabled\".to_string(),\r\n            label: \"Aktiviert\".to_string(),\r\n            prop_type: PropertyType::Bool,\r\n            state: PropertyState::Enabled,\r\n            sort_order: 4,\r\n            description: None,\r\n            category: None,\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_form_state_default() {\r\n        let state = PropertyFormState::default();\r\n        assert!(state.input.is_empty());\r\n        assert_eq!(state.cursor, 0);\r\n        assert!(!state.editing);\r\n        assert!(state.error.is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn test_form_state_from_int_value() {\r\n        let state = PropertyFormState::new(&PropertyValue::Int(720));\r\n        assert_eq!(state.input, \"720\");\r\n        assert_eq!(state.cursor, 3);\r\n    }\r\n\r\n    #[test]\r\n    fn test_form_state_from_float_value() {\r\n        let state = PropertyFormState::new(&PropertyValue::Float(1.5));\r\n        assert_eq!(state.input, \"1.5\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_form_state_from_bool_value() {\r\n        let state = PropertyFormState::new(&PropertyValue::Bool(true));\r\n        assert_eq!(state.input, \"ja\");\r\n\r\n        let state = PropertyFormState::new(&PropertyValue::Bool(false));\r\n        assert_eq!(state.input, \"nein\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_form_state_from_string_value() {\r\n        let state = PropertyFormState::new(&PropertyValue::String(\"test\".to_string()));\r\n        assert_eq!(state.input, \"test\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_form_state_from_symbol_value() {\r\n        let state = PropertyFormState::new(&PropertyValue::Symbol(\"white\".to_string()));\r\n        assert_eq!(state.input, \"white\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_form_insert_character() {\r\n        let mut state = PropertyFormState::default();\r\n        state.insert('7');\r\n        state.insert('2');\r\n        state.insert('0');\r\n        assert_eq!(state.input, \"720\");\r\n        assert_eq!(state.cursor, 3);\r\n    }\r\n\r\n    #[test]\r\n    fn test_form_backspace() {\r\n        let mut state = PropertyFormState::default();\r\n        state.input = \"720\".to_string();\r\n        state.cursor = 3;\r\n\r\n        state.backspace();\r\n        assert_eq!(state.input, \"72\");\r\n        assert_eq!(state.cursor, 2);\r\n    }\r\n\r\n    #[test]\r\n    fn test_form_backspace_at_start() {\r\n        let mut state = PropertyFormState::default();\r\n        state.input = \"720\".to_string();\r\n        state.cursor = 0;\r\n\r\n        state.backspace();\r\n        // Should not change anything\r\n        assert_eq!(state.input, \"720\");\r\n        assert_eq!(state.cursor, 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_form_delete() {\r\n        let mut state = PropertyFormState::default();\r\n        state.input = \"720\".to_string();\r\n        state.cursor = 0;\r\n\r\n        state.delete();\r\n        assert_eq!(state.input, \"20\");\r\n        assert_eq!(state.cursor, 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_form_delete_at_end() {\r\n        let mut state = PropertyFormState::default();\r\n        state.input = \"720\".to_string();\r\n        state.cursor = 3;\r\n\r\n        state.delete();\r\n        // Should not change anything\r\n        assert_eq!(state.input, \"720\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_form_cursor_movement() {\r\n        let mut state = PropertyFormState::default();\r\n        state.input = \"720\".to_string();\r\n        state.cursor = 1;\r\n\r\n        state.left();\r\n        assert_eq!(state.cursor, 0);\r\n\r\n        state.left();\r\n        assert_eq!(state.cursor, 0); // Can't go below 0\r\n\r\n        state.right();\r\n        assert_eq!(state.cursor, 1);\r\n\r\n        state.right();\r\n        state.right();\r\n        assert_eq!(state.cursor, 3);\r\n\r\n        state.right();\r\n        assert_eq!(state.cursor, 3); // Can't exceed length\r\n    }\r\n\r\n    #[test]\r\n    fn test_validate_int_valid() {\r\n        let def = create_int_property();\r\n        let mut state = PropertyFormState::default();\r\n        state.input = \"720\".to_string();\r\n\r\n        let result = state.validate(&def);\r\n        assert!(result.is_ok());\r\n        assert_eq!(result.unwrap(), PropertyValue::Int(720));\r\n    }\r\n\r\n    #[test]\r\n    fn test_validate_int_below_min() {\r\n        let def = create_int_property();\r\n        let mut state = PropertyFormState::default();\r\n        state.input = \"500\".to_string();\r\n\r\n        let result = state.validate(&def);\r\n        assert!(result.is_err());\r\n        assert!(result.unwrap_err().contains(\"mindestens\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_validate_int_above_max() {\r\n        let def = create_int_property();\r\n        let mut state = PropertyFormState::default();\r\n        state.input = \"900\".to_string();\r\n\r\n        let result = state.validate(&def);\r\n        assert!(result.is_err());\r\n        assert!(result.unwrap_err().contains(\"h√∂chstens\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_validate_int_invalid_format() {\r\n        let def = create_int_property();\r\n        let mut state = PropertyFormState::default();\r\n        state.input = \"abc\".to_string();\r\n\r\n        let result = state.validate(&def);\r\n        assert!(result.is_err());\r\n        assert!(result.unwrap_err().contains(\"Ung√ºltige Ganzzahl\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_validate_float_valid() {\r\n        let def = create_float_property();\r\n        let mut state = PropertyFormState::default();\r\n        state.input = \"1.5\".to_string();\r\n\r\n        let result = state.validate(&def);\r\n        assert!(result.is_ok());\r\n        assert_eq!(result.unwrap(), PropertyValue::Float(1.5));\r\n    }\r\n\r\n    #[test]\r\n    fn test_validate_float_below_min() {\r\n        let def = create_float_property();\r\n        let mut state = PropertyFormState::default();\r\n        state.input = \"0.1\".to_string();\r\n\r\n        let result = state.validate(&def);\r\n        assert!(result.is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_validate_choice_valid() {\r\n        let def = create_choice_property();\r\n        let mut state = PropertyFormState::default();\r\n        state.input = \"white\".to_string();\r\n\r\n        let result = state.validate(&def);\r\n        assert!(result.is_ok());\r\n        assert_eq!(result.unwrap(), PropertyValue::Symbol(\"white\".to_string()));\r\n    }\r\n\r\n    #[test]\r\n    fn test_validate_choice_invalid() {\r\n        let def = create_choice_property();\r\n        let mut state = PropertyFormState::default();\r\n        state.input = \"red\".to_string();\r\n\r\n        let result = state.validate(&def);\r\n        assert!(result.is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_validate_bool_ja() {\r\n        let def = create_bool_property();\r\n        let mut state = PropertyFormState::default();\r\n        state.input = \"ja\".to_string();\r\n\r\n        let result = state.validate(&def);\r\n        assert!(result.is_ok());\r\n        assert_eq!(result.unwrap(), PropertyValue::Bool(true));\r\n    }\r\n\r\n    #[test]\r\n    fn test_validate_bool_nein() {\r\n        let def = create_bool_property();\r\n        let mut state = PropertyFormState::default();\r\n        state.input = \"nein\".to_string();\r\n\r\n        let result = state.validate(&def);\r\n        assert!(result.is_ok());\r\n        assert_eq!(result.unwrap(), PropertyValue::Bool(false));\r\n    }\r\n\r\n    #[test]\r\n    fn test_validate_bool_true() {\r\n        let def = create_bool_property();\r\n        let mut state = PropertyFormState::default();\r\n        state.input = \"true\".to_string();\r\n\r\n        let result = state.validate(&def);\r\n        assert!(result.is_ok());\r\n        assert_eq!(result.unwrap(), PropertyValue::Bool(true));\r\n    }\r\n\r\n    #[test]\r\n    fn test_validate_bool_invalid() {\r\n        let def = create_bool_property();\r\n        let mut state = PropertyFormState::default();\r\n        state.input = \"maybe\".to_string();\r\n\r\n        let result = state.validate(&def);\r\n        assert!(result.is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_cycle_choice_forward() {\r\n        let def = create_choice_property();\r\n        let mut state = PropertyFormState::default();\r\n        state.input = \"white\".to_string();\r\n\r\n        state.cycle_choice(&def, true);\r\n        assert_eq!(state.input, \"black\");\r\n\r\n        state.cycle_choice(&def, true);\r\n        assert_eq!(state.input, \"oak\");\r\n\r\n        state.cycle_choice(&def, true);\r\n        assert_eq!(state.input, \"white\"); // Wraps around\r\n    }\r\n\r\n    #[test]\r\n    fn test_cycle_choice_backward() {\r\n        let def = create_choice_property();\r\n        let mut state = PropertyFormState::default();\r\n        state.input = \"white\".to_string();\r\n\r\n        state.cycle_choice(&def, false);\r\n        assert_eq!(state.input, \"oak\"); // Wraps to last\r\n\r\n        state.cycle_choice(&def, false);\r\n        assert_eq!(state.input, \"black\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_toggle_bool() {\r\n        let mut state = PropertyFormState::default();\r\n        state.input = \"ja\".to_string();\r\n\r\n        state.toggle_bool();\r\n        assert_eq!(state.input, \"nein\");\r\n\r\n        state.toggle_bool();\r\n        assert_eq!(state.input, \"ja\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_error_clears_on_input() {\r\n        let mut state = PropertyFormState::default();\r\n        state.error = Some(\"Previous error\".to_string());\r\n\r\n        state.insert('1');\r\n        assert!(state.error.is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn test_error_clears_on_backspace() {\r\n        let mut state = PropertyFormState::default();\r\n        state.input = \"abc\".to_string();\r\n        state.cursor = 3;\r\n        state.error = Some(\"Previous error\".to_string());\r\n\r\n        state.backspace();\r\n        assert!(state.error.is_none());\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","unit","tui_resize_test.rs"],"content":"//! Unit tests for TUI terminal resize handling (T062)\n\n#[cfg(feature = \"tui\")]\nmod resize_tests {\n    use ofml_lib::oap::Manufacturer;\n    use ofml_lib::tui::{App, Message};\n    use std::path::PathBuf;\n\n    fn create_manufacturer(id: &str, name: &str) -> Manufacturer {\n        Manufacturer {\n            id: id.into(),\n            name: name.into(),\n            path: PathBuf::new(),\n        }\n    }\n\n    #[test]\n    fn test_resize_message_exists() {\n        // Verify Resize message variant exists\n        let _resize = Message::Resize(80, 24);\n    }\n\n    #[test]\n    fn test_app_handles_resize() {\n        let mut app = App::new(\"/path/to/data\".into());\n\n        // Should not panic on resize\n        app.update(Message::Resize(120, 40));\n\n        // App should still be functional\n        assert!(!app.should_quit);\n    }\n\n    #[test]\n    fn test_app_handles_small_resize() {\n        let mut app = App::new(\"/path/to/data\".into());\n\n        // Very small terminal\n        app.update(Message::Resize(20, 10));\n\n        // Should handle gracefully\n        assert!(!app.should_quit);\n    }\n\n    #[test]\n    fn test_app_handles_large_resize() {\n        let mut app = App::new(\"/path/to/data\".into());\n\n        // Very large terminal\n        app.update(Message::Resize(300, 100));\n\n        // Should handle gracefully\n        assert!(!app.should_quit);\n    }\n\n    #[test]\n    fn test_resize_updates_dimensions() {\n        let mut app = App::new(\"/path/to/data\".into());\n\n        app.update(Message::Resize(120, 40));\n\n        // Verify dimensions are updated\n        assert_eq!(app.terminal_size, (120, 40));\n    }\n\n    #[test]\n    fn test_multiple_resizes() {\n        let mut app = App::new(\"/path/to/data\".into());\n\n        // Simulate rapid resizing\n        app.update(Message::Resize(80, 24));\n        app.update(Message::Resize(100, 30));\n        app.update(Message::Resize(120, 40));\n        app.update(Message::Resize(80, 24));\n\n        // Should handle all gracefully\n        assert!(!app.should_quit);\n        assert_eq!(app.terminal_size, (80, 24));\n    }\n\n    #[test]\n    fn test_resize_during_search() {\n        let mut app = App::new(\"/path/to/data\".into());\n\n        app.update(Message::ToggleSearch);\n        app.search_query = \"test\".into();\n\n        // Resize during search\n        app.update(Message::Resize(100, 30));\n\n        // Search state should be preserved\n        assert!(app.search_active);\n        assert_eq!(app.search_query, \"test\");\n    }\n\n    #[test]\n    fn test_resize_preserves_selection() {\n        let mut app = App::new(\"/path/to/data\".into());\n        app.manufacturers = vec![\n            create_manufacturer(\"vitra\", \"Vitra AG\"),\n            create_manufacturer(\"sedus\", \"Sedus\"),\n        ];\n        app.manufacturer_list_state.select(Some(1));\n\n        // Resize\n        app.update(Message::Resize(100, 30));\n\n        // Selection should be preserved\n        assert_eq!(app.manufacturer_list_state.selected(), Some(1));\n    }\n\n    #[test]\n    fn test_resize_minimum_dimensions() {\n        let mut app = App::new(\"/path/to/data\".into());\n\n        // Minimum viable terminal size\n        app.update(Message::Resize(10, 5));\n\n        // Should still work, maybe with degraded UI\n        assert!(!app.should_quit);\n    }\n\n    #[test]\n    fn test_resize_zero_dimensions() {\n        let mut app = App::new(\"/path/to/data\".into());\n\n        // Edge case: zero dimensions (shouldn't happen but be defensive)\n        app.update(Message::Resize(0, 0));\n\n        // Should not crash\n        assert!(!app.should_quit);\n    }\n}\n\n// Test that resize works without TUI feature (no-op)\n#[cfg(not(feature = \"tui\"))]\n#[test]\nfn test_tui_feature_disabled() {\n    // When TUI is disabled, these types shouldn't be available\n    // This is a compile-time check\n    assert!(true);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","unit","tui_search_test.rs"],"content":"//! Unit tests for TUI search/filter functionality (T029a)\n\n#[cfg(feature = \"tui\")]\nmod search_tests {\n    use ofml_lib::oap::Manufacturer;\n    use ofml_lib::tui::{App, Message};\n    use std::path::PathBuf;\n\n    fn create_test_manufacturers() -> Vec<Manufacturer> {\n        vec![\n            Manufacturer {\n                id: \"vitra\".into(),\n                name: \"Vitra AG\".into(),\n                path: PathBuf::new(),\n            },\n            Manufacturer {\n                id: \"sedus\".into(),\n                name: \"Sedus Stoll AG\".into(),\n                path: PathBuf::new(),\n            },\n            Manufacturer {\n                id: \"vs\".into(),\n                name: \"VS Vereinigte\".into(),\n                path: PathBuf::new(),\n            },\n        ]\n    }\n\n    #[test]\n    fn test_search_mode_toggle() {\n        let mut app = App::new(\"/path/to/data\".into());\n        assert!(!app.search_active);\n        assert!(app.search_query.is_empty());\n\n        app.update(Message::ToggleSearch);\n        assert!(app.search_active);\n\n        app.update(Message::ToggleSearch);\n        assert!(!app.search_active);\n    }\n\n    #[test]\n    fn test_search_input() {\n        let mut app = App::new(\"/path/to/data\".into());\n        app.manufacturers = create_test_manufacturers();\n        app.update(Message::ToggleSearch);\n\n        // Simulate typing via UpdateSearch\n        app.update(Message::UpdateSearch(\"v\".into()));\n        assert_eq!(app.search_query, \"v\");\n\n        app.update(Message::UpdateSearch(\"vi\".into()));\n        assert_eq!(app.search_query, \"vi\");\n    }\n\n    #[test]\n    fn test_search_clears_on_exit() {\n        let mut app = App::new(\"/path/to/data\".into());\n        app.update(Message::ToggleSearch);\n        app.search_query = \"test\".into();\n\n        // Exit search mode\n        app.update(Message::ToggleSearch);\n        // Query should be cleared\n        assert!(app.search_query.is_empty());\n    }\n\n    #[test]\n    fn test_filter_updates_on_search() {\n        let mut app = App::new(\"/path/to/data\".into());\n        app.manufacturers = create_test_manufacturers();\n\n        // Search for \"vitra\"\n        app.update(Message::UpdateSearch(\"vitra\".into()));\n\n        // Should have filtered indices\n        assert_eq!(app.filtered_indices.len(), 1);\n        assert_eq!(app.filtered_indices[0], 0); // vitra is at index 0\n    }\n\n    #[test]\n    fn test_filter_case_insensitive() {\n        let mut app = App::new(\"/path/to/data\".into());\n        app.manufacturers = create_test_manufacturers();\n\n        // Search with uppercase\n        app.update(Message::UpdateSearch(\"VITRA\".into()));\n\n        // Should still find it\n        assert_eq!(app.filtered_indices.len(), 1);\n    }\n\n    #[test]\n    fn test_filter_matches_name() {\n        let mut app = App::new(\"/path/to/data\".into());\n        app.manufacturers = create_test_manufacturers();\n\n        // Search by name\n        app.update(Message::UpdateSearch(\"Stoll\".into()));\n\n        // Should find sedus\n        assert_eq!(app.filtered_indices.len(), 1);\n        assert_eq!(app.manufacturers[app.filtered_indices[0]].id, \"sedus\");\n    }\n\n    #[test]\n    fn test_filter_no_match() {\n        let mut app = App::new(\"/path/to/data\".into());\n        app.manufacturers = create_test_manufacturers();\n\n        app.update(Message::UpdateSearch(\"nonexistent\".into()));\n\n        assert!(app.filtered_indices.is_empty());\n    }\n\n    #[test]\n    fn test_filter_empty_query() {\n        let mut app = App::new(\"/path/to/data\".into());\n        app.manufacturers = create_test_manufacturers();\n\n        // Set and then clear query\n        app.update(Message::UpdateSearch(\"vitra\".into()));\n        assert!(!app.filtered_indices.is_empty());\n\n        app.update(Message::UpdateSearch(\"\".into()));\n        assert!(app.filtered_indices.is_empty());\n    }\n\n    #[test]\n    fn test_selection_resets_on_filter() {\n        let mut app = App::new(\"/path/to/data\".into());\n        app.manufacturers = create_test_manufacturers();\n        app.manufacturer_list_state.select(Some(2));\n\n        // Apply filter\n        app.update(Message::UpdateSearch(\"v\".into()));\n\n        // Selection should reset to 0\n        assert_eq!(app.manufacturer_list_state.selected(), Some(0));\n    }\n\n    #[test]\n    fn test_fuzzy_search_sorted_by_score() {\n        let mut app = App::new(\"/path/to/data\".into());\n        app.manufacturers = vec![\n            Manufacturer {\n                id: \"sedus\".into(),\n                name: \"Sedus Stoll AG\".into(), // 'v' is not at start\n                path: PathBuf::new(),\n            },\n            Manufacturer {\n                id: \"vitra\".into(),\n                name: \"Vitra AG\".into(), // 'v' is at start - should rank higher\n                path: PathBuf::new(),\n            },\n            Manufacturer {\n                id: \"vs\".into(),\n                name: \"VS Vereinigte\".into(), // 'v' is at start - should rank high\n                path: PathBuf::new(),\n            },\n            Manufacturer {\n                id: \"haver\".into(),\n                name: \"Haver GmbH\".into(), // 'v' in middle\n                path: PathBuf::new(),\n            },\n        ];\n\n        // Search for 'v' - prefix matches should come first\n        app.update(Message::UpdateSearch(\"v\".into()));\n\n        // All contain 'v', but vitra and vs start with it\n        assert!(!app.filtered_indices.is_empty());\n\n        // First results should be the ones starting with 'v'\n        let first_id = &app.manufacturers[app.filtered_indices[0]].id;\n        assert!(\n            first_id == \"vitra\" || first_id == \"vs\",\n            \"Expected 'vitra' or 'vs' first, got '{}'\",\n            first_id\n        );\n    }\n\n    #[test]\n    fn test_fuzzy_search_exact_match_first() {\n        let mut app = App::new(\"/path/to/data\".into());\n        app.manufacturers = vec![\n            Manufacturer {\n                id: \"vitra_special\".into(),\n                name: \"Vitra Special Edition\".into(),\n                path: PathBuf::new(),\n            },\n            Manufacturer {\n                id: \"vitra\".into(),\n                name: \"Vitra AG\".into(), // Exact match on id\n                path: PathBuf::new(),\n            },\n            Manufacturer {\n                id: \"vitraplus\".into(),\n                name: \"VitraPlus\".into(),\n                path: PathBuf::new(),\n            },\n        ];\n\n        // Search for exact 'vitra'\n        app.update(Message::UpdateSearch(\"vitra\".into()));\n\n        // Exact match should be first\n        assert_eq!(app.manufacturers[app.filtered_indices[0]].id, \"vitra\");\n    }\n\n    #[test]\n    fn test_fuzzy_subsequence_match() {\n        let mut app = App::new(\"/path/to/data\".into());\n        app.manufacturers = vec![\n            Manufacturer {\n                id: \"steelcase\".into(),\n                name: \"Steelcase Inc.\".into(),\n                path: PathBuf::new(),\n            },\n            Manufacturer {\n                id: \"vitra\".into(),\n                name: \"Vitra AG\".into(),\n                path: PathBuf::new(),\n            },\n        ];\n\n        // Search for 'ste' - subsequence/prefix match for Steelcase\n        // (Note: 'scl' doesn't work because in 'steelcase', l comes BEFORE c)\n        app.update(Message::UpdateSearch(\"slc\".into()));\n\n        // Should find steelcase via subsequence (s-tee-l-c-ase)\n        assert!(!app.filtered_indices.is_empty());\n        assert_eq!(app.manufacturers[app.filtered_indices[0]].id, \"steelcase\");\n    }\n\n    #[test]\n    fn test_fuzzy_word_boundary_match() {\n        let mut app = App::new(\"/path/to/data\".into());\n        app.manufacturers = vec![\n            Manufacturer {\n                id: \"ag\".into(),\n                name: \"ABC Group\".into(), // 'ag' not at word boundary for 'Group'\n                path: PathBuf::new(),\n            },\n            Manufacturer {\n                id: \"vitra_ag\".into(),\n                name: \"Vitra_AG\".into(), // 'ag' after underscore - word boundary\n                path: PathBuf::new(),\n            },\n        ];\n\n        // Search for 'ag' - word boundary match should score higher\n        app.update(Message::UpdateSearch(\"ag\".into()));\n\n        // Both match, but exact id match should come first\n        assert!(!app.filtered_indices.is_empty());\n        assert_eq!(app.manufacturers[app.filtered_indices[0]].id, \"ag\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","unit","tui_snapshot_test.rs"],"content":"//! TUI Snapshot Tests\n//!\n//! Uses ratatui's TestBackend with insta snapshots to verify UI rendering.\n//! These tests ensure the TUI displays correctly and that price changes\n//! are properly reflected in the UI.\n\n#[cfg(feature = \"tui\")]\nmod snapshot_tests {\n    use std::path::{Path, PathBuf};\n\n    use insta::assert_snapshot;\n    use ratatui::{backend::TestBackend, buffer::Buffer, Terminal};\n\n    use ofml_lib::oap::engine::ConfigurationEngine;\n    use ofml_lib::oap::families::{\n        FamilyConfiguration, FamilyLoader, FamilyProperty, ProductFamily,\n    };\n    use ofml_lib::oap::{Manufacturer, PriceResult};\n    use ofml_lib::tui::app::{App, Screen};\n    use ofml_lib::tui::ui::render;\n\n    const OFMLDATA_BASE: &str = \"/reference/ofmldata\";\n\n    fn ofmldata_exists() -> bool {\n        Path::new(OFMLDATA_BASE).exists()\n    }\n\n    /// Convert buffer to string for snapshot comparison\n    fn buffer_to_string(buffer: &Buffer) -> String {\n        let mut result = String::new();\n        let area = buffer.area();\n\n        for y in area.y..area.y + area.height {\n            for x in area.x..area.x + area.width {\n                let cell = &buffer[(x, y)];\n                result.push_str(cell.symbol());\n            }\n            result.push('\\n');\n        }\n\n        result\n    }\n\n    /// Create a test app with mock data\n    fn create_test_app() -> App {\n        let mut app = App::new(OFMLDATA_BASE.to_string());\n\n        // Add some test manufacturers\n        app.manufacturers = vec![\n            Manufacturer {\n                id: \"sex\".to_string(),\n                name: \"Sedus\".to_string(),\n                path: PathBuf::from(\"/reference/ofmldata/sex\"),\n            },\n            Manufacturer {\n                id: \"vitra\".to_string(),\n                name: \"Vitra\".to_string(),\n                path: PathBuf::from(\"/reference/ofmldata/vitra\"),\n            },\n            Manufacturer {\n                id: \"kn\".to_string(),\n                name: \"Knoll\".to_string(),\n                path: PathBuf::from(\"/reference/ofmldata/kn\"),\n            },\n        ];\n\n        app.terminal_size = (80, 24);\n        app\n    }\n\n    #[test]\n    fn test_manufacturer_list_render() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let app = create_test_app();\n\n        terminal\n            .draw(|frame| {\n                render(frame, &app);\n            })\n            .unwrap();\n\n        let buffer_str = buffer_to_string(terminal.backend().buffer());\n        assert_snapshot!(\"manufacturer_list\", buffer_str);\n    }\n\n    #[test]\n    fn test_manufacturer_list_with_selection() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = create_test_app();\n        // Select second manufacturer\n        app.manufacturer_list_state.select(Some(1));\n\n        terminal\n            .draw(|frame| {\n                render(frame, &app);\n            })\n            .unwrap();\n\n        let buffer_str = buffer_to_string(terminal.backend().buffer());\n        assert_snapshot!(\"manufacturer_list_selected\", buffer_str);\n    }\n\n    #[test]\n    fn test_family_list_render() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = create_test_app();\n        app.screen = Screen::Families;\n        app.selected_manufacturer = Some(Manufacturer {\n            id: \"sex\".to_string(),\n            name: \"Sedus\".to_string(),\n            path: PathBuf::from(\"/reference/ofmldata/sex\"),\n        });\n\n        // Add test families\n        app.families = vec![\n            ProductFamily {\n                id: \"ai\".to_string(),\n                name: \"Drehstuhl se:air\".to_string(),\n                description: \"Ergonomischer Drehstuhl\".to_string(),\n                long_description: \"Sedus se:air\\nErgonomischer Drehstuhl\".to_string(),\n                series: \"ai\".to_string(),\n                base_article_nr: \"AI-121\".to_string(),\n                prop_classes: vec![\"KLASSE_TEST\".to_string()],\n                variant_count: 5,\n                is_configurable: true,\n                article_nrs: vec![\"AI-121\".to_string(), \"AI-821\".to_string()],\n                article_descriptions: vec![\"Drehstuhl\".to_string(), \"Drehstuhl XXL\".to_string()],\n                article_long_descriptions: vec![\n                    \"Sedus se:air\\nDrehstuhl\".to_string(),\n                    \"Sedus se:air\\nDrehstuhl XXL\".to_string(),\n                ],\n            },\n            ProductFamily {\n                id: \"ap\".to_string(),\n                name: \"Konferenzstuhl ap\".to_string(),\n                description: \"Konferenzstuhl\".to_string(),\n                long_description: \"Sedus ap\\nKonferenzstuhl\".to_string(),\n                series: \"ap\".to_string(),\n                base_article_nr: \"AP-101\".to_string(),\n                prop_classes: vec![],\n                variant_count: 3,\n                is_configurable: false,\n                article_nrs: vec![\"AP-101\".to_string()],\n                article_descriptions: vec![\"Konferenzstuhl\".to_string()],\n                article_long_descriptions: vec![\"Sedus ap\\nKonferenzstuhl\".to_string()],\n            },\n        ];\n        app.family_list_state.select(Some(0));\n\n        terminal\n            .draw(|frame| {\n                render(frame, &app);\n            })\n            .unwrap();\n\n        let buffer_str = buffer_to_string(terminal.backend().buffer());\n        assert_snapshot!(\"family_list\", buffer_str);\n    }\n\n    #[test]\n    fn test_family_config_with_price() {\n        let backend = TestBackend::new(100, 30);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = create_test_app();\n        app.terminal_size = (100, 30);\n        app.screen = Screen::FamilyConfig;\n        app.selected_manufacturer = Some(Manufacturer {\n            id: \"sex\".to_string(),\n            name: \"Sedus\".to_string(),\n            path: PathBuf::from(\"/reference/ofmldata/sex\"),\n        });\n\n        app.selected_family = Some(ProductFamily {\n            id: \"ai\".to_string(),\n            name: \"Drehstuhl se:air\".to_string(),\n            description: \"Ergonomischer Drehstuhl\".to_string(),\n            long_description: \"Sedus se:air\\nErgonomischer Drehstuhl\".to_string(),\n            series: \"ai\".to_string(),\n            base_article_nr: \"AI-121\".to_string(),\n            prop_classes: vec![\"KLASSE_TEST\".to_string()],\n            variant_count: 5,\n            is_configurable: true,\n            article_nrs: vec![\"AI-121\".to_string()],\n            article_descriptions: vec![\"Drehstuhl\".to_string()],\n            article_long_descriptions: vec![\"Sedus se:air\\nDrehstuhl\".to_string()],\n        });\n\n        // Add test properties\n        app.family_properties = vec![\n            FamilyProperty {\n                key: \"S_STOFF\".to_string(),\n                label: \"Stoffgruppe\".to_string(),\n                group: \"Polsterung\".to_string(),\n                group_label: \"Polsterung\".to_string(),\n                prop_type: ofml_lib::oap::families::PropertyType::Choice,\n                required: true,\n                options: vec![\n                    ofml_lib::oap::families::PropertyOption {\n                        value: \"2G3\".to_string(),\n                        label: \"Preisgruppe 3\".to_string(),\n                        is_default: true,\n                    },\n                    ofml_lib::oap::families::PropertyOption {\n                        value: \"2G4\".to_string(),\n                        label: \"Preisgruppe 4\".to_string(),\n                        is_default: false,\n                    },\n                ],\n                default_value: Some(\"2G3\".to_string()),\n                position: 1,\n                hint: None,\n            },\n            FamilyProperty {\n                key: \"S_FUSSFARBE\".to_string(),\n                label: \"Fussfarbe\".to_string(),\n                group: \"Gestell\".to_string(),\n                group_label: \"Gestell\".to_string(),\n                prop_type: ofml_lib::oap::families::PropertyType::Choice,\n                required: true,\n                options: vec![\n                    ofml_lib::oap::families::PropertyOption {\n                        value: \"119\".to_string(),\n                        label: \"Schwarz\".to_string(),\n                        is_default: true,\n                    },\n                    ofml_lib::oap::families::PropertyOption {\n                        value: \"120\".to_string(),\n                        label: \"Weiss\".to_string(),\n                        is_default: false,\n                    },\n                ],\n                default_value: Some(\"119\".to_string()),\n                position: 2,\n                hint: None,\n            },\n        ];\n\n        // Create configuration\n        app.family_config = Some(FamilyConfiguration::new(\"ai\", &app.family_properties));\n\n        // Set price\n        app.family_price = Some(PriceResult::new(\n            rust_decimal::Decimal::from(599),\n            vec![],\n            \"EUR\".to_string(),\n            chrono::Local::now().date_naive(),\n            chrono::Local::now().date_naive(),\n            None,\n        ));\n\n        terminal\n            .draw(|frame| {\n                render(frame, &app);\n            })\n            .unwrap();\n\n        let buffer_str = buffer_to_string(terminal.backend().buffer());\n        assert_snapshot!(\"family_config_with_price\", buffer_str);\n    }\n\n    #[test]\n    fn test_family_config_with_surcharges() {\n        let backend = TestBackend::new(100, 30);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = create_test_app();\n        app.terminal_size = (100, 30);\n        app.screen = Screen::FamilyConfig;\n        app.selected_manufacturer = Some(Manufacturer {\n            id: \"sex\".to_string(),\n            name: \"Sedus\".to_string(),\n            path: PathBuf::from(\"/reference/ofmldata/sex\"),\n        });\n\n        app.selected_family = Some(ProductFamily {\n            id: \"ai\".to_string(),\n            name: \"Drehstuhl se:air\".to_string(),\n            description: \"Ergonomischer Drehstuhl\".to_string(),\n            long_description: \"Sedus se:air\\nErgonomischer Drehstuhl\".to_string(),\n            series: \"ai\".to_string(),\n            base_article_nr: \"AI-121\".to_string(),\n            prop_classes: vec![\"KLASSE_TEST\".to_string()],\n            variant_count: 5,\n            is_configurable: true,\n            article_nrs: vec![\"AI-121\".to_string()],\n            article_descriptions: vec![\"Drehstuhl\".to_string()],\n            article_long_descriptions: vec![\"Sedus se:air\\nDrehstuhl\".to_string()],\n        });\n\n        app.family_properties = vec![FamilyProperty {\n            key: \"S_STOFF_FRONT_GABRIEL\".to_string(),\n            label: \"Gabriel Stoff\".to_string(),\n            group: \"Polsterung\".to_string(),\n            group_label: \"Polsterung\".to_string(),\n            prop_type: ofml_lib::oap::families::PropertyType::Choice,\n            required: true,\n            options: vec![ofml_lib::oap::families::PropertyOption {\n                value: \"XST244166018\".to_string(),\n                label: \"Gabriel Comfort 166\".to_string(),\n                is_default: false,\n            }],\n            default_value: Some(\"XST244166018\".to_string()),\n            position: 1,\n            hint: None,\n        }];\n\n        app.family_config = Some(FamilyConfiguration::new(\"ai\", &app.family_properties));\n\n        // Set price with surcharge\n        use ofml_lib::oap::Surcharge;\n        app.family_price = Some(PriceResult::new(\n            rust_decimal::Decimal::from(599),\n            vec![Surcharge {\n                name: \"S_166\".to_string(),\n                amount: rust_decimal::Decimal::from(44),\n                is_percentage: false,\n            }],\n            \"EUR\".to_string(),\n            chrono::Local::now().date_naive(),\n            chrono::Local::now().date_naive(),\n            None,\n        ));\n\n        terminal\n            .draw(|frame| {\n                render(frame, &app);\n            })\n            .unwrap();\n\n        let buffer_str = buffer_to_string(terminal.backend().buffer());\n        assert_snapshot!(\"family_config_with_surcharges\", buffer_str);\n    }\n\n    #[test]\n    fn test_help_screen() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = create_test_app();\n        app.screen = Screen::Help;\n\n        terminal\n            .draw(|frame| {\n                render(frame, &app);\n            })\n            .unwrap();\n\n        let buffer_str = buffer_to_string(terminal.backend().buffer());\n        assert_snapshot!(\"help_screen\", buffer_str);\n    }\n\n    #[test]\n    fn test_search_mode_active() {\n        let backend = TestBackend::new(80, 24);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = create_test_app();\n        app.search_active = true;\n        app.search_query = \"vitra\".to_string();\n\n        terminal\n            .draw(|frame| {\n                render(frame, &app);\n            })\n            .unwrap();\n\n        let buffer_str = buffer_to_string(terminal.backend().buffer());\n        assert_snapshot!(\"search_mode_active\", buffer_str);\n    }\n\n    /// Integration test with real data (if available)\n    #[test]\n    fn test_real_data_price_display() {\n        if !ofmldata_exists() {\n            eprintln!(\"Skipping: ofmldata not found\");\n            return;\n        }\n\n        let backend = TestBackend::new(120, 35);\n        let mut terminal = Terminal::new(backend).unwrap();\n\n        let mut app = App::new(OFMLDATA_BASE.to_string());\n        app.terminal_size = (120, 35);\n\n        // Load real Sedus data\n        let mfr_path = Path::new(OFMLDATA_BASE).join(\"sex\");\n        if !mfr_path.exists() {\n            return;\n        }\n\n        let loader = FamilyLoader::load(&mfr_path, \"DE\");\n        let engine = ConfigurationEngine::new(OFMLDATA_BASE);\n\n        // Find AI family\n        let ai_family = loader\n            .get_families()\n            .iter()\n            .find(|f| f.base_article_nr.contains(\"AI\"))\n            .cloned();\n\n        if let Some(family) = ai_family {\n            let properties = loader.get_properties_for_family(&family);\n            let config = FamilyConfiguration::new(&family.id, &properties);\n\n            // Set up app state\n            app.screen = Screen::FamilyConfig;\n            app.selected_manufacturer = Some(Manufacturer {\n                id: \"sex\".to_string(),\n                name: \"Sedus\".to_string(),\n                path: PathBuf::from(\"/reference/ofmldata/sex\"),\n            });\n            app.selected_family = Some(family.clone());\n            app.family_properties = properties;\n            app.family_config = Some(config.clone());\n            app.family_price = engine.calculate_family_price(\n                \"sex\",\n                &family,\n                &config,\n                chrono::Local::now().date_naive(),\n            );\n\n            terminal\n                .draw(|frame| {\n                    render(frame, &app);\n                })\n                .unwrap();\n\n            let buffer_str = buffer_to_string(terminal.backend().buffer());\n\n            // Verify price is displayed\n            assert!(\n                buffer_str.contains(\"599\") || buffer_str.contains(\"Preis\"),\n                \"Price should be displayed in the UI\"\n            );\n        }\n    }\n\n    /// Test that price updates when property changes\n    #[test]\n    fn test_price_update_on_property_change() {\n        if !ofmldata_exists() {\n            eprintln!(\"Skipping: ofmldata not found\");\n            return;\n        }\n\n        let mfr_path = Path::new(OFMLDATA_BASE).join(\"sex\");\n        if !mfr_path.exists() {\n            return;\n        }\n\n        let loader = FamilyLoader::load(&mfr_path, \"DE\");\n        let engine = ConfigurationEngine::new(OFMLDATA_BASE);\n\n        // Find AI family\n        let ai_family = loader\n            .get_families()\n            .iter()\n            .find(|f| f.base_article_nr.contains(\"AI\"))\n            .cloned();\n\n        if let Some(family) = ai_family {\n            let properties = loader.get_properties_for_family(&family);\n\n            // Find S_STOFF_FRONT_GABRIEL property\n            let gabriel_prop = properties.iter().find(|p| p.key == \"S_STOFF_FRONT_GABRIEL\");\n            if gabriel_prop.is_none() {\n                return;\n            }\n            let prop = gabriel_prop.unwrap();\n\n            // Find an option with \"166\" embedded\n            let opt_166 = prop.options.iter().find(|o| o.value.contains(\"166\"));\n            let opt_other = prop.options.iter().find(|o| {\n                !o.value.contains(\"166\") && !o.value.contains(\"167\") && !o.value.contains(\"168\")\n            });\n\n            if opt_166.is_none() || opt_other.is_none() {\n                return;\n            }\n\n            // Create two configurations - one without surcharge trigger, one with\n            let mut config_without = FamilyConfiguration::new(&family.id, &properties);\n            config_without.set(&prop.key, &opt_other.unwrap().value);\n\n            let mut config_with = FamilyConfiguration::new(&family.id, &properties);\n            config_with.set(&prop.key, &opt_166.unwrap().value);\n\n            let price_without = engine.calculate_family_price(\n                \"sex\",\n                &family,\n                &config_without,\n                chrono::Local::now().date_naive(),\n            );\n            let price_with = engine.calculate_family_price(\n                \"sex\",\n                &family,\n                &config_with,\n                chrono::Local::now().date_naive(),\n            );\n\n            if let (Some(p1), Some(p2)) = (&price_without, &price_with) {\n                // Verify prices are different\n                assert_ne!(\n                    p1.total_price, p2.total_price,\n                    \"Price should change when selecting option with embedded surcharge code\"\n                );\n\n                // Verify the one with 166 has a surcharge\n                assert!(\n                    !p2.surcharges.is_empty(),\n                    \"Option with embedded '166' should trigger S_166 surcharge\"\n                );\n\n                // Render both states\n                let backend1 = TestBackend::new(100, 30);\n                let mut terminal1 = Terminal::new(backend1).unwrap();\n\n                let mut app1 = App::new(OFMLDATA_BASE.to_string());\n                app1.terminal_size = (100, 30);\n                app1.screen = Screen::FamilyConfig;\n                app1.selected_manufacturer = Some(Manufacturer {\n                    id: \"sex\".to_string(),\n                    name: \"Sedus\".to_string(),\n                    path: PathBuf::from(\"/reference/ofmldata/sex\"),\n                });\n                app1.selected_family = Some(family.clone());\n                app1.family_properties = properties.clone();\n                app1.family_config = Some(config_without);\n                app1.family_price = Some(p1.clone());\n\n                terminal1\n                    .draw(|frame| {\n                        render(frame, &app1);\n                    })\n                    .unwrap();\n\n                let buffer1 = buffer_to_string(terminal1.backend().buffer());\n\n                let backend2 = TestBackend::new(100, 30);\n                let mut terminal2 = Terminal::new(backend2).unwrap();\n\n                // Create a new app for the second render\n                let mut app2 = App::new(OFMLDATA_BASE.to_string());\n                app2.terminal_size = (100, 30);\n                app2.screen = Screen::FamilyConfig;\n                app2.selected_manufacturer = app1.selected_manufacturer.clone();\n                app2.selected_family = app1.selected_family.clone();\n                app2.family_properties = properties.clone();\n                app2.family_config = Some(config_with);\n                app2.family_price = Some(p2.clone());\n\n                terminal2\n                    .draw(|frame| {\n                        render(frame, &app2);\n                    })\n                    .unwrap();\n\n                let buffer2 = buffer_to_string(terminal2.backend().buffer());\n\n                // The buffers should be different (price changed)\n                assert_ne!(buffer1, buffer2, \"UI should show different prices\");\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","unit","tui_state_test.rs"],"content":"//! Unit tests for TUI app state transitions (T029)\n\n#[cfg(feature = \"tui\")]\nmod tui_tests {\n    use ofml_lib::oap::Manufacturer;\n    use ofml_lib::tui::{App, Message, Screen};\n    use std::path::PathBuf;\n\n    fn create_manufacturer(id: &str, name: &str) -> Manufacturer {\n        Manufacturer {\n            id: id.into(),\n            name: name.into(),\n            path: PathBuf::new(),\n        }\n    }\n\n    #[test]\n    fn test_app_initial_state() {\n        let app = App::new(\"/path/to/data\".into());\n        assert!(matches!(app.screen, Screen::Manufacturers));\n        assert!(!app.should_quit);\n    }\n\n    #[test]\n    fn test_app_quit_message() {\n        let mut app = App::new(\"/path/to/data\".into());\n        app.update(Message::Quit);\n        assert!(app.should_quit);\n    }\n\n    #[test]\n    fn test_app_navigate_down() {\n        let mut app = App::new(\"/path/to/data\".into());\n        app.manufacturers = vec![\n            create_manufacturer(\"vitra\", \"Vitra AG\"),\n            create_manufacturer(\"sedus\", \"Sedus\"),\n        ];\n\n        assert_eq!(app.manufacturer_list_state.selected(), Some(0));\n        app.update(Message::NavigateDown);\n        assert_eq!(app.manufacturer_list_state.selected(), Some(1));\n    }\n\n    #[test]\n    fn test_app_navigate_up() {\n        let mut app = App::new(\"/path/to/data\".into());\n        app.manufacturers = vec![\n            create_manufacturer(\"vitra\", \"Vitra AG\"),\n            create_manufacturer(\"sedus\", \"Sedus\"),\n        ];\n        app.manufacturer_list_state.select(Some(1));\n\n        app.update(Message::NavigateUp);\n        assert_eq!(app.manufacturer_list_state.selected(), Some(0));\n    }\n\n    #[test]\n    fn test_app_navigate_wraps() {\n        let mut app = App::new(\"/path/to/data\".into());\n        app.manufacturers = vec![create_manufacturer(\"vitra\", \"Vitra AG\")];\n        app.manufacturer_list_state.select(Some(0));\n\n        // Navigate down wraps to beginning\n        app.update(Message::NavigateDown);\n        assert_eq!(app.manufacturer_list_state.selected(), Some(0));\n\n        // Navigate up from 0 wraps to end\n        app.update(Message::NavigateUp);\n        assert_eq!(app.manufacturer_list_state.selected(), Some(0));\n    }\n\n    #[test]\n    fn test_app_show_help() {\n        let mut app = App::new(\"/path/to/data\".into());\n\n        app.update(Message::ShowHelp);\n        assert!(matches!(app.screen, Screen::Help));\n    }\n\n    #[test]\n    fn test_app_toggle_search() {\n        let mut app = App::new(\"/path/to/data\".into());\n        assert!(!app.search_active);\n\n        app.update(Message::ToggleSearch);\n        assert!(app.search_active);\n\n        app.update(Message::ToggleSearch);\n        assert!(!app.search_active);\n    }\n\n    #[test]\n    fn test_app_go_back_from_articles() {\n        let mut app = App::new(\"/path/to/data\".into());\n        app.screen = Screen::Articles;\n        app.selected_manufacturer = Some(create_manufacturer(\"vitra\", \"Vitra AG\"));\n\n        app.update(Message::GoBack);\n        assert!(matches!(app.screen, Screen::Manufacturers));\n    }\n\n    #[test]\n    fn test_app_go_back_from_properties() {\n        let mut app = App::new(\"/path/to/data\".into());\n        app.screen = Screen::Properties;\n\n        app.update(Message::GoBack);\n        assert!(matches!(app.screen, Screen::Articles));\n    }\n\n    #[test]\n    fn test_app_go_back_from_manufacturers_quits() {\n        let mut app = App::new(\"/path/to/data\".into());\n        app.screen = Screen::Manufacturers;\n\n        app.update(Message::GoBack);\n        assert!(app.should_quit);\n    }\n\n    #[test]\n    fn test_screen_enum_variants() {\n        // Verify all screen variants exist\n        let _manufacturers = Screen::Manufacturers;\n        let _articles = Screen::Articles;\n        let _properties = Screen::Properties;\n        let _help = Screen::Help;\n    }\n\n    #[test]\n    fn test_message_enum_variants() {\n        // Verify key message variants exist\n        let _quit = Message::Quit;\n        let _up = Message::NavigateUp;\n        let _down = Message::NavigateDown;\n        let _back = Message::GoBack;\n        let _help = Message::ShowHelp;\n        let _search = Message::ToggleSearch;\n        let _export = Message::Export;\n        let _resize = Message::Resize(80, 24);\n    }\n\n    #[test]\n    fn test_new_message_variants() {\n        // Verify new message variants for config/favorites/history features exist\n        let _save_config = Message::SaveConfig;\n        let _load_config = Message::LoadConfig;\n        let _show_saved = Message::ShowSavedConfigs;\n        let _select_saved = Message::SelectSavedConfig(0);\n        let _toggle_fav = Message::ToggleFavorite;\n    }\n\n    #[test]\n    fn test_screen_saved_configs_exists() {\n        // Verify SavedConfigs screen variant exists\n        let _saved_configs = Screen::SavedConfigs;\n    }\n\n    #[test]\n    fn test_app_show_saved_configs() {\n        let mut app = App::new(\"/path/to/data\".into());\n\n        app.update(Message::ShowSavedConfigs);\n        assert!(matches!(app.screen, Screen::SavedConfigs));\n    }\n\n    #[test]\n    fn test_app_go_back_from_saved_configs() {\n        let mut app = App::new(\"/path/to/data\".into());\n        app.screen = Screen::SavedConfigs;\n\n        app.update(Message::GoBack);\n        // Should go back to manufacturers\n        assert!(matches!(app.screen, Screen::Manufacturers));\n    }\n}\n\n// Compile-time test that TUI types exist when feature is enabled\n#[cfg(feature = \"tui\")]\n#[test]\nfn test_tui_types_exist() {\n    use ofml_lib::tui::{App, Message, Screen};\n\n    let _ = std::mem::size_of::<App>();\n    let _ = std::mem::size_of::<Message>();\n    let _ = std::mem::size_of::<Screen>();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-lib","tests","unit.rs"],"content":"//! Unit tests for OAP Configurator TUI\n\nmod unit {\n    mod oap_actions_test;\n    mod oap_export_test;\n    mod oap_price_test;\n    mod oap_variant_test;\n    mod ocd_features_test;\n    mod ocd_snapshot_test;\n    mod propvalue2varcond_test;\n    mod table_relation_test;\n    mod test_descriptions;\n\n    #[cfg(feature = \"tui\")]\n    mod tui_data_validation_test;\n    #[cfg(feature = \"tui\")]\n    mod tui_form_test;\n    #[cfg(feature = \"tui\")]\n    mod tui_resize_test;\n    #[cfg(feature = \"tui\")]\n    mod tui_search_test;\n    #[cfg(feature = \"tui\")]\n    mod tui_snapshot_test;\n    #[cfg(feature = \"tui\")]\n    mod tui_state_test;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-tui","src","app.rs"],"content":"//! TUI Application state and event handling\n//!\n//! This module implements the Elm Architecture (TEA) pattern for the TUI:\n//! - App: Application state\n//! - Message: Events that can occur\n//! - Screen: Current view state\n\nuse chrono::NaiveDate;\nuse ratatui::widgets::ListState;\n\nuse ofml_lib::oap::catalog::{CatalogNode, NodeType, XcfCatalog};\nuse ofml_lib::oap::engine::ConfigurationEngine;\nuse ofml_lib::oap::families::{FamilyConfiguration, FamilyProperty, ProductFamily};\nuse ofml_lib::oap::{Article, Configuration, Manufacturer, PriceResult};\n\n/// Packaging information for display\n\n#[derive(Debug, Clone)]\npub struct PackagingInfo {\n    /// Weight in kg\n    pub weight_kg: f64,\n    /// Dimensions (width x depth x height) in cm\n    pub dimensions_cm: (f64, f64, f64),\n    /// Volume in m¬≥\n    pub volume_m3: f64,\n}\n\n/// Composite component information for display\n\n#[derive(Debug, Clone)]\npub struct CompositeComponent {\n    /// Item ID (article number)\n    pub item_id: String,\n    /// Position in the bill\n    pub position: u16,\n    /// Quantity\n    pub quantity: f64,\n    /// Description (if available)\n    pub description: String,\n}\n\n/// Current screen/view in the TUI\n\n#[derive(Debug, Clone, PartialEq)]\npub enum Screen {\n    /// List of manufacturers\n    Manufacturers,\n    /// XCF Catalog browser (hierarchical categories)\n    Catalog,\n    /// List of product families for selected manufacturer\n    Families,\n    /// Family configuration view with property selection\n    FamilyConfig,\n    /// List of articles for selected manufacturer (legacy)\n    Articles,\n    /// Property configuration for selected article (legacy)\n    Properties,\n    /// Custom table browser (shows all tables in pdata.ebase)\n    Tables,\n    /// Table contents viewer (shows rows in selected table)\n    TableView,\n    /// Saved configurations browser\n    SavedConfigs,\n    /// Help screen\n    Help,\n}\n\n/// Information about a custom table\n\n#[derive(Debug, Clone)]\npub struct TableInfo {\n    /// Table name\n    pub name: String,\n    /// Number of rows\n    pub row_count: usize,\n    /// Column names\n    pub columns: Vec<String>,\n    /// Whether this is a standard OCD table\n    pub is_standard: bool,\n    /// Source file path\n    pub source_path: String,\n}\n\n/// A row of data from a table\n\n#[derive(Debug, Clone)]\npub struct TableRow {\n    /// Column values as strings\n    pub values: Vec<String>,\n}\n\n/// A single property change for undo/redo\n\n#[derive(Debug, Clone)]\npub struct PropertyChange {\n    /// Property key\n    pub key: String,\n    /// Old value\n    pub old_value: String,\n    /// New value\n    pub new_value: String,\n}\n\n/// Messages/events that can occur in the TUI\n\n#[derive(Debug, Clone)]\npub enum Message {\n    /// Select a manufacturer by index\n    SelectManufacturer(usize),\n    /// Select a catalog node (enter folder or select article)\n    SelectCatalogNode(usize),\n    /// Select a product family by index\n    SelectFamily(usize),\n    /// Select an article by index\n    SelectArticle(usize),\n    /// Cycle through property options (Left/Right)\n    CyclePropertyOption(i32),\n    /// Edit a property value\n    EditProperty(String, String),\n    /// Navigate up in the list\n    NavigateUp,\n    /// Navigate down in the list\n    NavigateDown,\n    /// Navigate up by page (10 items)\n    NavigatePageUp,\n    /// Navigate down by page (10 items)\n    NavigatePageDown,\n    /// Navigate to top of list\n    NavigateToTop,\n    /// Navigate to bottom of list\n    NavigateToBottom,\n    /// Go back to previous screen\n    GoBack,\n    /// Go back to home screen (manufacturers)\n    GoHome,\n    /// Undo last property change\n    Undo,\n    /// Redo last undone property change\n    Redo,\n    /// Toggle search mode\n    ToggleSearch,\n    /// Update search query\n    UpdateSearch(String),\n    /// Set price date\n    SetPriceDate(NaiveDate),\n    /// Export configuration to JSON\n    Export,\n    /// Export geometry to GLB file\n    ExportGeometry,\n    /// Show help\n    ShowHelp,\n    /// Toggle debug console\n    ToggleDebug,\n    /// Show tables browser\n    ShowTables,\n    /// Select a table by index\n    SelectTable(usize),\n    /// Scroll table view left/right\n    ScrollTableHorizontal(i32),\n    /// Save current configuration\n    SaveConfig,\n    /// Load a saved configuration\n    LoadConfig,\n    /// Show saved configurations list\n    ShowSavedConfigs,\n    /// Select a saved configuration to load\n    SelectSavedConfig(usize),\n    /// Toggle favorite status for current family\n    ToggleFavorite,\n    /// Toggle theme (light/dark)\n    ToggleTheme,\n    /// Quit application\n    Quit,\n    /// Resize terminal\n    Resize(u16, u16),\n}\n\n/// Main application state\n\npub struct App {\n    /// Current screen\n    pub screen: Screen,\n    /// List of loaded manufacturers\n    pub manufacturers: Vec<Manufacturer>,\n    /// Manufacturer list selection state\n    pub manufacturer_list_state: ListState,\n    /// Currently selected manufacturer\n    pub selected_manufacturer: Option<Manufacturer>,\n\n    // === XCF Catalog Mode ===\n    /// Loaded XCF catalog for current manufacturer\n    pub catalog: Option<XcfCatalog>,\n    /// Stack of catalog nodes for navigation (breadcrumb)\n    pub catalog_path: Vec<CatalogNode>,\n    /// Current catalog children being displayed\n    pub catalog_children: Vec<CatalogNode>,\n    /// Catalog list selection state\n    pub catalog_list_state: ListState,\n\n    // === Product Family Mode (new) ===\n    /// List of product families for current manufacturer\n    pub families: Vec<ProductFamily>,\n    /// Family list selection state\n    pub family_list_state: ListState,\n    /// Currently selected product family\n    pub selected_family: Option<ProductFamily>,\n    /// Configurable properties for current family\n    pub family_properties: Vec<FamilyProperty>,\n    /// Current family configuration (selections)\n    pub family_config: Option<FamilyConfiguration>,\n    /// Current family price result\n    pub family_price: Option<PriceResult>,\n    /// Data warnings for current family (from OCD parsing)\n    pub family_warnings: Vec<ofml_lib::oap::DataWarning>,\n    /// Focused article index (when no OCD properties, navigate articles instead)\n    pub focused_article_index: usize,\n    /// Packaging info for current article\n    pub packaging_info: Option<PackagingInfo>,\n    /// Data version info for current manufacturer\n    pub data_version: Option<String>,\n    /// Data validity warning if data is outdated\n    pub data_validity_warning: Option<String>,\n    /// Variant code separator from code scheme (default is \"_\")\n    pub varcode_separator: String,\n    /// Composite product components (if current article is a composite)\n    pub composite_components: Vec<CompositeComponent>,\n    /// Undo stack for property changes\n    pub undo_stack: Vec<PropertyChange>,\n    /// Redo stack for undone property changes\n    pub redo_stack: Vec<PropertyChange>,\n\n    // === Legacy Article Mode ===\n    /// List of articles for current manufacturer\n    pub articles: Vec<Article>,\n    /// Article list selection state\n    pub article_list_state: ListState,\n    /// Currently selected article\n    pub selected_article: Option<Article>,\n    /// Current configuration\n    pub configuration: Option<Configuration>,\n    /// Current price result\n    pub price: Option<PriceResult>,\n\n    // === Table Browser Mode ===\n    /// List of tables for current manufacturer\n    pub tables: Vec<TableInfo>,\n    /// Table list selection state\n    pub table_list_state: ListState,\n    /// Currently selected table\n    pub selected_table: Option<TableInfo>,\n    /// Rows of the currently selected table\n    pub table_rows: Vec<TableRow>,\n    /// Table row selection state\n    pub table_row_list_state: ListState,\n    /// Horizontal scroll offset for table view\n    pub table_scroll_x: usize,\n\n    // === Saved Configurations ===\n    /// List of saved configurations\n    pub saved_configs: Vec<(std::path::PathBuf, super::config_store::SavedConfiguration)>,\n    /// Saved configs list selection state\n    pub saved_configs_list_state: ListState,\n\n    // === Debug Console ===\n    /// Debug mode enabled\n    pub debug_mode: bool,\n    /// Debug log messages (newest first)\n    pub debug_log: Vec<String>,\n    /// Maximum debug log entries\n    pub debug_log_max: usize,\n\n    // === Common State ===\n    /// Price lookup date\n    pub price_date: NaiveDate,\n    /// Search mode active\n    pub search_active: bool,\n    /// Search query\n    pub search_query: String,\n    /// Filtered items for current list\n    pub filtered_indices: Vec<usize>,\n    /// Currently focused property index\n    pub focused_property: usize,\n    /// Status message\n    pub status_message: Option<String>,\n    /// Whether to quit\n    pub should_quit: bool,\n    /// Data path\n    pub data_path: String,\n    /// Terminal size\n    pub terminal_size: (u16, u16),\n    /// Configuration engine for price calculation\n    pub engine: ConfigurationEngine,\n    /// Current theme variant\n    pub theme_variant: super::theme::ThemeVariant,\n}\n\n\nimpl App {\n    /// Create a new App instance\n    pub fn new(data_path: String) -> Self {\n        let mut manufacturer_list_state = ListState::default();\n        manufacturer_list_state.select(Some(0));\n\n        Self {\n            screen: Screen::Manufacturers,\n            manufacturers: Vec::new(),\n            manufacturer_list_state,\n            selected_manufacturer: None,\n            // XCF catalog mode\n            catalog: None,\n            catalog_path: Vec::new(),\n            catalog_children: Vec::new(),\n            catalog_list_state: ListState::default(),\n            // Product family mode\n            families: Vec::new(),\n            family_list_state: ListState::default(),\n            selected_family: None,\n            family_properties: Vec::new(),\n            family_config: None,\n            family_price: None,\n            family_warnings: Vec::new(),\n            focused_article_index: 0,\n            packaging_info: None,\n            data_version: None,\n            data_validity_warning: None,\n            varcode_separator: \"_\".to_string(),\n            composite_components: Vec::new(),\n            undo_stack: Vec::new(),\n            redo_stack: Vec::new(),\n            // Legacy article mode\n            articles: Vec::new(),\n            article_list_state: ListState::default(),\n            selected_article: None,\n            configuration: None,\n            price: None,\n            // Table browser mode\n            tables: Vec::new(),\n            table_list_state: ListState::default(),\n            selected_table: None,\n            table_rows: Vec::new(),\n            table_row_list_state: ListState::default(),\n            table_scroll_x: 0,\n            // Saved configurations\n            saved_configs: Vec::new(),\n            saved_configs_list_state: ListState::default(),\n            // Debug console\n            debug_mode: false,\n            debug_log: Vec::new(),\n            debug_log_max: 100,\n            // Common state\n            price_date: chrono::Local::now().date_naive(),\n            search_active: false,\n            search_query: String::new(),\n            filtered_indices: Vec::new(),\n            focused_property: 0,\n            status_message: None,\n            should_quit: false,\n            engine: ConfigurationEngine::new(&data_path),\n            data_path,\n            terminal_size: (80, 24),\n            theme_variant: super::theme::ThemeVariant::default(),\n        }\n    }\n\n    /// Get the current theme\n    pub fn theme(&self) -> super::theme::Theme {\n        self.theme_variant.theme()\n    }\n\n    /// Set the catalog for the current manufacturer\n    pub fn set_catalog(&mut self, catalog: Option<XcfCatalog>) {\n        self.catalog = catalog;\n        self.catalog_path.clear();\n        self.catalog_children.clear();\n        self.catalog_list_state = ListState::default();\n\n        if let Some(ref cat) = self.catalog {\n            // Start at root level\n            self.catalog_children = cat.root.children.clone();\n            if !self.catalog_children.is_empty() {\n                self.catalog_list_state.select(Some(0));\n            }\n        }\n    }\n\n    /// Get the current catalog node (for display in breadcrumb)\n    pub fn current_catalog_node(&self) -> Option<&CatalogNode> {\n        self.catalog_path.last()\n    }\n\n    /// Get the catalog breadcrumb path as a string\n    pub fn catalog_breadcrumb(&self) -> String {\n        if self.catalog_path.is_empty() {\n            return \"Katalog\".to_string();\n        }\n        self.catalog_path\n            .iter()\n            .map(|n| n.name.as_str())\n            .collect::<Vec<_>>()\n            .join(\" > \")\n    }\n\n    /// Enter a catalog folder\n    pub fn enter_catalog_folder(&mut self, node: &CatalogNode) {\n        self.catalog_path.push(node.clone());\n        self.catalog_children = node.children.clone();\n        self.catalog_list_state = ListState::default();\n        if !self.catalog_children.is_empty() {\n            self.catalog_list_state.select(Some(0));\n        }\n    }\n\n    /// Go back one level in the catalog\n    pub fn exit_catalog_folder(&mut self) {\n        if self.catalog_path.is_empty() {\n            // At root, exit catalog view\n            return;\n        }\n\n        self.catalog_path.pop();\n\n        if self.catalog_path.is_empty() {\n            // Back to root level\n            if let Some(ref cat) = self.catalog {\n                self.catalog_children = cat.root.children.clone();\n            }\n        } else {\n            // Back to parent's children\n            if let Some(parent) = self.catalog_path.last() {\n                self.catalog_children = parent.children.clone();\n            }\n        }\n\n        self.catalog_list_state = ListState::default();\n        if !self.catalog_children.is_empty() {\n            self.catalog_list_state.select(Some(0));\n        }\n    }\n\n    /// Add a debug log message\n    pub fn debug_log(&mut self, msg: String) {\n        let timestamp = chrono::Local::now().format(\"%H:%M:%S%.3f\");\n        self.debug_log.insert(0, format!(\"[{}] {}\", timestamp, msg));\n        if self.debug_log.len() > self.debug_log_max {\n            self.debug_log.pop();\n        }\n    }\n\n    /// Recalculate price for current family configuration\n    pub fn recalculate_price(&mut self) {\n        if let (Some(ref mfr), Some(ref family), Some(ref config)) = (\n            &self.selected_manufacturer,\n            &self.selected_family,\n            &self.family_config,\n        ) {\n            let old_price = self.family_price.as_ref().map(|p| p.total_price);\n\n            self.family_price =\n                self.engine\n                    .calculate_family_price(&mfr.id, family, config, self.price_date);\n\n            // Log debug info\n            if self.debug_mode {\n                // Collect price info first to avoid borrow issues\n                let price_info = self.family_price.as_ref().map(|price| {\n                        let surcharges: Vec<(String, String)> = price\n                            .surcharges\n                            .iter()\n                            .map(|s| (s.name.clone(), s.amount.to_string()))\n                            .collect();\n                        (\n                            price.total_price.to_string(),\n                            price.currency.clone(),\n                            price.surcharges.len(),\n                            surcharges,\n                        )\n                    });\n\n                if let Some((total, _currency, count, surcharges)) = price_info {\n                    let old_str = old_price\n                        .map(|p| format!(\"{}\", p))\n                        .unwrap_or_else(|| \"N/A\".to_string());\n                    self.debug_log(format!(\n                        \"Price: {} -> {} EUR ({} surcharges)\",\n                        old_str, total, count\n                    ));\n                    for (name, amount) in surcharges {\n                        self.debug_log(format!(\"  + {}: {} EUR\", name, amount));\n                    }\n                } else {\n                    self.debug_log(\"Price calculation returned None\".to_string());\n                }\n            }\n        }\n    }\n\n    /// Save the current family configuration to a JSON file\n    pub fn save_current_configuration(&mut self) {\n        if let (Some(ref mfr), Some(ref family), Some(ref config)) = (\n            &self.selected_manufacturer,\n            &self.selected_family,\n            &self.family_config,\n        ) {\n            let saved = super::config_store::SavedConfiguration {\n                manufacturer: mfr.id.clone(),\n                series: family.id.clone(),\n                article_nr: family.base_article_nr.clone(),\n                properties: config.selections.clone(),\n                variant_code: config.variant_code.clone(),\n                description: family.name.clone(),\n                price_date: Some(self.price_date.format(\"%Y-%m-%d\").to_string()),\n                saved_at: chrono::Local::now().format(\"%Y-%m-%d %H:%M:%S\").to_string(),\n            };\n\n            match super::config_store::save_configuration(&saved) {\n                Ok(path) => {\n                    self.status_message = Some(format!(\n                        \"Gespeichert: {}\",\n                        path.file_name()\n                            .and_then(|s| s.to_str())\n                            .unwrap_or(\"config.json\")\n                    ));\n                }\n                Err(e) => {\n                    self.status_message = Some(format!(\"Speichern fehlgeschlagen: {}\", e));\n                }\n            }\n        } else {\n            self.status_message = Some(\"Keine Konfiguration zum Speichern\".to_string());\n        }\n    }\n\n    /// Process a message and update state\n    pub fn update(&mut self, msg: Message) {\n        match msg {\n            Message::SelectManufacturer(idx) => {\n                if idx < self.manufacturers.len() {\n                    self.selected_manufacturer = Some(self.manufacturers[idx].clone());\n                    // Screen is set in main.rs after loading catalog/families\n                    // If catalog exists -> Screen::Catalog, else -> Screen::Families\n                    self.family_list_state.select(Some(0));\n                    self.catalog_list_state.select(Some(0));\n                }\n            }\n            Message::SelectCatalogNode(idx) => {\n                if idx < self.catalog_children.len() {\n                    let node = self.catalog_children[idx].clone();\n                    match node.node_type {\n                        NodeType::Folder => {\n                            // Enter the folder\n                            self.enter_catalog_folder(&node);\n                        }\n                        NodeType::Article => {\n                            // Find family for this article and configure it\n                            // This is handled externally in main.rs\n                            self.status_message =\n                                Some(format!(\"Artikel: {} ({})\", node.name, node.id));\n                        }\n                        NodeType::Root => {}\n                    }\n                }\n            }\n            Message::SelectFamily(idx) => {\n                if idx < self.families.len() {\n                    self.selected_family = Some(self.families[idx].clone());\n                    self.screen = Screen::FamilyConfig;\n                    self.focused_property = 0;\n                    self.focused_article_index = 0;\n                    // Properties and configuration are loaded in main.rs TUI loop\n                }\n            }\n            Message::SelectArticle(idx) => {\n                if idx < self.articles.len() {\n                    self.selected_article = Some(self.articles[idx].clone());\n                    self.screen = Screen::Properties;\n                    self.focused_property = 0;\n                    // Legacy article mode - configuration loaded externally\n                }\n            }\n            Message::CyclePropertyOption(delta) => {\n                // Cycle through options for the focused property\n                let mut changed = false;\n                let mut change_info: Option<(String, String, String, usize)> = None;\n\n                if let Some(ref mut config) = self.family_config {\n                    if let Some(prop) = self.family_properties.get(self.focused_property) {\n                        if !prop.options.is_empty() {\n                            let current_value = config\n                                .selections\n                                .get(&prop.key)\n                                .cloned()\n                                .unwrap_or_default();\n                            let current_idx = prop\n                                .options\n                                .iter()\n                                .position(|o| o.value == current_value)\n                                .unwrap_or(0);\n                            let new_idx = ((current_idx as i32 + delta)\n                                .rem_euclid(prop.options.len() as i32))\n                                as usize;\n                            let new_value = prop.options[new_idx].value.clone();\n\n                            if current_value != new_value {\n                                config.set(&prop.key, &new_value);\n                                changed = true;\n                                change_info = Some((\n                                    prop.key.clone(),\n                                    current_value,\n                                    new_value,\n                                    prop.options.len(),\n                                ));\n                            }\n                        }\n                    }\n                }\n                if changed {\n                    if let Some((key, old, new, opts)) = change_info {\n                        // Push to undo stack and clear redo stack\n                        self.undo_stack.push(PropertyChange {\n                            key: key.clone(),\n                            old_value: old.clone(),\n                            new_value: new.clone(),\n                        });\n                        self.redo_stack.clear();\n\n                        if self.debug_mode {\n                            self.debug_log(format!(\n                                \"Property changed: {} = '{}' -> '{}' ({} options)\",\n                                key, old, new, opts\n                            ));\n                        }\n                    }\n                    self.recalculate_price();\n                }\n            }\n            Message::EditProperty(name, value) => {\n                if let Some(ref mut config) = self.configuration {\n                    // Parse and set property value\n                    use ofml_lib::property::PropertyValue;\n                    let pv = if let Ok(i) = value.parse::<i64>() {\n                        PropertyValue::Int(i)\n                    } else if let Ok(f) = value.parse::<f64>() {\n                        PropertyValue::Float(f)\n                    } else if value == \"true\" {\n                        PropertyValue::Bool(true)\n                    } else if value == \"false\" {\n                        PropertyValue::Bool(false)\n                    } else {\n                        PropertyValue::String(value)\n                    };\n                    config.properties.values.insert(name, pv);\n                    config.update_variant_code();\n                    // Legacy article mode price recalculation not yet implemented\n                }\n            }\n            Message::NavigateUp => {\n                self.navigate(-1);\n            }\n            Message::NavigateDown => {\n                self.navigate(1);\n            }\n            Message::NavigatePageUp => {\n                self.navigate(-10);\n            }\n            Message::NavigatePageDown => {\n                self.navigate(10);\n            }\n            Message::NavigateToTop => {\n                self.navigate_to(0);\n            }\n            Message::NavigateToBottom => {\n                let max_idx = self.get_current_list_length().saturating_sub(1);\n                self.navigate_to(max_idx);\n            }\n            Message::GoBack => {\n                match self.screen {\n                    Screen::Catalog => {\n                        if !self.catalog_path.is_empty() {\n                            // Navigate up in catalog hierarchy\n                            self.exit_catalog_folder();\n                        } else {\n                            // At root of catalog, go back to manufacturer list\n                            self.screen = Screen::Manufacturers;\n                            self.selected_manufacturer = None;\n                            self.catalog = None;\n                            self.catalog_path.clear();\n                            self.catalog_children.clear();\n                        }\n                    }\n                    Screen::Families => {\n                        // Check if we came from catalog\n                        if self.catalog.is_some() {\n                            self.screen = Screen::Catalog;\n                        } else {\n                            self.screen = Screen::Manufacturers;\n                            self.selected_manufacturer = None;\n                            self.families.clear();\n                        }\n                    }\n                    Screen::FamilyConfig => {\n                        // Go back to catalog if we have one, otherwise families\n                        if self.catalog.is_some() && !self.catalog_path.is_empty() {\n                            self.screen = Screen::Catalog;\n                        } else if self.catalog.is_some() {\n                            // At catalog root, restore children\n                            if let Some(ref cat) = self.catalog {\n                                self.catalog_children = cat.root.children.clone();\n                            }\n                            self.screen = Screen::Catalog;\n                        } else {\n                            self.screen = Screen::Families;\n                        }\n                        self.selected_family = None;\n                        self.family_properties.clear();\n                        self.family_config = None;\n                        self.family_price = None;\n                        self.focused_article_index = 0;\n                    }\n                    Screen::Articles => {\n                        self.screen = Screen::Manufacturers;\n                        self.selected_manufacturer = None;\n                    }\n                    Screen::Properties => {\n                        self.screen = Screen::Articles;\n                        self.selected_article = None;\n                        self.configuration = None;\n                    }\n                    Screen::Help => {\n                        // Return to previous screen\n                        self.screen = Screen::Manufacturers;\n                    }\n                    Screen::Tables => {\n                        // Return to families or catalog\n                        if self.catalog.is_some() {\n                            self.screen = Screen::Catalog;\n                        } else {\n                            self.screen = Screen::Families;\n                        }\n                        self.tables.clear();\n                    }\n                    Screen::TableView => {\n                        self.screen = Screen::Tables;\n                        self.selected_table = None;\n                        self.table_rows.clear();\n                        self.table_scroll_x = 0;\n                    }\n                    Screen::SavedConfigs => {\n                        // Return to manufacturer list\n                        self.screen = Screen::Manufacturers;\n                        self.saved_configs.clear();\n                    }\n                    Screen::Manufacturers => {\n                        // At top level, quit\n                        self.should_quit = true;\n                    }\n                }\n            }\n            Message::GoHome => {\n                // Reset to manufacturers screen\n                self.screen = Screen::Manufacturers;\n                self.selected_manufacturer = None;\n                self.selected_family = None;\n                self.selected_article = None;\n                self.catalog = None;\n                self.catalog_path.clear();\n                self.catalog_children.clear();\n                self.families.clear();\n                self.family_properties.clear();\n                self.family_config = None;\n                self.family_price = None;\n                self.articles.clear();\n                self.configuration = None;\n                self.tables.clear();\n                self.table_rows.clear();\n                self.search_query.clear();\n                self.search_active = false;\n                self.filtered_indices.clear();\n                self.manufacturer_list_state.select(Some(0));\n                // Also clear undo/redo stacks when going home\n                self.undo_stack.clear();\n                self.redo_stack.clear();\n            }\n            Message::Undo => {\n                if let Some(change) = self.undo_stack.pop() {\n                    // Apply the reverse change\n                    if let Some(ref mut config) = self.family_config {\n                        config.set(&change.key, &change.old_value);\n                        // Move to redo stack (swap old/new for redo)\n                        self.redo_stack.push(PropertyChange {\n                            key: change.key.clone(),\n                            old_value: change.new_value.clone(),\n                            new_value: change.old_value.clone(),\n                        });\n                        self.recalculate_price();\n                        self.status_message = Some(format!(\"R√ºckg√§ngig: {}\", change.key));\n                        if self.debug_mode {\n                            self.debug_log(format!(\n                                \"Undo: {} = '{}' (was '{}')\",\n                                change.key, change.old_value, change.new_value\n                            ));\n                        }\n                    }\n                } else {\n                    self.status_message = Some(\"Nichts zum R√ºckg√§ngigmachen\".to_string());\n                }\n            }\n            Message::Redo => {\n                if let Some(change) = self.redo_stack.pop() {\n                    // Reapply the change (old_value in redo is what we want to apply)\n                    if let Some(ref mut config) = self.family_config {\n                        config.set(&change.key, &change.old_value);\n                        // Move back to undo stack\n                        self.undo_stack.push(PropertyChange {\n                            key: change.key.clone(),\n                            old_value: change.new_value.clone(),\n                            new_value: change.old_value.clone(),\n                        });\n                        self.recalculate_price();\n                        self.status_message = Some(format!(\"Wiederherstellen: {}\", change.key));\n                        if self.debug_mode {\n                            self.debug_log(format!(\n                                \"Redo: {} = '{}' (was '{}')\",\n                                change.key, change.old_value, change.new_value\n                            ));\n                        }\n                    }\n                } else {\n                    self.status_message = Some(\"Nichts zum Wiederherstellen\".to_string());\n                }\n            }\n            Message::ToggleSearch => {\n                self.search_active = !self.search_active;\n                if !self.search_active {\n                    self.search_query.clear();\n                    self.update_filter();\n                }\n            }\n            Message::UpdateSearch(query) => {\n                self.search_query = query;\n                self.update_filter();\n            }\n            Message::SetPriceDate(date) => {\n                self.price_date = date;\n                self.recalculate_price();\n            }\n            Message::Export => {\n                // Try family configuration export first (new mode)\n                if let (Some(ref mfr), Some(ref family), Some(ref config)) = (\n                    &self.selected_manufacturer,\n                    &self.selected_family,\n                    &self.family_config,\n                ) {\n                    let article_nr = family.base_article_nr.as_str();\n                    let series_id = &family.id;\n                    let json = ofml_lib::oap::export_family_json(\n                        &mfr.id,\n                        series_id,\n                        article_nr,\n                        config,\n                        self.family_price.as_ref(),\n                        &self.family_warnings,\n                    );\n                    let filename = format!(\n                        \"{}_{}_{}_{}.json\",\n                        mfr.id,\n                        series_id,\n                        article_nr,\n                        chrono::Utc::now().format(\"%Y%m%d_%H%M%S\")\n                    );\n                    match std::fs::write(&filename, &json) {\n                        Ok(_) => {\n                            self.status_message = Some(format!(\"Export erfolgreich: {}\", filename))\n                        }\n                        Err(e) => {\n                            self.status_message = Some(format!(\"Export fehlgeschlagen: {}\", e))\n                        }\n                    }\n                }\n                // Fallback to legacy configuration export\n                else if let Some(ref config) = self.configuration {\n                    let export_data = config.to_export_data();\n                    let filename = format!(\n                        \"{}_{}_{}.json\",\n                        config.manufacturer_id,\n                        config.article_id,\n                        chrono::Utc::now().format(\"%Y%m%d_%H%M%S\")\n                    );\n                    match serde_json::to_string_pretty(&export_data) {\n                        Ok(json) => match std::fs::write(&filename, json) {\n                            Ok(_) => {\n                                self.status_message =\n                                    Some(format!(\"Export erfolgreich: {}\", filename))\n                            }\n                            Err(e) => {\n                                self.status_message = Some(format!(\"Export fehlgeschlagen: {}\", e))\n                            }\n                        },\n                        Err(e) => self.status_message = Some(format!(\"JSON Fehler: {}\", e)),\n                    }\n                } else {\n                    self.status_message = Some(\"Keine Konfiguration zum Exportieren\".to_string());\n                }\n            }\n            Message::ShowHelp => {\n                self.screen = Screen::Help;\n            }\n            Message::ToggleDebug => {\n                self.debug_mode = !self.debug_mode;\n                if self.debug_mode {\n                    self.debug_log(\"Debug console enabled (F12 to hide)\".to_string());\n                    // Log current config state\n                    if let Some(ref config) = self.family_config {\n                        self.debug_log(format!(\"Current config: {} selections\", config.selections.len()));\n                    }\n                    if let Some(ref price) = self.family_price {\n                        self.debug_log(format!(\n                            \"Current price: {} EUR ({} surcharges)\",\n                            price.total_price, price.surcharges.len()\n                        ));\n                    }\n                }\n            }\n            Message::ShowTables => {\n                self.screen = Screen::Tables;\n                self.table_list_state.select(Some(0));\n            }\n            Message::SelectTable(idx) => {\n                if idx < self.tables.len() {\n                    self.selected_table = Some(self.tables[idx].clone());\n                    self.screen = Screen::TableView;\n                    self.table_row_list_state.select(Some(0));\n                    self.table_scroll_x = 0;\n                    // Table rows are loaded in main.rs\n                }\n            }\n            Message::ScrollTableHorizontal(delta) => {\n                let new_offset = (self.table_scroll_x as i32 + delta).max(0) as usize;\n                self.table_scroll_x = new_offset;\n            }\n            Message::SaveConfig => {\n                self.save_current_configuration();\n            }\n            Message::LoadConfig | Message::ShowSavedConfigs => {\n                // Load saved configurations list\n                match super::config_store::list_configurations() {\n                    Ok(configs) => {\n                        self.saved_configs = configs;\n                        if !self.saved_configs.is_empty() {\n                            self.saved_configs_list_state.select(Some(0));\n                        }\n                        self.screen = Screen::SavedConfigs;\n                    }\n                    Err(e) => {\n                        self.status_message = Some(format!(\"Fehler beim Laden: {}\", e));\n                    }\n                }\n            }\n            Message::SelectSavedConfig(idx) => {\n                if idx < self.saved_configs.len() {\n                    let (_, config) = &self.saved_configs[idx];\n                    // Store which configuration to load - actual loading happens in main.rs\n                    self.status_message = Some(format!(\n                        \"Lade Konfiguration: {} {} ({})\",\n                        config.manufacturer, config.article_nr, config.variant_code\n                    ));\n                }\n            }\n            Message::ToggleFavorite => {\n                if let (Some(ref mfr), Some(ref family)) =\n                    (&self.selected_manufacturer, &self.selected_family)\n                {\n                    let is_fav = super::config_store::is_favorite(&mfr.id, &family.id);\n                    if is_fav {\n                        if let Err(e) = super::config_store::remove_favorite(&mfr.id, &family.id) {\n                            self.status_message = Some(format!(\"Fehler: {}\", e));\n                        } else {\n                            self.status_message = Some(format!(\"‚òÖ {} entfernt\", family.name));\n                        }\n                    } else if let Err(e) =\n                        super::config_store::add_favorite(&mfr.id, &family.id, &family.name)\n                    {\n                        self.status_message = Some(format!(\"Fehler: {}\", e));\n                    } else {\n                        self.status_message = Some(format!(\"‚òÖ {} als Favorit\", family.name));\n                    }\n                } else {\n                    self.status_message =\n                        Some(\"W√§hlen Sie erst eine Produktfamilie aus\".to_string());\n                }\n            }\n            Message::ToggleTheme => {\n                self.theme_variant = self.theme_variant.toggle();\n                let theme_name = match self.theme_variant {\n                    super::theme::ThemeVariant::Dark => \"Dunkel\",\n                    super::theme::ThemeVariant::Light => \"Hell\",\n                };\n                self.status_message = Some(format!(\"Theme: {}\", theme_name));\n            }\n            Message::Quit => {\n                self.should_quit = true;\n            }\n            Message::Resize(width, height) => {\n                self.terminal_size = (width, height);\n            }\n            Message::ExportGeometry => {\n                // Handled in main.rs TUI loop (needs file I/O)\n            }\n        }\n    }\n\n    /// Navigate up or down in the current list\n    fn navigate(&mut self, delta: i32) {\n        match self.screen {\n            Screen::Manufacturers => {\n                let len = if self.filtered_indices.is_empty() {\n                    self.manufacturers.len()\n                } else {\n                    self.filtered_indices.len()\n                };\n                if len == 0 {\n                    return;\n                }\n                let current = self.manufacturer_list_state.selected().unwrap_or(0) as i32;\n                let new = (current + delta).rem_euclid(len as i32) as usize;\n                self.manufacturer_list_state.select(Some(new));\n            }\n            Screen::Catalog => {\n                let len = if self.filtered_indices.is_empty() {\n                    self.catalog_children.len()\n                } else {\n                    self.filtered_indices.len()\n                };\n                if len == 0 {\n                    return;\n                }\n                let current = self.catalog_list_state.selected().unwrap_or(0) as i32;\n                let new = (current + delta).rem_euclid(len as i32) as usize;\n                self.catalog_list_state.select(Some(new));\n            }\n            Screen::Families => {\n                let len = if self.filtered_indices.is_empty() {\n                    self.families.len()\n                } else {\n                    self.filtered_indices.len()\n                };\n                if len == 0 {\n                    return;\n                }\n                let current = self.family_list_state.selected().unwrap_or(0) as i32;\n                let new = (current + delta).rem_euclid(len as i32) as usize;\n                self.family_list_state.select(Some(new));\n            }\n            Screen::FamilyConfig => {\n                if !self.family_properties.is_empty() {\n                    // Navigate through properties\n                    let len = self.family_properties.len();\n                    let current = self.focused_property as i32;\n                    let new = (current + delta).rem_euclid(len as i32) as usize;\n                    self.focused_property = new;\n                } else if let Some(ref family) = self.selected_family {\n                    // No properties - navigate through articles\n                    let len = family.article_nrs.len();\n                    if len == 0 {\n                        return;\n                    }\n                    let current = self.focused_article_index as i32;\n                    let new = (current + delta).rem_euclid(len as i32) as usize;\n                    self.focused_article_index = new;\n                }\n            }\n            Screen::Articles => {\n                let len = if self.filtered_indices.is_empty() {\n                    self.articles.len()\n                } else {\n                    self.filtered_indices.len()\n                };\n                if len == 0 {\n                    return;\n                }\n                let current = self.article_list_state.selected().unwrap_or(0) as i32;\n                let new = (current + delta).rem_euclid(len as i32) as usize;\n                self.article_list_state.select(Some(new));\n            }\n            Screen::Properties => {\n                if let Some(ref config) = self.configuration {\n                    let len = config.properties.definitions.len();\n                    if len == 0 {\n                        return;\n                    }\n                    let current = self.focused_property as i32;\n                    let new = (current + delta).rem_euclid(len as i32) as usize;\n                    self.focused_property = new;\n                }\n            }\n            Screen::Tables => {\n                let len = if self.filtered_indices.is_empty() {\n                    self.tables.len()\n                } else {\n                    self.filtered_indices.len()\n                };\n                if len == 0 {\n                    return;\n                }\n                let current = self.table_list_state.selected().unwrap_or(0) as i32;\n                let new = (current + delta).rem_euclid(len as i32) as usize;\n                self.table_list_state.select(Some(new));\n            }\n            Screen::TableView => {\n                let len = self.table_rows.len();\n                if len == 0 {\n                    return;\n                }\n                let current = self.table_row_list_state.selected().unwrap_or(0) as i32;\n                let new = (current + delta).rem_euclid(len as i32) as usize;\n                self.table_row_list_state.select(Some(new));\n            }\n            Screen::SavedConfigs => {\n                let len = self.saved_configs.len();\n                if len == 0 {\n                    return;\n                }\n                let current = self.saved_configs_list_state.selected().unwrap_or(0) as i32;\n                let new = (current + delta).rem_euclid(len as i32) as usize;\n                self.saved_configs_list_state.select(Some(new));\n            }\n            Screen::Help => {}\n        }\n    }\n\n    /// Get the length of the current list (for navigation)\n    fn get_current_list_length(&self) -> usize {\n        match self.screen {\n            Screen::Manufacturers => {\n                if self.filtered_indices.is_empty() {\n                    self.manufacturers.len()\n                } else {\n                    self.filtered_indices.len()\n                }\n            }\n            Screen::Catalog => {\n                if self.filtered_indices.is_empty() {\n                    self.catalog_children.len()\n                } else {\n                    self.filtered_indices.len()\n                }\n            }\n            Screen::Families => {\n                if self.filtered_indices.is_empty() {\n                    self.families.len()\n                } else {\n                    self.filtered_indices.len()\n                }\n            }\n            Screen::FamilyConfig => {\n                if !self.family_properties.is_empty() {\n                    self.family_properties.len()\n                } else if let Some(ref family) = self.selected_family {\n                    family.article_nrs.len()\n                } else {\n                    0\n                }\n            }\n            Screen::Articles => {\n                if self.filtered_indices.is_empty() {\n                    self.articles.len()\n                } else {\n                    self.filtered_indices.len()\n                }\n            }\n            Screen::Properties => self\n                .configuration\n                .as_ref()\n                .map(|c| c.properties.definitions.len())\n                .unwrap_or(0),\n            Screen::Tables => {\n                if self.filtered_indices.is_empty() {\n                    self.tables.len()\n                } else {\n                    self.filtered_indices.len()\n                }\n            }\n            Screen::TableView => self.table_rows.len(),\n            Screen::SavedConfigs => self.saved_configs.len(),\n            Screen::Help => 0,\n        }\n    }\n\n    /// Navigate directly to a specific index\n    fn navigate_to(&mut self, index: usize) {\n        let len = self.get_current_list_length();\n        if len == 0 {\n            return;\n        }\n        let new_idx = index.min(len.saturating_sub(1));\n\n        match self.screen {\n            Screen::Manufacturers => {\n                self.manufacturer_list_state.select(Some(new_idx));\n            }\n            Screen::Catalog => {\n                self.catalog_list_state.select(Some(new_idx));\n            }\n            Screen::Families => {\n                self.family_list_state.select(Some(new_idx));\n            }\n            Screen::FamilyConfig => {\n                if !self.family_properties.is_empty() {\n                    self.focused_property = new_idx;\n                } else {\n                    self.focused_article_index = new_idx;\n                }\n            }\n            Screen::Articles => {\n                self.article_list_state.select(Some(new_idx));\n            }\n            Screen::Properties => {\n                self.focused_property = new_idx;\n            }\n            Screen::Tables => {\n                self.table_list_state.select(Some(new_idx));\n            }\n            Screen::TableView => {\n                self.table_row_list_state.select(Some(new_idx));\n            }\n            Screen::SavedConfigs => {\n                self.saved_configs_list_state.select(Some(new_idx));\n            }\n            Screen::Help => {}\n        }\n    }\n\n    /// Calculate fuzzy match score between query and target\n    ///\n    /// Returns None if no match, Some(score) otherwise.\n    /// Higher scores indicate better matches.\n    ///\n    /// Scoring criteria:\n    /// - 1000: Exact match (case-insensitive)\n    /// - 500+: Prefix match (query at start of target)\n    /// - 200+: Word boundary match (query appears after space/underscore/dash)\n    /// - 100+: Substring match (query appears anywhere)\n    /// - 10+: Subsequence match (all chars appear in order)\n    /// - Bonus: Consecutive character matches\n    /// - Penalty: Longer gaps between matches\n    fn fuzzy_score(query: &str, target: &str) -> Option<i32> {\n        if query.is_empty() {\n            return Some(0);\n        }\n\n        let target_lower = target.to_lowercase();\n        let query_lower = query.to_lowercase();\n\n        // Exact match (highest priority)\n        if target_lower == query_lower {\n            return Some(1000);\n        }\n\n        // Prefix match\n        if target_lower.starts_with(&query_lower) {\n            return Some(500 + (100 - target_lower.len().min(100) as i32));\n        }\n\n        // Word boundary match (after space, underscore, or dash)\n        let word_boundaries: Vec<usize> = target_lower\n            .char_indices()\n            .filter(|(i, c)| {\n                *i == 0\n                    || *c == ' '\n                    || *c == '_'\n                    || *c == '-'\n                    || target_lower.chars().nth(i.saturating_sub(1)).map_or(false, |prev| {\n                        prev == ' ' || prev == '_' || prev == '-'\n                    })\n            })\n            .map(|(i, _)| i)\n            .collect();\n\n        for boundary in &word_boundaries {\n            if target_lower[*boundary..].starts_with(&query_lower) {\n                return Some(200 + (100 - target_lower.len().min(100) as i32));\n            }\n        }\n\n        // Substring match\n        if let Some(pos) = target_lower.find(&query_lower) {\n            // Earlier position = better score\n            return Some(100 + (50 - pos.min(50) as i32));\n        }\n\n        // Subsequence match with gap penalty\n        let mut query_chars = query_lower.chars().peekable();\n        let mut score = 10;\n        let mut consecutive = 0;\n        let mut last_match_idx: Option<usize> = None;\n\n        for (idx, target_char) in target_lower.chars().enumerate() {\n            if query_chars.peek().is_some_and(|&q| q == target_char) {\n                query_chars.next();\n\n                // Bonus for consecutive matches\n                if last_match_idx.is_some_and(|last| idx == last + 1) {\n                    consecutive += 1;\n                    score += consecutive * 2;\n                } else {\n                    consecutive = 0;\n                    // Penalty for gaps\n                    if let Some(last) = last_match_idx {\n                        let gap = idx - last - 1;\n                        score -= (gap as i32).min(5);\n                    }\n                }\n\n                // Bonus for word boundary matches\n                if word_boundaries.contains(&idx) {\n                    score += 3;\n                }\n\n                last_match_idx = Some(idx);\n            }\n        }\n\n        if query_chars.peek().is_none() {\n            Some(score.max(1))\n        } else {\n            None\n        }\n    }\n\n    /// Get the best fuzzy match score from multiple targets\n    fn fuzzy_score_any(query: &str, targets: &[&str]) -> Option<i32> {\n        targets\n            .iter()\n            .filter_map(|t| Self::fuzzy_score(query, t))\n            .max()\n    }\n\n    /// Update filter based on search query\n    fn update_filter(&mut self) {\n        if self.search_query.is_empty() {\n            self.filtered_indices.clear();\n            return;\n        }\n\n        let query = &self.search_query;\n\n        // Collect (index, score) pairs and sort by score descending\n        let mut scored: Vec<(usize, i32)> = match self.screen {\n            Screen::Manufacturers => self\n                .manufacturers\n                .iter()\n                .enumerate()\n                .filter_map(|(i, m)| {\n                    Self::fuzzy_score_any(query, &[&m.id, &m.name]).map(|s| (i, s))\n                })\n                .collect(),\n            Screen::Catalog => self\n                .catalog_children\n                .iter()\n                .enumerate()\n                .filter_map(|(i, n)| {\n                    Self::fuzzy_score_any(query, &[&n.id, &n.name]).map(|s| (i, s))\n                })\n                .collect(),\n            Screen::Families => self\n                .families\n                .iter()\n                .enumerate()\n                .filter_map(|(i, f)| {\n                    Self::fuzzy_score_any(query, &[&f.id, &f.name, &f.description]).map(|s| (i, s))\n                })\n                .collect(),\n            Screen::Articles => self\n                .articles\n                .iter()\n                .enumerate()\n                .filter_map(|(i, a)| {\n                    Self::fuzzy_score_any(query, &[&a.id, &a.short_description]).map(|s| (i, s))\n                })\n                .collect(),\n            Screen::Tables => self\n                .tables\n                .iter()\n                .enumerate()\n                .filter_map(|(i, t)| Self::fuzzy_score(query, &t.name).map(|s| (i, s)))\n                .collect(),\n            _ => Vec::new(),\n        };\n\n        // Sort by score descending (higher score = better match = first)\n        scored.sort_by(|a, b| b.1.cmp(&a.1));\n        self.filtered_indices = scored.into_iter().map(|(i, _)| i).collect();\n\n        // Reset selection to first filtered item\n        match self.screen {\n            Screen::Manufacturers => {\n                self.manufacturer_list_state.select(Some(0));\n            }\n            Screen::Catalog => {\n                self.catalog_list_state.select(Some(0));\n            }\n            Screen::Families => {\n                self.family_list_state.select(Some(0));\n            }\n            Screen::Articles => {\n                self.article_list_state.select(Some(0));\n            }\n            Screen::Tables => {\n                self.table_list_state.select(Some(0));\n            }\n            _ => {}\n        }\n    }\n\n    /// Get the currently selected item index (accounting for filter)\n    pub fn get_selected_index(&self) -> Option<usize> {\n        match self.screen {\n            Screen::Manufacturers => {\n                let selected = self.manufacturer_list_state.selected()?;\n                if self.filtered_indices.is_empty() {\n                    Some(selected)\n                } else {\n                    self.filtered_indices.get(selected).copied()\n                }\n            }\n            Screen::Catalog => {\n                let selected = self.catalog_list_state.selected()?;\n                if self.filtered_indices.is_empty() {\n                    Some(selected)\n                } else {\n                    self.filtered_indices.get(selected).copied()\n                }\n            }\n            Screen::Families => {\n                let selected = self.family_list_state.selected()?;\n                if self.filtered_indices.is_empty() {\n                    Some(selected)\n                } else {\n                    self.filtered_indices.get(selected).copied()\n                }\n            }\n            Screen::Articles => {\n                let selected = self.article_list_state.selected()?;\n                if self.filtered_indices.is_empty() {\n                    Some(selected)\n                } else {\n                    self.filtered_indices.get(selected).copied()\n                }\n            }\n            Screen::Tables => {\n                let selected = self.table_list_state.selected()?;\n                if self.filtered_indices.is_empty() {\n                    Some(selected)\n                } else {\n                    self.filtered_indices.get(selected).copied()\n                }\n            }\n            _ => None,\n        }\n    }\n}\n\n\nimpl Default for App {\n    fn default() -> Self {\n        Self::new(String::new())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_app_new() {\n        let app = App::new(\"/workspace/ofmldata\".to_string());\n        assert_eq!(app.screen, Screen::Manufacturers);\n        assert!(!app.should_quit);\n        assert!(app.manufacturers.is_empty());\n    }\n\n    #[test]\n    fn test_app_navigate() {\n        let mut app = App::new(\"/workspace/ofmldata\".to_string());\n        app.manufacturers = vec![\n            Manufacturer {\n                id: \"a\".to_string(),\n                name: \"A\".to_string(),\n                path: std::path::PathBuf::new(),\n            },\n            Manufacturer {\n                id: \"b\".to_string(),\n                name: \"B\".to_string(),\n                path: std::path::PathBuf::new(),\n            },\n        ];\n\n        assert_eq!(app.manufacturer_list_state.selected(), Some(0));\n        app.update(Message::NavigateDown);\n        assert_eq!(app.manufacturer_list_state.selected(), Some(1));\n        app.update(Message::NavigateDown);\n        assert_eq!(app.manufacturer_list_state.selected(), Some(0)); // Wrap around\n    }\n\n    #[test]\n    fn test_app_quit() {\n        let mut app = App::new(\"/workspace/ofmldata\".to_string());\n        assert!(!app.should_quit);\n        app.update(Message::Quit);\n        assert!(app.should_quit);\n    }\n\n    #[test]\n    fn test_app_search() {\n        let mut app = App::new(\"/workspace/ofmldata\".to_string());\n        app.manufacturers = vec![\n            Manufacturer {\n                id: \"vitra\".to_string(),\n                name: \"Vitra AG\".to_string(),\n                path: std::path::PathBuf::new(),\n            },\n            Manufacturer {\n                id: \"sedus\".to_string(),\n                name: \"Sedus Stoll\".to_string(),\n                path: std::path::PathBuf::new(),\n            },\n        ];\n\n        app.update(Message::ToggleSearch);\n        assert!(app.search_active);\n\n        app.update(Message::UpdateSearch(\"vit\".to_string()));\n        assert_eq!(app.filtered_indices, vec![0]);\n\n        app.update(Message::ToggleSearch);\n        assert!(!app.search_active);\n        assert!(app.filtered_indices.is_empty());\n    }\n\n    #[test]\n    fn test_fuzzy_score() {\n        // Exact match - highest score\n        assert!(App::fuzzy_score(\"vitra\", \"vitra\").unwrap() >= 1000);\n\n        // Prefix match - high score\n        let prefix_score = App::fuzzy_score(\"vit\", \"Vitra\").unwrap();\n        assert!(prefix_score >= 500);\n\n        // Case insensitive\n        assert!(App::fuzzy_score(\"VIT\", \"vitra\").is_some());\n\n        // Subsequence match - lower score\n        let subseq_score = App::fuzzy_score(\"vs\", \"Vitra Sedus\").unwrap();\n        assert!(subseq_score >= 10);\n        assert!(subseq_score < prefix_score); // Subsequence < prefix\n\n        assert!(App::fuzzy_score(\"ai\", \"Aeris_Inspire\").is_some());\n        assert!(App::fuzzy_score(\"sd\", \"Sedus\").is_some());\n\n        // Non-matches should return None\n        assert!(App::fuzzy_score(\"xyz\", \"Vitra\").is_none());\n        assert!(App::fuzzy_score(\"ab\", \"ba\").is_none()); // Order matters\n\n        // Verify scoring priority: exact > prefix > substring > subsequence\n        let exact = App::fuzzy_score(\"vitra\", \"vitra\").unwrap();\n        let prefix = App::fuzzy_score(\"vit\", \"vitra\").unwrap();\n        let substring = App::fuzzy_score(\"itr\", \"vitra\").unwrap();\n        let subsequence = App::fuzzy_score(\"va\", \"vitra\").unwrap();\n\n        assert!(exact > prefix, \"exact ({}) should beat prefix ({})\", exact, prefix);\n        assert!(prefix > substring, \"prefix ({}) should beat substring ({})\", prefix, substring);\n        assert!(substring > subsequence, \"substring ({}) should beat subsequence ({})\", substring, subsequence);\n    }\n\n    #[test]\n    fn test_fuzzy_search() {\n        let mut app = App::new(\"/workspace/ofmldata\".to_string());\n        app.manufacturers = vec![\n            Manufacturer {\n                id: \"vitra\".to_string(),\n                name: \"Vitra AG\".to_string(),\n                path: std::path::PathBuf::new(),\n            },\n            Manufacturer {\n                id: \"sedus\".to_string(),\n                name: \"Sedus Stoll\".to_string(),\n                path: std::path::PathBuf::new(),\n            },\n            Manufacturer {\n                id: \"bisley\".to_string(),\n                name: \"Bisley\".to_string(),\n                path: std::path::PathBuf::new(),\n            },\n        ];\n\n        app.update(Message::ToggleSearch);\n\n        // Test fuzzy subsequence match\n        app.update(Message::UpdateSearch(\"vs\".to_string()));\n        // \"vs\" matches \"Vitra\" (v...s) and \"Sedus\" (s...s would need 2 s's)\n        // Actually \"vs\" only matches if v and s appear in order\n        // In \"Vitra AG\" we have v-i-t-r-a, no 's' -> doesn't match\n        // In \"Sedus Stoll\" we have s-e-d-u-s, has 's' but no 'v' before -> doesn't match\n        // So \"vs\" shouldn't match anything in this set\n        assert!(app.filtered_indices.is_empty());\n\n        // Test fuzzy match with \"ss\" for Sedus Stoll\n        app.update(Message::UpdateSearch(\"ss\".to_string()));\n        assert_eq!(app.filtered_indices, vec![1]); // Sedus has two s's\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-tui","src","config_store.rs"],"content":"//! Configuration persistence for TUI\r\n//!\r\n//! This module handles saving and loading product configurations to/from JSON files.\r\n//! It provides three main features:\r\n//!\r\n//! ## Saved Configurations\r\n//! Save and load complete product configurations including all property selections,\r\n//! variant codes, and pricing information. Stored in `~/.ofml-configs/`.\r\n//!\r\n//! ## Favorites System\r\n//! Mark product families as favorites for quick access. Favorites are stored in\r\n//! `~/.ofml-configs/favorites.json`.\r\n//!\r\n//! ## History System\r\n//! Automatically track recently configured products with access counts.\r\n//! Limited to 20 entries, stored in `~/.ofml-configs/history.json`.\r\n//!\r\n//! # Example\r\n//! ```ignore\r\n//! use ofml_interpreter::tui::config_store::*;\r\n//!\r\n//! // Add a product to favorites\r\n//! add_favorite(\"sedus\", \"ai\", \"AI Drehstuhl\")?;\r\n//!\r\n//! // Check if it's a favorite\r\n//! assert!(is_favorite(\"sedus\", \"ai\"));\r\n//!\r\n//! // Remove from favorites\r\n//! remove_favorite(\"sedus\", \"ai\")?;\r\n//! ```\r\n\r\nuse serde::{Deserialize, Serialize};\r\nuse std::collections::HashMap;\r\nuse std::fs;\r\nuse std::path::{Path, PathBuf};\r\n\r\n/// A saved product configuration\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct SavedConfiguration {\r\n    /// Manufacturer ID\r\n    pub manufacturer: String,\r\n    /// Series/Product family ID\r\n    pub series: String,\r\n    /// Article number\r\n    pub article_nr: String,\r\n    /// Property selections (key -> value)\r\n    pub properties: HashMap<String, String>,\r\n    /// Variant code\r\n    pub variant_code: String,\r\n    /// Description from catalog\r\n    #[serde(default)]\r\n    pub description: String,\r\n    /// Price date used\r\n    #[serde(default)]\r\n    pub price_date: Option<String>,\r\n    /// Saved timestamp\r\n    pub saved_at: String,\r\n}\r\n\r\n/// Configuration store directory location\r\nfn get_config_dir() -> PathBuf {\r\n    // Use ~/.ofml-configs for storing configurations\r\n    let home = std::env::var(\"HOME\").unwrap_or_else(|_| \".\".to_string());\r\n    PathBuf::from(home).join(\".ofml-configs\")\r\n}\r\n\r\n/// Ensure config directory exists\r\nfn ensure_config_dir() -> std::io::Result<PathBuf> {\r\n    let dir = get_config_dir();\r\n    if !dir.exists() {\r\n        fs::create_dir_all(&dir)?;\r\n    }\r\n    Ok(dir)\r\n}\r\n\r\n/// Generate a filename for a configuration\r\nfn config_filename(manufacturer: &str, article: &str, variant_code: &str) -> String {\r\n    // Sanitize for filename\r\n    let safe_article = article.replace([':', '/', '\\\\'], \"_\");\r\n    let safe_variant = variant_code.replace([':', '/', '\\\\', '.'], \"_\");\r\n    format!(\"{}_{}_{}_{}.json\", manufacturer, safe_article, safe_variant,\r\n            chrono::Local::now().format(\"%Y%m%d_%H%M%S\"))\r\n}\r\n\r\n/// Save a configuration to a JSON file\r\npub fn save_configuration(config: &SavedConfiguration) -> Result<PathBuf, String> {\r\n    let dir = ensure_config_dir().map_err(|e| format!(\"Failed to create config directory: {}\", e))?;\r\n\r\n    let filename = config_filename(&config.manufacturer, &config.article_nr, &config.variant_code);\r\n    let path = dir.join(&filename);\r\n\r\n    let json = serde_json::to_string_pretty(config)\r\n        .map_err(|e| format!(\"Failed to serialize configuration: {}\", e))?;\r\n\r\n    fs::write(&path, json)\r\n        .map_err(|e| format!(\"Failed to write configuration file: {}\", e))?;\r\n\r\n    Ok(path)\r\n}\r\n\r\n/// Load a configuration from a JSON file\r\npub fn load_configuration(path: &Path) -> Result<SavedConfiguration, String> {\r\n    let json = fs::read_to_string(path)\r\n        .map_err(|e| format!(\"Failed to read configuration file: {}\", e))?;\r\n\r\n    serde_json::from_str(&json)\r\n        .map_err(|e| format!(\"Failed to parse configuration: {}\", e))\r\n}\r\n\r\n/// List all saved configurations\r\npub fn list_configurations() -> Result<Vec<(PathBuf, SavedConfiguration)>, String> {\r\n    let dir = get_config_dir();\r\n    if !dir.exists() {\r\n        return Ok(Vec::new());\r\n    }\r\n\r\n    let mut configs = Vec::new();\r\n\r\n    let entries = fs::read_dir(&dir)\r\n        .map_err(|e| format!(\"Failed to read config directory: {}\", e))?;\r\n\r\n    for entry in entries.flatten() {\r\n        let path = entry.path();\r\n        if path.extension().and_then(|s| s.to_str()) == Some(\"json\") {\r\n            if let Ok(config) = load_configuration(&path) {\r\n                configs.push((path, config));\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sort by saved_at descending (newest first)\r\n    configs.sort_by(|a, b| b.1.saved_at.cmp(&a.1.saved_at));\r\n\r\n    Ok(configs)\r\n}\r\n\r\n/// Delete a saved configuration\r\npub fn delete_configuration(path: &Path) -> Result<(), String> {\r\n    fs::remove_file(path)\r\n        .map_err(|e| format!(\"Failed to delete configuration: {}\", e))\r\n}\r\n\r\n// === Favorites System ===\r\n\r\n/// A favorite product family for quick access\r\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\r\npub struct Favorite {\r\n    /// Manufacturer ID\r\n    pub manufacturer: String,\r\n    /// Series/Product family ID\r\n    pub series: String,\r\n    /// Human-readable name\r\n    pub name: String,\r\n    /// When this was added to favorites\r\n    pub added_at: String,\r\n}\r\n\r\n/// Favorites storage\r\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\r\npub struct FavoritesStore {\r\n    pub favorites: Vec<Favorite>,\r\n}\r\n\r\n/// Get the favorites file path\r\nfn get_favorites_path() -> PathBuf {\r\n    get_config_dir().join(\"favorites.json\")\r\n}\r\n\r\n/// Load favorites from disk\r\npub fn load_favorites() -> FavoritesStore {\r\n    let path = get_favorites_path();\r\n    if !path.exists() {\r\n        return FavoritesStore::default();\r\n    }\r\n\r\n    fs::read_to_string(&path)\r\n        .ok()\r\n        .and_then(|json| serde_json::from_str(&json).ok())\r\n        .unwrap_or_default()\r\n}\r\n\r\n/// Save favorites to disk\r\npub fn save_favorites(store: &FavoritesStore) -> Result<(), String> {\r\n    let _ = ensure_config_dir();\r\n    let path = get_favorites_path();\r\n    let json = serde_json::to_string_pretty(store)\r\n        .map_err(|e| format!(\"Failed to serialize favorites: {}\", e))?;\r\n    fs::write(&path, json).map_err(|e| format!(\"Failed to write favorites: {}\", e))\r\n}\r\n\r\n/// Add a favorite\r\npub fn add_favorite(manufacturer: &str, series: &str, name: &str) -> Result<(), String> {\r\n    let mut store = load_favorites();\r\n\r\n    // Check if already exists\r\n    if store\r\n        .favorites\r\n        .iter()\r\n        .any(|f| f.manufacturer == manufacturer && f.series == series)\r\n    {\r\n        return Ok(()); // Already a favorite\r\n    }\r\n\r\n    store.favorites.push(Favorite {\r\n        manufacturer: manufacturer.to_string(),\r\n        series: series.to_string(),\r\n        name: name.to_string(),\r\n        added_at: chrono::Local::now().format(\"%Y-%m-%d %H:%M:%S\").to_string(),\r\n    });\r\n\r\n    save_favorites(&store)\r\n}\r\n\r\n/// Remove a favorite\r\npub fn remove_favorite(manufacturer: &str, series: &str) -> Result<(), String> {\r\n    let mut store = load_favorites();\r\n    store\r\n        .favorites\r\n        .retain(|f| !(f.manufacturer == manufacturer && f.series == series));\r\n    save_favorites(&store)\r\n}\r\n\r\n/// Check if a product family is a favorite\r\npub fn is_favorite(manufacturer: &str, series: &str) -> bool {\r\n    let store = load_favorites();\r\n    store\r\n        .favorites\r\n        .iter()\r\n        .any(|f| f.manufacturer == manufacturer && f.series == series)\r\n}\r\n\r\n// === History System ===\r\n\r\n/// Maximum number of history entries\r\nconst MAX_HISTORY_ENTRIES: usize = 20;\r\n\r\n/// A history entry for a recently configured product\r\n#[derive(Debug, Clone, Serialize, Deserialize)]\r\npub struct HistoryEntry {\r\n    /// Manufacturer ID\r\n    pub manufacturer: String,\r\n    /// Series/Product family ID\r\n    pub series: String,\r\n    /// Article number\r\n    pub article_nr: String,\r\n    /// Human-readable name\r\n    pub name: String,\r\n    /// Last access timestamp\r\n    pub last_accessed: String,\r\n    /// Access count\r\n    pub access_count: u32,\r\n}\r\n\r\n/// History storage\r\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\r\npub struct HistoryStore {\r\n    pub entries: Vec<HistoryEntry>,\r\n}\r\n\r\n/// Get the history file path\r\nfn get_history_path() -> PathBuf {\r\n    get_config_dir().join(\"history.json\")\r\n}\r\n\r\n/// Load history from disk\r\npub fn load_history() -> HistoryStore {\r\n    let path = get_history_path();\r\n    if !path.exists() {\r\n        return HistoryStore::default();\r\n    }\r\n\r\n    fs::read_to_string(&path)\r\n        .ok()\r\n        .and_then(|json| serde_json::from_str(&json).ok())\r\n        .unwrap_or_default()\r\n}\r\n\r\n/// Save history to disk\r\nfn save_history(store: &HistoryStore) -> Result<(), String> {\r\n    let _ = ensure_config_dir();\r\n    let path = get_history_path();\r\n    let json = serde_json::to_string_pretty(store)\r\n        .map_err(|e| format!(\"Failed to serialize history: {}\", e))?;\r\n    fs::write(&path, json).map_err(|e| format!(\"Failed to write history: {}\", e))\r\n}\r\n\r\n/// Add or update a history entry\r\npub fn add_to_history(\r\n    manufacturer: &str,\r\n    series: &str,\r\n    article_nr: &str,\r\n    name: &str,\r\n) -> Result<(), String> {\r\n    let mut store = load_history();\r\n    let now = chrono::Local::now().format(\"%Y-%m-%d %H:%M:%S\").to_string();\r\n\r\n    // Check if entry already exists\r\n    if let Some(entry) = store.entries.iter_mut().find(|e| {\r\n        e.manufacturer == manufacturer && e.series == series && e.article_nr == article_nr\r\n    }) {\r\n        entry.last_accessed = now;\r\n        entry.access_count += 1;\r\n    } else {\r\n        // Add new entry\r\n        store.entries.push(HistoryEntry {\r\n            manufacturer: manufacturer.to_string(),\r\n            series: series.to_string(),\r\n            article_nr: article_nr.to_string(),\r\n            name: name.to_string(),\r\n            last_accessed: now,\r\n            access_count: 1,\r\n        });\r\n    }\r\n\r\n    // Sort by last_accessed descending\r\n    store\r\n        .entries\r\n        .sort_by(|a, b| b.last_accessed.cmp(&a.last_accessed));\r\n\r\n    // Trim to max entries\r\n    store.entries.truncate(MAX_HISTORY_ENTRIES);\r\n\r\n    save_history(&store)\r\n}\r\n\r\n/// Get recent history entries\r\npub fn get_recent_history(limit: usize) -> Vec<HistoryEntry> {\r\n    let store = load_history();\r\n    store.entries.into_iter().take(limit).collect()\r\n}\r\n\r\n/// Clear history\r\npub fn clear_history() -> Result<(), String> {\r\n    save_history(&HistoryStore::default())\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_config_filename() {\r\n        let filename = config_filename(\"sex\", \"AI:100A\", \"PG3_CSE166\");\r\n        assert!(filename.starts_with(\"sex_AI_100A_PG3_CSE166_\"));\r\n        assert!(filename.ends_with(\".json\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_config_filename_special_chars() {\r\n        // Test that special characters in article/variant are sanitized\r\n        let filename = config_filename(\"mfr\", \"ART/123\", \"VAR:456.789\");\r\n        // Path separators should be converted to underscores\r\n        assert!(!filename.contains('/'));\r\n        assert!(!filename.contains('\\\\'));\r\n        // The filename ends with .json, so we check the base name doesn't have colons/dots\r\n        let base = filename.strip_suffix(\".json\").unwrap();\r\n        // Colons in article and variant should be replaced with underscores\r\n        assert!(!base[base.find(\"ART\").unwrap()..].contains(':'));\r\n        // Dots in variant should be replaced with underscores\r\n        assert!(!base[base.find(\"VAR\").unwrap()..].contains('.'));\r\n        assert!(filename.ends_with(\".json\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_saved_configuration_serialization() {\r\n        let config = SavedConfiguration {\r\n            manufacturer: \"sedus\".to_string(),\r\n            series: \"ai\".to_string(),\r\n            article_nr: \"SE:AI-100\".to_string(),\r\n            properties: HashMap::from([\r\n                (\"PG\".to_string(), \"3\".to_string()),\r\n                (\"CSE\".to_string(), \"166\".to_string()),\r\n            ]),\r\n            variant_code: \"PG=3;CSE=166\".to_string(),\r\n            description: \"Drehstuhl\".to_string(),\r\n            price_date: Some(\"2024-01-15\".to_string()),\r\n            saved_at: \"2024-01-15 10:30:00\".to_string(),\r\n        };\r\n\r\n        let json = serde_json::to_string(&config).expect(\"Serialization should work\");\r\n        assert!(json.contains(\"sedus\"));\r\n        assert!(json.contains(\"ai\"));\r\n        assert!(json.contains(\"SE:AI-100\"));\r\n\r\n        let parsed: SavedConfiguration =\r\n            serde_json::from_str(&json).expect(\"Deserialization should work\");\r\n        assert_eq!(parsed.manufacturer, \"sedus\");\r\n        assert_eq!(parsed.series, \"ai\");\r\n        assert_eq!(parsed.properties.len(), 2);\r\n    }\r\n\r\n    #[test]\r\n    fn test_favorite_serialization() {\r\n        let fav = Favorite {\r\n            manufacturer: \"vitra\".to_string(),\r\n            series: \"abc\".to_string(),\r\n            name: \"Add System\".to_string(),\r\n            added_at: \"2024-01-15 10:00:00\".to_string(),\r\n        };\r\n\r\n        let json = serde_json::to_string(&fav).expect(\"Serialization should work\");\r\n        let parsed: Favorite = serde_json::from_str(&json).expect(\"Deserialization should work\");\r\n        assert_eq!(parsed.manufacturer, \"vitra\");\r\n        assert_eq!(parsed.series, \"abc\");\r\n        assert_eq!(parsed.name, \"Add System\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_favorites_store_serialization() {\r\n        let store = FavoritesStore {\r\n            favorites: vec![\r\n                Favorite {\r\n                    manufacturer: \"sedus\".to_string(),\r\n                    series: \"ai\".to_string(),\r\n                    name: \"AI Chair\".to_string(),\r\n                    added_at: \"2024-01-01\".to_string(),\r\n                },\r\n                Favorite {\r\n                    manufacturer: \"vitra\".to_string(),\r\n                    series: \"allstar\".to_string(),\r\n                    name: \"Allstar Chair\".to_string(),\r\n                    added_at: \"2024-01-02\".to_string(),\r\n                },\r\n            ],\r\n        };\r\n\r\n        let json = serde_json::to_string(&store).expect(\"Serialization should work\");\r\n        let parsed: FavoritesStore =\r\n            serde_json::from_str(&json).expect(\"Deserialization should work\");\r\n        assert_eq!(parsed.favorites.len(), 2);\r\n    }\r\n\r\n    #[test]\r\n    fn test_history_entry_serialization() {\r\n        let entry = HistoryEntry {\r\n            manufacturer: \"sedus\".to_string(),\r\n            series: \"ai\".to_string(),\r\n            article_nr: \"SE:AI-100\".to_string(),\r\n            name: \"AI Chair\".to_string(),\r\n            last_accessed: \"2024-01-15 10:30:00\".to_string(),\r\n            access_count: 5,\r\n        };\r\n\r\n        let json = serde_json::to_string(&entry).expect(\"Serialization should work\");\r\n        let parsed: HistoryEntry =\r\n            serde_json::from_str(&json).expect(\"Deserialization should work\");\r\n        assert_eq!(parsed.manufacturer, \"sedus\");\r\n        assert_eq!(parsed.access_count, 5);\r\n    }\r\n\r\n    #[test]\r\n    fn test_history_store_serialization() {\r\n        let store = HistoryStore {\r\n            entries: vec![\r\n                HistoryEntry {\r\n                    manufacturer: \"sedus\".to_string(),\r\n                    series: \"ai\".to_string(),\r\n                    article_nr: \"SE:AI-100\".to_string(),\r\n                    name: \"AI Chair\".to_string(),\r\n                    last_accessed: \"2024-01-15 10:30:00\".to_string(),\r\n                    access_count: 3,\r\n                },\r\n                HistoryEntry {\r\n                    manufacturer: \"vitra\".to_string(),\r\n                    series: \"abc\".to_string(),\r\n                    article_nr: \"VIT:ABC-200\".to_string(),\r\n                    name: \"Add System\".to_string(),\r\n                    last_accessed: \"2024-01-14 09:00:00\".to_string(),\r\n                    access_count: 1,\r\n                },\r\n            ],\r\n        };\r\n\r\n        let json = serde_json::to_string(&store).expect(\"Serialization should work\");\r\n        let parsed: HistoryStore =\r\n            serde_json::from_str(&json).expect(\"Deserialization should work\");\r\n        assert_eq!(parsed.entries.len(), 2);\r\n    }\r\n\r\n    #[test]\r\n    fn test_favorite_equality() {\r\n        let fav1 = Favorite {\r\n            manufacturer: \"sedus\".to_string(),\r\n            series: \"ai\".to_string(),\r\n            name: \"AI Chair\".to_string(),\r\n            added_at: \"2024-01-01\".to_string(),\r\n        };\r\n        let fav2 = Favorite {\r\n            manufacturer: \"sedus\".to_string(),\r\n            series: \"ai\".to_string(),\r\n            name: \"AI Chair\".to_string(),\r\n            added_at: \"2024-01-01\".to_string(),\r\n        };\r\n        let fav3 = Favorite {\r\n            manufacturer: \"vitra\".to_string(),\r\n            series: \"ai\".to_string(),\r\n            name: \"AI Chair\".to_string(),\r\n            added_at: \"2024-01-01\".to_string(),\r\n        };\r\n\r\n        // Identical favorites are equal\r\n        assert_eq!(fav1, fav2);\r\n        // Different manufacturer means not equal\r\n        assert_ne!(fav1, fav3);\r\n    }\r\n\r\n    #[test]\r\n    fn test_max_history_entries_constant() {\r\n        // Verify the constant exists and has a reasonable value\r\n        assert!(MAX_HISTORY_ENTRIES > 0);\r\n        assert!(MAX_HISTORY_ENTRIES <= 100);\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-tui","src","lib.rs"],"content":"//! TUI (Terminal User Interface) for OAP Configurator\r\n//!\r\n//! This crate provides an interactive terminal interface for:\r\n//! - Browsing manufacturers and articles\r\n//! - Configuring product properties\r\n//! - Viewing prices in real-time\r\n//! - Exporting configurations\r\n//!\r\n//! Built with ratatui and crossterm following the Elm Architecture (TEA) pattern.\r\n\r\npub mod app;\r\npub mod config_store;\r\npub mod theme;\r\npub mod ui;\r\npub mod views;\r\npub mod widgets;\r\n\r\npub use app::{App, Message, Screen};\r\npub use config_store::SavedConfiguration;\r\npub use theme::{Theme, ThemeVariant};\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-tui","src","main.rs"],"content":"//! OFML TUI - Terminal User Interface for OFML Product Configuration\r\n//!\r\n//! A terminal-based product configurator for browsing and configuring\r\n//! OFML (Office Furniture Modeling Language) product data.\r\n\r\nuse std::io;\r\nuse std::path::Path;\r\n\r\nuse clap::Parser;\r\nuse crossterm::{\r\n    event::{DisableMouseCapture, EnableMouseCapture},\r\n    execute,\r\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\r\n};\r\nuse ratatui::{backend::CrosstermBackend, Terminal};\r\nuse tracing_subscriber::{fmt, prelude::*, EnvFilter};\r\n\r\nuse ofml_lib::oap::engine::ConfigurationEngine;\r\nuse ofml_lib::oap::manufacturers;\r\n\r\nmod runner;\r\n\r\n/// OFML TUI - Terminal Product Configurator\r\n#[derive(Parser)]\r\n#[command(name = \"ofml-tui\")]\r\n#[command(author, version, about = \"Terminal UI for OFML product configuration\")]\r\nstruct Cli {\r\n    /// Path to OFML data directory\r\n    data_path: String,\r\n\r\n    /// Price date (YYYY-MM-DD)\r\n    #[arg(short = 'd', long)]\r\n    price_date: Option<String>,\r\n\r\n    /// Increase output verbosity (-v, -vv, -vvv)\r\n    #[arg(short, long, action = clap::ArgAction::Count)]\r\n    verbose: u8,\r\n}\r\n\r\nfn main() -> Result<(), Box<dyn std::error::Error>> {\r\n    let cli = Cli::parse();\r\n\r\n    // Setup tracing\r\n    let filter = match cli.verbose {\r\n        0 => \"warn\",\r\n        1 => \"info\",\r\n        2 => \"debug\",\r\n        _ => \"trace\",\r\n    };\r\n    tracing_subscriber::registry()\r\n        .with(fmt::layer())\r\n        .with(EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new(filter)))\r\n        .init();\r\n\r\n    // Run the TUI\r\n    run_tui(&cli.data_path, cli.price_date.as_deref())?;\r\n\r\n    Ok(())\r\n}\r\n\r\nfn run_tui(data_path: &str, price_date_str: Option<&str>) -> Result<(), String> {\r\n    let path = Path::new(data_path);\r\n    if !path.exists() {\r\n        return Err(format!(\"Data path not found: {}\", data_path));\r\n    }\r\n\r\n    // Parse price date\r\n    let price_date = match price_date_str {\r\n        Some(s) => chrono::NaiveDate::parse_from_str(s, \"%Y-%m-%d\")\r\n            .map_err(|_| format!(\"Invalid date format: {}. Use YYYY-MM-DD\", s))?,\r\n        None => chrono::Local::now().date_naive(),\r\n    };\r\n\r\n    // Setup terminal\r\n    enable_raw_mode().map_err(|e| e.to_string())?;\r\n    let mut stdout = io::stdout();\r\n    execute!(stdout, EnterAlternateScreen, EnableMouseCapture).map_err(|e| e.to_string())?;\r\n    let backend = CrosstermBackend::new(stdout);\r\n    let mut terminal = Terminal::new(backend).map_err(|e| e.to_string())?;\r\n\r\n    // Create app and load manufacturers\r\n    let mut app = ofml_tui::App::new(data_path.to_string());\r\n    app.price_date = price_date;\r\n\r\n    // Create configuration engine\r\n    let mut engine = ConfigurationEngine::new(path);\r\n\r\n    // Initialize manufacturer names from Manufacturers.ebase\r\n    manufacturers::init_from_data_path(path);\r\n\r\n    // Load installed manufacturers from SQLite (fast)\r\n    let installed = manufacturers::get_installed_manufacturers(path);\r\n    for mfr in installed {\r\n        app.manufacturers.push(ofml_lib::oap::Manufacturer {\r\n            id: mfr.id,\r\n            name: mfr.name,\r\n            path: mfr.path,\r\n        });\r\n    }\r\n\r\n    // Main loop\r\n    let result = runner::run_event_loop(&mut terminal, &mut app, &mut engine);\r\n\r\n    // Restore terminal\r\n    disable_raw_mode().map_err(|e| e.to_string())?;\r\n    execute!(\r\n        terminal.backend_mut(),\r\n        LeaveAlternateScreen,\r\n        DisableMouseCapture\r\n    )\r\n    .map_err(|e| e.to_string())?;\r\n    terminal.show_cursor().map_err(|e| e.to_string())?;\r\n\r\n    result\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-tui","src","runner.rs"],"content":"//! TUI event loop runner\n//!\n//! This module contains the main event loop for the TUI application.\n\nuse std::collections::{HashMap, HashSet};\nuse std::io::Stdout;\nuse std::path::Path;\n\nuse ratatui::{backend::CrosstermBackend, Terminal};\n\nuse ofml_lib::ebase::{EBaseReader};\nuse ofml_lib::oap::engine::ConfigurationEngine;\nuse ofml_lib::oap::ocd;\n\nuse ofml_tui::app::{App, CompositeComponent, PackagingInfo, TableInfo, TableRow};\nuse ofml_tui::{ui::render, config_store, Message, Screen};\n\n/// Run the TUI event loop\npub fn run_event_loop(\n    terminal: &mut Terminal<CrosstermBackend<Stdout>>,\n    app: &mut App,\n    engine: &mut ConfigurationEngine,\n) -> Result<(), String> {\n    use crossterm::event::{self, Event, KeyCode};\n    use ofml_lib::oap::catalog::load_smart_catalog;\n    use ofml_lib::oap::families::{FamilyConfiguration, ProductFamily};\n\n    loop {\n        terminal\n            .draw(|f| render(f, app))\n            .map_err(|e| e.to_string())?;\n\n        if let Event::Key(key) = event::read().map_err(|e| e.to_string())? {\n            use crossterm::event::KeyModifiers;\n            let is_ctrl = key.modifiers.contains(KeyModifiers::CONTROL);\n\n            let msg = match key.code {\n                // Undo/Redo with Ctrl+Z / Ctrl+Y\n                KeyCode::Char('z') if is_ctrl && !app.search_active => Some(Message::Undo),\n                KeyCode::Char('y') if is_ctrl && !app.search_active => Some(Message::Redo),\n                KeyCode::Char('u') if !app.search_active => Some(Message::Undo), // vim-style undo\n                KeyCode::Char('q') if !app.search_active => Some(Message::Quit),\n                KeyCode::Char('?') if !app.search_active => Some(Message::ShowHelp),\n                KeyCode::F(12) => Some(Message::ToggleDebug),\n                KeyCode::Char('/') if !app.search_active => Some(Message::ToggleSearch),\n                KeyCode::Char('e') if !app.search_active => Some(Message::Export),\n                // Geometry export with Ctrl+G (only in FamilyConfig)\n                KeyCode::Char('g') if is_ctrl && !app.search_active && app.screen == Screen::FamilyConfig => {\n                    Some(Message::ExportGeometry)\n                }\n                // Save/Load configuration shortcuts\n                KeyCode::Char('s') if is_ctrl && !app.search_active => Some(Message::SaveConfig),\n                KeyCode::Char('l') if is_ctrl && !app.search_active => Some(Message::LoadConfig),\n                KeyCode::Char('o') if is_ctrl && !app.search_active => Some(Message::LoadConfig),\n                // Toggle favorite\n                KeyCode::Char('f')\n                    if !app.search_active && app.screen == Screen::FamilyConfig =>\n                {\n                    Some(Message::ToggleFavorite)\n                }\n                KeyCode::Char('t') if !app.search_active && app.selected_manufacturer.is_some() => {\n                    // Load tables for current manufacturer\n                    if let Some(ref mfr) = app.selected_manufacturer {\n                        app.status_message = Some(\"Lade Tabellen...\".to_string());\n                        let _ = terminal.draw(|f| render(f, app));\n                        app.tables = load_manufacturer_tables(Path::new(&mfr.path));\n                        app.table_list_state.select(Some(0));\n                        app.status_message = Some(format!(\"{} Tabellen geladen\", app.tables.len()));\n                    }\n                    Some(Message::ShowTables)\n                }\n                KeyCode::Up => Some(Message::NavigateUp),\n                KeyCode::Down => Some(Message::NavigateDown),\n                KeyCode::PageUp => Some(Message::NavigatePageUp),\n                KeyCode::PageDown => Some(Message::NavigatePageDown),\n                KeyCode::Home if !app.search_active => Some(Message::NavigateToTop),\n                KeyCode::End if !app.search_active => Some(Message::NavigateToBottom),\n                KeyCode::Char('g') if !app.search_active => Some(Message::NavigateToTop),\n                KeyCode::Char('G') if !app.search_active => Some(Message::NavigateToBottom),\n                KeyCode::Char('h') if !app.search_active => Some(Message::GoHome),\n                KeyCode::Char('T') if !app.search_active => Some(Message::ToggleTheme),\n                KeyCode::Left if app.screen == Screen::FamilyConfig => {\n                    Some(Message::CyclePropertyOption(-1))\n                }\n                KeyCode::Right if app.screen == Screen::FamilyConfig => {\n                    Some(Message::CyclePropertyOption(1))\n                }\n                KeyCode::Left if app.screen == Screen::TableView => {\n                    Some(Message::ScrollTableHorizontal(-1))\n                }\n                KeyCode::Right if app.screen == Screen::TableView => {\n                    Some(Message::ScrollTableHorizontal(1))\n                }\n                KeyCode::Enter => {\n                    if let Some(idx) = app.get_selected_index() {\n                        match app.screen {\n                            Screen::Manufacturers => {\n                                // Load catalog and product families for the selected manufacturer\n                                if idx < app.manufacturers.len() {\n                                    // Clone manufacturer data to avoid borrow issues\n                                    let manufacturer_id = app.manufacturers[idx].id.clone();\n                                    let manufacturer_name = app.manufacturers[idx].name.clone();\n                                    let manufacturer_path = app.manufacturers[idx].path.clone();\n\n                                    app.status_message =\n                                        Some(format!(\"Lade {}...\", manufacturer_name));\n                                    let _ = terminal.draw(|f| render(f, app));\n\n                                    // Try to load XCF catalog (master or aggregated from series)\n                                    let data_path = Path::new(&app.data_path);\n                                    let catalog = load_smart_catalog(\n                                        data_path,\n                                        &manufacturer_path,\n                                        &manufacturer_id,\n                                        \"de\",\n                                    );\n                                    let has_catalog = catalog.is_some();\n                                    app.set_catalog(catalog);\n\n                                    // Load product families using ConfigurationEngine\n                                    let families = engine.load_families(&manufacturer_id);\n\n                                    let configurable_count =\n                                        families.iter().filter(|f| f.is_configurable).count();\n                                    let with_props_count = families\n                                        .iter()\n                                        .filter(|f| !f.prop_classes.is_empty())\n                                        .count();\n\n                                    app.families = families.to_vec();\n\n                                    // Set status message\n                                    if has_catalog {\n                                        let cat_stats =\n                                            app.catalog.as_ref().map(|c| c.stats()).unwrap_or_else(\n                                                || ofml_lib::oap::catalog::CatalogStats {\n                                                    total_nodes: 0,\n                                                    folder_count: 0,\n                                                    article_count: 0,\n                                                    text_entries: 0,\n                                                    languages: vec![],\n                                                },\n                                            );\n                                        app.status_message = Some(format!(\n                                            \"Katalog: {} Kategorien, {} Artikel\",\n                                            cat_stats.folder_count, cat_stats.article_count\n                                        ));\n                                        // Navigate to catalog view\n                                        app.screen = Screen::Catalog;\n                                    } else {\n                                        app.status_message = Some(format!(\n                                            \"{} Produktfamilien ({} konfigurierbar, {} mit Eigenschaften)\",\n                                            app.families.len(),\n                                            configurable_count,\n                                            with_props_count\n                                        ));\n                                        // Navigate to families view\n                                        app.screen = Screen::Families;\n                                    }\n                                }\n                                Some(Message::SelectManufacturer(idx))\n                            }\n                            Screen::Catalog => {\n                                // Handle catalog selection\n                                if idx < app.catalog_children.len() {\n                                    let node = app.catalog_children[idx].clone();\n                                    match node.node_type {\n                                        ofml_lib::oap::catalog::NodeType::Folder => {\n                                            app.enter_catalog_folder(&node);\n                                            app.status_message = Some(format!(\n                                                \"{} - {} Eintr√§ge\",\n                                                node.name,\n                                                node.children.len()\n                                            ));\n                                        }\n                                        ofml_lib::oap::catalog::NodeType::Article => {\n                                            // Find family matching this article and configure it\n                                            // Use case-insensitive matching and try multiple strategies\n                                            let node_id_upper = node.id.to_uppercase();\n                                            let matching_family = app.families.iter().find(|f| {\n                                                f.article_nrs.iter().any(|nr| {\n                                                    let nr_upper = nr.to_uppercase();\n                                                    // Exact match (case-insensitive)\n                                                    nr_upper == node_id_upper ||\n                                                    // Family article contains catalog node id\n                                                    nr_upper.contains(&node_id_upper) ||\n                                                    // Catalog node id contains family article\n                                                    node_id_upper.contains(&nr_upper)\n                                                })\n                                            });\n\n                                            if let Some(family) = matching_family {\n                                                if let Some(ref manufacturer) =\n                                                    app.selected_manufacturer\n                                                {\n                                                    // Load properties for this family\n                                                    let properties = engine.get_family_properties(\n                                                        &manufacturer.id,\n                                                        &family.id,\n                                                    );\n                                                    app.family_properties = properties.clone();\n                                                    app.selected_family = Some(family.clone());\n\n                                                    // Create configuration\n                                                    let mut config = FamilyConfiguration::new(\n                                                        &family.id,\n                                                        &properties,\n                                                    );\n\n                                                    // Apply variant settings if node has a variant code\n                                                    if let Some(ref variant_code) =\n                                                        node.variant_code\n                                                    {\n                                                        if let Some(ref catalog) = app.catalog {\n                                                            if let Some(variant_def) = catalog\n                                                                .get_variant(&node.id, variant_code)\n                                                            {\n                                                                // Parse and apply property settings\n                                                                // Format: \"PROPERTYCLASS.PROPERTY=VALUE\"\n                                                                for setting in\n                                                                    &variant_def.property_settings\n                                                                {\n                                                                    if let Some(eq_pos) =\n                                                                        setting.rfind('=')\n                                                                    {\n                                                                        let prop_path =\n                                                                            &setting[..eq_pos];\n                                                                        let value =\n                                                                            &setting[eq_pos + 1..];\n                                                                        // Extract property name (after last dot)\n                                                                        if let Some(dot_pos) =\n                                                                            prop_path.rfind('.')\n                                                                        {\n                                                                            let prop_key =\n                                                                                &prop_path\n                                                                                    [dot_pos + 1..];\n                                                                            config.set(\n                                                                                prop_key, value,\n                                                                            );\n                                                                        }\n                                                                    }\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n\n                                                    app.family_config = Some(config.clone());\n\n                                                    // Calculate price\n                                                    app.family_price = engine\n                                                        .calculate_family_price(\n                                                            &manufacturer.id,\n                                                            family,\n                                                            &config,\n                                                            app.price_date,\n                                                        );\n\n                                                    // Load packaging info\n                                                    if let Some(pkg) = engine\n                                                        .get_packaging_for_article(\n                                                            &manufacturer.id,\n                                                            &family.base_article_nr,\n                                                        )\n                                                    {\n                                                        // Convert units to standard cm/kg/m¬≥\n                                                        let (w, d, h) = match pkg\n                                                            .measure_unit\n                                                            .to_lowercase()\n                                                            .as_str()\n                                                        {\n                                                            \"mm\" => (\n                                                                pkg.width / 10.0,\n                                                                pkg.depth / 10.0,\n                                                                pkg.height / 10.0,\n                                                            ),\n                                                            \"m\" => (\n                                                                pkg.width * 100.0,\n                                                                pkg.depth * 100.0,\n                                                                pkg.height * 100.0,\n                                                            ),\n                                                            _ => (pkg.width, pkg.depth, pkg.height),\n                                                        };\n                                                        let weight = match pkg\n                                                            .weight_unit\n                                                            .to_lowercase()\n                                                            .as_str()\n                                                        {\n                                                            \"g\" => pkg.net_weight / 1000.0,\n                                                            _ => pkg.net_weight,\n                                                        };\n                                                        app.packaging_info = Some(PackagingInfo {\n                                                            weight_kg: weight,\n                                                            dimensions_cm: (w, d, h),\n                                                            volume_m3: pkg.volume,\n                                                        });\n                                                    } else {\n                                                        app.packaging_info = None;\n                                                    }\n\n                                                    // Load data version\n                                                    app.data_version =\n                                                        engine.get_data_version(&manufacturer.id);\n\n                                                    // Check data validity\n                                                    app.data_validity_warning = engine\n                                                        .get_data_validity_warning(\n                                                            &manufacturer.id,\n                                                            app.price_date,\n                                                        );\n\n                                                    // Load variant code separator\n                                                    app.varcode_separator =\n                                                        engine.get_varcode_separator(&manufacturer.id);\n\n                                                    // Load composite components if this is a composite product\n                                                    let components = engine.get_composite_components(\n                                                        &manufacturer.id,\n                                                        &family.base_article_nr,\n                                                    );\n                                                    app.composite_components = components\n                                                        .into_iter()\n                                                        .map(|c| CompositeComponent {\n                                                            item_id: c.item_id,\n                                                            position: c.item_pos,\n                                                            quantity: c.quantity,\n                                                            description: String::new(),\n                                                        })\n                                                        .collect();\n\n                                                    app.screen = Screen::FamilyConfig;\n\n                                                    // Track in history\n                                                    let _ = config_store::add_to_history(\n                                                        &manufacturer.id,\n                                                        &family.id,\n                                                        &family.base_article_nr,\n                                                        &family.name,\n                                                    );\n\n                                                    let price_str = app\n                                                        .family_price\n                                                        .as_ref()\n                                                        .map(|p| {\n                                                            format!(\n                                                                \"{:.2} {}\",\n                                                                p.base_price, p.currency\n                                                            )\n                                                        })\n                                                        .unwrap_or_else(|| \"Preis n/a\".to_string());\n                                                    app.status_message = Some(format!(\n                                                        \"{} - {}\",\n                                                        family.name, price_str\n                                                    ));\n                                                }\n                                            } else {\n                                                // No matching family found - try to create a minimal family from the catalog node\n                                                // This allows viewing articles that aren't in the family list\n                                                if let Some(ref manufacturer) =\n                                                    app.selected_manufacturer\n                                                {\n                                                    // Get series from catalog node or path\n                                                    let series = node\n                                                        .series_ref\n                                                        .clone()\n                                                        .or_else(|| {\n                                                            // Try to extract series from breadcrumb\n                                                            app.catalog_path\n                                                                .first()\n                                                                .map(|s| s.id.to_lowercase())\n                                                        })\n                                                        .unwrap_or_else(|| node.id.clone());\n\n                                                    // Create a minimal family for this article\n                                                    let minimal_family = ProductFamily {\n                                                        id: node.id.clone(),\n                                                        name: node.name.clone(),\n                                                        description: node.name.clone(),\n                                                        long_description: String::new(),\n                                                        series: series.clone(),\n                                                        base_article_nr: node.id.clone(),\n                                                        prop_classes: vec![],\n                                                        variant_count: 1,\n                                                        is_configurable: false,\n                                                        article_nrs: vec![node.id.clone()],\n                                                        article_descriptions: vec![node\n                                                            .name\n                                                            .clone()],\n                                                        article_long_descriptions: vec![],\n                                                    };\n\n                                                    // Try to load properties using the series\n                                                    let properties = engine.get_family_properties(\n                                                        &manufacturer.id,\n                                                        &series,\n                                                    );\n                                                    app.family_properties = properties.clone();\n                                                    app.selected_family =\n                                                        Some(minimal_family.clone());\n\n                                                    // Create configuration\n                                                    let config = FamilyConfiguration::new(\n                                                        &minimal_family.id,\n                                                        &properties,\n                                                    );\n                                                    app.family_config = Some(config.clone());\n\n                                                    // Calculate price\n                                                    app.family_price = engine\n                                                        .calculate_family_price(\n                                                            &manufacturer.id,\n                                                            &minimal_family,\n                                                            &config,\n                                                            app.price_date,\n                                                        );\n\n                                                    // Load packaging info\n                                                    if let Some(pkg) = engine\n                                                        .get_packaging_for_article(\n                                                            &manufacturer.id,\n                                                            &node.id,\n                                                        )\n                                                    {\n                                                        let (w, d, h) = match pkg\n                                                            .measure_unit\n                                                            .to_lowercase()\n                                                            .as_str()\n                                                        {\n                                                            \"mm\" => (\n                                                                pkg.width / 10.0,\n                                                                pkg.depth / 10.0,\n                                                                pkg.height / 10.0,\n                                                            ),\n                                                            \"m\" => (\n                                                                pkg.width * 100.0,\n                                                                pkg.depth * 100.0,\n                                                                pkg.height * 100.0,\n                                                            ),\n                                                            _ => (pkg.width, pkg.depth, pkg.height),\n                                                        };\n                                                        let weight = match pkg\n                                                            .weight_unit\n                                                            .to_lowercase()\n                                                            .as_str()\n                                                        {\n                                                            \"g\" => pkg.net_weight / 1000.0,\n                                                            _ => pkg.net_weight,\n                                                        };\n                                                        app.packaging_info = Some(PackagingInfo {\n                                                            weight_kg: weight,\n                                                            dimensions_cm: (w, d, h),\n                                                            volume_m3: pkg.volume,\n                                                        });\n                                                    } else {\n                                                        app.packaging_info = None;\n                                                    }\n\n                                                    // Load data version\n                                                    app.data_version =\n                                                        engine.get_data_version(&manufacturer.id);\n\n                                                    // Check data validity\n                                                    app.data_validity_warning = engine\n                                                        .get_data_validity_warning(\n                                                            &manufacturer.id,\n                                                            app.price_date,\n                                                        );\n\n                                                    // Load variant code separator\n                                                    app.varcode_separator =\n                                                        engine.get_varcode_separator(&manufacturer.id);\n\n                                                    // Load composite components\n                                                    let components = engine.get_composite_components(\n                                                        &manufacturer.id,\n                                                        &node.id,\n                                                    );\n                                                    app.composite_components = components\n                                                        .into_iter()\n                                                        .map(|c| CompositeComponent {\n                                                            item_id: c.item_id,\n                                                            position: c.item_pos,\n                                                            quantity: c.quantity,\n                                                            description: String::new(),\n                                                        })\n                                                        .collect();\n\n                                                    app.screen = Screen::FamilyConfig;\n\n                                                    // Track in history\n                                                    let _ = config_store::add_to_history(\n                                                        &manufacturer.id,\n                                                        &minimal_family.id,\n                                                        &minimal_family.base_article_nr,\n                                                        &node.name,\n                                                    );\n\n                                                    let price_str = app\n                                                        .family_price\n                                                        .as_ref()\n                                                        .map(|p| {\n                                                            format!(\n                                                                \"{:.2} {}\",\n                                                                p.base_price, p.currency\n                                                            )\n                                                        })\n                                                        .unwrap_or_else(|| \"Preis n/a\".to_string());\n                                                    app.status_message = Some(format!(\n                                                        \"{} - {}\",\n                                                        node.name, price_str\n                                                    ));\n                                                }\n                                            }\n                                        }\n                                        _ => {}\n                                    }\n                                }\n                                Some(Message::SelectCatalogNode(idx))\n                            }\n                            Screen::Families => {\n                                // Load properties for the selected product family\n                                if idx < app.families.len() {\n                                    let family = &app.families[idx];\n\n                                    if let Some(ref manufacturer) = app.selected_manufacturer {\n                                        app.status_message =\n                                            Some(format!(\"Lade {}...\", family.name));\n                                        let _ = terminal.draw(|f| render(f, app));\n\n                                        // Load family properties\n                                        let properties = engine\n                                            .get_family_properties(&manufacturer.id, &family.id);\n                                        app.family_properties = properties.clone();\n\n                                        // Create configuration with default values\n                                        let config =\n                                            FamilyConfiguration::new(&family.id, &properties);\n                                        app.family_config = Some(config.clone());\n\n                                        // Calculate initial price\n                                        app.family_price = engine.calculate_family_price(\n                                            &manufacturer.id,\n                                            family,\n                                            &config,\n                                            app.price_date,\n                                        );\n\n                                        // Load packaging info\n                                        if let Some(pkg) = engine.get_packaging_for_article(\n                                            &manufacturer.id,\n                                            &family.base_article_nr,\n                                        ) {\n                                            // Convert units to standard cm/kg/m¬≥\n                                            let (w, d, h) = match pkg\n                                                .measure_unit\n                                                .to_lowercase()\n                                                .as_str()\n                                            {\n                                                \"mm\" => (\n                                                    pkg.width / 10.0,\n                                                    pkg.depth / 10.0,\n                                                    pkg.height / 10.0,\n                                                ),\n                                                \"m\" => (\n                                                    pkg.width * 100.0,\n                                                    pkg.depth * 100.0,\n                                                    pkg.height * 100.0,\n                                                ),\n                                                _ => (pkg.width, pkg.depth, pkg.height),\n                                            };\n                                            let weight = match pkg\n                                                .weight_unit\n                                                .to_lowercase()\n                                                .as_str()\n                                            {\n                                                \"g\" => pkg.net_weight / 1000.0,\n                                                _ => pkg.net_weight,\n                                            };\n                                            app.packaging_info = Some(PackagingInfo {\n                                                weight_kg: weight,\n                                                dimensions_cm: (w, d, h),\n                                                volume_m3: pkg.volume,\n                                            });\n                                        } else {\n                                            app.packaging_info = None;\n                                        }\n\n                                        // Load data version\n                                        app.data_version =\n                                            engine.get_data_version(&manufacturer.id);\n\n                                        // Check data validity\n                                        app.data_validity_warning = engine\n                                            .get_data_validity_warning(&manufacturer.id, app.price_date);\n\n                                        // Load variant code separator\n                                        app.varcode_separator =\n                                            engine.get_varcode_separator(&manufacturer.id);\n\n                                        // Load composite components\n                                        let components = engine.get_composite_components(\n                                            &manufacturer.id,\n                                            &family.base_article_nr,\n                                        );\n                                        app.composite_components = components\n                                            .into_iter()\n                                            .map(|c| CompositeComponent {\n                                                item_id: c.item_id,\n                                                position: c.item_pos,\n                                                quantity: c.quantity,\n                                                description: String::new(),\n                                            })\n                                            .collect();\n\n                                        let price_str = app\n                                            .family_price\n                                            .as_ref()\n                                            .map(|p| format!(\"{:.2} {}\", p.base_price, p.currency))\n                                            .unwrap_or_else(|| \"Preis n/a\".to_string());\n\n                                        // Track in history\n                                        let _ = config_store::add_to_history(\n                                            &manufacturer.id,\n                                            &family.id,\n                                            &family.base_article_nr,\n                                            &family.name,\n                                        );\n\n                                        app.status_message = Some(format!(\n                                            \"{} Eigenschaften, {}\",\n                                            app.family_properties.len(),\n                                            price_str\n                                        ));\n                                    }\n                                }\n                                Some(Message::SelectFamily(idx))\n                            }\n                            Screen::FamilyConfig => {\n                                // Handle Enter in FamilyConfig when no properties (select article)\n                                if app.family_properties.is_empty() {\n                                    // Extract data first to avoid borrow issues\n                                    let article_data = app.selected_family.as_ref().and_then(|f| {\n                                        let idx = app.focused_article_index;\n                                        f.article_nrs.get(idx).map(|nr| {\n                                            let mut selected = f.clone();\n                                            selected.base_article_nr = nr.clone();\n                                            (nr.clone(), selected)\n                                        })\n                                    });\n\n                                    if let Some((article_nr, selected_family)) = article_data {\n                                        if let Some(ref manufacturer) = app.selected_manufacturer {\n                                            // Recalculate price for the selected article\n                                            if let Some(ref config) = app.family_config {\n                                                app.family_price = engine.calculate_family_price(\n                                                    &manufacturer.id,\n                                                    &selected_family,\n                                                    config,\n                                                    app.price_date,\n                                                );\n                                            }\n\n                                            // Update the selected family to reflect the chosen article\n                                            app.selected_family = Some(selected_family);\n\n                                            let price_str = app\n                                                .family_price\n                                                .as_ref()\n                                                .map(|p| {\n                                                    format!(\"{:.2} {}\", p.base_price, p.currency)\n                                                })\n                                                .unwrap_or_else(|| \"Preis n/a\".to_string());\n\n                                            app.status_message = Some(format!(\n                                                \"Artikel {} ausgew√§hlt - {}\",\n                                                article_nr, price_str\n                                            ));\n                                        }\n                                    }\n                                }\n                                None\n                            }\n                            Screen::Articles => {\n                                // Load configuration for the selected article (legacy mode)\n                                if idx < app.articles.len() {\n                                    let article = &app.articles[idx];\n\n                                    if let Some(ref manufacturer) = app.selected_manufacturer {\n                                        app.status_message =\n                                            Some(format!(\"Lade {}...\", article.short_description));\n                                        let _ = terminal.draw(|f| render(f, app));\n\n                                        // Always look up base price from OCD first\n                                        let pdata_files = ocd::find_pdata_files(Path::new(&manufacturer.path));\n                                        let mut found_price = None;\n\n                                        for pdata_path in &pdata_files {\n                                            if let Ok(reader) =\n                                                ocd::OcdReader::from_ebase(pdata_path)\n                                            {\n                                                if let Some(ocd_price) =\n                                                    reader.get_base_price(&article.id)\n                                                {\n                                                    use chrono::NaiveDate;\n                                                    use rust_decimal::Decimal;\n\n                                                    let base_price =\n                                                        Decimal::from_f32_retain(ocd_price.price)\n                                                            .unwrap_or(Decimal::ZERO);\n\n                                                    let price_date = NaiveDate::parse_from_str(\n                                                        &ocd_price.date_from,\n                                                        \"%Y%m%d\",\n                                                    )\n                                                    .unwrap_or(app.price_date);\n                                                    let valid_to = NaiveDate::parse_from_str(\n                                                        &ocd_price.date_to,\n                                                        \"%Y%m%d\",\n                                                    )\n                                                    .ok();\n\n                                                    found_price = Some(\n                                                        ofml_lib::oap::PriceResult::new(\n                                                            base_price,\n                                                            vec![],\n                                                            ocd_price.currency.clone(),\n                                                            app.price_date,\n                                                            price_date,\n                                                            valid_to,\n                                                        ),\n                                                    );\n                                                    break;\n                                                }\n                                            }\n                                        }\n\n                                        // Create base configuration\n                                        let mut config =\n                                            ofml_lib::oap::config::Configuration::new(\n                                                article.id.clone(),\n                                                manufacturer.id.clone(),\n                                            );\n                                        config.article_number =\n                                            Some(article.base_article_number.clone());\n                                        config.price = found_price;\n\n                                        // Try to load CLS properties if configurable\n                                        let status_msg = if article.has_configuration {\n                                            match engine\n                                                .load_configuration(&manufacturer.id, &article.id)\n                                            {\n                                                Ok(loaded_config) => {\n                                                    // Merge properties from CLS\n                                                    config.properties = loaded_config.properties;\n                                                    let prop_count =\n                                                        config.properties.definitions.len();\n\n                                                    let price_str = config\n                                                        .price\n                                                        .as_ref()\n                                                        .map(|p| {\n                                                            format!(\n                                                                \"{:.2} {}\",\n                                                                p.base_price, p.currency\n                                                            )\n                                                        })\n                                                        .unwrap_or_else(|| \"Preis n/a\".to_string());\n\n                                                    if prop_count > 0 {\n                                                        format!(\n                                                            \"{} Eigenschaften, {}\",\n                                                            prop_count, price_str\n                                                        )\n                                                    } else {\n                                                        format!(\n                                                            \"Keine Eigenschaften, {}\",\n                                                            price_str\n                                                        )\n                                                    }\n                                                }\n                                                Err(_) => {\n                                                    let price_str = config\n                                                        .price\n                                                        .as_ref()\n                                                        .map(|p| {\n                                                            format!(\n                                                                \"{:.2} {}\",\n                                                                p.base_price, p.currency\n                                                            )\n                                                        })\n                                                        .unwrap_or_else(|| \"Preis n/a\".to_string());\n                                                    format!(\"CLS nicht geladen, {}\", price_str)\n                                                }\n                                            }\n                                        } else {\n                                            let price_str = config\n                                                .price\n                                                .as_ref()\n                                                .map(|p| {\n                                                    format!(\"{:.2} {}\", p.base_price, p.currency)\n                                                })\n                                                .unwrap_or_else(|| {\n                                                    \"Preis nicht verf√ºgbar\".to_string()\n                                                });\n                                            format!(\"Nicht konfigurierbar, {}\", price_str)\n                                        };\n\n                                        app.status_message = Some(status_msg);\n                                        app.configuration = Some(config);\n                                    }\n                                }\n                                Some(Message::SelectArticle(idx))\n                            }\n                            Screen::Tables => {\n                                // Load table contents for selected table\n                                if idx < app.tables.len() {\n                                    let table_info = app.tables[idx].clone();\n                                    app.status_message =\n                                        Some(format!(\"Lade Tabelle {}...\", table_info.name));\n                                    let _ = terminal.draw(|f| render(f, app));\n\n                                    // Load table rows\n                                    app.table_rows =\n                                        load_table_rows(&table_info.source_path, &table_info.name);\n                                    app.table_row_list_state.select(Some(0));\n                                    app.table_scroll_x = 0;\n                                    app.status_message =\n                                        Some(format!(\"{} Zeilen geladen\", app.table_rows.len()));\n                                }\n                                Some(Message::SelectTable(idx))\n                            }\n                            Screen::SavedConfigs => {\n                                // Load selected saved configuration\n                                if idx < app.saved_configs.len() {\n                                    let (_, saved_config) = &app.saved_configs[idx];\n                                    let manufacturer = saved_config.manufacturer.clone();\n                                    let series = saved_config.series.clone();\n                                    let saved_properties = saved_config.properties.clone();\n\n                                    // Find and load the manufacturer\n                                    if let Some(mfr_idx) = app\n                                        .manufacturers\n                                        .iter()\n                                        .position(|m| m.id == manufacturer)\n                                    {\n                                        let mfr = app.manufacturers[mfr_idx].clone();\n                                        app.selected_manufacturer = Some(mfr.clone());\n\n                                        // Load families\n                                        let families = engine.load_families(&manufacturer);\n                                        app.families = families.to_vec();\n\n                                        // Find the matching family\n                                        if let Some(family) = app\n                                            .families\n                                            .iter()\n                                            .find(|f| f.id == series)\n                                            .cloned()\n                                        {\n                                            app.selected_family = Some(family.clone());\n\n                                            // Get family properties\n                                            let properties =\n                                                engine.get_family_properties(&manufacturer, &family.id);\n                                            app.family_properties = properties.clone();\n\n                                            // Create configuration with saved property values\n                                            let mut fam_config =\n                                                FamilyConfiguration::new(&family.id, &properties);\n\n                                            // Apply saved property values\n                                            for (key, value) in saved_properties {\n                                                fam_config.set(&key, &value);\n                                            }\n\n                                            // Calculate price\n                                            app.family_price = engine.calculate_family_price(\n                                                &manufacturer,\n                                                &family,\n                                                &fam_config,\n                                                app.price_date,\n                                            );\n                                            app.family_config = Some(fam_config);\n\n                                            app.screen = Screen::FamilyConfig;\n\n                                            // Track in history\n                                            let _ = config_store::add_to_history(\n                                                &manufacturer,\n                                                &family.id,\n                                                &family.base_article_nr,\n                                                &family.name,\n                                            );\n\n                                            app.status_message =\n                                                Some(\"Konfiguration geladen\".to_string());\n                                        } else {\n                                            app.status_message =\n                                                Some(\"Produktfamilie nicht gefunden\".to_string());\n                                        }\n                                    } else {\n                                        app.status_message =\n                                            Some(\"Hersteller nicht gefunden\".to_string());\n                                    }\n                                }\n                                Some(Message::SelectSavedConfig(idx))\n                            }\n                            _ => None,\n                        }\n                    } else {\n                        None\n                    }\n                }\n                KeyCode::Esc => {\n                    if app.search_active {\n                        Some(Message::ToggleSearch)\n                    } else {\n                        Some(Message::GoBack)\n                    }\n                }\n                KeyCode::Char(c) if app.search_active => {\n                    let mut query = app.search_query.clone();\n                    query.push(c);\n                    Some(Message::UpdateSearch(query))\n                }\n                KeyCode::Backspace if app.search_active => {\n                    let mut query = app.search_query.clone();\n                    query.pop();\n                    Some(Message::UpdateSearch(query))\n                }\n                _ => None,\n            };\n\n            if let Some(m) = msg {\n                app.update(m.clone());\n\n                // Handle geometry export\n                if matches!(m, Message::ExportGeometry) {\n                    if let (Some(ref manufacturer), Some(ref family)) = (\n                        &app.selected_manufacturer,\n                        &app.selected_family,\n                    ) {\n                        app.status_message = Some(\"Exportiere Geometrie...\".to_string());\n                        let _ = terminal.draw(|f| render(f, app));\n\n                        match export_family_geometry(Path::new(&manufacturer.path), &family.id, &family.base_article_nr) {\n                            Ok(path) => {\n                                app.status_message = Some(format!(\n                                    \"GLB exportiert: {}\",\n                                    path.file_name()\n                                        .and_then(|s| s.to_str())\n                                        .unwrap_or(\"export.glb\")\n                                ));\n                            }\n                            Err(e) => {\n                                app.status_message = Some(format!(\"Export fehlgeschlagen: {}\", e));\n                            }\n                        }\n                    } else {\n                        app.status_message = Some(\"Keine Familie ausgew√§hlt\".to_string());\n                    }\n                }\n\n                // Handle price recalculation and property dependency updates on property change\n                if matches!(m, Message::CyclePropertyOption(_)) {\n                    if let (Some(ref manufacturer), Some(ref family), Some(ref config)) = (\n                        &app.selected_manufacturer,\n                        &app.selected_family,\n                        &app.family_config,\n                    ) {\n                        // Refresh properties with current selections to update TABLE-dependent options\n                        let updated_properties = engine.get_family_properties_with_selections(\n                            &manufacturer.id,\n                            &family.id,\n                            &config.selections,\n                        );\n                        app.family_properties = updated_properties;\n\n                        // Recalculate price\n                        app.family_price = engine.calculate_family_price(\n                            &manufacturer.id,\n                            family,\n                            config,\n                            app.price_date,\n                        );\n                    }\n                }\n            }\n        }\n\n        if app.should_quit {\n            break;\n        }\n    }\n\n    Ok(())\n}\n\n/// Export geometry for a product family to a GLB file\n\n/// Load all tables from manufacturer's pdata.ebase files\npub fn load_manufacturer_tables(manufacturer_path: &Path) -> Vec<TableInfo> {\n    let mut all_tables: HashMap<String, TableInfo> = HashMap::new();\n\n    let standard_tables: HashSet<&str> = [\n        \"ocd_article\", \"ocd_articletext\", \"ocd_artshorttext\", \"ocd_artlongtext\",\n        \"ocd_price\", \"ocd_pricetext\", \"ocd_property\", \"ocd_propertyclass\",\n        \"ocd_propertyvalue\", \"ocd_propertyvaluetext\", \"ocd_propvaluetext\",\n        \"ocd_variantcondition\", \"ocd_relation\", \"ocd_relationobj\",\n        \"ocd_propertygroup\", \"ocd_article2propgroup\", \"ocd_composite\",\n        \"ocd_billofitems\", \"propvalue2varcond\",\n    ].into_iter().collect();\n\n    fn find_ebase_files(path: &Path, files: &mut Vec<std::path::PathBuf>) {\n        if let Ok(entries) = std::fs::read_dir(path) {\n            for entry in entries.flatten() {\n                let p = entry.path();\n                if p.is_dir() {\n                    find_ebase_files(&p, files);\n                } else if p.file_name().is_some_and(|n| n == \"pdata.ebase\") {\n                    files.push(p);\n                }\n            }\n        }\n    }\n\n    let mut ebase_files = Vec::new();\n    find_ebase_files(manufacturer_path, &mut ebase_files);\n\n    for ebase_path in ebase_files {\n        if let Ok(reader) = EBaseReader::open(&ebase_path) {\n            for table_name in reader.table_names() {\n                if all_tables.contains_key(table_name) {\n                    continue;\n                }\n\n                let is_standard = standard_tables.contains(table_name);\n                let row_count = reader\n                    .get_table(table_name)\n                    .map(|t| t.record_count as usize)\n                    .unwrap_or(0);\n                let columns: Vec<String> = reader\n                    .get_table(table_name)\n                    .map(|t| t.columns.iter().map(|c| c.name.clone()).collect())\n                    .unwrap_or_default();\n\n                all_tables.insert(\n                    table_name.to_string(),\n                    TableInfo {\n                        name: table_name.to_string(),\n                        row_count,\n                        columns,\n                        is_standard,\n                        source_path: ebase_path.to_string_lossy().to_string(),\n                    },\n                );\n            }\n        }\n    }\n\n    let mut result: Vec<TableInfo> = all_tables.into_values().collect();\n    result.sort_by(|a, b| match (a.is_standard, b.is_standard) {\n        (false, true) => std::cmp::Ordering::Less,\n        (true, false) => std::cmp::Ordering::Greater,\n        _ => a.name.cmp(&b.name),\n    });\n\n    result\n}\n\n/// Load rows from a specific table\npub fn load_table_rows(ebase_path: &str, table_name: &str) -> Vec<TableRow> {\n\n    let mut rows = Vec::new();\n    let path = Path::new(ebase_path);\n\n    if let Ok(mut reader) = EBaseReader::open(path) {\n        let columns: Vec<String> = reader\n            .get_table(table_name)\n            .map(|t| t.columns.iter().map(|c| c.name.clone()).collect())\n            .unwrap_or_default();\n\n        if let Ok(records) = reader.read_records(table_name, Some(500)) {\n            for record in records.iter() {\n                let values: Vec<String> = columns\n                    .iter()\n                    .map(|col| {\n                        record\n                            .get(col.as_str())\n                            .map(value_to_string)\n                            .unwrap_or_default()\n                    })\n                    .collect();\n                rows.push(TableRow { values });\n            }\n        }\n    }\n\n    rows\n}\n\nfn value_to_string(v: &ofml_lib::ebase::Value) -> String {\n    use ofml_lib::ebase::Value;\n    match v {\n        Value::Int(i) => i.to_string(),\n        Value::UInt(u) => u.to_string(),\n        Value::Float(f) => format!(\"{:.4}\", f),\n        Value::String(s) => s.clone(),\n        Value::Blob(id) => format!(\"[blob:{}]\", id),\n        Value::Null => String::new(),\n    }\n}\n\n/// Export family geometry to GLB file\npub fn export_family_geometry(\n    manufacturer_path: &Path,\n    series_id: &str,\n    article_nr: &str,\n) -> Result<std::path::PathBuf, String> {\n    use ofml_lib::operations::{assemble_product, export_to_glb, ProductConfig};\n\n    let series_path = manufacturer_path.join(series_id);\n    if !series_path.exists() {\n        return Err(format!(\"Series directory not found: {}\", series_id));\n    }\n\n    let product_path = find_product_path(&series_path)?;\n\n    let config = ProductConfig {\n        article: Some(article_nr.to_string()),\n        properties: std::collections::HashMap::new(),\n    };\n\n    let result = assemble_product(&product_path, &config)\n        .map_err(|e| format!(\"Geometry assembly failed: {}\", e))?;\n\n    if result.geometry_loaded == 0 {\n        return Err(\"No geometry found\".to_string());\n    }\n\n    let glb_data = export_to_glb(&result.scene)\n        .map_err(|e| format!(\"GLB export failed: {}\", e))?;\n\n    let output_dir = std::env::current_dir().unwrap_or_else(|_| std::path::PathBuf::from(\".\"));\n    let safe_article = article_nr.replace([':', '/', '\\\\'], \"_\");\n    let output_path = output_dir.join(format!(\"{}_{}.glb\", series_id, safe_article));\n\n    std::fs::write(&output_path, glb_data)\n        .map_err(|e| format!(\"Could not write file: {}\", e))?;\n\n    Ok(output_path)\n}\n\nfn find_product_path(series_path: &Path) -> Result<std::path::PathBuf, String> {\n    let candidates = [\n        series_path.join(\"DE/1\"),\n        series_path.join(\"1\"),\n        series_path.to_path_buf(),\n    ];\n\n    for candidate in &candidates {\n        if candidate.join(\"db/odb.ebase\").exists() || has_alb_files(candidate) {\n            return Ok(candidate.clone());\n        }\n    }\n\n    Ok(series_path.to_path_buf())\n}\n\nfn has_alb_files(path: &Path) -> bool {\n    if let Ok(entries) = std::fs::read_dir(path) {\n        for entry in entries.flatten() {\n            if let Some(ext) = entry.path().extension() {\n                if ext.to_string_lossy().to_lowercase() == \"alb\" {\n                    return true;\n                }\n            }\n        }\n    }\n    false\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-tui","src","theme.rs"],"content":"//! Theme support for TUI\r\n//!\r\n//! Provides Light and Dark themes for the configurator interface.\r\n\r\nuse ratatui::style::{Color, Style};\r\n\r\n/// Theme variant\r\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]\r\npub enum ThemeVariant {\r\n    #[default]\r\n    Dark,\r\n    Light,\r\n}\r\n\r\nimpl ThemeVariant {\r\n    /// Toggle between light and dark\r\n    pub fn toggle(self) -> Self {\r\n        match self {\r\n            ThemeVariant::Dark => ThemeVariant::Light,\r\n            ThemeVariant::Light => ThemeVariant::Dark,\r\n        }\r\n    }\r\n\r\n    /// Get the theme for this variant\r\n    pub fn theme(self) -> Theme {\r\n        match self {\r\n            ThemeVariant::Dark => Theme::dark(),\r\n            ThemeVariant::Light => Theme::light(),\r\n        }\r\n    }\r\n}\r\n\r\n/// Color theme for the TUI\r\n#[derive(Debug, Clone)]\r\npub struct Theme {\r\n    // Base colors\r\n    pub background: Color,\r\n    pub foreground: Color,\r\n    pub muted: Color,\r\n    pub border: Color,\r\n\r\n    // Selection/highlight\r\n    pub selection_bg: Color,\r\n    pub selection_fg: Color,\r\n\r\n    // Status colors\r\n    pub success: Color,\r\n    pub warning: Color,\r\n    pub error: Color,\r\n    pub info: Color,\r\n\r\n    // Accent colors\r\n    pub accent: Color,\r\n    pub accent_secondary: Color,\r\n\r\n    // List items\r\n    pub list_active: Color,\r\n    pub list_inactive: Color,\r\n\r\n    // Title bar\r\n    pub title_bg: Color,\r\n    pub title_fg: Color,\r\n\r\n    // Search bar\r\n    pub search_bg: Color,\r\n    pub search_fg: Color,\r\n}\r\n\r\nimpl Default for Theme {\r\n    fn default() -> Self {\r\n        Self::dark()\r\n    }\r\n}\r\n\r\nimpl Theme {\r\n    /// Dark theme (default)\r\n    pub fn dark() -> Self {\r\n        Theme {\r\n            // Base colors\r\n            background: Color::Reset,\r\n            foreground: Color::White,\r\n            muted: Color::Gray,\r\n            border: Color::DarkGray,\r\n\r\n            // Selection/highlight\r\n            selection_bg: Color::Blue,\r\n            selection_fg: Color::White,\r\n\r\n            // Status colors\r\n            success: Color::Green,\r\n            warning: Color::Yellow,\r\n            error: Color::Red,\r\n            info: Color::Cyan,\r\n\r\n            // Accent colors\r\n            accent: Color::Cyan,\r\n            accent_secondary: Color::Magenta,\r\n\r\n            // List items\r\n            list_active: Color::Green,\r\n            list_inactive: Color::DarkGray,\r\n\r\n            // Title bar\r\n            title_bg: Color::Blue,\r\n            title_fg: Color::White,\r\n\r\n            // Search bar\r\n            search_bg: Color::Blue,\r\n            search_fg: Color::White,\r\n        }\r\n    }\r\n\r\n    /// Light theme\r\n    pub fn light() -> Self {\r\n        Theme {\r\n            // Base colors\r\n            background: Color::White,\r\n            foreground: Color::Black,\r\n            muted: Color::DarkGray,\r\n            border: Color::Gray,\r\n\r\n            // Selection/highlight\r\n            selection_bg: Color::Blue,\r\n            selection_fg: Color::White,\r\n\r\n            // Status colors\r\n            success: Color::Green,\r\n            warning: Color::Rgb(200, 150, 0), // Darker yellow for visibility\r\n            error: Color::Red,\r\n            info: Color::Blue,\r\n\r\n            // Accent colors\r\n            accent: Color::Blue,\r\n            accent_secondary: Color::Magenta,\r\n\r\n            // List items\r\n            list_active: Color::Green,\r\n            list_inactive: Color::Gray,\r\n\r\n            // Title bar\r\n            title_bg: Color::Blue,\r\n            title_fg: Color::White,\r\n\r\n            // Search bar\r\n            search_bg: Color::Blue,\r\n            search_fg: Color::White,\r\n        }\r\n    }\r\n\r\n    // Helper methods for common styles\r\n\r\n    /// Default text style\r\n    pub fn text(&self) -> Style {\r\n        Style::default().fg(self.foreground)\r\n    }\r\n\r\n    /// Muted text style\r\n    pub fn text_muted(&self) -> Style {\r\n        Style::default().fg(self.muted)\r\n    }\r\n\r\n    /// Border style\r\n    pub fn border_style(&self) -> Style {\r\n        Style::default().fg(self.border)\r\n    }\r\n\r\n    /// Selection/highlight style\r\n    pub fn selection(&self) -> Style {\r\n        Style::default().bg(self.selection_bg).fg(self.selection_fg)\r\n    }\r\n\r\n    /// Success text style\r\n    pub fn text_success(&self) -> Style {\r\n        Style::default().fg(self.success)\r\n    }\r\n\r\n    /// Warning text style\r\n    pub fn text_warning(&self) -> Style {\r\n        Style::default().fg(self.warning)\r\n    }\r\n\r\n    /// Error text style\r\n    pub fn text_error(&self) -> Style {\r\n        Style::default().fg(self.error)\r\n    }\r\n\r\n    /// Info text style\r\n    pub fn text_info(&self) -> Style {\r\n        Style::default().fg(self.info)\r\n    }\r\n\r\n    /// Accent text style\r\n    pub fn text_accent(&self) -> Style {\r\n        Style::default().fg(self.accent)\r\n    }\r\n\r\n    /// Title bar style\r\n    pub fn title(&self) -> Style {\r\n        Style::default().bg(self.title_bg).fg(self.title_fg)\r\n    }\r\n\r\n    /// Search bar style\r\n    pub fn search(&self) -> Style {\r\n        Style::default().bg(self.search_bg).fg(self.search_fg)\r\n    }\r\n\r\n    /// Active list item indicator style\r\n    pub fn list_active_style(&self) -> Style {\r\n        Style::default().fg(self.list_active)\r\n    }\r\n\r\n    /// Inactive list item indicator style\r\n    pub fn list_inactive_style(&self) -> Style {\r\n        Style::default().fg(self.list_inactive)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_theme_toggle() {\r\n        let variant = ThemeVariant::Dark;\r\n        assert_eq!(variant.toggle(), ThemeVariant::Light);\r\n        assert_eq!(variant.toggle().toggle(), ThemeVariant::Dark);\r\n    }\r\n\r\n    #[test]\r\n    fn test_dark_theme_colors() {\r\n        let theme = Theme::dark();\r\n        assert_eq!(theme.foreground, Color::White);\r\n        assert_eq!(theme.selection_bg, Color::Blue);\r\n    }\r\n\r\n    #[test]\r\n    fn test_light_theme_colors() {\r\n        let theme = Theme::light();\r\n        assert_eq!(theme.foreground, Color::Black);\r\n        assert_eq!(theme.background, Color::White);\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-tui","src","ui.rs"],"content":"//! TUI rendering functions\n//!\n//! This module contains the main render loop and layout logic for the TUI.\n\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect},\n    style::{Color, Modifier, Style},\n    text::{Line, Span},\n    widgets::{Block, Borders, List, ListItem, Paragraph},\n    Frame,\n};\n\n\nuse super::app::{App, Screen};\n\nuse super::views::{\n    articles, catalog, families, family_config, help, manufacturers, properties, tables,\n};\n\n/// Main render function that dispatches to the appropriate view\n\npub fn render(frame: &mut Frame, app: &App) {\n    let theme = app.theme();\n\n    // Set background for light theme\n    if app.theme_variant == super::theme::ThemeVariant::Light {\n        let background = Block::default().style(Style::default().bg(theme.background));\n        frame.render_widget(background, frame.area());\n    }\n\n    let chunks = Layout::default()\n        .direction(Direction::Vertical)\n        .constraints([\n            Constraint::Length(3), // Header\n            Constraint::Min(0),    // Main content\n            Constraint::Length(3), // Footer/help\n        ])\n        .split(frame.area());\n\n    render_header(frame, app, chunks[0]);\n\n    // Split content area for debug panel if enabled\n    let content_area = if app.debug_mode {\n        let debug_chunks = Layout::default()\n            .direction(Direction::Horizontal)\n            .constraints([\n                Constraint::Percentage(65), // Main content\n                Constraint::Percentage(35), // Debug panel\n            ])\n            .split(chunks[1]);\n\n        render_debug_panel(frame, app, debug_chunks[1]);\n        debug_chunks[0]\n    } else {\n        chunks[1]\n    };\n\n    match app.screen {\n        Screen::Manufacturers => manufacturers::render(frame, app, content_area),\n        Screen::Catalog => catalog::render(frame, app, content_area),\n        Screen::Families => families::render(frame, app, content_area),\n        Screen::FamilyConfig => family_config::render(frame, app, content_area),\n        Screen::Articles => articles::render(frame, app, content_area),\n        Screen::Properties => properties::render(frame, app, content_area),\n        Screen::Tables => tables::render_tables(frame, app, content_area),\n        Screen::TableView => tables::render_table_view(frame, app, content_area),\n        Screen::SavedConfigs => render_saved_configs(frame, app, content_area),\n        Screen::Help => help::render(frame, app, content_area),\n    }\n\n    render_footer(frame, app, chunks[2]);\n}\n\n/// Render the debug panel\n\nfn render_debug_panel(frame: &mut Frame, app: &App, area: Rect) {\n    let lines: Vec<Line> = app\n        .debug_log\n        .iter()\n        .take(area.height.saturating_sub(2) as usize)\n        .map(|msg| {\n            // Color code different types of messages\n            let style = if msg.contains(\"Property changed\") {\n                Style::default().fg(Color::Cyan)\n            } else if msg.contains(\"Price:\") {\n                Style::default().fg(Color::Green)\n            } else if msg.contains(\"+ \") {\n                Style::default().fg(Color::Yellow)\n            } else if msg.contains(\"Error\") || msg.contains(\"None\") {\n                Style::default().fg(Color::Red)\n            } else {\n                Style::default().fg(Color::Gray)\n            };\n            Line::from(Span::styled(msg.as_str(), style))\n        })\n        .collect();\n\n    let debug_panel = Paragraph::new(lines)\n        .block(\n            Block::default()\n                .title(\" Debug Console (F12) \")\n                .borders(Borders::ALL)\n                .border_style(Style::default().fg(Color::DarkGray)),\n        )\n        .style(Style::default().fg(Color::Gray));\n\n    frame.render_widget(debug_panel, area);\n}\n\n/// Render the saved configurations list\n\nfn render_saved_configs(frame: &mut Frame, app: &App, area: Rect) {\n    if app.saved_configs.is_empty() {\n        let message = Paragraph::new(\"Keine gespeicherten Konfigurationen gefunden.\\n\\nDr√ºcken Sie Ctrl+S im Konfigurationsbildschirm, um die aktuelle Konfiguration zu speichern.\")\n            .style(Style::default().fg(Color::Gray))\n            .block(\n                Block::default()\n                    .borders(Borders::ALL)\n                    .title(\" Gespeicherte Konfigurationen \"),\n            );\n        frame.render_widget(message, area);\n        return;\n    }\n\n    let items: Vec<ListItem> = app\n        .saved_configs\n        .iter()\n        .enumerate()\n        .map(|(i, (path, config))| {\n            let is_selected = app.saved_configs_list_state.selected() == Some(i);\n            let style = if is_selected {\n                Style::default()\n                    .bg(Color::Blue)\n                    .fg(Color::White)\n                    .add_modifier(Modifier::BOLD)\n            } else {\n                Style::default()\n            };\n\n            // Format the config info\n            let filename = path\n                .file_name()\n                .and_then(|s| s.to_str())\n                .unwrap_or(\"unknown\");\n            let line1 = format!(\n                \"{} - {} ({})\",\n                config.manufacturer.to_uppercase(),\n                config.article_nr,\n                config.variant_code\n            );\n            let line2 = format!(\"  {} | {}\", config.saved_at, filename);\n\n            ListItem::new(vec![\n                Line::from(Span::styled(line1, style)),\n                Line::from(Span::styled(\n                    line2,\n                    if is_selected {\n                        style\n                    } else {\n                        Style::default().fg(Color::DarkGray)\n                    },\n                )),\n            ])\n        })\n        .collect();\n\n    let list = List::new(items)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .title(\" Gespeicherte Konfigurationen \"),\n        )\n        .highlight_style(Style::default().bg(Color::Blue).fg(Color::White));\n\n    frame.render_stateful_widget(list, area, &mut app.saved_configs_list_state.clone());\n}\n\n/// Render the header bar\n\nfn render_header(frame: &mut Frame, app: &App, area: Rect) {\n    let title = match app.screen {\n        Screen::Manufacturers => \"OAP Konfigurator - Hersteller\".to_string(),\n        Screen::Catalog => {\n            if let Some(ref m) = app.selected_manufacturer {\n                format!(\"OAP Konfigurator - {} - Katalog\", m.name)\n            } else {\n                \"OAP Konfigurator - Katalog\".to_string()\n            }\n        }\n        Screen::Families => {\n            if let Some(ref m) = app.selected_manufacturer {\n                format!(\"OAP Konfigurator - {} - Produktfamilien\", m.name)\n            } else {\n                \"OAP Konfigurator - Produktfamilien\".to_string()\n            }\n        }\n        Screen::FamilyConfig => {\n            if let Some(ref f) = app.selected_family {\n                format!(\"OAP Konfigurator - {} - Konfiguration\", f.name)\n            } else {\n                \"OAP Konfigurator - Konfiguration\".to_string()\n            }\n        }\n        Screen::Articles => {\n            if let Some(ref m) = app.selected_manufacturer {\n                format!(\"OAP Konfigurator - {} - Artikel\", m.name)\n            } else {\n                \"OAP Konfigurator - Artikel\".to_string()\n            }\n        }\n        Screen::Properties => {\n            if let Some(ref a) = app.selected_article {\n                format!(\"OAP Konfigurator - {} - Konfiguration\", a.id)\n            } else {\n                \"OAP Konfigurator - Konfiguration\".to_string()\n            }\n        }\n        Screen::Tables => {\n            if let Some(ref m) = app.selected_manufacturer {\n                format!(\"OAP Konfigurator - {} - Tabellen\", m.name)\n            } else {\n                \"OAP Konfigurator - Tabellen\".to_string()\n            }\n        }\n        Screen::TableView => {\n            if let Some(ref t) = app.selected_table {\n                format!(\"OAP Konfigurator - Tabelle: {}\", t.name)\n            } else {\n                \"OAP Konfigurator - Tabelle\".to_string()\n            }\n        }\n        Screen::SavedConfigs => {\n            format!(\n                \"OAP Konfigurator - Gespeicherte Konfigurationen ({} vorhanden)\",\n                app.saved_configs.len()\n            )\n        }\n        Screen::Help => \"OAP Konfigurator - Hilfe\".to_string(),\n    };\n\n    let theme = app.theme();\n    let header = Paragraph::new(title)\n        .style(theme.title())\n        .block(Block::default().borders(Borders::BOTTOM).border_style(theme.border_style()));\n\n    frame.render_widget(header, area);\n}\n\n/// Render the footer with keybindings\n\nfn render_footer(frame: &mut Frame, app: &App, area: Rect) {\n    let chunks = Layout::default()\n        .direction(Direction::Horizontal)\n        .constraints([Constraint::Percentage(70), Constraint::Percentage(30)])\n        .split(area);\n\n    // Keybindings\n    let keybindings = match app.screen {\n        Screen::Manufacturers | Screen::Catalog | Screen::Families | Screen::Articles => {\n            if app.search_active {\n                vec![\n                    Span::raw(\"Esc: \"),\n                    Span::styled(\"Suche beenden\", Style::default().fg(Color::Yellow)),\n                    Span::raw(\" | \"),\n                    Span::raw(\"Enter: \"),\n                    Span::styled(\"Ausw√§hlen\", Style::default().fg(Color::Yellow)),\n                ]\n            } else {\n                vec![\n                    Span::raw(\"‚Üë‚Üì: \"),\n                    Span::styled(\"Navigation\", Style::default().fg(Color::Yellow)),\n                    Span::raw(\" | \"),\n                    Span::raw(\"Enter: \"),\n                    Span::styled(\"Ausw√§hlen\", Style::default().fg(Color::Yellow)),\n                    Span::raw(\" | \"),\n                    Span::raw(\"/: \"),\n                    Span::styled(\"Suchen\", Style::default().fg(Color::Yellow)),\n                    Span::raw(\" | \"),\n                    Span::raw(\"q: \"),\n                    Span::styled(\"Beenden\", Style::default().fg(Color::Yellow)),\n                ]\n            }\n        }\n        Screen::FamilyConfig => vec![\n            Span::raw(\"‚Üë‚Üì: \"),\n            Span::styled(\"Eigenschaft\", Style::default().fg(Color::Yellow)),\n            Span::raw(\" | \"),\n            Span::raw(\"‚Üê‚Üí: \"),\n            Span::styled(\"Wert √§ndern\", Style::default().fg(Color::Yellow)),\n            Span::raw(\" | \"),\n            Span::raw(\"f: \"),\n            Span::styled(\"‚òÖFavorit\", Style::default().fg(Color::Yellow)),\n            Span::raw(\" | \"),\n            Span::raw(\"Ctrl+S: \"),\n            Span::styled(\"Speichern\", Style::default().fg(Color::Yellow)),\n            Span::raw(\" | \"),\n            Span::raw(\"e: \"),\n            Span::styled(\"Export\", Style::default().fg(Color::Yellow)),\n            Span::raw(\" | \"),\n            Span::raw(\"Esc: \"),\n            Span::styled(\"Zur√ºck\", Style::default().fg(Color::Yellow)),\n        ],\n        Screen::Properties => vec![\n            Span::raw(\"‚Üë‚Üì: \"),\n            Span::styled(\"Navigation\", Style::default().fg(Color::Yellow)),\n            Span::raw(\" | \"),\n            Span::raw(\"Tab: \"),\n            Span::styled(\"N√§chste\", Style::default().fg(Color::Yellow)),\n            Span::raw(\" | \"),\n            Span::raw(\"e: \"),\n            Span::styled(\"Export\", Style::default().fg(Color::Yellow)),\n            Span::raw(\" | \"),\n            Span::raw(\"Esc: \"),\n            Span::styled(\"Zur√ºck\", Style::default().fg(Color::Yellow)),\n        ],\n        Screen::Tables => vec![\n            Span::raw(\"‚Üë‚Üì: \"),\n            Span::styled(\"Navigation\", Style::default().fg(Color::Yellow)),\n            Span::raw(\" | \"),\n            Span::raw(\"Enter: \"),\n            Span::styled(\"√ñffnen\", Style::default().fg(Color::Yellow)),\n            Span::raw(\" | \"),\n            Span::raw(\"/: \"),\n            Span::styled(\"Suchen\", Style::default().fg(Color::Yellow)),\n            Span::raw(\" | \"),\n            Span::raw(\"Esc: \"),\n            Span::styled(\"Zur√ºck\", Style::default().fg(Color::Yellow)),\n        ],\n        Screen::TableView => vec![\n            Span::raw(\"‚Üë‚Üì: \"),\n            Span::styled(\"Zeile\", Style::default().fg(Color::Yellow)),\n            Span::raw(\" | \"),\n            Span::raw(\"‚Üê‚Üí: \"),\n            Span::styled(\"Spalten scrollen\", Style::default().fg(Color::Yellow)),\n            Span::raw(\" | \"),\n            Span::raw(\"Esc: \"),\n            Span::styled(\"Zur√ºck\", Style::default().fg(Color::Yellow)),\n        ],\n        Screen::SavedConfigs => vec![\n            Span::raw(\"‚Üë‚Üì: \"),\n            Span::styled(\"Navigation\", Style::default().fg(Color::Yellow)),\n            Span::raw(\" | \"),\n            Span::raw(\"Enter: \"),\n            Span::styled(\"Laden\", Style::default().fg(Color::Yellow)),\n            Span::raw(\" | \"),\n            Span::raw(\"Del: \"),\n            Span::styled(\"L√∂schen\", Style::default().fg(Color::Red)),\n            Span::raw(\" | \"),\n            Span::raw(\"Esc: \"),\n            Span::styled(\"Zur√ºck\", Style::default().fg(Color::Yellow)),\n        ],\n        Screen::Help => vec![\n            Span::raw(\"Esc: \"),\n            Span::styled(\"Zur√ºck\", Style::default().fg(Color::Yellow)),\n        ],\n    };\n\n    let theme = app.theme();\n    let help_text = Paragraph::new(Line::from(keybindings))\n        .style(theme.text())\n        .block(Block::default().borders(Borders::TOP).border_style(theme.border_style()));\n\n    frame.render_widget(help_text, chunks[0]);\n\n    // Status message\n    let status = if let Some(ref msg) = app.status_message {\n        Paragraph::new(msg.as_str())\n            .style(theme.text_success())\n            .block(Block::default().borders(Borders::TOP).border_style(theme.border_style()))\n    } else {\n        Paragraph::new(\"\").block(Block::default().borders(Borders::TOP).border_style(theme.border_style()))\n    };\n\n    frame.render_widget(status, chunks[1]);\n}\n\n/// Render a search bar\n\npub fn render_search_bar(frame: &mut Frame, app: &App, area: Rect) {\n    let search_text = format!(\"Suche: {}\", app.search_query);\n    let search = Paragraph::new(search_text)\n        .style(\n            Style::default()\n                .fg(Color::Yellow)\n                .add_modifier(Modifier::BOLD),\n        )\n        .block(Block::default().borders(Borders::ALL).title(\"Suche\"));\n\n    frame.render_widget(search, area);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-tui","src","views","articles.rs"],"content":"//! Articles list view\n\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect},\n    style::{Color, Modifier, Style},\n    text::{Line, Span},\n    widgets::{Block, Borders, List, ListItem},\n    Frame,\n};\n\n\nuse crate::app::App;\n\nuse crate::ui::render_search_bar;\n\n/// Render the articles list view\n\npub fn render(frame: &mut Frame, app: &App, area: Rect) {\n    let chunks = if app.search_active {\n        Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([Constraint::Length(3), Constraint::Min(0)])\n            .split(area)\n    } else {\n        Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([Constraint::Min(0)])\n            .split(area)\n    };\n\n    let list_area = if app.search_active {\n        render_search_bar(frame, app, chunks[0]);\n        chunks[1]\n    } else {\n        chunks[0]\n    };\n\n    // Group articles by series\n    let items: Vec<ListItem> = if app.filtered_indices.is_empty() {\n        app.articles\n            .iter()\n            .map(|a| {\n                let config_indicator = if a.has_configuration {\n                    Span::styled(\"‚óè\", Style::default().fg(Color::Green))\n                } else {\n                    Span::styled(\"‚óã\", Style::default().fg(Color::DarkGray))\n                };\n\n                let line = Line::from(vec![\n                    config_indicator,\n                    Span::raw(\" \"),\n                    Span::styled(\n                        format!(\"{:<24}\", a.id),\n                        Style::default().add_modifier(Modifier::BOLD),\n                    ),\n                    Span::raw(format!(\" {}\", a.short_description)),\n                ]);\n                ListItem::new(line)\n            })\n            .collect()\n    } else {\n        app.filtered_indices\n            .iter()\n            .filter_map(|&i| app.articles.get(i))\n            .map(|a| {\n                let config_indicator = if a.has_configuration {\n                    Span::styled(\"‚óè\", Style::default().fg(Color::Green))\n                } else {\n                    Span::styled(\"‚óã\", Style::default().fg(Color::DarkGray))\n                };\n\n                let line = Line::from(vec![\n                    config_indicator,\n                    Span::raw(\" \"),\n                    Span::styled(\n                        format!(\"{:<24}\", a.id),\n                        Style::default().add_modifier(Modifier::BOLD),\n                    ),\n                    Span::raw(format!(\" {}\", a.short_description)),\n                ]);\n                ListItem::new(line)\n            })\n            .collect()\n    };\n\n    let manufacturer_name = app\n        .selected_manufacturer\n        .as_ref()\n        .map(|m| m.name.as_str())\n        .unwrap_or(\"?\");\n\n    let list = List::new(items)\n        .block(Block::default().borders(Borders::ALL).title(format!(\n            \" {} - Artikel ({}) \",\n            manufacturer_name,\n            if app.filtered_indices.is_empty() {\n                app.articles.len()\n            } else {\n                app.filtered_indices.len()\n            }\n        )))\n        .highlight_style(\n            Style::default()\n                .bg(Color::Blue)\n                .fg(Color::White)\n                .add_modifier(Modifier::BOLD),\n        )\n        .highlight_symbol(\"‚ñ∂ \");\n\n    frame.render_stateful_widget(list, list_area, &mut app.article_list_state.clone());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-tui","src","views","catalog.rs"],"content":"//! XCF Catalog browser view\n//!\n//! Displays the hierarchical catalog structure from XCF format,\n//! allowing navigation through categories to find products.\n\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect},\n    style::{Color, Modifier, Style},\n    text::{Line, Span},\n    widgets::{Block, Borders, List, ListItem, Paragraph},\n    Frame,\n};\n\n\nuse ofml_lib::oap::catalog::NodeType;\n\nuse crate::app::App;\n\nuse crate::ui::render_search_bar;\n\n/// Render the catalog browser view\n\npub fn render(frame: &mut Frame, app: &App, area: Rect) {\n    // Layout: breadcrumb + list (+ search bar if active)\n    let chunks = if app.search_active {\n        Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Length(3), // Search bar\n                Constraint::Length(2), // Breadcrumb\n                Constraint::Min(0),    // List\n            ])\n            .split(area)\n    } else {\n        Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Length(2), // Breadcrumb\n                Constraint::Min(0),    // List\n            ])\n            .split(area)\n    };\n\n    let (breadcrumb_area, list_area) = if app.search_active {\n        render_search_bar(frame, app, chunks[0]);\n        (chunks[1], chunks[2])\n    } else {\n        (chunks[0], chunks[1])\n    };\n\n    // Render breadcrumb\n    let breadcrumb = app.catalog_breadcrumb();\n    let breadcrumb_widget = Paragraph::new(Line::from(vec![\n        Span::styled(\"  \", Style::default()),\n        Span::styled(breadcrumb, Style::default().fg(Color::Cyan)),\n    ]));\n    frame.render_widget(breadcrumb_widget, breadcrumb_area);\n\n    // Render catalog items\n    let items: Vec<ListItem> = if app.filtered_indices.is_empty() {\n        app.catalog_children\n            .iter()\n            .map(|node| render_catalog_item(node))\n            .collect()\n    } else {\n        app.filtered_indices\n            .iter()\n            .filter_map(|&i| app.catalog_children.get(i))\n            .map(|node| render_catalog_item(node))\n            .collect()\n    };\n\n    let manufacturer_name = app\n        .selected_manufacturer\n        .as_ref()\n        .map(|m| m.name.as_str())\n        .unwrap_or(\"?\");\n\n    let folder_count = app\n        .catalog_children\n        .iter()\n        .filter(|n| n.node_type == NodeType::Folder)\n        .count();\n    let article_count = app\n        .catalog_children\n        .iter()\n        .filter(|n| n.node_type == NodeType::Article)\n        .count();\n\n    let title = format!(\n        \" {} - Katalog ({} Kategorien, {} Artikel) \",\n        manufacturer_name, folder_count, article_count\n    );\n\n    let list = List::new(items)\n        .block(Block::default().borders(Borders::ALL).title(title))\n        .highlight_style(\n            Style::default()\n                .bg(Color::Blue)\n                .fg(Color::White)\n                .add_modifier(Modifier::BOLD),\n        )\n        .highlight_symbol(\"> \");\n\n    frame.render_stateful_widget(list, list_area, &mut app.catalog_list_state.clone());\n}\n\n/// Render a single catalog item\n\nfn render_catalog_item(node: &ofml_lib::oap::catalog::CatalogNode) -> ListItem<'static> {\n    let (icon, icon_style) = match node.node_type {\n        NodeType::Folder => get_folder_icon(&node.name),\n        NodeType::Article => (\" * \", Style::default().fg(Color::Green)),\n        NodeType::Root => (\"   \", Style::default()),\n    };\n\n    let child_info = if node.node_type == NodeType::Folder && !node.children.is_empty() {\n        let sub_folders = node\n            .children\n            .iter()\n            .filter(|c| c.node_type == NodeType::Folder)\n            .count();\n        let sub_articles = node\n            .children\n            .iter()\n            .filter(|c| c.node_type == NodeType::Article)\n            .count();\n        if sub_folders > 0 && sub_articles > 0 {\n            format!(\" ({} Kat., {} Art.)\", sub_folders, sub_articles)\n        } else if sub_folders > 0 {\n            format!(\" ({} Kat.)\", sub_folders)\n        } else if sub_articles > 0 {\n            format!(\" ({} Art.)\", sub_articles)\n        } else {\n            String::new()\n        }\n    } else {\n        String::new()\n    };\n\n    let line = Line::from(vec![\n        Span::styled(icon, icon_style),\n        Span::raw(\" \"),\n        Span::styled(\n            truncate_str(&node.name, 60),\n            Style::default().add_modifier(Modifier::BOLD),\n        ),\n        Span::styled(child_info, Style::default().fg(Color::DarkGray)),\n    ]);\n\n    ListItem::new(line)\n}\n\n/// Get folder icon based on folder name (language-agnostic pattern matching)\n\nfn get_folder_icon(name: &str) -> (&'static str, Style) {\n    let name_lower = name.to_lowercase();\n\n    // New/Latest products (German: Neuheiten, English: New, Spanish: Novedades, French: Nouveaut√©s)\n    if name_lower.contains(\"neu\")\n        || name_lower.contains(\"new\")\n        || name_lower.contains(\"novel\")\n        || name_lower.contains(\"nouveau\")\n    {\n        return (\"<3 \", Style::default().fg(Color::Magenta));\n    }\n\n    // Bestsellers/Popular (German: Bestseller, English: Best, Spanish: Popular)\n    if name_lower.contains(\"best\") || name_lower.contains(\"popular\") || name_lower.contains(\"top\") {\n        return (\n            \"#1 \",\n            Style::default()\n                .fg(Color::Yellow)\n                .add_modifier(Modifier::BOLD),\n        );\n    }\n\n    // Information/About (German: Information, English: Info/About)\n    if name_lower.contains(\"info\") || name_lower.contains(\"about\") || name_lower.contains(\"√ºber\") {\n        return (\"(i)\", Style::default().fg(Color::Cyan));\n    }\n\n    // Categories/All products (German: Kategorien/Alle, English: Categories/All)\n    if name_lower.contains(\"kategor\")\n        || name_lower.contains(\"categor\")\n        || name_lower.contains(\"alle\")\n        || name_lower.contains(\"all \")\n    {\n        return (\"[+]\", Style::default().fg(Color::Blue));\n    }\n\n    // Rooms/Spaces (German: R√§ume, English: Rooms)\n    if name_lower.contains(\"raum\")\n        || name_lower.contains(\"r√§um\")\n        || name_lower.contains(\"room\")\n        || name_lower.contains(\"space\")\n    {\n        return (\"[=]\", Style::default().fg(Color::Green));\n    }\n\n    // Quick delivery/Fast (German: Schnell, English: Quick/Fast)\n    if name_lower.contains(\"schnell\")\n        || name_lower.contains(\"quick\")\n        || name_lower.contains(\"fast\")\n        || name_lower.contains(\"express\")\n    {\n        return (\n            \">>>\",\n            Style::default()\n                .fg(Color::Green)\n                .add_modifier(Modifier::BOLD),\n        );\n    }\n\n    // Preferred/Recommended combinations (German: Vorzug, English: Preferred)\n    if name_lower.contains(\"vorzug\")\n        || name_lower.contains(\"prefer\")\n        || name_lower.contains(\"recommend\")\n        || name_lower.contains(\"empfohl\")\n    {\n        return (\"[*]\", Style::default().fg(Color::Yellow));\n    }\n\n    // Accessories/Add-ons (German: Zubeh√∂r, English: Accessories)\n    if name_lower.contains(\"zubeh√∂r\")\n        || name_lower.contains(\"accessor\")\n        || name_lower.contains(\"add-on\")\n    {\n        return (\"(+)\", Style::default().fg(Color::Cyan));\n    }\n\n    // Chairs/Seating (German: St√ºhle/Sitz, English: Chair/Seat)\n    if name_lower.contains(\"stuhl\")\n        || name_lower.contains(\"st√ºhl\")\n        || name_lower.contains(\"chair\")\n        || name_lower.contains(\"seat\")\n        || name_lower.contains(\"sitz\")\n    {\n        return (\"[S]\", Style::default().fg(Color::Yellow));\n    }\n\n    // Tables/Desks (German: Tisch, English: Table/Desk)\n    if name_lower.contains(\"tisch\") || name_lower.contains(\"table\") || name_lower.contains(\"desk\") {\n        return (\"[T]\", Style::default().fg(Color::Yellow));\n    }\n\n    // Sofas/Lounge (German: Sofa, English: Sofa/Lounge)\n    if name_lower.contains(\"sofa\") || name_lower.contains(\"lounge\") || name_lower.contains(\"couch\")\n    {\n        return (\"[L]\", Style::default().fg(Color::Yellow));\n    }\n\n    // Storage/Cabinets (German: Schrank/Regal, English: Cabinet/Storage)\n    if name_lower.contains(\"schrank\")\n        || name_lower.contains(\"cabinet\")\n        || name_lower.contains(\"storage\")\n        || name_lower.contains(\"regal\")\n    {\n        return (\"[C]\", Style::default().fg(Color::Yellow));\n    }\n\n    // Default folder icon\n    (\"[ ]\", Style::default().fg(Color::Yellow))\n}\n\n/// Truncate a string to max length (UTF-8 safe)\nfn truncate_str(s: &str, max_len: usize) -> String {\n    let char_count = s.chars().count();\n    if char_count > max_len {\n        let truncated: String = s.chars().take(max_len - 1).collect();\n        format!(\"{}...\", truncated)\n    } else {\n        s.to_string()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-tui","src","views","families.rs"],"content":"//! Product Families list view\n//!\n//! Displays product families grouped by series, with configuration indicator.\n\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect},\n    style::{Color, Modifier, Style},\n    text::{Line, Span},\n    widgets::{Block, Borders, List, ListItem},\n    Frame,\n};\n\n\nuse ofml_lib::oap::families::ProductFamily;\n\nuse crate::app::App;\n\nuse crate::ui::render_search_bar;\n\n/// Render the product families list view\n\npub fn render(frame: &mut Frame, app: &App, area: Rect) {\n    let chunks = if app.search_active {\n        Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([Constraint::Length(3), Constraint::Min(0)])\n            .split(area)\n    } else {\n        Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([Constraint::Min(0)])\n            .split(area)\n    };\n\n    let list_area = if app.search_active {\n        render_search_bar(frame, app, chunks[0]);\n        chunks[1]\n    } else {\n        chunks[0]\n    };\n\n    let mfr_id = app\n        .selected_manufacturer\n        .as_ref()\n        .map(|m| m.id.as_str())\n        .unwrap_or(\"\");\n\n    let items: Vec<ListItem> = if app.filtered_indices.is_empty() {\n        app.families\n            .iter()\n            .map(|f| render_family_item(f, mfr_id))\n            .collect()\n    } else {\n        app.filtered_indices\n            .iter()\n            .filter_map(|&i| app.families.get(i))\n            .map(|f| render_family_item(f, mfr_id))\n            .collect()\n    };\n\n    let manufacturer_name = app\n        .selected_manufacturer\n        .as_ref()\n        .map(|m| m.name.as_str())\n        .unwrap_or(\"?\");\n\n    let configurable_count = app.families.iter().filter(|f| f.is_configurable).count();\n\n    let list = List::new(items)\n        .block(Block::default().borders(Borders::ALL).title(format!(\n            \" {} - Produktfamilien ({}, {} konfigurierbar) \",\n            manufacturer_name,\n            if app.filtered_indices.is_empty() {\n                app.families.len()\n            } else {\n                app.filtered_indices.len()\n            },\n            configurable_count\n        )))\n        .highlight_style(\n            Style::default()\n                .bg(Color::Blue)\n                .fg(Color::White)\n                .add_modifier(Modifier::BOLD),\n        )\n        .highlight_symbol(\"‚ñ∂ \");\n\n    frame.render_stateful_widget(list, list_area, &mut app.family_list_state.clone());\n}\n\n/// Render a single product family item\n\nfn render_family_item(family: &ProductFamily, manufacturer_id: &str) -> ListItem<'static> {\n    // Check if this family is a favorite\n    let is_favorite = crate::config_store::is_favorite(manufacturer_id, &family.id);\n\n    // Indicator: ‚öô = has OCD properties (configurable options)\n    //            ‚óè = has OAM mapping (CLS geometry) but no OCD properties\n    //            ‚óã = simple article (no configuration)\n    let indicator = if !family.prop_classes.is_empty() {\n        Span::styled(\"‚öô\", Style::default().fg(Color::Cyan))\n    } else if family.is_configurable {\n        Span::styled(\"‚óè\", Style::default().fg(Color::Yellow))\n    } else {\n        Span::styled(\"‚óã\", Style::default().fg(Color::DarkGray))\n    };\n\n    // Favorite star indicator\n    let fav_indicator = if is_favorite {\n        Span::styled(\"‚òÖ\", Style::default().fg(Color::Yellow))\n    } else {\n        Span::raw(\" \")\n    };\n\n    let variant_info = if family.variant_count > 1 {\n        format!(\" ({} Art.)\", family.variant_count)\n    } else {\n        String::new()\n    };\n\n    let line = Line::from(vec![\n        fav_indicator,\n        indicator,\n        Span::raw(\" \"),\n        Span::styled(\n            format!(\"{:<12}\", truncate_str(&family.id, 12)),\n            Style::default().add_modifier(Modifier::BOLD),\n        ),\n        Span::raw(\" \"),\n        Span::raw(format!(\n            \"{}{}\",\n            truncate_str(&family.name, 45),\n            variant_info\n        )),\n    ]);\n\n    ListItem::new(line)\n}\n\n/// Truncate a string to max length (UTF-8 safe)\nfn truncate_str(s: &str, max_len: usize) -> String {\n    let char_count = s.chars().count();\n    if char_count > max_len {\n        let truncated: String = s.chars().take(max_len - 1).collect();\n        format!(\"{}‚Ä¶\", truncated)\n    } else {\n        s.to_string()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-tui","src","views","family_config.rs"],"content":"//! Family Configuration view\n//!\n//! Displays configurable properties for a product family with dropdown selection.\n\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect},\n    style::{Color, Modifier, Style},\n    text::{Line, Span},\n    widgets::{Block, Borders, List, ListItem, Paragraph},\n    Frame,\n};\n\n\nuse ofml_lib::oap::families::{FamilyProperty, PropertyType};\n\nuse ofml_lib::oap::format_german_price_with_currency;\n\nuse crate::app::App;\n\n/// Render the family configuration view\n\npub fn render(frame: &mut Frame, app: &App, area: Rect) {\n    // Split into left (properties) and right (summary/price)\n    let chunks = Layout::default()\n        .direction(Direction::Horizontal)\n        .constraints([Constraint::Percentage(60), Constraint::Percentage(40)])\n        .split(area);\n\n    render_property_list(frame, app, chunks[0]);\n    render_summary(frame, app, chunks[1]);\n}\n\n/// Render the property list with dropdown-style selection\n\nfn render_property_list(frame: &mut Frame, app: &App, area: Rect) {\n    let family_name = app\n        .selected_family\n        .as_ref()\n        .map(|f| f.name.as_str())\n        .unwrap_or(\"?\");\n\n    let items: Vec<ListItem> = if app.family_properties.is_empty() {\n        // No OCD properties - show article variants instead\n        let mut items = vec![\n            ListItem::new(Line::from(Span::styled(\n                \"Keine konfigurierbaren Eigenschaften - Artikel w√§hlen:\",\n                Style::default().fg(Color::Yellow),\n            ))),\n            ListItem::new(Line::from(\"\")),\n        ];\n\n        // Show available article variants\n        if let Some(ref family) = app.selected_family {\n            if family.article_nrs.len() > 1 {\n                items.push(ListItem::new(Line::from(Span::styled(\n                    format!(\n                        \"Verf√ºgbare Artikel ({}) - ‚Üë‚Üì Enter:\",\n                        family.article_nrs.len()\n                    ),\n                    Style::default().add_modifier(Modifier::BOLD),\n                ))));\n                items.push(ListItem::new(Line::from(\"\")));\n\n                for (i, art_nr) in family.article_nrs.iter().enumerate() {\n                    let is_focused = i == app.focused_article_index;\n                    let prefix = if is_focused { \"‚ñ∂ \" } else { \"  \" };\n\n                    // Get description for this article\n                    let desc = family\n                        .article_descriptions\n                        .get(i)\n                        .map(|d| truncate_str(d, 40))\n                        .unwrap_or_default();\n\n                    let style = if is_focused {\n                        Style::default()\n                            .fg(Color::White)\n                            .bg(Color::DarkGray)\n                            .add_modifier(Modifier::BOLD)\n                    } else {\n                        Style::default()\n                    };\n\n                    let desc_style = if is_focused {\n                        Style::default().fg(Color::Yellow).bg(Color::DarkGray)\n                    } else {\n                        Style::default().fg(Color::DarkGray)\n                    };\n\n                    let line = Line::from(vec![\n                        Span::styled(prefix.to_string(), style),\n                        Span::styled(format!(\"{:<12}\", art_nr), style),\n                        Span::raw(\" \"),\n                        Span::styled(desc, desc_style),\n                    ]);\n\n                    items.push(ListItem::new(line));\n                }\n            } else {\n                // Single article\n                let desc = family\n                    .article_descriptions\n                    .first()\n                    .map(|d| d.as_str())\n                    .unwrap_or(\"-\");\n                items.push(ListItem::new(Line::from(vec![\n                    Span::styled(\"Artikel: \", Style::default().add_modifier(Modifier::BOLD)),\n                    Span::raw(family.base_article_nr.clone()),\n                ])));\n                items.push(ListItem::new(Line::from(Span::styled(\n                    desc.to_string(),\n                    Style::default().fg(Color::DarkGray),\n                ))));\n            }\n        }\n\n        items\n    } else {\n        // Calculate max label width for alignment (min 15, max 30)\n        let max_label_width = app\n            .family_properties\n            .iter()\n            .map(|p| p.label.chars().count())\n            .max()\n            .unwrap_or(15)\n            .clamp(15, 30);\n\n        // Group properties by their group field\n        let mut items: Vec<ListItem> = Vec::new();\n        let mut current_group: Option<&str> = None;\n\n        for (i, prop) in app.family_properties.iter().enumerate() {\n            // Add group header if group changed\n            let prop_group = if prop.group.is_empty() {\n                \"Eigenschaften\"\n            } else {\n                &prop.group\n            };\n            if current_group != Some(prop_group) {\n                if current_group.is_some() {\n                    // Add spacer between groups\n                    items.push(ListItem::new(Line::from(\"\")));\n                }\n                // Use human-readable group_label if available, otherwise fall back to group key\n                let display_group = if !prop.group_label.is_empty() && prop.group_label != prop.group\n                {\n                    &prop.group_label\n                } else if prop.group.is_empty() {\n                    \"Eigenschaften\"\n                } else {\n                    &prop.group\n                };\n                // Add group header\n                let header = Line::from(vec![\n                    Span::styled(\n                        format!(\"‚îÄ‚îÄ {} \", display_group),\n                        Style::default()\n                            .fg(Color::Blue)\n                            .add_modifier(Modifier::BOLD),\n                    ),\n                    Span::styled(\"‚îÄ\".repeat(30), Style::default().fg(Color::DarkGray)),\n                ]);\n                items.push(ListItem::new(header));\n                current_group = Some(prop_group);\n            }\n\n            items.push(render_property_item(prop, app, i, max_label_width));\n        }\n\n        items\n    };\n\n    let list = List::new(items).block(\n        Block::default()\n            .borders(Borders::ALL)\n            .title(format!(\" {} - Konfiguration \", family_name)),\n    );\n\n    frame.render_widget(list, area);\n}\n\n/// Render a single property item with current selection\n\nfn render_property_item(\n    prop: &FamilyProperty,\n    app: &App,\n    index: usize,\n    label_width: usize,\n) -> ListItem<'static> {\n    let is_focused = index == app.focused_property;\n\n    // Get current value from configuration\n    let current_value = app\n        .family_config\n        .as_ref()\n        .and_then(|c| c.selections.get(&prop.key))\n        .cloned()\n        .unwrap_or_default();\n\n    // Find matching option label\n    let value_label = prop\n        .options\n        .iter()\n        .find(|o| o.value == current_value)\n        .map(|o| o.label.clone())\n        .unwrap_or_else(|| {\n            if current_value.is_empty() {\n                \"-\".to_string()\n            } else {\n                current_value.clone()\n            }\n        });\n\n    let prefix = if is_focused { \"‚ñ∂ \" } else { \"  \" };\n    let required_mark = if prop.required { \"*\" } else { \"\" };\n\n    // Type indicator\n    let type_info = match &prop.prop_type {\n        PropertyType::Choice => {\n            let count = prop.options.len();\n            format!(\"[{} Optionen]\", count)\n        }\n        PropertyType::Range { min, max, step } => {\n            format!(\"[{:.0}-{:.0}, ¬±{:.0}]\", min, max, step)\n        }\n        PropertyType::Integer { min, max } => {\n            format!(\"[{}-{}]\", min, max)\n        }\n        PropertyType::Boolean => \"[Ja/Nein]\".to_string(),\n        PropertyType::Text => \"[Text]\".to_string(),\n    };\n\n    let label_style = if is_focused {\n        Style::default()\n            .fg(Color::White)\n            .add_modifier(Modifier::BOLD)\n    } else {\n        Style::default()\n    };\n\n    let value_style = if is_focused {\n        Style::default()\n            .fg(Color::Yellow)\n            .add_modifier(Modifier::BOLD)\n    } else {\n        Style::default().fg(Color::Cyan)\n    };\n\n    // Truncate label if needed, but use dynamic width\n    let display_label = if prop.label.chars().count() > label_width {\n        let truncated: String = prop.label.chars().take(label_width - 1).collect();\n        format!(\"{}‚Ä¶\", truncated)\n    } else {\n        prop.label.clone()\n    };\n\n    let line = Line::from(vec![\n        Span::raw(prefix.to_string()),\n        Span::styled(\n            format!(\n                \"{:<width$}{}\",\n                display_label,\n                required_mark,\n                width = label_width\n            ),\n            label_style,\n        ),\n        Span::raw(\" = \"),\n        Span::styled(format!(\"{:<20}\", value_label), value_style),\n        Span::styled(type_info, Style::default().fg(Color::DarkGray)),\n    ]);\n\n    if is_focused {\n        ListItem::new(line).style(Style::default().bg(Color::DarkGray))\n    } else {\n        ListItem::new(line)\n    }\n}\n\n/// Render the summary panel with variant code, price, and options\n\nfn render_summary(frame: &mut Frame, app: &App, area: Rect) {\n    let chunks = Layout::default()\n        .direction(Direction::Vertical)\n        .constraints([\n            Constraint::Length(5),  // Variant code\n            Constraint::Length(10), // Product info/description (increased for more text)\n            Constraint::Length(10), // Current property options\n            Constraint::Min(0),     // Price info\n        ])\n        .split(area);\n\n    // Variant code with manufacturer-specific formatting\n    let variant_code = app\n        .family_config\n        .as_ref()\n        .map(|c| {\n            // Apply manufacturer's code scheme separator\n            if app.varcode_separator != \"_\" && !app.varcode_separator.is_empty() {\n                c.variant_code.replace('_', &app.varcode_separator)\n            } else {\n                c.variant_code.clone()\n            }\n        })\n        .unwrap_or_else(|| \"-\".to_string());\n\n    // Show focused article when navigating article list (no properties mode)\n    let (article_nr, article_desc) = if app.family_properties.is_empty() {\n        // Article selection mode - show focused article\n        app.selected_family\n            .as_ref()\n            .and_then(|f| {\n                let idx = app.focused_article_index;\n                f.article_nrs.get(idx).map(|nr| {\n                    let desc = f\n                        .article_descriptions\n                        .get(idx)\n                        .map(|d| d.as_str())\n                        .unwrap_or(\"\");\n                    (nr.as_str(), desc)\n                })\n            })\n            .unwrap_or((\"-\", \"\"))\n    } else {\n        // Property mode - show base article\n        app.selected_family\n            .as_ref()\n            .map(|f| (f.base_article_nr.as_str(), \"\"))\n            .unwrap_or((\"-\", \"\"))\n    };\n\n    let mut lines = vec![Line::from(vec![\n        Span::styled(\n            \"Artikel:      \",\n            Style::default().add_modifier(Modifier::BOLD),\n        ),\n        Span::raw(article_nr.to_string()),\n    ])];\n\n    // Show article description if available\n    if !article_desc.is_empty() {\n        lines.push(Line::from(vec![Span::styled(\n            truncate_variant_code(article_desc, 35),\n            Style::default().fg(Color::DarkGray),\n        )]));\n    }\n\n    lines.push(Line::from(vec![\n        Span::styled(\n            \"Variante:     \",\n            Style::default().add_modifier(Modifier::BOLD),\n        ),\n        Span::styled(\n            truncate_variant_code(&variant_code, 30),\n            Style::default().fg(Color::Cyan),\n        ),\n    ]));\n\n    let variant_block =\n        Paragraph::new(lines).block(Block::default().borders(Borders::ALL).title(\" Code \"));\n\n    frame.render_widget(variant_block, chunks[0]);\n\n    // Product information (long description)\n    render_product_info(frame, app, chunks[1]);\n\n    // Current property options (for focused property)\n    render_options_panel(frame, app, chunks[2]);\n\n    // Price info\n    render_price_panel(frame, app, chunks[3]);\n}\n\n/// Render the product information panel with dynamic configuration summary\n\nfn render_product_info(frame: &mut Frame, app: &App, area: Rect) {\n    let mut lines: Vec<Line> = Vec::new();\n\n    if let Some(ref family) = app.selected_family {\n        // First line: product name from long description or family name\n        let product_name = if !family.long_description.is_empty() {\n            family\n                .long_description\n                .lines()\n                .next()\n                .unwrap_or(&family.name)\n        } else {\n            &family.name\n        };\n        lines.push(Line::from(Span::styled(\n            truncate_str(product_name, 38),\n            Style::default()\n                .fg(Color::White)\n                .add_modifier(Modifier::BOLD),\n        )));\n\n        // Show description text (word-wrapped)\n        let long_desc = family\n            .article_long_descriptions\n            .get(app.focused_article_index)\n            .map(|d| d.as_str())\n            .filter(|d| !d.is_empty())\n            .unwrap_or(&family.long_description);\n\n        if !long_desc.is_empty() {\n            // Word-wrap the description to fit the panel width\n            let wrapped = word_wrap(long_desc, 38);\n            // Show lines after the title line, up to 7 lines of description (fills 10-line box)\n            for line in wrapped.iter().skip(1).take(7) {\n                lines.push(Line::from(Span::styled(\n                    line.clone(),\n                    Style::default().fg(Color::DarkGray),\n                )));\n            }\n        } else if !app.family_properties.is_empty() {\n            // No description - show dynamic configuration from selected properties\n            if let Some(ref config) = app.family_config {\n                let config_lines: Vec<_> = app\n                    .family_properties\n                    .iter()\n                    .filter_map(|prop| {\n                        let value = config.selections.get(&prop.key)?;\n                        if value.is_empty() {\n                            return None;\n                        }\n                        let value_label = prop\n                            .options\n                            .iter()\n                            .find(|o| &o.value == value)\n                            .map(|o| o.label.as_str())\n                            .unwrap_or(value.as_str());\n                        Some(format!(\"{}: {}\", prop.label, value_label))\n                    })\n                    .take(5)\n                    .collect();\n\n                for line in config_lines {\n                    lines.push(Line::from(Span::styled(\n                        truncate_str(&line, 38),\n                        Style::default().fg(Color::Cyan),\n                    )));\n                }\n            }\n        }\n    }\n\n    if lines.is_empty() {\n        lines.push(Line::from(Span::styled(\n            \"Keine Konfiguration\",\n            Style::default().fg(Color::DarkGray),\n        )));\n    }\n\n    let info_block = Paragraph::new(lines).block(\n        Block::default()\n            .borders(Borders::ALL)\n            .title(\" Information \"),\n    );\n\n    frame.render_widget(info_block, area);\n}\n\n/// Render the options panel for the currently focused property\n\nfn render_options_panel(frame: &mut Frame, app: &App, area: Rect) {\n    let (options_lines, title) = if app.family_properties.is_empty() {\n        // Article selection mode - show hint\n        let lines = if let Some(ref family) = app.selected_family {\n            vec![\n                Line::from(Span::styled(\n                    format!(\"{} Artikel verf√ºgbar\", family.article_nrs.len()),\n                    Style::default().fg(Color::White),\n                )),\n                Line::from(\"\"),\n                Line::from(Span::styled(\n                    \"‚Üë‚Üì Navigieren\",\n                    Style::default().fg(Color::DarkGray),\n                )),\n                Line::from(Span::styled(\n                    \"Enter Ausw√§hlen\",\n                    Style::default().fg(Color::DarkGray),\n                )),\n                Line::from(Span::styled(\n                    \"Esc  Zur√ºck\",\n                    Style::default().fg(Color::DarkGray),\n                )),\n            ]\n        } else {\n            vec![Line::from(Span::styled(\n                \"Keine Artikel\",\n                Style::default().fg(Color::DarkGray),\n            ))]\n        };\n        (lines, \" Artikel \".to_string())\n    } else if let Some(prop) = app.family_properties.get(app.focused_property) {\n        let current_value = app\n            .family_config\n            .as_ref()\n            .and_then(|c| c.selections.get(&prop.key))\n            .cloned()\n            .unwrap_or_default();\n\n        let mut lines: Vec<Line> = prop\n            .options\n            .iter()\n            .take(7) // Show 7 options to leave room for hint (fits in 10-line box)\n            .map(|opt| {\n                let is_selected = opt.value == current_value;\n                let prefix = if is_selected { \"‚óè \" } else { \"‚óã \" };\n                let style = if is_selected {\n                    Style::default()\n                        .fg(Color::Green)\n                        .add_modifier(Modifier::BOLD)\n                } else {\n                    Style::default().fg(Color::White)\n                };\n\n                Line::from(vec![\n                    Span::styled(prefix.to_string(), style),\n                    Span::styled(opt.label.clone(), style),\n                ])\n            })\n            .collect();\n\n        // Add \"more options\" indicator if truncated\n        if prop.options.len() > 7 {\n            lines.push(Line::from(Span::styled(\n                format!(\"  ... +{} more\", prop.options.len() - 7),\n                Style::default().fg(Color::DarkGray),\n            )));\n        }\n\n        // Add hint text if available (shows as a tooltip/help text)\n        if let Some(ref hint) = prop.hint {\n            lines.push(Line::from(\"\"));\n            lines.push(Line::from(Span::styled(\n                format!(\"‚Ñπ {}\", truncate_str(hint, 35)),\n                Style::default().fg(Color::Yellow),\n            )));\n        }\n\n        // Add navigation hint\n        lines.push(Line::from(\"\"));\n        lines.push(Line::from(Span::styled(\n            \"‚Üê‚Üí Wert √§ndern\",\n            Style::default().fg(Color::Cyan),\n        )));\n\n        (lines, format!(\" {} \", prop.label))\n    } else {\n        (\n            vec![Line::from(Span::styled(\n                \"Keine Optionen\",\n                Style::default().fg(Color::DarkGray),\n            ))],\n            \" Optionen \".to_string(),\n        )\n    };\n\n    let options_block =\n        Paragraph::new(options_lines).block(Block::default().borders(Borders::ALL).title(title));\n\n    frame.render_widget(options_block, area);\n}\n\n/// Render the price panel\n\nfn render_price_panel(frame: &mut Frame, app: &App, area: Rect) {\n    let price_lines = if let Some(ref price) = app.family_price {\n        use rust_decimal::Decimal;\n\n        let mut lines = vec![Line::from(vec![\n            Span::styled(\n                \"Grundpreis:  \",\n                Style::default().add_modifier(Modifier::BOLD),\n            ),\n            Span::styled(\n                format_german_price_with_currency(price.base_price, &price.currency),\n                Style::default().fg(Color::White),\n            ),\n        ])];\n\n        // Separate surcharges (positive) from discounts (negative)\n        let surcharges: Vec<_> = price\n            .surcharges\n            .iter()\n            .filter(|s| s.amount >= Decimal::ZERO)\n            .collect();\n        let discounts: Vec<_> = price\n            .surcharges\n            .iter()\n            .filter(|s| s.amount < Decimal::ZERO)\n            .collect();\n\n        // Show surcharges (positive amounts)\n        for surcharge in &surcharges {\n            let amount_str = if surcharge.is_percentage {\n                format!(\"{}%\", surcharge.amount)\n            } else {\n                format_german_price_with_currency(surcharge.amount, &price.currency)\n            };\n            lines.push(Line::from(vec![\n                Span::styled(\n                    format!(\"  + {}:  \", truncate_str(&surcharge.name, 15)),\n                    Style::default().fg(Color::DarkGray),\n                ),\n                Span::styled(amount_str, Style::default().fg(Color::Yellow)),\n            ]));\n        }\n\n        // Show discounts (negative amounts) in green\n        for discount in &discounts {\n            // Remove \"Rabatt: \" prefix if present for cleaner display\n            let name = discount\n                .name\n                .strip_prefix(\"Rabatt: \")\n                .unwrap_or(&discount.name);\n            let abs_amount = discount.amount.abs();\n            let amount_str = if discount.is_percentage {\n                format!(\"-{}%\", abs_amount)\n            } else {\n                format!(\"-{}\", format_german_price_with_currency(abs_amount, &price.currency))\n            };\n            lines.push(Line::from(vec![\n                Span::styled(\n                    format!(\"  ‚îÄ {}:  \", truncate_str(name, 15)),\n                    Style::default().fg(Color::Cyan),\n                ),\n                Span::styled(amount_str, Style::default().fg(Color::Cyan)),\n            ]));\n        }\n\n        // Show net price if there are taxes\n        if !price.taxes.is_empty() {\n            lines.push(Line::from(vec![\n                Span::styled(\"Netto:       \", Style::default().fg(Color::DarkGray)),\n                Span::styled(\n                    format_german_price_with_currency(price.net_price, &price.currency),\n                    Style::default().fg(Color::White),\n                ),\n            ]));\n\n            // Show each tax\n            for tax in &price.taxes {\n                lines.push(Line::from(vec![\n                    Span::styled(\n                        format!(\"  + {}:  \", truncate_str(&tax.name, 13)),\n                        Style::default().fg(Color::Magenta),\n                    ),\n                    Span::styled(\n                        format_german_price_with_currency(tax.amount, &price.currency),\n                        Style::default().fg(Color::Magenta),\n                    ),\n                ]));\n            }\n        }\n\n        lines.push(Line::from(vec![\n            Span::styled(\n                if price.taxes.is_empty() {\n                    \"Gesamtpreis: \"\n                } else {\n                    \"Brutto:      \"\n                },\n                Style::default()\n                    .add_modifier(Modifier::BOLD)\n                    .fg(Color::Green),\n            ),\n            Span::styled(\n                format_german_price_with_currency(price.total_price, &price.currency),\n                Style::default()\n                    .fg(Color::Green)\n                    .add_modifier(Modifier::BOLD),\n            ),\n        ]));\n\n        lines.push(Line::from(\"\"));\n        lines.push(Line::from(vec![\n            Span::styled(\"Preisdatum:  \", Style::default().fg(Color::DarkGray)),\n            Span::raw(price.price_date.format(\"%d.%m.%Y\").to_string()),\n        ]));\n\n        // Show packaging info if available\n        if let Some(ref pkg) = app.packaging_info {\n            if pkg.weight_kg > 0.0 || pkg.volume_m3 > 0.0 {\n                lines.push(Line::from(\"\"));\n                if pkg.weight_kg > 0.0 {\n                    lines.push(Line::from(vec![\n                        Span::styled(\"Gewicht:     \", Style::default().fg(Color::DarkGray)),\n                        Span::raw(format!(\"{:.1} kg\", pkg.weight_kg)),\n                    ]));\n                }\n                if pkg.volume_m3 > 0.0 {\n                    lines.push(Line::from(vec![\n                        Span::styled(\"Volumen:     \", Style::default().fg(Color::DarkGray)),\n                        Span::raw(format!(\"{:.3} m¬≥\", pkg.volume_m3)),\n                    ]));\n                }\n            }\n        }\n\n        // Show data version if available\n        if let Some(ref version) = app.data_version {\n            lines.push(Line::from(vec![\n                Span::styled(\"Daten v:     \", Style::default().fg(Color::DarkGray)),\n                Span::raw(truncate_str(version, 15)),\n            ]));\n        }\n\n        // Show data validity warning if present\n        if let Some(ref warning) = app.data_validity_warning {\n            lines.push(Line::from(Span::styled(\n                format!(\"‚ö† {}\", truncate_str(warning, 22)),\n                Style::default().fg(Color::Yellow),\n            )));\n        }\n\n        // Show composite components if this is a composite product\n        if !app.composite_components.is_empty() {\n            lines.push(Line::from(Span::styled(\n                \"‚îÄ Komponenten ‚îÄ\",\n                Style::default().fg(Color::DarkGray),\n            )));\n            for component in app.composite_components.iter().take(5) {\n                let qty_str = if component.quantity == 1.0 {\n                    String::new()\n                } else {\n                    format!(\"{}√ó \", component.quantity)\n                };\n                lines.push(Line::from(Span::styled(\n                    format!(\"  {}{}\", qty_str, truncate_str(&component.item_id, 18)),\n                    Style::default().fg(Color::Gray),\n                )));\n            }\n            if app.composite_components.len() > 5 {\n                lines.push(Line::from(Span::styled(\n                    format!(\"  ... +{} weitere\", app.composite_components.len() - 5),\n                    Style::default().fg(Color::DarkGray),\n                )));\n            }\n        }\n\n        lines\n    } else {\n        vec![Line::from(Span::styled(\n            \"Preis wird geladen...\",\n            Style::default().fg(Color::Yellow),\n        ))]\n    };\n\n    // Build title with warning indicator if there are warnings\n    let has_validity_warning = app.data_validity_warning.is_some();\n    let title = if !app.family_warnings.is_empty() {\n        let warn_count = app.family_warnings.len();\n        if has_validity_warning {\n            format!(\" Preis ‚ö† {}+ \", warn_count)\n        } else {\n            format!(\" Preis ‚ö† {} \", warn_count)\n        }\n    } else if has_validity_warning {\n        \" Preis ‚ö† \".to_string()\n    } else {\n        \" Preis \".to_string()\n    };\n\n    let title_style = if !app.family_warnings.is_empty() || has_validity_warning {\n        Style::default().fg(Color::Yellow)\n    } else {\n        Style::default()\n    };\n\n    let price_block = Paragraph::new(price_lines).block(\n        Block::default()\n            .borders(Borders::ALL)\n            .title(Span::styled(title, title_style)),\n    );\n\n    frame.render_widget(price_block, area);\n}\n\n/// Truncate variant code for display (UTF-8 safe)\nfn truncate_variant_code(s: &str, max_len: usize) -> String {\n    let char_count = s.chars().count();\n    if char_count > max_len {\n        let truncated: String = s.chars().take(max_len - 1).collect();\n        format!(\"{}‚Ä¶\", truncated)\n    } else {\n        s.to_string()\n    }\n}\n\n/// Truncate a string for display (UTF-8 safe)\nfn truncate_str(s: &str, max_len: usize) -> String {\n    let char_count = s.chars().count();\n    if char_count > max_len {\n        let truncated: String = s.chars().take(max_len - 1).collect();\n        format!(\"{}‚Ä¶\", truncated)\n    } else {\n        s.to_string()\n    }\n}\n\n/// Word-wrap text to fit within max_width characters\n/// Handles both multi-line input and single long lines\nfn word_wrap(text: &str, max_width: usize) -> Vec<String> {\n    let mut result = Vec::new();\n\n    for line in text.lines() {\n        if line.chars().count() <= max_width {\n            result.push(line.to_string());\n        } else {\n            // Word-wrap this line\n            let mut current_line = String::new();\n            for word in line.split_whitespace() {\n                if current_line.is_empty() {\n                    // First word on line\n                    if word.chars().count() > max_width {\n                        // Word is too long, truncate it\n                        result.push(truncate_str(word, max_width));\n                    } else {\n                        current_line = word.to_string();\n                    }\n                } else if current_line.chars().count() + 1 + word.chars().count() <= max_width {\n                    // Word fits on current line\n                    current_line.push(' ');\n                    current_line.push_str(word);\n                } else {\n                    // Word doesn't fit, start new line\n                    result.push(current_line);\n                    if word.chars().count() > max_width {\n                        result.push(truncate_str(word, max_width));\n                        current_line = String::new();\n                    } else {\n                        current_line = word.to_string();\n                    }\n                }\n            }\n            if !current_line.is_empty() {\n                result.push(current_line);\n            }\n        }\n    }\n\n    result\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-tui","src","views","help.rs"],"content":"//! Help screen view\n\n\nuse ratatui::{\n    layout::Rect,\n    style::{Color, Modifier, Style},\n    text::{Line, Span},\n    widgets::{Block, Borders, Paragraph},\n    Frame,\n};\n\n\nuse crate::app::App;\n\n/// Render the help screen\n\npub fn render(frame: &mut Frame, _app: &App, area: Rect) {\n    let help_text = vec![\n        Line::from(\"\"),\n        Line::from(Span::styled(\n            \"  OAP Konfigurator - Tastaturk√ºrzel\",\n            Style::default()\n                .add_modifier(Modifier::BOLD)\n                .fg(Color::Yellow),\n        )),\n        Line::from(\"\"),\n        Line::from(\"  Navigation:\"),\n        Line::from(vec![\n            Span::styled(\"    ‚Üë/‚Üì       \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"In Liste navigieren\"),\n        ]),\n        Line::from(vec![\n            Span::styled(\"    PgUp/PgDn \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"10 Eintr√§ge vor/zur√ºck\"),\n        ]),\n        Line::from(vec![\n            Span::styled(\"    Home/g    \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"Zum Anfang der Liste\"),\n        ]),\n        Line::from(vec![\n            Span::styled(\"    End/G     \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"Zum Ende der Liste\"),\n        ]),\n        Line::from(vec![\n            Span::styled(\"    Enter     \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"Ausw√§hlen / √ñffnen\"),\n        ]),\n        Line::from(vec![\n            Span::styled(\"    Esc       \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"Zur√ºck / Schlie√üen\"),\n        ]),\n        Line::from(vec![\n            Span::styled(\"    h         \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"Zur Herstellerliste (Home)\"),\n        ]),\n        Line::from(\"\"),\n        Line::from(\"  Aktionen:\"),\n        Line::from(vec![\n            Span::styled(\"    /         \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"Suche starten\"),\n        ]),\n        Line::from(vec![\n            Span::styled(\"    t         \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"Tabellen-Browser √∂ffnen\"),\n        ]),\n        Line::from(vec![\n            Span::styled(\"    e         \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"Konfiguration exportieren (JSON)\"),\n        ]),\n        Line::from(vec![\n            Span::styled(\"    Ctrl+G    \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"Geometrie exportieren (GLB)\"),\n        ]),\n        Line::from(vec![\n            Span::styled(\"    Ctrl+S    \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"Konfiguration speichern\"),\n        ]),\n        Line::from(vec![\n            Span::styled(\"    Ctrl+O    \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"Konfiguration laden\"),\n        ]),\n        Line::from(vec![\n            Span::styled(\"    f         \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"Favorit markieren/entfernen\"),\n        ]),\n        Line::from(vec![\n            Span::styled(\"    ?         \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"Diese Hilfe anzeigen\"),\n        ]),\n        Line::from(vec![\n            Span::styled(\"    T         \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"Theme umschalten (Hell/Dunkel)\"),\n        ]),\n        Line::from(vec![\n            Span::styled(\"    F12       \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"Debug-Konsole ein/aus\"),\n        ]),\n        Line::from(vec![\n            Span::styled(\"    q         \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"Programm beenden\"),\n        ]),\n        Line::from(\"\"),\n        Line::from(\"  Eigenschaftseingabe:\"),\n        Line::from(vec![\n            Span::styled(\"    ‚Üê/‚Üí       \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"Auswahl √§ndern (bei Auswahllisten)\"),\n        ]),\n        Line::from(vec![\n            Span::styled(\"    Space     \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"Boolean umschalten\"),\n        ]),\n        Line::from(vec![\n            Span::styled(\"    Ctrl+Z/u  \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"Letzte √Ñnderung r√ºckg√§ngig\"),\n        ]),\n        Line::from(vec![\n            Span::styled(\"    Ctrl+Y    \", Style::default().fg(Color::Cyan)),\n            Span::raw(\"√Ñnderung wiederherstellen\"),\n        ]),\n        Line::from(\"\"),\n        Line::from(Span::styled(\n            \"  Dr√ºcke Esc um zur Anwendung zur√ºckzukehren\",\n            Style::default().fg(Color::DarkGray),\n        )),\n    ];\n\n    let help =\n        Paragraph::new(help_text).block(Block::default().borders(Borders::ALL).title(\" Hilfe \"));\n\n    frame.render_widget(help, area);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-tui","src","views","manufacturers.rs"],"content":"//! Manufacturers list view\n\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect},\n    style::{Color, Modifier, Style},\n    text::{Line, Span},\n    widgets::{Block, Borders, List, ListItem},\n    Frame,\n};\n\n\nuse crate::app::App;\n\nuse crate::ui::render_search_bar;\n\n/// Render the manufacturers list view\n\npub fn render(frame: &mut Frame, app: &App, area: Rect) {\n    let chunks = if app.search_active {\n        Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([Constraint::Length(3), Constraint::Min(0)])\n            .split(area)\n    } else {\n        Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([Constraint::Min(0)])\n            .split(area)\n    };\n\n    let list_area = if app.search_active {\n        render_search_bar(frame, app, chunks[0]);\n        chunks[1]\n    } else {\n        chunks[0]\n    };\n\n    // Build list items - show ID and display name\n    let items: Vec<ListItem> = if app.filtered_indices.is_empty() {\n        app.manufacturers\n            .iter()\n            .map(|m| {\n                let line = Line::from(vec![\n                    Span::styled(\n                        format!(\"{:<12}\", m.id),\n                        Style::default().add_modifier(Modifier::BOLD),\n                    ),\n                    Span::raw(\" \"),\n                    Span::styled(&m.name, Style::default().fg(Color::Cyan)),\n                ]);\n                ListItem::new(line)\n            })\n            .collect()\n    } else {\n        app.filtered_indices\n            .iter()\n            .filter_map(|&i| app.manufacturers.get(i))\n            .map(|m| {\n                let line = Line::from(vec![\n                    Span::styled(\n                        format!(\"{:<12}\", m.id),\n                        Style::default().add_modifier(Modifier::BOLD),\n                    ),\n                    Span::raw(\" \"),\n                    Span::styled(&m.name, Style::default().fg(Color::Cyan)),\n                ]);\n                ListItem::new(line)\n            })\n            .collect()\n    };\n\n    let list = List::new(items)\n        .block(Block::default().borders(Borders::ALL).title(format!(\n            \" Hersteller ({}) \",\n            if app.filtered_indices.is_empty() {\n                app.manufacturers.len()\n            } else {\n                app.filtered_indices.len()\n            }\n        )))\n        .highlight_style(\n            Style::default()\n                .bg(Color::Blue)\n                .fg(Color::White)\n                .add_modifier(Modifier::BOLD),\n        )\n        .highlight_symbol(\"‚ñ∂ \");\n\n    frame.render_stateful_widget(list, list_area, &mut app.manufacturer_list_state.clone());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-tui","src","views","mod.rs"],"content":"//! TUI Views\r\n//!\r\n//! This module contains individual view renderers for each screen.\r\n\r\n\r\npub mod articles;\r\n\r\npub mod catalog;\r\n\r\npub mod families;\r\n\r\npub mod family_config;\r\n\r\npub mod help;\r\n\r\npub mod manufacturers;\r\n\r\npub mod properties;\r\n\r\npub mod tables;\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-tui","src","views","properties.rs"],"content":"//! Properties configuration view\n\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect},\n    style::{Color, Modifier, Style},\n    text::{Line, Span},\n    widgets::{Block, Borders, List, ListItem, Paragraph},\n    Frame,\n};\n\n\nuse ofml_lib::oap::format_german_price_with_currency;\n\nuse ofml_lib::property::{PropertyState, PropertyType};\n\nuse crate::app::App;\n\n/// Render the properties configuration view\n\npub fn render(frame: &mut Frame, app: &App, area: Rect) {\n    // Split into left (properties) and right (summary/price)\n    let chunks = Layout::default()\n        .direction(Direction::Horizontal)\n        .constraints([Constraint::Percentage(60), Constraint::Percentage(40)])\n        .split(area);\n\n    render_property_list(frame, app, chunks[0]);\n    render_summary(frame, app, chunks[1]);\n}\n\n/// Render the property list\n\nfn render_property_list(frame: &mut Frame, app: &App, area: Rect) {\n    let items: Vec<ListItem> = if let Some(ref config) = app.configuration {\n        let mut props: Vec<_> = config.properties.definitions.iter().collect();\n        props.sort_by_key(|(_, def)| def.sort_order);\n\n        props\n            .iter()\n            .enumerate()\n            .map(|(i, (name, def))| {\n                let value = config\n                    .properties\n                    .values\n                    .get(*name)\n                    .map(|v| format!(\"{:?}\", v))\n                    .unwrap_or_else(|| \"-\".to_string());\n\n                let type_info = match &def.prop_type {\n                    PropertyType::Int { min, max } => {\n                        let min_str = min.map(|v| v.to_string()).unwrap_or_default();\n                        let max_str = max.map(|v| v.to_string()).unwrap_or_default();\n                        format!(\"[{}-{}]\", min_str, max_str)\n                    }\n                    PropertyType::Float { min, max } => {\n                        let min_str = min.map(|v| format!(\"{:.1}\", v)).unwrap_or_default();\n                        let max_str = max.map(|v| format!(\"{:.1}\", v)).unwrap_or_default();\n                        format!(\"[{}-{}]\", min_str, max_str)\n                    }\n                    PropertyType::Choice { options } => {\n                        format!(\"[{}]\", options.join(\",\"))\n                    }\n                    PropertyType::Bool => \"[ja/nein]\".to_string(),\n                    PropertyType::String => \"[Text]\".to_string(),\n                };\n\n                let state_style = match def.state {\n                    PropertyState::Enabled => Style::default(),\n                    PropertyState::Hidden => Style::default().fg(Color::DarkGray),\n                    PropertyState::ReadOnly => Style::default().fg(Color::Yellow),\n                };\n\n                let is_focused = i == app.focused_property;\n                let prefix = if is_focused { \"‚ñ∂ \" } else { \"  \" };\n\n                let line = Line::from(vec![\n                    Span::raw(prefix),\n                    Span::styled(\n                        format!(\"{:<16}\", def.label),\n                        if is_focused {\n                            Style::default()\n                                .fg(Color::White)\n                                .add_modifier(Modifier::BOLD)\n                        } else {\n                            state_style\n                        },\n                    ),\n                    Span::raw(\" = \"),\n                    Span::styled(format!(\"{:<16}\", value), Style::default().fg(Color::Cyan)),\n                    Span::styled(type_info, Style::default().fg(Color::DarkGray)),\n                ]);\n\n                if is_focused {\n                    ListItem::new(line).style(Style::default().bg(Color::DarkGray))\n                } else {\n                    ListItem::new(line)\n                }\n            })\n            .collect()\n    } else {\n        vec![ListItem::new(\"Keine Eigenschaften verf√ºgbar\")]\n    };\n\n    let article_name = app\n        .selected_article\n        .as_ref()\n        .map(|a| a.id.as_str())\n        .unwrap_or(\"?\");\n\n    let list = List::new(items).block(\n        Block::default()\n            .borders(Borders::ALL)\n            .title(format!(\" {} - Eigenschaften \", article_name)),\n    );\n\n    frame.render_widget(list, area);\n}\n\n/// Render the summary panel with variant code and price\n\nfn render_summary(frame: &mut Frame, app: &App, area: Rect) {\n    let chunks = Layout::default()\n        .direction(Direction::Vertical)\n        .constraints([\n            Constraint::Length(5), // Variant code\n            Constraint::Min(0),    // Price info\n        ])\n        .split(area);\n\n    // Variant code with manufacturer-specific formatting\n    let variant_code = app\n        .configuration\n        .as_ref()\n        .map(|c| {\n            // Apply manufacturer's code scheme separator\n            if app.varcode_separator != \"_\" && !app.varcode_separator.is_empty() {\n                c.variant_code.replace('_', &app.varcode_separator)\n            } else {\n                c.variant_code.clone()\n            }\n        })\n        .unwrap_or_else(|| \"-\".to_string());\n\n    let variant_block = Paragraph::new(vec![\n        Line::from(Span::styled(\n            \"Variantencode:\",\n            Style::default().add_modifier(Modifier::BOLD),\n        )),\n        Line::from(Span::styled(variant_code, Style::default().fg(Color::Cyan))),\n    ])\n    .block(Block::default().borders(Borders::ALL).title(\" Code \"));\n\n    frame.render_widget(variant_block, chunks[0]);\n\n    // Price info\n    let price_lines =\n        if let Some(price) = app.configuration.as_ref().and_then(|c| c.price.as_ref()) {\n            let mut lines = vec![Line::from(vec![\n                Span::styled(\n                    \"Grundpreis:  \",\n                    Style::default().add_modifier(Modifier::BOLD),\n                ),\n                Span::styled(\n                    format_german_price_with_currency(price.base_price, &price.currency),\n                    Style::default().fg(Color::White),\n                ),\n            ])];\n\n            for surcharge in &price.surcharges {\n                let amount_str = if surcharge.is_percentage {\n                    format!(\"{}%\", surcharge.amount)\n                } else {\n                    format_german_price_with_currency(surcharge.amount, &price.currency)\n                };\n                lines.push(Line::from(vec![\n                    Span::styled(\n                        format!(\"  + {}:  \", surcharge.name),\n                        Style::default().fg(Color::DarkGray),\n                    ),\n                    Span::styled(amount_str, Style::default().fg(Color::Yellow)),\n                ]));\n            }\n\n            lines.push(Line::from(vec![\n                Span::styled(\n                    \"Gesamtpreis: \",\n                    Style::default()\n                        .add_modifier(Modifier::BOLD)\n                        .fg(Color::Green),\n                ),\n                Span::styled(\n                    format_german_price_with_currency(price.total_price, &price.currency),\n                    Style::default()\n                        .fg(Color::Green)\n                        .add_modifier(Modifier::BOLD),\n                ),\n            ]));\n\n            lines.push(Line::from(\"\"));\n            lines.push(Line::from(vec![\n                Span::styled(\"Preisdatum:  \", Style::default().fg(Color::DarkGray)),\n                Span::raw(price.price_date.format(\"%d.%m.%Y\").to_string()),\n            ]));\n\n            lines\n        } else {\n            vec![Line::from(Span::styled(\n                \"Preis nicht verf√ºgbar\",\n                Style::default().fg(Color::Red),\n            ))]\n        };\n\n    let price_block =\n        Paragraph::new(price_lines).block(Block::default().borders(Borders::ALL).title(\" Preis \"));\n\n    frame.render_widget(price_block, chunks[1]);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-tui","src","views","tables.rs"],"content":"//! Table browser view for inspecting custom manufacturer tables\n//!\n//! This view allows browsing all tables in pdata.ebase files,\n//! including standard OCD tables and custom manufacturer tables.\n\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect},\n    style::{Color, Modifier, Style},\n    text::{Line, Span},\n    widgets::{Block, Borders, Cell, List, ListItem, Paragraph, Row, Table},\n    Frame,\n};\n\n\nuse crate::app::{App, TableInfo};\n\nuse crate::ui::render_search_bar;\n\n/// Standard OCD table names (for highlighting custom tables)\n#[allow(dead_code)]\nconst _STANDARD_TABLES: &[&str] = &[\n    \"ocd_article\",\n    \"ocd_articletext\",\n    \"ocd_artshorttext\",\n    \"ocd_artlongtext\",\n    \"ocd_price\",\n    \"ocd_pricetext\",\n    \"ocd_property\",\n    \"ocd_propertyclass\",\n    \"ocd_propertyvalue\",\n    \"ocd_propertyvaluetext\",\n    \"ocd_propvaluetext\",\n    \"ocd_variantcondition\",\n    \"ocd_relation\",\n    \"ocd_relationobj\",\n    \"ocd_propertygroup\",\n    \"ocd_article2propgroup\",\n    \"ocd_composite\",\n    \"ocd_billofitems\",\n    \"propvalue2varcond\",\n];\n\n/// Check if a table name is a standard OCD table\n#[allow(dead_code)]\nfn _is_standard_table(name: &str) -> bool {\n    _STANDARD_TABLES\n        .iter()\n        .any(|&s| s.eq_ignore_ascii_case(name))\n}\n\n/// Render the table browser view (list of tables)\n\npub fn render_tables(frame: &mut Frame, app: &App, area: Rect) {\n    let chunks = if app.search_active {\n        Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([\n                Constraint::Length(3), // Search bar\n                Constraint::Min(0),    // List\n            ])\n            .split(area)\n    } else {\n        Layout::default()\n            .direction(Direction::Vertical)\n            .constraints([Constraint::Min(0)])\n            .split(area)\n    };\n\n    let list_area = if app.search_active {\n        render_search_bar(frame, app, chunks[0]);\n        chunks[1]\n    } else {\n        chunks[0]\n    };\n\n    // Count standard vs custom tables\n    let custom_count = app.tables.iter().filter(|t| !t.is_standard).count();\n    let standard_count = app.tables.len() - custom_count;\n\n    let title = format!(\n        \" Tabellen ({} Standard, {} Custom) - 't' zum √ñffnen \",\n        standard_count, custom_count\n    );\n\n    let items: Vec<ListItem> = if app.filtered_indices.is_empty() {\n        app.tables.iter().map(render_table_item).collect()\n    } else {\n        app.filtered_indices\n            .iter()\n            .filter_map(|&i| app.tables.get(i))\n            .map(render_table_item)\n            .collect()\n    };\n\n    let list = List::new(items)\n        .block(Block::default().borders(Borders::ALL).title(title))\n        .highlight_style(\n            Style::default()\n                .bg(Color::Blue)\n                .fg(Color::White)\n                .add_modifier(Modifier::BOLD),\n        )\n        .highlight_symbol(\"> \");\n\n    frame.render_stateful_widget(list, list_area, &mut app.table_list_state.clone());\n}\n\n/// Render a single table item in the list\n\nfn render_table_item(table: &TableInfo) -> ListItem<'static> {\n    let (icon, style) = if table.is_standard {\n        (\"[S]\", Style::default().fg(Color::DarkGray))\n    } else {\n        (\n            \"[C]\",\n            Style::default()\n                .fg(Color::Yellow)\n                .add_modifier(Modifier::BOLD),\n        )\n    };\n\n    let cols_preview = if table.columns.len() > 3 {\n        format!(\n            \"{}, {} +{}\",\n            table.columns.first().map(|s| s.as_str()).unwrap_or(\"\"),\n            table.columns.get(1).map(|s| s.as_str()).unwrap_or(\"\"),\n            table.columns.len() - 2\n        )\n    } else {\n        table.columns.join(\", \")\n    };\n\n    let line = Line::from(vec![\n        Span::styled(icon, style),\n        Span::raw(\" \"),\n        Span::styled(\n            table.name.clone(),\n            if table.is_standard {\n                Style::default()\n            } else {\n                Style::default().add_modifier(Modifier::BOLD)\n            },\n        ),\n        Span::styled(\n            format!(\" ({} rows)\", table.row_count),\n            Style::default().fg(Color::Cyan),\n        ),\n        Span::styled(\n            format!(\" [{}]\", cols_preview),\n            Style::default().fg(Color::DarkGray),\n        ),\n    ]);\n\n    ListItem::new(line)\n}\n\n/// Render the table view (contents of selected table)\n\npub fn render_table_view(frame: &mut Frame, app: &App, area: Rect) {\n    let table_info = match &app.selected_table {\n        Some(t) => t,\n        None => {\n            let msg = Paragraph::new(\"Keine Tabelle ausgew√§hlt\")\n                .block(Block::default().borders(Borders::ALL).title(\" Tabelle \"));\n            frame.render_widget(msg, area);\n            return;\n        }\n    };\n\n    // Layout: header info + table contents\n    let chunks = Layout::default()\n        .direction(Direction::Vertical)\n        .constraints([\n            Constraint::Length(4), // Header info\n            Constraint::Min(0),    // Table contents\n        ])\n        .split(area);\n\n    // Header info\n    let header_text = vec![\n        Line::from(vec![\n            Span::styled(\"Tabelle: \", Style::default().fg(Color::Cyan)),\n            Span::styled(\n                &table_info.name,\n                Style::default().add_modifier(Modifier::BOLD),\n            ),\n            Span::styled(\n                format!(\n                    \" ({} Zeilen, {} Spalten)\",\n                    table_info.row_count,\n                    table_info.columns.len()\n                ),\n                Style::default().fg(Color::DarkGray),\n            ),\n        ]),\n        Line::from(vec![\n            Span::styled(\"Spalten: \", Style::default().fg(Color::Cyan)),\n            Span::raw(table_info.columns.join(\", \")),\n        ]),\n        Line::from(vec![Span::styled(\n            \"‚Üê‚Üí: Scroll | ‚Üë‚Üì: Zeile | Esc: Zur√ºck\",\n            Style::default().fg(Color::DarkGray),\n        )]),\n    ];\n    let header =\n        Paragraph::new(header_text).block(Block::default().borders(Borders::ALL).title(\" Info \"));\n    frame.render_widget(header, chunks[0]);\n\n    // Table contents\n    if app.table_rows.is_empty() {\n        let msg = Paragraph::new(\"Keine Daten in dieser Tabelle\")\n            .block(Block::default().borders(Borders::ALL).title(\" Daten \"));\n        frame.render_widget(msg, chunks[1]);\n        return;\n    }\n\n    // Calculate column widths based on content\n    let col_count = table_info.columns.len();\n    let visible_cols = col_count.saturating_sub(app.table_scroll_x);\n\n    if visible_cols == 0 {\n        let msg = Paragraph::new(\"Scroll zur√ºck mit ‚Üê\")\n            .block(Block::default().borders(Borders::ALL).title(\" Daten \"));\n        frame.render_widget(msg, chunks[1]);\n        return;\n    }\n\n    // Build header row\n    let header_cells: Vec<Cell> = table_info\n        .columns\n        .iter()\n        .skip(app.table_scroll_x)\n        .take(10) // Show max 10 columns\n        .map(|c| {\n            Cell::from(c.clone()).style(\n                Style::default()\n                    .fg(Color::Yellow)\n                    .add_modifier(Modifier::BOLD),\n            )\n        })\n        .collect();\n\n    let header_row = Row::new(header_cells).height(1);\n\n    // Build data rows\n    let rows: Vec<Row> = app\n        .table_rows\n        .iter()\n        .map(|row| {\n            let cells: Vec<Cell> = row\n                .values\n                .iter()\n                .skip(app.table_scroll_x)\n                .take(10)\n                .map(|v| {\n                    let display = if v.len() > 30 {\n                        format!(\"{}...\", &v[..27])\n                    } else {\n                        v.clone()\n                    };\n                    Cell::from(display)\n                })\n                .collect();\n            Row::new(cells)\n        })\n        .collect();\n\n    // Calculate widths for visible columns\n    let widths: Vec<Constraint> = (0..visible_cols.min(10))\n        .map(|_| Constraint::Min(15))\n        .collect();\n\n    let scroll_info = if app.table_scroll_x > 0 {\n        format!(\" (Spalte {}+) \", app.table_scroll_x + 1)\n    } else {\n        String::new()\n    };\n\n    let table = Table::new(rows, widths)\n        .header(header_row)\n        .block(\n            Block::default()\n                .borders(Borders::ALL)\n                .title(format!(\" Daten{} \", scroll_info)),\n        )\n        .row_highlight_style(Style::default().bg(Color::Blue).fg(Color::White));\n\n    // Note: Table widget doesn't support stateful rendering, so we use plain render\n    // The row selection is handled by scrolling\n    frame.render_widget(table, chunks[1]);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-tui","src","widgets","form.rs"],"content":"//! Form widget for property editing\r\n\r\n\r\nuse ratatui::{\r\n    layout::Rect,\r\n    style::{Color, Modifier, Style},\r\n    text::{Line, Span},\r\n    widgets::{Block, Borders, Paragraph},\r\n    Frame,\r\n};\r\n\r\n\r\nuse ofml_lib::property::{PropertyDef, PropertyType, PropertyValue};\r\n\r\n/// Property form input state\r\n\r\n#[derive(Debug, Clone, Default)]\r\npub struct PropertyFormState {\r\n    /// Current input buffer\r\n    pub input: String,\r\n    /// Cursor position\r\n    pub cursor: usize,\r\n    /// Whether in edit mode\r\n    pub editing: bool,\r\n    /// Validation error\r\n    pub error: Option<String>,\r\n}\r\n\r\n// Default is derived automatically since all fields have Default\r\n\r\n\r\nimpl PropertyFormState {\r\n    /// Create a new form state with initial value\r\n    pub fn new(value: &PropertyValue) -> Self {\r\n        let input = match value {\r\n            PropertyValue::Int(i) => i.to_string(),\r\n            PropertyValue::Float(f) => f.to_string(),\r\n            PropertyValue::Bool(b) => if *b { \"ja\" } else { \"nein\" }.to_string(),\r\n            PropertyValue::String(s) => s.clone(),\r\n            PropertyValue::Symbol(s) => s.clone(),\r\n        };\r\n        let cursor = input.len();\r\n        Self {\r\n            input,\r\n            cursor,\r\n            editing: false,\r\n            error: None,\r\n        }\r\n    }\r\n\r\n    /// Handle character input\r\n    pub fn insert(&mut self, c: char) {\r\n        self.input.insert(self.cursor, c);\r\n        self.cursor += 1;\r\n        self.error = None;\r\n    }\r\n\r\n    /// Handle backspace\r\n    pub fn backspace(&mut self) {\r\n        if self.cursor > 0 {\r\n            self.cursor -= 1;\r\n            self.input.remove(self.cursor);\r\n            self.error = None;\r\n        }\r\n    }\r\n\r\n    /// Handle delete\r\n    pub fn delete(&mut self) {\r\n        if self.cursor < self.input.len() {\r\n            self.input.remove(self.cursor);\r\n            self.error = None;\r\n        }\r\n    }\r\n\r\n    /// Move cursor left\r\n    pub fn left(&mut self) {\r\n        if self.cursor > 0 {\r\n            self.cursor -= 1;\r\n        }\r\n    }\r\n\r\n    /// Move cursor right\r\n    pub fn right(&mut self) {\r\n        if self.cursor < self.input.len() {\r\n            self.cursor += 1;\r\n        }\r\n    }\r\n\r\n    /// Validate input against property definition\r\n    pub fn validate(&mut self, def: &PropertyDef) -> Result<PropertyValue, String> {\r\n        match &def.prop_type {\r\n            PropertyType::Int { min, max } => {\r\n                let value: i64 = self\r\n                    .input\r\n                    .parse()\r\n                    .map_err(|_| \"Ung√ºltige Ganzzahl\".to_string())?;\r\n                if let Some(min_val) = min {\r\n                    if value < *min_val {\r\n                        return Err(format!(\"Wert muss mindestens {} sein\", min_val));\r\n                    }\r\n                }\r\n                if let Some(max_val) = max {\r\n                    if value > *max_val {\r\n                        return Err(format!(\"Wert darf h√∂chstens {} sein\", max_val));\r\n                    }\r\n                }\r\n                Ok(PropertyValue::Int(value))\r\n            }\r\n            PropertyType::Float { min, max } => {\r\n                let value: f64 = self\r\n                    .input\r\n                    .parse()\r\n                    .map_err(|_| \"Ung√ºltige Dezimalzahl\".to_string())?;\r\n                if let Some(min_val) = min {\r\n                    if value < *min_val {\r\n                        return Err(format!(\"Wert muss mindestens {} sein\", min_val));\r\n                    }\r\n                }\r\n                if let Some(max_val) = max {\r\n                    if value > *max_val {\r\n                        return Err(format!(\"Wert darf h√∂chstens {} sein\", max_val));\r\n                    }\r\n                }\r\n                Ok(PropertyValue::Float(value))\r\n            }\r\n            PropertyType::Bool => match self.input.to_lowercase().as_str() {\r\n                \"ja\" | \"true\" | \"1\" | \"yes\" => Ok(PropertyValue::Bool(true)),\r\n                \"nein\" | \"false\" | \"0\" | \"no\" => Ok(PropertyValue::Bool(false)),\r\n                _ => Err(\"Wert muss 'ja' oder 'nein' sein\".to_string()),\r\n            },\r\n            PropertyType::Choice { options } => {\r\n                if options.contains(&self.input) {\r\n                    Ok(PropertyValue::Symbol(self.input.clone()))\r\n                } else {\r\n                    Err(format!(\"Wert muss einer von {:?} sein\", options))\r\n                }\r\n            }\r\n            PropertyType::String => Ok(PropertyValue::String(self.input.clone())),\r\n        }\r\n    }\r\n\r\n    /// Cycle through choice options\r\n    pub fn cycle_choice(&mut self, def: &PropertyDef, forward: bool) {\r\n        if let PropertyType::Choice { options } = &def.prop_type {\r\n            let current_idx = options.iter().position(|o| o == &self.input);\r\n            let new_idx = match current_idx {\r\n                Some(idx) => {\r\n                    if forward {\r\n                        (idx + 1) % options.len()\r\n                    } else if idx == 0 {\r\n                        options.len() - 1\r\n                    } else {\r\n                        idx - 1\r\n                    }\r\n                }\r\n                None => 0,\r\n            };\r\n            self.input = options[new_idx].clone();\r\n            self.cursor = self.input.len();\r\n        }\r\n    }\r\n\r\n    /// Toggle boolean value\r\n    pub fn toggle_bool(&mut self) {\r\n        match self.input.to_lowercase().as_str() {\r\n            \"ja\" | \"true\" | \"1\" | \"yes\" => {\r\n                self.input = \"nein\".to_string();\r\n            }\r\n            _ => {\r\n                self.input = \"ja\".to_string();\r\n            }\r\n        }\r\n        self.cursor = self.input.len();\r\n    }\r\n}\r\n\r\n/// Render a property input field\r\n\r\npub fn render_property_input(\r\n    frame: &mut Frame,\r\n    state: &PropertyFormState,\r\n    def: &PropertyDef,\r\n    area: Rect,\r\n    focused: bool,\r\n) {\r\n    let style = if focused {\r\n        Style::default()\r\n            .fg(Color::White)\r\n            .bg(Color::Blue)\r\n            .add_modifier(Modifier::BOLD)\r\n    } else {\r\n        Style::default()\r\n    };\r\n\r\n    let type_hint = match &def.prop_type {\r\n        PropertyType::Int { min, max } => {\r\n            let min_str = min.map(|v| v.to_string()).unwrap_or_default();\r\n            let max_str = max.map(|v| v.to_string()).unwrap_or_default();\r\n            format!(\"[{}-{}]\", min_str, max_str)\r\n        }\r\n        PropertyType::Float { min, max } => {\r\n            let min_str = min.map(|v| format!(\"{:.1}\", v)).unwrap_or_default();\r\n            let max_str = max.map(|v| format!(\"{:.1}\", v)).unwrap_or_default();\r\n            format!(\"[{}-{}]\", min_str, max_str)\r\n        }\r\n        PropertyType::Choice { options } => format!(\"[{}]\", options.join(\",\")),\r\n        PropertyType::Bool => \"[ja/nein]\".to_string(),\r\n        PropertyType::String => \"[Text]\".to_string(),\r\n    };\r\n\r\n    let content = if state.editing && focused {\r\n        // Show cursor\r\n        let before = &state.input[..state.cursor];\r\n        let after = &state.input[state.cursor..];\r\n        vec![Line::from(vec![\r\n            Span::raw(before),\r\n            Span::styled(\"‚îÇ\", Style::default().add_modifier(Modifier::RAPID_BLINK)),\r\n            Span::raw(after),\r\n        ])]\r\n    } else {\r\n        vec![Line::from(state.input.clone())]\r\n    };\r\n\r\n    let error_style = Style::default().fg(Color::Red);\r\n    let content = if let Some(ref err) = state.error {\r\n        vec![\r\n            content.into_iter().next().unwrap_or_default(),\r\n            Line::from(Span::styled(err.as_str(), error_style)),\r\n        ]\r\n    } else {\r\n        content\r\n    };\r\n\r\n    let input = Paragraph::new(content).style(style).block(\r\n        Block::default()\r\n            .borders(Borders::ALL)\r\n            .title(format!(\" {} {} \", def.label, type_hint)),\r\n    );\r\n\r\n    frame.render_widget(input, area);\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-tui","src","widgets","list.rs"],"content":"//! List widget helpers\n\n\nuse ratatui::{\n    style::{Color, Modifier, Style},\n    text::{Line, Span},\n    widgets::ListItem,\n};\n\n/// Create a styled list item for manufacturers\n\npub fn manufacturer_item(id: &str, name: &str, article_count: usize) -> ListItem<'static> {\n    let line = Line::from(vec![\n        Span::styled(\n            format!(\"{:<12}\", id),\n            Style::default().add_modifier(Modifier::BOLD),\n        ),\n        Span::raw(format!(\" {} \", name)),\n        Span::styled(\n            format!(\"({} Artikel)\", article_count),\n            Style::default().fg(Color::DarkGray),\n        ),\n    ]);\n    ListItem::new(line)\n}\n\n/// Create a styled list item for articles\n\npub fn article_item(id: &str, description: &str, has_configuration: bool) -> ListItem<'static> {\n    let config_indicator = if has_configuration {\n        Span::styled(\"‚óè\", Style::default().fg(Color::Green))\n    } else {\n        Span::styled(\"‚óã\", Style::default().fg(Color::DarkGray))\n    };\n\n    let line = Line::from(vec![\n        config_indicator,\n        Span::raw(\" \"),\n        Span::styled(\n            format!(\"{:<24}\", id),\n            Style::default().add_modifier(Modifier::BOLD),\n        ),\n        Span::raw(format!(\" {}\", description)),\n    ]);\n    ListItem::new(line)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","crates","ofml-tui","src","widgets","mod.rs"],"content":"//! TUI Widgets\r\n//!\r\n//! Custom widgets for the OAP configurator TUI.\r\n\r\n\r\npub mod form;\r\n\r\npub mod list;\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","investigate_framery_price.rs"],"content":"use std::path::Path;\r\n\r\nmod ebase;\r\nuse ebase::EBaseReader;\r\n\r\nfn main() {\r\n    let path = Path::new(\"/reference/ofmldata/framery/frmr_one_compact/ANY/1/db/pdata.ebase\");\r\n\r\n    println!(\"Opening: {}\", path.display());\r\n\r\n    let mut reader = match EBaseReader::open(path) {\r\n        Ok(r) => r,\r\n        Err(e) => {\r\n            eprintln!(\"Failed to open: {}\", e);\r\n            return;\r\n        }\r\n    };\r\n\r\n    println!(\"\\nVersion: {}.{}\", reader.major_version, reader.minor_version);\r\n    println!(\"\\nAvailable tables:\");\r\n    for table_name in reader.table_names() {\r\n        let table = reader.get_table(table_name).unwrap();\r\n        println!(\"  {} - {} records, {} bytes/record\",\r\n                 table_name, table.record_count, table.record_size);\r\n    }\r\n\r\n    // Examine ocd_price table structure\r\n    if let Some(table) = reader.get_table(\"ocd_price\") {\r\n        println!(\"\\n=== ocd_price Table Schema ===\");\r\n        println!(\"Record count: {}\", table.record_count);\r\n        println!(\"Record size: {} bytes\", table.record_size);\r\n        println!(\"\\nColumns:\");\r\n        for (i, col) in table.columns.iter().enumerate() {\r\n            println!(\"  [{}] {} - type_id={}, offset={}, size={}, flags={}\",\r\n                     i, col.name, col.type_id, col.offset, col.size, col.flags);\r\n        }\r\n\r\n        // Read all price records\r\n        match reader.read_records(\"ocd_price\", None) {\r\n            Ok(records) => {\r\n                println!(\"\\n=== All Price Records ===\");\r\n                for (idx, record) in records.iter().enumerate() {\r\n                    println!(\"\\n--- Record {} ---\", idx);\r\n\r\n                    // Get all fields\r\n                    let article_nr = record.get(\"article_nr\")\r\n                        .and_then(|v| v.as_str())\r\n                        .unwrap_or(\"(null)\");\r\n                    let price_type = record.get(\"price_type\")\r\n                        .and_then(|v| v.as_str())\r\n                        .unwrap_or(\"(null)\");\r\n                    let price_textnr = record.get(\"price_textnr\")\r\n                        .and_then(|v| v.as_str())\r\n                        .unwrap_or(\"(null)\");\r\n                    let level = record.get(\"level\")\r\n                        .and_then(|v| v.as_str())\r\n                        .unwrap_or(\"(null)\");\r\n                    let var_cond = record.get(\"var_cond\")\r\n                        .and_then(|v| v.as_str())\r\n                        .unwrap_or(\"(null)\");\r\n                    let price = record.get(\"price\")\r\n                        .and_then(|v| v.as_f64())\r\n                        .unwrap_or(0.0);\r\n                    let currency = record.get(\"currency\")\r\n                        .and_then(|v| v.as_str())\r\n                        .unwrap_or(\"(null)\");\r\n\r\n                    println!(\"  article_nr: {}\", article_nr);\r\n                    println!(\"  price_type: {}\", price_type);\r\n                    println!(\"  price_textnr: {}\", price_textnr);\r\n                    println!(\"  level: {}\", level);\r\n                    println!(\"  var_cond: {}\", var_cond);\r\n                    println!(\"  price: {}\", price);\r\n                    println!(\"  currency: {}\", currency);\r\n\r\n                    // Print all fields to see what's there\r\n                    println!(\"  All fields:\");\r\n                    for (key, value) in record {\r\n                        println!(\"    {}: {:?}\", key, value);\r\n                    }\r\n                }\r\n            }\r\n            Err(e) => eprintln!(\"Failed to read records: {}\", e),\r\n        }\r\n    } else {\r\n        println!(\"\\nNo ocd_price table found!\");\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","workspace","multi_mfr_pricing_analysis.rs"],"content":"// Comprehensive Multi-Manufacturer Pricing Analysis\r\n// Analyzes pricing patterns across multiple manufacturers to find common structures\r\n\r\nuse ofml_interpreter::oap::ocd::{OcdReader, OcdPrice};\r\nuse std::collections::{HashSet};\r\nuse std::error::Error;\r\nuse std::path::Path;\r\n\r\nstruct ManufacturerAnalysis {\r\n    manufacturer: String,\r\n    series: String,\r\n    db_path: String,\r\n    base_price_count: usize,\r\n    surcharge_count: usize,\r\n    base_var_cond_patterns: Vec<String>,\r\n    surcharge_var_cond_samples: Vec<String>,\r\n    sample_base_prices: Vec<OcdPrice>,\r\n    sample_surcharges: Vec<OcdPrice>,\r\n    has_propvalue2varcond: bool,\r\n    propvalue2varcond_count: usize,\r\n    property_class_count: usize,\r\n    article_count: usize,\r\n}\r\n\r\nfn analyze_manufacturer(mfr: &str, series: &str, db_path: &str) -> Result<ManufacturerAnalysis, Box<dyn Error>> {\r\n    println!(\"\\n{}\", \"=\".repeat(80));\r\n    println!(\"ANALYZING: {}/{}\", mfr, series);\r\n    println!(\"Path: {}\", db_path);\r\n    println!(\"{}\", \"=\".repeat(80));\r\n\r\n    let path = Path::new(db_path);\r\n    if !path.exists() {\r\n        return Err(format!(\"Database file does not exist: {}\", db_path).into());\r\n    }\r\n\r\n    let ocd = OcdReader::from_ebase(path)?;\r\n\r\n    // 1. Analyze ocd_price table\r\n    println!(\"\\n--- OCD_PRICE TABLE ---\");\r\n    println!(\"Total price records: {}\", ocd.prices.len());\r\n\r\n    let mut base_count = 0;\r\n    let mut surcharge_count = 0;\r\n    let mut base_var_conds = HashSet::new();\r\n    let mut surcharge_var_conds = HashSet::new();\r\n    let mut sample_base_prices = Vec::new();\r\n    let mut sample_surcharges = Vec::new();\r\n\r\n    for price in &ocd.prices {\r\n        if price.price_level == \"B\" {\r\n            base_count += 1;\r\n            base_var_conds.insert(price.var_cond.clone());\r\n            if sample_base_prices.len() < 10 {\r\n                sample_base_prices.push(price.clone());\r\n            }\r\n        } else if price.price_level == \"X\" {\r\n            surcharge_count += 1;\r\n            surcharge_var_conds.insert(price.var_cond.clone());\r\n            if sample_surcharges.len() < 10 {\r\n                sample_surcharges.push(price.clone());\r\n            }\r\n        }\r\n    }\r\n\r\n    println!(\"Base prices (level B): {}\", base_count);\r\n    println!(\"Surcharges (level X): {}\", surcharge_count);\r\n\r\n    println!(\"\\nBase price var_cond patterns: {:?}\", base_var_conds);\r\n    if !sample_base_prices.is_empty() {\r\n        println!(\"\\nSample base prices (first 5):\");\r\n        for (i, bp) in sample_base_prices.iter().take(5).enumerate() {\r\n            println!(\"  {}. article_nr='{}', var_cond='{}', price={} {}\",\r\n                i+1, bp.article_nr, bp.var_cond, bp.price, bp.currency);\r\n        }\r\n    }\r\n\r\n    let surcharge_samples: Vec<String> = surcharge_var_conds.iter().take(10).cloned().collect();\r\n    println!(\"\\nSurcharge var_cond samples (first 10): {:?}\", surcharge_samples);\r\n    if !sample_surcharges.is_empty() {\r\n        println!(\"\\nSample surcharges (first 5):\");\r\n        for (i, sc) in sample_surcharges.iter().take(5).enumerate() {\r\n            println!(\"  {}. article_nr='{}', var_cond='{}', price={} {}\",\r\n                i+1, sc.article_nr, sc.var_cond, sc.price, sc.currency);\r\n        }\r\n    }\r\n\r\n    // 2. Check ocd_propvalue2varcond table\r\n    println!(\"\\n--- OCD_PROPVALUE2VARCOND TABLE ---\");\r\n    let has_p2v = ocd.has_varcond_mappings();\r\n    let p2v_count = ocd.propvalue2varcond.len();\r\n    if has_p2v {\r\n        println!(\"Table EXISTS! Record count: {}\", p2v_count);\r\n        // Sample some mappings\r\n        println!(\"Sample mappings (first 5):\");\r\n        for (i, ((prop_class, prop_value), mapping)) in ocd.propvalue2varcond.iter().take(5).enumerate() {\r\n            println!(\"  {}. prop_class='{}', prop_value='{}' -> var_cond='{}'\",\r\n                i+1, prop_class, prop_value, mapping.var_cond);\r\n        }\r\n    } else {\r\n        println!(\"Table does NOT exist or is empty\");\r\n    }\r\n\r\n    // 3. Check ocd_propertyclass\r\n    println!(\"\\n--- OCD_PROPERTYCLASS TABLE ---\");\r\n    let propclass_count = ocd.article_prop_classes.len();\r\n    println!(\"Total article property class mappings: {}\", propclass_count);\r\n\r\n    if !ocd.article_prop_classes.is_empty() {\r\n        println!(\"Sample property class mappings (first 5):\");\r\n        for (i, (article_nr, classes)) in ocd.article_prop_classes.iter().take(5).enumerate() {\r\n            println!(\"  {}. article_nr='{}', classes={:?}\",\r\n                i+1, article_nr, classes);\r\n        }\r\n    }\r\n\r\n    // 4. Check articles\r\n    println!(\"\\n--- OCD_ARTICLE TABLE ---\");\r\n    println!(\"Total articles: {}\", ocd.articles.len());\r\n\r\n    if !ocd.articles.is_empty() {\r\n        println!(\"Sample articles (first 5):\");\r\n        for (i, art) in ocd.articles.iter().take(5).enumerate() {\r\n            println!(\"  {}. article_nr='{}', manufacturer='{}', series='{}'\",\r\n                i+1, art.article_nr, art.manufacturer, art.series);\r\n        }\r\n    }\r\n\r\n    Ok(ManufacturerAnalysis {\r\n        manufacturer: mfr.to_string(),\r\n        series: series.to_string(),\r\n        db_path: db_path.to_string(),\r\n        base_price_count: base_count,\r\n        surcharge_count,\r\n        base_var_cond_patterns: base_var_conds.into_iter().collect(),\r\n        surcharge_var_cond_samples: surcharge_samples,\r\n        sample_base_prices,\r\n        sample_surcharges,\r\n        has_propvalue2varcond: has_p2v,\r\n        propvalue2varcond_count: p2v_count,\r\n        property_class_count: propclass_count,\r\n        article_count: ocd.articles.len(),\r\n    })\r\n}\r\n\r\nfn main() -> Result<(), Box<dyn Error>> {\r\n    println!(\"COMPREHENSIVE MULTI-MANUFACTURER PRICING INVESTIGATION\");\r\n    println!(\"{}\", \"=\".repeat(120));\r\n\r\n    // Define manufacturers to investigate\r\n    let manufacturers = vec![\r\n        // Framery - phone booths (should be thousands of EUR)\r\n        (\"framery\", \"frmr_one\", \"/reference/ofmldata/framery/frmr_one/ANY/1/db/pdata.ebase\"),\r\n        (\"framery\", \"frmr_2q\", \"/reference/ofmldata/framery/frmr_2q/ANY/1/db/pdata.ebase\"),\r\n        (\"framery\", \"frmr_q\", \"/reference/ofmldata/framery/frmr_q/ANY/1/db/pdata.ebase\"),\r\n\r\n        // FAST - wall decorations\r\n        (\"fast\", \"kr\", \"/reference/ofmldata/fast/kr/DE/1/db/pdata.ebase\"),\r\n        (\"fast\", \"wkm\", \"/reference/ofmldata/fast/wkm/DE/1/db/pdata.ebase\"),\r\n\r\n        // Sedus - office chairs\r\n        (\"sedus\", \"ai\", \"/reference/ofmldata/sex/ai/DE/1/db/pdata.ebase\"),\r\n        (\"sedus\", \"sf\", \"/reference/ofmldata/sex/sf/DE/1/db/pdata.ebase\"),\r\n\r\n        // Bisley - file cabinets\r\n        (\"bisley\", \"sf\", \"/reference/ofmldata/bisley/sf/ANY/1/db/pdata.ebase\"),\r\n        (\"bisley\", \"pf\", \"/reference/ofmldata/bisley/pf/ANY/1/db/pdata.ebase\"),\r\n\r\n        // Arper - furniture\r\n        (\"arper\", \"catifa46\", \"/reference/ofmldata/arper/catifa46/EU/1/db/pdata.ebase\"),\r\n        (\"arper\", \"saya\", \"/reference/ofmldata/arper/saya/EU/1/db/pdata.ebase\"),\r\n    ];\r\n\r\n    let mut results = Vec::new();\r\n\r\n    for (mfr, series, db_path) in manufacturers {\r\n        match analyze_manufacturer(mfr, series, db_path) {\r\n            Ok(result) => results.push(result),\r\n            Err(e) => eprintln!(\"\\nERROR analyzing {}/{}: {}\", mfr, series, e),\r\n        }\r\n    }\r\n\r\n    // Generate comparison table\r\n    println!(\"\\n{}\", \"=\".repeat(120));\r\n    println!(\"PRICING PATTERNS COMPARISON TABLE\");\r\n    println!(\"{}\", \"=\".repeat(120));\r\n    println!(\"{:<15} {:<20} {:<30} {:<30} {:<20}\",\r\n        \"Manufacturer\", \"Series\", \"Base Pattern\", \"Surch Pattern\", \"propvalue2varcond?\");\r\n    println!(\"{}\", \"-\".repeat(120));\r\n\r\n    for r in &results {\r\n        let base_pattern = if r.base_var_cond_patterns.is_empty() {\r\n            \"NONE\".to_string()\r\n        } else {\r\n            r.base_var_cond_patterns.iter()\r\n                .take(3)\r\n                .map(|s| format!(\"'{}'\", s))\r\n                .collect::<Vec<_>>()\r\n                .join(\", \")\r\n        };\r\n\r\n        let surch_pattern = if r.surcharge_var_cond_samples.is_empty() {\r\n            \"NONE\".to_string()\r\n        } else {\r\n            r.surcharge_var_cond_samples.iter()\r\n                .take(2)\r\n                .map(|s| format!(\"'{}'\", s))\r\n                .collect::<Vec<_>>()\r\n                .join(\", \")\r\n        };\r\n\r\n        let has_p2v = if r.has_propvalue2varcond {\r\n            format!(\"YES ({})\", r.propvalue2varcond_count)\r\n        } else {\r\n            \"NO\".to_string()\r\n        };\r\n\r\n        println!(\"{:<15} {:<20} {:<30} {:<30} {:<20}\",\r\n            r.manufacturer, r.series, base_pattern, surch_pattern, has_p2v);\r\n    }\r\n\r\n    // Print summary\r\n    println!(\"\\n{}\", \"=\".repeat(120));\r\n    println!(\"KEY FINDINGS:\");\r\n    println!(\"{}\", \"=\".repeat(120));\r\n\r\n    println!(\"\\n1. BASE PRICE PATTERNS:\");\r\n    let mut all_base_patterns: HashSet<String> = HashSet::new();\r\n    for r in &results {\r\n        for pattern in &r.base_var_cond_patterns {\r\n            all_base_patterns.insert(pattern.clone());\r\n        }\r\n    }\r\n    println!(\"   All unique base var_cond values across all manufacturers:\");\r\n    for pattern in &all_base_patterns {\r\n        println!(\"     - '{}'\", pattern);\r\n    }\r\n\r\n    println!(\"\\n2. PROPVALUE2VARCOND TABLE:\");\r\n    let manufacturers_with_p2v: Vec<_> = results.iter()\r\n        .filter(|r| r.has_propvalue2varcond)\r\n        .map(|r| format!(\"{}/{} ({} records)\", r.manufacturer, r.series, r.propvalue2varcond_count))\r\n        .collect();\r\n    if manufacturers_with_p2v.is_empty() {\r\n        println!(\"   NO manufacturers have this table\");\r\n    } else {\r\n        println!(\"   Manufacturers with table:\");\r\n        for mfr in manufacturers_with_p2v {\r\n            println!(\"     - {}\", mfr);\r\n        }\r\n    }\r\n\r\n    println!(\"\\n3. HIGHEST BASE PRICES (looking for Framery's thousands of EUR):\");\r\n    for r in &results {\r\n        if !r.sample_base_prices.is_empty() {\r\n            let max_price = r.sample_base_prices.iter()\r\n                .map(|p| p.price)\r\n                .max_by(|a, b| a.partial_cmp(b).unwrap())\r\n                .unwrap();\r\n            let min_price = r.sample_base_prices.iter()\r\n                .map(|p| p.price)\r\n                .min_by(|a, b| a.partial_cmp(b).unwrap())\r\n                .unwrap();\r\n            println!(\"   {}/{}: min={}, max={} (from {} base prices)\",\r\n                r.manufacturer, r.series, min_price, max_price, r.base_price_count);\r\n        }\r\n    }\r\n\r\n    println!(\"\\n4. DATA COMPLETENESS:\");\r\n    println!(\"   {:<15} {:<20} {:<12} {:<12} {:<12} {:<12}\",\r\n        \"Manufacturer\", \"Series\", \"Articles\", \"Base Prices\", \"Surcharges\", \"Prop Classes\");\r\n    println!(\"   {}\", \"-\".repeat(88));\r\n    for r in &results {\r\n        println!(\"   {:<15} {:<20} {:<12} {:<12} {:<12} {:<12}\",\r\n            r.manufacturer, r.series, r.article_count,\r\n            r.base_price_count, r.surcharge_count, r.property_class_count);\r\n    }\r\n\r\n    Ok(())\r\n}\r\n","traces":[],"covered":0,"coverable":0}],"coverage":62.243480944298724,"covered":8068,"coverable":12962}